unique_id,repo_name,path,effective_code_length,loop_count,computation_count,execution_time_cycles,instruction_count,cpi,I1mr,ILmr,Dr,Dw,D1mr,D1mw,DLmr,DLmw,cpu_fre,execution_time,total_memory,instruction_cache_miss_rate,data_cache_miss_rate,code
270-32575,doc-cloud/c,sc/signal/sigaction.c,21,1,3,9012617125.52514,177095.0,50891.42621192016,1319.0,1299.0,40346.0,13806.0,1638.0,640.0,1359.0,593.0,1500000000,6.00841141701676,1082014363648.0,0.0147830260594596,0.078113458413355,"#include<stdio.h>
#include<unistd.h>
#include<signal.h>

void timeout(int sig)
{
	if (sig == SIGALRM)
		puts(""Time out!"");
	alarm(2);
}

int main(int argc, char *argv[])
{
	int i;
	struct sigaction sig_act;

	sig_act.sa_handler = timeout;
	sigemptyset(&sig_act.sa_mask);
	sig_act.sa_flags = 0;

	sigaction(SIGALRM, &sig_act, 0);
	alarm(2);

	for (i = 0; i < 3; i++) {
		puts(""waiting...."");
		sleep(600);
	}
	return 0;
}
"
143-34617,doc-cloud/c,sc/signal/signal.c,23,1,4,9001730242.394842,175651.0,51247.81664778453,1325.0,1304.0,39948.0,13680.0,1625.0,637.0,1345.0,593.0,1500000000,6.001153494929895,1082014363648.0,0.0149671792360988,0.0783172969344372,"#include<stdio.h>
#include<unistd.h>
#include<signal.h>

void timeout(int sig)
{
	if (sig == SIGALRM)
		puts(""Time out!"");
	alarm(2);
}

void keycontrol(int sig)
{
	if (sig == SIGINT)
		puts(""CTRL + C pressed."");
}

int main(int argc, char *argv[])
{
	int i;
	signal(SIGALRM, timeout);
	signal(SIGINT, keycontrol);
	alarm(2);

	for (i = 0; i < 3; i++) {
		puts(""waiting...."");
		sleep(600);
	}
	return 0;
}
"
309-12247,joselisboa/dominoes,tests/time.c,14,1,1,7516930240.555666,178212.0,42179.70866159406,1420.0,1397.0,40560.0,13953.0,1651.0,640.0,1367.0,596.0,1500000000,5.011286827037111,1082014363648.0,0.0158070163625345,0.0780364316768477,"#include <stdio.h>
#include <time.h>

int main ()
{
   time_t start_t, end_t;
   double diff_t;

   printf(""Starting of the program...\n"");
   time(&start_t);

   printf(""Sleeping for 5 seconds...\n"");
   sleep(5);

   time(&end_t);
   diff_t = difftime(end_t, start_t);

   printf(""Execution time = %f\n"", diff_t);
   printf(""Exiting of the program...\n"");

   return(0);
}"
112-2598,weiqiangdragonite/blog_tmp,unix_linux/Linux_network/tcp_ip_book/ch10_process/sigaction.c,23,1,3,9002083747.414871,177116.0,50825.92056618261,1320.0,1300.0,40349.0,13809.0,1638.0,640.0,1359.0,593.0,1500000000,6.001389164943248,1082014363648.0,0.0147925653244201,0.0781048044610214,"
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>

void
timeout(int sig)
{
	if (sig == SIGALRM)
		printf(""Time out!\n"");
	alarm(2);
}


int
main(int argc, char *argv[])
{
	int i;
	struct sigaction action;

	action.sa_handler = timeout;
	sigemptyset(&action.sa_mask);
	action.sa_flags = 0;

	sigaction(SIGALRM, &action, 0);

	alarm(2);

	for (i = 0; i < 3; ++i) {
		printf(""wait...\n"");
		sleep(100);
	}

	return 0;
}




"
244-1795,wcnnbdk1/hello_world,CLearning/understandC_ja/m_chap02/return.c,20,1,4,6109878823.393956,212634434.0,28.73419280246961,1326.0,1307.0,50030286.0,12511269.0,1640.0,636.0,1353.0,593.0,1500000000,4.073252548929304,1082014363648.0,1.2382754526014352e-05,6.750711586880116e-05,"#include <stdio.h>
#include <time.h>

int sleep(unsigned long x)
{
    clock_t c1 = clock(), c2;
    do {
        if ((c2 = clock()) == (clock_t)-1)
            return 0;
    } while (1000.0 * (c2 - c1) / CLOCKS_PER_SEC < x);
    return 1;
}
int main(void)
{
    printf(""My name is BohYoh."");
    fflush(stdout);

    sleep(2000);
    printf(""\rHow do you do ?   "");
    fflush(stdout);

    sleep(2000);
    printf(""\rThanks.            \n"");

    return 0;
}
"
275-33407,jnuyens/linux-c-programming,1_4_basics/break1.c,16,1,3,9798629737.459124,183073.0,53523.07405788948,1356.0,1329.0,41373.0,14720.0,1630.0,636.0,1350.0,593.0,1500000000,6.532419824972749,1082014363648.0,0.0146662806639974,0.0750361007612358,"#include <stdio.h>
#include <time.h>

int main(void)
{ 
	struct timespec tim;
   	tim.tv_sec = 0;
   	tim.tv_nsec = 500000000L;	
	int i = 0;    
	while ( i < 20 ) { 
		if (i == 13) {
                        break ;
                }
		printf( ""%d\n"", i );
		i++;            
		nanosleep(&tim , NULL);
	}
	return 0;
}

"
036-32323,jnuyens/linux-c-programming,1_4_basics/continue.c,16,1,3,14270127550.698816,187323.0,76179.26015491958,1350.0,1323.0,42258.0,15352.0,1630.0,637.0,1350.0,594.0,1500000000,9.513418367132545,1082014363648.0,0.0142694703800387,0.0730949487936122,"#include <stdio.h>
#include <time.h>

int main(void)
{ 
	struct timespec tim;
   	tim.tv_sec = 0;
   	tim.tv_nsec = 500000000L;	
	int i = 0;    
	while ( i < 20 ) { 
		i++;
		if (i == 13) {
                        continue ;
                }
		printf( ""%d\n"", i );
		nanosleep(&tim , NULL);
	}
	return 0;
}

"
161-26401,yusyaif/grader-library,src/bashcode/Sandbox/testsuite/config/pthread.c,33,2,7,7515145634.883083,190292.0,39492.70402329052,1550.0,1518.0,43463.0,15613.0,1671.0,674.0,1379.0,631.0,1500000000,5.010097089922056,1082014363648.0,0.016122590545057,0.073718599769788,"#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
int cntdwn = 5;

void * thread_a(void * dummy)
{
    pthread_mutex_lock(&mutex);
    while (cntdwn)
    {
        pthread_cond_wait(&cond, &mutex);
        printf(""thread: %d\n"", cntdwn);
    }
    pthread_mutex_unlock(&mutex);
    return dummy;
}

int main(void)
{
    pthread_t tid;
    pthread_create(&tid, NULL, &thread_a, NULL);
    void * ret = NULL;
    pthread_mutex_lock(&mutex);
    while (cntdwn > 0)
    {
        --cntdwn;
        printf(""main: %d\n"", cntdwn);
        pthread_cond_broadcast(&cond);
        pthread_mutex_unlock(&mutex);
        sleep(1);
        pthread_mutex_lock(&mutex);
    }
    pthread_mutex_unlock(&mutex);
    pthread_join(tid, &ret);
    return 0;
}

"
120-15013,cxsjabc/basic,c/_topics/printf/test_stdout_size.c,14,1,3,19502646746.928802,394255.0,49467.0879151818,1277.0,1261.0,133457.0,54294.0,1607.0,699.0,1335.0,656.0,1500000000,13.001764497952536,1082014363648.0,0.0064374579903869,0.0228866956767207,"#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>

void test_stdout_buf_size()
{
	int i;

	for(i = 0; i < 4096; ++i)
		printf(""a"");

	sleep(3);
	printf(""b"");
	sleep(10);
}

int main(int argc, char *argv[])
{
	test_stdout_buf_size();

	return 0;
}
"
228-33163,dariaphoebe/maybe-hugs,c/maybe_hug.c,29,2,7,13502880655.461922,175332.0,77013.21296169552,1343.0,1323.0,39806.0,13646.0,1629.0,636.0,1349.0,593.0,1500000000,9.001920436974615,1082014363648.0,0.0152054388246298,0.0787061288632792,"#include <stdio.h>
#include <unistd.h>

//Define the person to test with
#define NAME         ""Amber""
#define ISCUTIE      1
#define LIKESCONTACT 1

typedef struct {
	char  *name;
	short likesPhysicalContact;
	short isCutie;
} human;

void executeHug(human person) {
	printf(""%s accepted your offer!\n"",person.name);
	sleep(3);
	puts(""*hugs*"");
	sleep(3);
	printf(""You Hugged %s! :^)\n"",person.name);
}

void offerHug(human person) {
	puts(""You asked for a hug."");
	sleep(3);
	if (person.likesPhysicalContact)
		executeHug(person);
	else
		puts(""They'd rather not, thanks for being considerate."");
}

int main() {
	human person = {NAME,LIKESCONTACT,ISCUTIE};
	if (person.isCutie)
		offerHug(person);
	else
		puts(""They're not as cute as you first thought..."");
	return 0;
}
"
199-33056,fernandozamoraj/c_sandbox,file_io/write.c,34,1,6,4491142.4629389,204599.0,21.950947951847272,1526.0,1497.0,46124.0,18117.0,1656.0,648.0,1374.0,603.0,1500000000,0.0029940949752926,1082014363648.0,0.0147752432807589,0.0666396849364113,"#include<stdio.h>
#include<string.h>

typedef struct{
    char firstName[30];
    char lastName[30];
    int age;
    float gpa;
} Student;

void writeStudent(FILE* fp){
    Student student;
    char temp[10];

    strcpy(student.firstName, ""Mary"");
    strcpy(student.lastName, ""Jones"");
    student.age = 17;
    student.gpa = 3.9;

  
    fputs(student.firstName, fp);
    fputs("","", fp);
    fputs(student.lastName, fp);    
    fputs("","", fp);

    sprintf(temp, ""%d"", student.age);
    fputs(temp, fp);
    fputs("","", fp);

    sprintf(temp, ""%0.1f"", student.gpa);
    fputs(temp, fp);
    fputs(""\n"", fp);
}

int main(void){
    
    FILE* fp = fopen(""C:\\dev\\temp\\students1.dat"", ""w"");
    
    if(fp != NULL){

        for(int i=0;i<10;i++){
            writeStudent(fp);
        }
    
        fclose(fp);
    }

    return 0;
}"
249-34196,ArmstrongJ/MiNTLib,stdio/test-fwrite.c,56,2,4,2658439.3344819,400798.0,6.63286493445576,1518.0,1482.0,49301.0,215412.0,4967.0,3965.0,1445.0,3694.0,1500000000,0.0017722928896546,1082014363648.0,0.0074850672907549,0.053155681813889,"#include <stdio.h>
#include <string.h>

long _stksize = 256L * 1024L;

int
main (int argc, char *argv[])
{
  FILE *f = tmpfile ();
  char obuf[99999], ibuf[sizeof obuf];
  char *line;
  size_t linesz;

  if (! f)
    {
      perror (""tmpfile"");
      return 1;
    }

  if (fputs (""line\n"", f) == EOF)
    {
      perror (""fputs"");
      return 1;
    }

  memset (obuf, 'z', sizeof obuf);
  memset (ibuf, 'y', sizeof ibuf);

  if (fwrite (obuf, sizeof obuf, 1, f) != 1)
    {
      perror (""fwrite"");
      return 1;
    }

  rewind (f);

  line = NULL;
  linesz = 0;
  if (getline (&line, &linesz, f) != 5)
    {
      perror (""getline"");
      return 1;
    }
  if (strcmp (line, ""line\n""))
    {
      puts (""Lines differ.  Test FAILED!"");
      return 1;
    }

  if (fread (ibuf, sizeof ibuf, 1, f) != 1)
    {
      perror (""fread"");
      return 1;
    }

  if (memcmp (ibuf, obuf, sizeof ibuf))
    {
      puts (""Buffers differ.  Test FAILED!"");
      return 1;
    }

  asprintf (&line, ""\
GDB is free software and you are welcome to distribute copies of it\n\
 under certain conditions; type \""show copying\"" to see the conditions.\n\
There is absolutely no warranty for GDB; type \""show warranty\"" for details.\n\
"");

  puts (""Test succeeded."");
  return 0;
}
"
210-24961,c4pr1c3/learngit,AppliedCryptology/benchmark/isprime.c,16,1,4,326734849.4846373,889621918.0,0.3672738299147886,1339.0,1320.0,39173.0,13297.0,1617.0,636.0,1340.0,593.0,1500000000,0.2178232329897582,1082014363648.0,2.9889101720625546e-06,0.0797789212883552,"#include <stdio.h> 

int NUM = 111181111; 

int is_prime(int n) { 
    int i; 
    for(i = 2; i < n; i++) { 
        if (n % i == 0) { 
            return 0; 
        } 
    } 
    return 1; 
} 

int main() { 
    int result; 

    result = is_prime(NUM); 
    printf(""%d\n"", result); 

    return 0; 
}
"
126-26703,jdetter/Chronos,user/src/sleep-test.c,19,5,2,31502721124.794334,176112.0,178878.90163078043,1312.0,1293.0,40075.0,13744.0,1626.0,636.0,1343.0,592.0,1500000000,21.001814083196223,1082014363648.0,0.0147917234487144,0.0779836117356324,"#include <stdio.h>
#include <unistd.h>

int main(int argc, char** argv)
{
	printf(""sleeping for 1 second...\n"");
	fflush(stdout);
	sleep(1);
	printf(""sleeping for 2 seconds...\n"");
	fflush(stdout);
	sleep(2);
	printf(""sleeping for 3 seconds...\n"");
	fflush(stdout);
	sleep(3);
	printf(""sleeping for 5 seconds...\n"");
	fflush(stdout);
	sleep(5);
	printf(""sleeping for 10 seconds...\n"");
	fflush(stdout);
	sleep(10);

	return 0;
}
"
102-29093,dunso/algorithm,C/Math/LeetCode0007.c,17,1,5,1972039.69582905,173238.0,11.383408951846592,1340.0,1320.0,39161.0,13297.0,1618.0,638.0,1339.0,593.0,1500000000,0.0013146931305527,1082014363648.0,0.0153545988755353,0.0798352968088756,"#include <limits.h>
#include <stdio.h>

int reverse(int x)
{
    long long mResult = 0;
    while (x) {
        mResult = mResult * 10 + x % 10;

        if (mResult > INT_MAX || mResult < INT_MIN) {
            return 0;
        }
        x /= 10;
    }
    return mResult;
}

int main()
{
    printf(""%d\n"", reverse(1534236469));
    return 0;
}"
367-9893,707wk/Senior-middle-school,temp/encrypt/main.c,29,1,5,2503038.15118965,176407.0,14.188994767781324,1353.0,1330.0,40199.0,13816.0,1640.0,643.0,1360.0,600.0,1500000000,0.0016686921007931,1082014363648.0,0.0152091470293128,0.0785522540035175,"#include<stdio.h>
void encrypt()
{
	char c;
	FILE *fin,*fout;
	if((fin=fopen(""temp"",""r""))==NULL)
	{
		printf(""error"");
		return ;	
	}
	if((fout=fopen(""error"",""w""))==NULL)
	{
		printf(""error"");
		return ;	
	}
	while(!feof(fin))
	{
		c=fgetc(fin);
		c+=5;
		//fwrite(&c,1,1,fout);
		fputc(c,fout);
	}
	fclose(fin);
	fclose(fout);
}
int main()
{
	encrypt();
	return 0;	
}
"
253-34286,SanDisk-Open-Source/SSD_Dashboard,uefi/userspace/glibc/stdio-common/test-fwrite.c,55,2,3,2359669.5391461,400798.0,5.887427082969476,1518.0,1482.0,49301.0,215412.0,4967.0,3965.0,1445.0,3694.0,1500000000,0.0015731130260974,1082014363648.0,0.0074850672907549,0.053155681813889,"#include <stdio.h>
#include <string.h>

int
main (int argc, char *argv[])
{
  FILE *f = tmpfile ();
  char obuf[99999], ibuf[sizeof obuf];
  char *line;
  size_t linesz;

  if (! f)
    {
      perror (""tmpfile"");
      return 1;
    }

  if (fputs (""line\n"", f) == EOF)
    {
      perror (""fputs"");
      return 1;
    }

  memset (obuf, 'z', sizeof obuf);
  memset (ibuf, 'y', sizeof ibuf);

  if (fwrite (obuf, sizeof obuf, 1, f) != 1)
    {
      perror (""fwrite"");
      return 1;
    }

  rewind (f);

  line = NULL;
  linesz = 0;
  if (getline (&line, &linesz, f) != 5)
    {
      perror (""getline"");
      return 1;
    }
  if (strcmp (line, ""line\n""))
    {
      puts (""Lines differ.  Test FAILED!"");
      return 1;
    }

  if (fread (ibuf, sizeof ibuf, 1, f) != 1)
    {
      perror (""fread"");
      return 1;
    }

  if (memcmp (ibuf, obuf, sizeof ibuf))
    {
      puts (""Buffers differ.  Test FAILED!"");
      return 1;
    }

  asprintf (&line, ""\
GDB is free software and you are welcome to distribute copies of it\n\
 under certain conditions; type \""show copying\"" to see the conditions.\n\
There is absolutely no warranty for GDB; type \""show warranty\"" for details.\n\
"");

  puts (""Test succeeded."");
  return 0;
}
"
235-30129,jasonmobley/euler-c,002.c,22,1,6,1629844.3078993498,173392.0,9.3997646950263,1333.0,1315.0,39180.0,13311.0,1617.0,636.0,1340.0,593.0,1500000000,0.0010865628719329,1082014363648.0,0.0152717541755098,0.0797470042483473,"#include <stdio.h>

int main(int argc, char **argv)
{
   int sum;
   int fib_curr, fib_prev, fib_temp;
   sum = 0;
   fib_curr = 2;
   fib_prev = 1;
   fib_temp = 0;

   do
   {
      if (fib_curr % 2 == 0)
      {
         sum += fib_curr;
      }

      fib_temp = fib_curr;
      fib_curr = fib_curr + fib_prev;
      fib_prev = fib_temp;
   }
   while (fib_curr <= 4000000);

   printf(""The sum is %i.\n"", sum);

   return 0;
}

"
070-22791,ForceBru/PyVM,C/src/recursion.c,36,1,5,1666966.3600623,171339.0,9.729051762879438,1150.0,1142.0,38744.0,12809.0,1582.0,587.0,1326.0,546.0,1500000000,0.0011113109067082,1082014363648.0,0.0133769894770017,0.078385350998002,"unsigned long long factorial(unsigned long long x) {
    if (x == 0)
        return 1;

    return x * factorial(x - 1);
}

#define NTESTS 21

int main(void) {
    unsigned long long factorials[NTESTS] = {
        1,
        1,
        2,
        6,
        24,
        120,
        720,
        5040,
        40320,
        362880,
        3628800,
        39916800,
        479001600,
        6227020800,
        87178291200,
        1307674368000,
        20922789888000,
        355687428096000,
        6402373705728000,
        121645100408832000,
        2432902008176640000
    };

    for (unsigned int i = 0; i < NTESTS; ++i) {
        unsigned long long ret = factorial(i);

        if (ret != factorials[i])
            return i + 1;
    }

    return 0;
}
"
189-12218,dhayalramk/Practice,Books/Pragmatic_C/Chapter1/Exercise_1_8.c,25,1,6,1570457.8254370498,185297.0,8.47218249620879,1355.0,1335.0,41713.0,15018.0,1627.0,641.0,1345.0,597.0,1500000000,0.0010469718836247,1082014363648.0,0.0145172344938126,0.0742098676208774,"#include<stdio.h>
struct cal{
  char monthName[12];
  int monthDays;
};

int main(){
  struct cal c[12] = {
    { ""January"", 31 },
    { ""Febrav"", 28 },
    { ""March"", 31 },
    { ""April"", 30 },
    { ""May"", 31 },
    { ""June"", 30 },
    { ""July"", 31 },
    { ""August"", 31 },
    { ""Septem"", 30 },
    { ""Octobe"", 31 },
    { ""Novemb"", 30 },
    { ""Decemb"", 31 },
  };
  printf(""%s\t\t %s\n"", ""Months"", ""No. of Days""  );
  for( int i=0;i<12;i++ ){
    printf(""%s\t\t %d\n"", c[i].monthName, c[i].monthDays );
  }
  return 0;
}
"
125-18443,csziacobus/euler,src/1-10/euler5.c,22,2,5,132088381.56424454,342124573.0,0.3860827061960264,1338.0,1319.0,39188.0,13309.0,1618.0,636.0,1340.0,593.0,1500000000,0.0880589210428297,1082014363648.0,7.766177029324346e-06,0.0797569384917233,"#include <stdio.h>

int
main()
{
  int i;
  int j;
  for (i = 20; ; i += 20)
    { 
      for (j = 1; j <= 20; j++)
	{
	  if (!(i % j))
	    continue;
	  else
	    break;
	}
      if (j > 20)
	{
	  printf(""answer: %d\n"", i);
	  return 0;
	}
    }
  return 0;
}
"
363-26280,neo-classic/cex,head_first_c/3/order_pizza.c,33,2,8,1411276.40381445,177181.0,7.965165565156535,1323.0,1302.0,40335.0,13726.0,1697.0,641.0,1355.0,595.0,1500000000,0.0009408509358763,1082014363648.0,0.0148153583059131,0.0793178076617154,"#include <stdio.h>
#include <unistd.h>

int main(int argc, char *argv[])
{
    char *delivery = """";
    int thick = 0;
    int count = 0;
    char ch;

    while ((ch = getopt(argc, argv, ""d:t"")) != EOF) {
        switch (ch) {
            case 'd':
                delivery = optarg;
                break;
            case 't':
                thick = 1;
                break;
            default:
                fprintf(stderr, ""Неизвестный параметр: '%s'\n"", optarg);
                return 1;
        }
    }

    argc -= optind;
    argv += optind;

    if (thick) {
        puts(""Пышное тесто."");
    }

    if (delivery[0]) {
        printf(""Будет доставлено: %s.\n"", delivery);
    }

    puts(""Ингридиенты:"");
    for(count = 0; count < argc; count++) {
        puts(argv[count]);
    }

    return 0;

}"
045-20790,gdos/SmallerC,v0100/tests/picoc/09.c,18,1,4,1830197.98714665,179276.0,10.208823266918047,1336.0,1318.0,40514.0,14250.0,1618.0,636.0,1341.0,593.0,1500000000,0.0012201319914311,1082014363648.0,0.0148039893795042,0.0764735957928566,"#include <stdio.h>

int main()
{
   int a;
   int p;
   int t;

   a = 1;
   p = 0;
   t = 0;

   do
   {
      printf(""%d\n"", a);
      t = a;
      a = t + p;
      p = t;
   } while (a < 100);

   return 0;
}

// vim: set expandtab ts=4 sw=3 sts=3 tw=80 :
"
232-29394,qeedquan/misc_utilities,snippets/threading/rwlock.c,21,1,7,1374060714.2681255,11006051719.0,0.124845925594546,1417.0,1395.0,2684398898.0,1073758459.0,1663.0,641.0,1369.0,599.0,1500000000,0.9160404761787504,1082014363648.0,2.5549580101877765e-07,1.1367272825984543e-06,"#define _GNU_SOURCE
#include <stdio.h>
#include <string.h>
#include <limits.h>
#include <pthread.h>

void
maxrdlocks(void)
{
	unsigned long long i;
	pthread_rwlock_t rw;
	int r;

	pthread_rwlock_init(&rw, NULL);

	for (i = 0; i < ULONG_MAX; i++) {
		if ((r = pthread_rwlock_rdlock(&rw)) != 0)
			break;
		if (i % 10000000 == 0)
			printf(""%llu\n"", i);
	}

	printf(""%d %s %llu\n"", r, strerror(r), i);
}

int
main(void)
{
	maxrdlocks();
	return 0;
}
"
248-34377,j3rgus/assignments,pb173-sys_lin/uloha7/src/condvar.c,25,1,2,15002272829.879076,183902.0,81577.54036932714,1545.0,1505.0,41914.0,14734.0,1668.0,715.0,1378.0,672.0,1500000000,10.001515219919384,1082014363648.0,0.0165849202292525,0.078255189944923,"#include <unistd.h>
#include <pthread.h>
#include <stdio.h>

pthread_mutex_t mutex;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

int flag = 0;

void *my_thread(void *var)
{
	pthread_mutex_lock(&mutex);
	while (flag == 0) {
    	pthread_cond_wait(&cond, &mutex);
	}
	pthread_mutex_unlock(&mutex);

	printf(""flag is set\n"");
	return NULL;
}

int main()
{
	pthread_t t;

	pthread_create (&t, NULL, my_thread, NULL);
	sleep(10);

	pthread_mutex_lock(&mutex);
	flag = 1;
	pthread_cond_signal(&cond);
	pthread_mutex_unlock(&mutex);

	pthread_join(t, NULL);
	return 0;
}
"
119-18935,moehuster/czq,day06/buffer.c,8,1,2,7502524928.888306,174731.0,42937.57219955246,1310.0,1293.0,39681.0,13637.0,1617.0,635.0,1339.0,593.0,1500000000,5.001683285925537,1082014363648.0,0.0148971848155164,0.0784725608612476,"#include <stdio.h>
#include <unistd.h>

int main()
{
	int i;
	for (i=0; i<5; i++){
		printf(""hello"");
		sleep(1);
	}
}
"
108-696,wcnnbdk1/hello_world,CLearning/understandC_ja/m_chap02/backspace.c,20,2,6,10601261671.632528,355040497.0,29.85930270089725,1316.0,1298.0,96149087.0,22192964.0,1629.0,635.0,1345.0,592.0,1500000000,7.067507781088352,1082014363648.0,7.362540392117578e-06,3.5498793239606777e-05,"#include <stdio.h>
#include <time.h>

int sleep(unsigned long x)
{
    clock_t c1 = clock(), c2;
    do {
        if ((c2 = clock()) == (clock_t)-1)
            return 0;
    } while (1000.0 * (c2 - c1) / CLOCKS_PER_SEC < x);
    return 1;
}

int main(void)
{
    int i;
    printf(""ABCDEFG"");
    for (i = 0; i < 7; i++) {
        sleep(1000);
        printf(""\b \b"");
        fflush(stdout);
    }
    return 0;
}
"
367-1888,27629678/Computer-Systems,01_chapter/show_byte.c,16,1,4,2022213.06972195,179529.0,11.26399077586351,1361.0,1341.0,40673.0,14251.0,1633.0,635.0,1354.0,593.0,1500000000,0.0013481420464813,1082014363648.0,0.0150504932350762,0.076742407690627,"#include <stdio.h>

typedef unsigned char *byte_pointer;

void show_bytes(byte_pointer start, int length) 
{
	int i;
	for(i=0;i<length;i++)
		printf(""%.2x"", start[i]);

	printf(""\n"");
}

int main()
{
	int x = 128000;
	show_bytes(&x, sizeof(int));

	float y = 1.0;
	show_bytes(&y, sizeof(float));

	return 0;
}
"
086-17439,JonArnfred/Euler,Euler5/euler5.c,18,2,6,735625300.4400059,2181591464.0,0.3371966347224395,1338.0,1319.0,39185.0,13310.0,1618.0,636.0,1340.0,593.0,1500000000,0.4904168669600039,1082014363648.0,1.2179182233910685e-06,0.07975997714068,"#include <stdlib.h>
#include <stdio.h>

int main(void){

	int foundIt = 0;
	for(int i = 20; i > 0; i++){
		int a = 20;
		while(i%a==0){
			a--;
			if(a==0){
				foundIt = 1;
				break;	
			}
		}
		if(foundIt == 1){
			printf(""this is it: %d"", i);
			break;
		}
	}
	return 0;
}
"
135-33554,lekum/head-first-c,chapter_7/marriage/marriage.c,45,1,7,1787884.7429527498,177959.0,10.046606240763325,1344.0,1324.0,40367.0,13951.0,1636.0,641.0,1355.0,599.0,1500000000,0.0011919231619685,1082014363648.0,0.0149922173084811,0.0778931477594904,"#include <stdio.h>

typedef enum
{
    DUMP,
    SECOND_CHANCE,
    MARRIAGE
} response_type;

typedef struct
{
    char *name;
    response_type type;
} response;

void dump(response r)
{
    printf(""Dear %s,\n"", r.name);
    puts(""Unfortunately your last date contacted us to"");
    puts(""say that they will not be seeing you again"");
}

void second_chance(response r)
{
    printf(""Dear %s,\n"", r.name);
    puts(""Good news: your last date has asked us to"");
    puts(""arrange another meeting. Please call ASAP."");
}

void marriage(response r)
{
    printf(""Dear %s,\n"", r.name);
    puts(""Congratulations! Your last date has contacted"");
    puts(""us with a proposal of marriage."");
}

void (*replies[])(response r) = {dump, second_chance, marriage};

int main()
{
    response r[] = {
                       {""Mike"", DUMP},
                       {""Luis"", SECOND_CHANCE},
                       {""Matt"", SECOND_CHANCE},
                       {""William"", MARRIAGE}
                   };
    int i;
    for (i = 0; i < 4; i++)
    {
        replies[r[i].type](r[i]);
    }
    return 0;
}
"
367-1062,wonsork/language-c-edu-firststep,Test_print_stack.c,29,1,9,1601988.10044675,188669.0,8.490997461162141,1346.0,1328.0,42591.0,15652.0,1625.0,642.0,1345.0,597.0,1500000000,0.0010679920669645,1082014363648.0,0.0141729695922488,0.0722661950792369,"#include<stdio.h>


static int nAge=0;
void callMe()
{
  printf(""Callme\n"" );
  int count=0;
  int age=0;


  
  printf("" age %d \t count %d\n"",age,count);

  count=100;
  age=25;
  printf("" new age %d \t count %d\n"",age,count);


  for(int i=0;i<10;i++)
    {
      printf(""\n variable i =%d\n"",i);
      age=i;
      printf(""age %d"",age);
      nAge  =age;
    }
}

void callName()
{
  printf(""Call name nAge %d \n"",nAge);
}



int main()
{
  printf(""hello \n"");
  callMe();
  callName();
  return 0;
}

"
285-31406,tdrhq/opc,tests/code-samples/TLE.c,7,1,1,29985075526.52154,616915670.0,48.60482069777868,1284.0,1269.0,94922701.0,47455051.0,1611.0,633.0,1337.0,592.0,1500000000,19.99005035101436,1082014363648.0,4.138328987493542e-06,2.930935445588437e-05,"#include <stdio.h>
#include <time.h>

#define TIMEOUT 20
int main ()
{
	time_t s = time (NULL);	
	while (time (NULL) - s < TIMEOUT);
	printf (""OK\n"");
	return 0;
}
"
192-24464,acarno/slicer,valgrind/memcheck/tests/malloc1.c,18,1,4,2118483.0693528,169083.0,12.52924894874115,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0014123220462352,1082014363648.0,0.0134490161636592,0.0785049652044725,"
#include <stdio.h>
#include <stdlib.h>

void really ( void );

int main ( void )
{ 
   really();
   return 0;
}

void really ( void )
{
   int i;
   char* p = malloc(10);
   for (i = 0; i < 10; i++)
      p[i] = 'z';
   free(p);
   p[1] = 'z';
   p = malloc(10);
   p[2] = 'z';
   p[-1] = 'z';
}
"
171-26597,zhongwei/learningc,cprimerplus/ch11/starsrch.c,19,1,7,1631342.92233735,176679.0,9.23014619734094,1363.0,1340.0,40015.0,13776.0,1632.0,637.0,1352.0,595.0,1500000000,0.0010875619482249,1082014363648.0,0.0152989319613536,0.0783774237325946,"#include <stdio.h>
#include <string.h>

#define LISTSIZE 6

int main()
{
	const char		*list[LISTSIZE] = {
		""astronomy"", ""astounding"",
		""astrophysics"", ""ostracize"",
		""asterism"", ""astrophobia""
	};

	int			count = 0;
	int			i;

	for (i = 0; i < LISTSIZE; i++) {
		if (strncmp(list[i], ""astro"", 5) == 0) {
			printf(""Found: %s\n"", list[i]);
			count++;
		}
	}

	printf(""The list contained %d words beginning""
		"" with astro.\n"", count);

	return 0;
}
"
126-20903,gorthauer/playground,labs/l3.c,15,1,4,1714051.3518825,173242.0,9.891158033271378,1336.0,1318.0,39181.0,13304.0,1618.0,636.0,1341.0,593.0,1500000000,0.001142700901255,1082014363648.0,0.0153196107179552,0.0797942269219777,"#include <stdio.h>

int main()
{
    int a,i,k,l,n,s = 2;
    k = 1;
    l = 1;
    while (l <= 4000)
    {
        a = l + k;
        k = l;
        l = a;
        if (l % 2 == 1) s += l;
    }

    printf (""\n%d\n"", s);
    return 0;
}
"
043-1526,k0gaMSX/scc,tests/execute/0006-whilestmt.c,9,1,1,2062445.8556994,169061.0,12.199413229544366,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0013749639037996,1082014363648.0,0.0134152761429306,0.0785563462891999,"int
main()
{
	int x;

	x = 50;
	while (x)
		x = x - 1;
	return x;
}
"
193-23996,xqbase/eleeye,codec/unixtext/dos2mac.c,37,1,5,1971303.13608795,176450.0,11.172020402380278,1293.0,1271.0,40222.0,13740.0,1644.0,634.0,1362.0,592.0,1500000000,0.0013142020907253,1082014363648.0,0.0145310286200056,0.0784255587265112,"#include <stdio.h>

const char *szTempFile = ""DOS2MAC.TMP"";

int main(int argc, char **argv) {
  FILE *fpIn, *fpOut;
  int nChar;

  if (argc < 2) {
    fpIn = stdin;
    fpOut = stdout;
  } else {
    fpIn = fopen(argv[1], ""rb"");
    if (fpIn == NULL) {
      return 1;
    }
    if (argc < 3) {
      fpOut = fopen(szTempFile, ""wb"");
    } else {
      fpOut = fopen(argv[2], ""wb"");
    }
    if (fpOut == NULL) {
      fclose(fpIn);
      return 1;
    }
  }

  while ((nChar = fgetc(fpIn)) != EOF) {
    if (nChar != '\n') {
      fputc(nChar, fpOut);
    }
  }

  if (argc > 1) {
    fclose(fpIn);
    fclose(fpOut);
    if (argc < 3) {
      remove(argv[1]);
      rename(szTempFile, argv[1]);
    }
  }
  return 0;
}
"
376-20420,goliveira/linguagemc,thehuxley/loop_de_inteiros.c,11,1,3,1691163.16828875,814899.0,2.0742435565634514,1335.0,1316.0,174917.0,110089.0,1620.0,699.0,1339.0,654.0,1500000000,0.0011274421121925,1082014363648.0,0.0032531638890218,0.0151295060454867,"#include <stdio.h>

int main()
{
    int n;
    n = 1;

    while (n <= 1000)
    {
        printf(""%d\n"", n);
        n++;
    }

    return 0;
}
"
241-21110,evan886/learn-c,mysrc/p67.c,12,1,4,1492938.1432011002,173063.0,8.626557958662453,1330.0,1312.0,39176.0,13306.0,1617.0,636.0,1340.0,593.0,1500000000,0.0009952920954674,1082014363648.0,0.0152661169631868,0.0797606798521397,"#include <stdio.h>

int main(void)
{
	 int no = 1;
	 int sum = 0;

	 do
	 {
		 sum +=no;
		 no++;
	 }while (no <= 5);

	 printf(""1 到5的合计值是 %d \n"", sum);
	 return (0);
}"
140-19759,ZenQ3/Linux-C-Program,basic/misc/getopt.c,29,1,6,1798892.97578475,176323.0,10.198941714920911,1317.0,1296.0,40166.0,13649.0,1696.0,637.0,1353.0,593.0,1500000000,0.0011992619838565,1082014363648.0,0.0148193939531428,0.0795131468921304,"#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char *argv[])
{
    int arg;

    if (argc < 2)
    {
        printf(""no arguments\n"");
    }
    while ((arg = getopt(argc, argv, ""ab:c"")) != -1)
    {
        printf(""optind: %d\n"", optind);
        switch (arg)
        {
            case 'a':
                printf(""option: a\n"");
                break;
            case 'b':
                printf(""option: b\n"");
                printf(""argument of -b: %s\n"", optarg);
                break;
            case 'c':
                printf(""option: c\n"");
                break;
            default:
                printf(""unknow option: %c\n"", (char)optopt);
                break;
        }
    }

    return 0;
}
"
302-8619,chenai/Lily,Test/all.c,22,1,3,2009194.57711275,169096.0,19.639009793253532,1139.0,1129.0,38451.0,12707.0,1567.0,587.0,1317.0,548.0,1500000000,0.0013394630514085,1082014363648.0,0.0134124994086199,0.0785605379412799,"
int a[12];

int xxx()
{
	return 0;
}

int sum(int a, int b)
{
	return a+b;
}

int main()
{
	int i;
	int j;

	i = 1;
	j = 12;
	while(i < j) 
	{
		a[i+j] = sum(i,j);
		i = i + 1;
	}
	
	return 0;
}"
260-2810,Gurgel100/gcc,gcc/testsuite/gcc.c-torture/execute/pr88693.c,48,1,10,1661958.1729173,172049.0,9.659794593400717,1156.0,1147.0,39231.0,12972.0,1595.0,586.0,1337.0,545.0,1500000000,0.0011079721152782,1082014363648.0,0.0133857215095699,0.0778307760090416,"/* PR tree-optimization/88693 */

__attribute__((noipa)) void
foo (char *p)
{
  if (__builtin_strlen (p) != 9)
    __builtin_abort ();
}

__attribute__((noipa)) void
quux (char *p)
{
  int i;
  for (i = 0; i < 100; i++)
    if (p[i] != 'x')
      __builtin_abort ();
}

__attribute__((noipa)) void
qux (void)
{
  char b[100];
  __builtin_memset (b, 'x', sizeof (b));
  quux (b);
}

__attribute__((noipa)) void
bar (void)
{
  static unsigned char u[9] = ""abcdefghi"";
  char b[100];
  __builtin_memcpy (b, u, sizeof (u));
  b[sizeof (u)] = 0;
  foo (b);
}

__attribute__((noipa)) void
baz (void)
{
  static unsigned char u[] = { 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r' };
  char b[100];
  __builtin_memcpy (b, u, sizeof (u));
  b[sizeof (u)] = 0;
  foo (b);
}

int
main ()
{
  qux ();
  bar ();
  baz ();
  return 0;
}
"
300-18445,Levi-Armstrong/gdb-7.7.1,gdb/testsuite/gdb.base/dprintf-non-stop.c,24,1,10,6002772897.016257,170157.0,35277.848675047164,1152.0,1142.0,38704.0,12811.0,1574.0,589.0,1321.0,547.0,1500000000,4.001848598010838,1082014363648.0,0.0134816669311283,0.0782490536736872,"/* This testcase is part of GDB, the GNU debugger.

   Copyright (C) 2013-2014 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

void
foo ()
{
}

int
main ()
{
  sleep (1);
  foo ();
  sleep (3);
  return 0;
}
"
016-6021,TommesDee/cpachecker,test/programs/simple/reachdef/localVarsLoop.c,9,1,0,1963413.32048175,169061.0,11.613636498068743,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0013089422136545,1082014363648.0,0.0134152761429306,0.0785563462891999,"

int main() {

int i;
int a;

  i = 0;

  while(i){
  	a = 0;
  }

 return 0;
}

"
291-33130,epicsdeb/rtems-gdb,gdb/testsuite/gdb.cell/break-spu.c,30,1,10,1635842.9566024502,173904.0,9.403222467568314,1340.0,1322.0,39447.0,13428.0,1626.0,636.0,1346.0,594.0,1500000000,0.0010905619710683,1082014363648.0,0.0153072959793909,0.0794704491725768,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2009, 2011 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

   Contributed by Markus Deuling <deuling@de.ibm.com>  */

#include <stdio.h>

void foo (void);

int
main (unsigned long long speid, unsigned long long argp,
      unsigned long long envp)
{
  int i;

  printf (""Hello World! from spu\n"");

  i = 5;
  foo ();
  printf (""i = %d\n"", i);

  return 0;
}

void
foo (void)
{
  printf (""in foo\n"");
}
"
213-6434,xdje42/gdb,gdb/testsuite/gdb.base/dprintf-non-stop.c,24,1,10,6020757488.7899685,170155.0,35383.958672974644,1152.0,1142.0,38704.0,12811.0,1574.0,589.0,1321.0,547.0,1500000000,4.013838325859979,1082014363648.0,0.0134818253944932,0.0782490536736872,"/* This testcase is part of GDB, the GNU debugger.

   Copyright (C) 2013-2014 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

void
foo ()
{
}

int
main ()
{
  sleep (1);
  foo ();
  sleep (3);
  return 0;
}
"
309-16838,mattstock/binutils-bexkat1,gdb/testsuite/gdb.base/dprintf-non-stop.c,24,1,10,6001885831.472464,170155.0,35273.0500484852,1152.0,1142.0,38704.0,12811.0,1574.0,589.0,1321.0,547.0,1500000000,4.001257220981643,1082014363648.0,0.0134818253944932,0.0782490536736872,"/* This testcase is part of GDB, the GNU debugger.

   Copyright (C) 2013-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

void
foo ()
{
}

int
main ()
{
  sleep (1);
  foo ();
  sleep (3);
  return 0;
}
"
383-17776,ANSSI-FR/picon,examples/unit_tests/src/test_sleep.c,5,1,1,3002721567.2889724,173672.0,17289.612413054492,1341.0,1321.0,39372.0,13401.0,1622.0,637.0,1342.0,593.0,1500000000,2.0018143781926483,1082014363648.0,0.0153277442535354,0.0794724575066795,"#include <unistd.h>
#include <stdio.h>

#define SLEEP_DURATION_SECONDS 2


int main() {

  printf(""entering sleep for %u seconds\n"", SLEEP_DURATION_SECONDS);

  sleep(SLEEP_DURATION_SECONDS);

  return 0;
}
"
135-3737,totalspectrum/binutils-propeller,gdb/testsuite/gdb.base/dprintf-non-stop.c,24,1,10,6002102590.631694,170155.0,35232.46507596016,1152.0,1142.0,38704.0,12811.0,1574.0,589.0,1321.0,547.0,1500000000,4.001401727087796,1082014363648.0,0.0134818253944932,0.0782490536736872,"/* This testcase is part of GDB, the GNU debugger.

   Copyright (C) 2013-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

void
foo ()
{
}

int
main ()
{
  sleep (1);
  foo ();
  sleep (3);
  return 0;
}
"
303-30727,swigger/gdb-ios,gdb/testsuite/gdb.base/dprintf-non-stop.c,24,1,10,6002146890.037693,170155.0,35274.58429079369,1152.0,1142.0,38704.0,12811.0,1574.0,589.0,1321.0,547.0,1500000000,4.001431260025129,1082014363648.0,0.0134818253944932,0.0782490536736872,"/* This testcase is part of GDB, the GNU debugger.

   Copyright (C) 2013-2016 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

void
foo ()
{
}

int
main ()
{
  sleep (1);
  foo ();
  sleep (3);
  return 0;
}
"
033-15392,jmesmon/trifles,fizzbuz.c,18,1,5,2106122.9053884,215936.0,9.753454727326616,1347.0,1327.0,48523.0,19468.0,1625.0,642.0,1345.0,600.0,1500000000,0.0014040819369256,1082014363648.0,0.0123832987551867,0.0619493756526599,"#include <stdio.h>

int main(void)
{
	int i;
	for(i = 0; i <= 100; i++) {
		int fizz = !(i % 3);
		int buzz = !(i % 5);

		if (fizz && buzz) {
			puts(""FizzBuzz"");
		} else if (fizz) {
			puts(""Fizz"");
		} else if (buzz) {
			puts(""Buzz"");
		} else {
			printf(""%d\n"", i);
		}
	}
	return 0;
}
"
152-27420,ProgDan/maratona,Maratona_C/OBI2008/telefone.c,16,1,5,1666217.9259582001,174826.0,9.530716255019277,1285.0,1267.0,39719.0,13508.0,1628.0,634.0,1345.0,591.0,1500000000,0.0011108119506388,1082014363648.0,0.0145973711004084,0.0788697465571984,"#include <stdio.h>
#include <ctype.h>

int main() {
	char ch;
	int dig;
	while ((ch = getc(stdin)) != EOF) {
		if (isalpha(ch)) {
			if (ch >= 'Q') {
				ch--;
			}
			dig = (ch - 'A') / 3;
			putc('2' + dig, stdout);
		} else {
			putc(ch, stdout);
		}
	}
	return 0;
}
"
252-1966,Jadoch/LinuxProject,MPS/prog_linux/31/exemple_gethostent.c,11,1,3,2400154.4807106,464153.0,5.171040583600666,2894.0,2107.0,101924.0,49807.0,2251.0,775.0,1615.0,693.0,1500000000,0.0016001029871404,1082014363648.0,0.0107744644546087,0.035154319156929,"	#include <stdio.h>
	#include <netdb.h>

	int
main (void)
{
	struct hostent * hote;
	sethostent (1);
	while ((hote = gethostent ()) != NULL)
		fprintf (stdout, ""%s "", hote -> h_name);
	fprintf (stdout, ""\n"");
	endhostent ();
	return (0);
}
"
144-28595,ZenQ3/Linux-C-Program,basic/string/isalpha.c,13,1,5,1698046.80626835,179362.0,9.46714465717376,1354.0,1334.0,40571.0,14101.0,1637.0,635.0,1352.0,594.0,1500000000,0.0011320312041789,1082014363648.0,0.014986451979795,0.0771510096575943,"#include <stdio.h>
#include <ctype.h>

int main()
{
    char s[] = ""cD1-5#Xt_Et"";
    int i;

    for (i = 0; s[i] != 0; i++)
    {
        if (isalpha(s[i]))
        {
            printf(""%d : %c \n"", i, s[i]);
        }
    }

    return 0;

}
"
178-21315,EvtimPavlov/c-programming-2014-2015-homework,B/02_Atanas_Chompolov/homework_3/task_2_v2.c,14,1,4,1666788.24461985,248857.0,6.693253555254624,1336.0,1317.0,53814.0,23978.0,1619.0,657.0,1341.0,614.0,1500000000,0.0011111921630799,1082014363648.0,0.0106607409074287,0.0543886260798025,"#include <stdio.h>

int main() {
	
	long unsigned int a, b, c;
	int counter;	

	a = 2;
	b = 1;

	for (counter = 0; counter < 100; counter++)
	{
		printf(""%lu, \n"",a);
		c = a + b;
		a = b;
		b = c;
	}	
	return 0;
}
"
015-22869,EvtimPavlov/c-programming-2014-2015-homework,B/02_Atanas_Chompolov/homework_3/task_4.c,13,1,5,1578993.0475875,173638.0,9.09359126458494,1340.0,1321.0,39261.0,13354.0,1619.0,636.0,1341.0,593.0,1500000000,0.001052662031725,1082014363648.0,0.0153249864660961,0.0796160790649054,"#include <stdio.h>

int main()
{
	int n, count;
    	long unsigned int factorial;
	
	factorial = 1;
        n = 10;

    	for (count=1; count<=n; count++)    
       	{
        	factorial*=count;              
       	}
    	printf(""Factorial of %d = %lu\n"",n, factorial);

    return 0;
}
"
206-17152,web1992/c_primer_plus,c_array/arf.c,22,2,7,1834307.9136684,198813.0,9.226293049247282,1505.0,1474.0,44796.0,16799.0,1652.0,639.0,1366.0,596.0,1500000000,0.0012228719424456,1082014363648.0,0.0149839296223084,0.0690478123224287,"#include <stdio.h>

#define SIZE 5

void show_array(const double ary[], int len);

void mult_array(double ary[], double mult, int len);

int main(void) {
    double dip[SIZE] = {5, 10.2, 3, 4, 100};
    printf(""the origin dip ary: \n"");
    show_array(dip, SIZE);
    printf(""the mult dip ary: \n"");
    mult_array(dip, 2.0, SIZE);
    show_array(dip, SIZE);
}

void show_array(const double ary[], int len) {
    int i;
    for (i = 0; i < len; i++) {
        printf(""ary[%d]=%8.3f \n"", i, ary[i]);
    }
}

void mult_array(double ary[], double mult, int len) {
    int i;
    for (i = 0; i < len; i++) {
        ary[i] *= mult;
    }
}
"
348-10151,mit-pdos/fscq-impl,bench/mini-mini.c,14,1,4,66140691.28409025,177479.0,372.6677015308853,1158.0,1148.0,40424.0,13514.0,1605.0,586.0,1341.0,546.0,1500000000,0.0440937941893935,1082014363648.0,0.0129930865060091,0.0756053246319848,"#define _GNU_SOURCE 1
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

int
main(int ac, char **av)
{
  int fd = open(""test.one"", O_CREAT | O_EXCL | O_WRONLY, 0666);
  close(fd);

  int dfd = open(""."", O_RDONLY | O_DIRECTORY);

  for (int i = 0; i < 100; i++) {
    rename(""test.one"", ""test.two"");
    fsync(dfd);

    rename(""test.two"", ""test.one"");
    fsync(dfd);
  }

  unlink(""test.one"");
}
"
299-7473,jaredly/codetalker,tests/data/c/more/code21.c,13,3,2,6719413388.98614,248493023.0,27.03306270695576,1301.0,1284.0,92009460.0,45998375.0,1631.0,636.0,1350.0,593.0,1500000000,4.47960892599076,1082014363648.0,1.0402706558083122e-05,3.050551441517795e-05,"
// Delay for 5 seconds example

#include <stdio.h>
#include <time.h> 
int main()
{
time_t start;
time_t current;

time(&start);
printf(""delay for 5 seconds.\n"");
do{
time(&current);
}while(difftime(current,start) < 5.0);
printf(""Finished delay.\n"");


return 0;
}
"
070-5578,Nidjo123/projecteuler,2.c,17,1,4,1670282.79975045,173316.0,9.634482679037134,1329.0,1311.0,39169.0,13306.0,1620.0,630.0,1342.0,590.0,1500000000,0.0011135218665003,1082014363648.0,0.0152322924600152,0.0796950929013816,"#include <stdio.h>

int main()
{
  int i, a, b, res;

  const int N = 4000000;

  res = 0;
  a = 1;
  b = 2;

  while (b <= N) {
    if (b % 2 == 0)
      res += b;

    int tmp = b;
    b = b + a;
    a = tmp;
  }

  printf(""%d"", res);

  return 0;
}
"
201-10196,dyladan/euler,c/5.1.c,17,2,7,646630795.5561206,1862513595.0,0.3471817852690627,1333.0,1315.0,39172.0,13306.0,1617.0,636.0,1340.0,593.0,1500000000,0.4310871970374137,1082014363648.0,1.4217345887346397e-06,0.0797667594039406,"#include <stdio.h>

int main(int argc, char *argv[]){
  int i = 20;
  int n;
  int div;
  int test = 0;
  for(n = 20; !test; n+=20){
    test = 1;
    for(div = 2; div <= 20; div++){
      if((n%div)!=0){
        test = 0;
        continue;
      }
    }
  }

  printf(""%d\n"", n - 20);
  return 0;
}
"
254-18141,endlessm/chromium-browser,third_party/llvm/polly/lib/External/ppcg/tests/iterator.c,12,1,2,1467557.7403976999,169057.0,8.680841373028032,1139.0,1129.0,38452.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0009783718269318,1082014363648.0,0.0134155935572026,0.0785172440760147,"#include <stdlib.h>

int main()
{
	int i;
	int a[101];

	i = 0;
#pragma scop
	for (i = 0; i < 100; ++i)
		a[i] = i;
	a[i] = i;
#pragma endscop
	if (a[100] != 100)
		return EXIT_FAILURE;

	return EXIT_SUCCESS;
}
"
201-12695,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.base/frame-args.c,43,1,11,1641903.0725955,169057.0,9.71212667916738,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.001094602048397,1082014363648.0,0.0134155935572026,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2007-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

struct s
{
  int a;
  int b;
};

union u
{
  int a;
  float b;
};

enum color { red, green, blue };

static void
break_me (void)
{
}

static void
call_me (int i, float f, struct s s, struct s *ss, union u u, enum color e)
{
  break_me ();
}

int
main (void)
{
  struct s s;
  union u u;

  s.a = 3;
  s.b = 5;
  u.a = 7;

  call_me (3, 5.0, s, &s, u, green);

  return 0;
}
"
372-15635,cxsjabc/basic,c/_topics/assemble/break.c,16,1,7,1501486.63669815,169083.0,8.88017127682854,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010009910911321,1082014363648.0,0.0134490161636592,0.0785049652044725,"/*
   Xi Chen(511272827@qq.com)
   cxsjabcabc
*/
#include <stdio.h>

int main(int argc, char *argv[])
{
	int i = 1;
	int j;

	while(i < 10) {
		if (i > 5)
			break;
		j = i;
		++i;
	}
 
	return 0;
}
"
015-22880,kumarjatin/pintos-selfrr,src/tests/userprog/memory-stress.c,11,1,3,1703314.48316565,169061.0,10.075144474479623,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0011355429887771,1082014363648.0,0.0134152761429306,0.0785563462891999,"int main(void)
{
	int i=0;
	int count = 1000000000;
	int a[1000] = {0};
	for(i=0;i<count;i++)
	{
		a[i%1000] = i;
	}
	return 0;
}
"
147-16226,jnuyens/linux-c-programming,1_4_basics/while3.c,14,1,7,6012784924.2417145,187087.0,32138.977716249658,1347.0,1327.0,42231.0,15424.0,1622.0,636.0,1344.0,594.0,1500000000,4.0085232828278095,1082014363648.0,0.0142928156419206,0.0727777295984736,"#include <stdio.h>
#include <unistd.h>

int main(void)
{ 
	int i = 0;    
	while ( i < 20 ) { 
		printf( ""%d\n"", i );
		i++;            
		usleep(200000); /*microsecond sleep
		there are one million microseconds in 
		one second
		defined in <unistd.h> 
		nanosleep() is defined in <time.h> */
	}
	return 0;
}

"
163-23572,protocolstack9/testzone,tools/valgrind/ex2.c,14,1,3,2308219.3220034,173862.0,13.276155801727809,1299.0,1282.0,39443.0,13426.0,1606.0,634.0,1335.0,592.0,1500000000,0.0015388128813356,1082014363648.0,0.0148451070389159,0.0788174544629177,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main( void)
{
	char    *p_error;
	int      ndx;

	p_error  = malloc(  10);

	for ( ndx = 0; ndx <= 10; ndx++)
	{
		p_error[ndx] = 'a';
	}    
	p_error[10] = '\0';
	puts( p_error);
	free( p_error);

	return 0;
}
"
010-25642,SanDisk-Open-Source/SSD_Dashboard,uefi/userspace/glibc/math/tst-definitions.c,34,1,11,1677196.82212905,172614.0,9.716454053553017,1291.0,1273.0,39066.0,13243.0,1607.0,638.0,1332.0,594.0,1500000000,0.0011181312147527,1082014363648.0,0.014853951591412,0.0797377124395419,"/* Copyright (C) 2000-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@redhat.com>, 2000.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#include <limits.h>
#include <math.h>
#include <stdio.h>


int
main (void)
{
  int result = 0;

  if (FP_ILOGB0 != INT_MIN && FP_ILOGB0 != -INT_MAX)
    {
      puts (""FP_ILOGB0 has no valid value"");
      result = 1;
    }
  else
    puts (""FP_ILOGB0 value is OK"");

  if (FP_ILOGBNAN != INT_MIN && FP_ILOGBNAN != INT_MAX)
    {
      puts (""FP_ILOBNAN has no valid value"");
      result = 1;
    }
  else
    puts (""FP_ILOGBNAN value is OK"");

  return result;
}
"
226-18729,Gathros/algorithm-archive,contents/euclidean_algorithm/code/c/euclidean_example.c,29,2,9,1836017.8219153502,173790.0,10.56457218482076,1338.0,1318.0,39304.0,13398.0,1618.0,638.0,1339.0,593.0,1500000000,0.0012240118812769,1082014363648.0,0.0152828125899073,0.0794656749269477,"#include <stdio.h>
#include <math.h>

int euclid_mod(int a, int b) {
    a = abs(a);
    b = abs(b);

    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }

    return a;
}

int euclid_sub(int a, int b) {
    a = abs(a);
    b = abs(b);

    while (a != b) {
        if (a > b) {
            a -= b;
        } else {
            b -= a;
        }
    }

    return a;
}

int main() {
    int check1 = euclid_mod(64 * 67, 64 * 81);
    int check2 = euclid_sub(128 * 12, 128 * 77);

    printf(""%d\n"", check1);
    printf(""%d\n"", check2);

    return 0;
}
"
081-14885,bitthunder-toolchain/gdb,gdb/testsuite/gdb.base/interrupt-noterm.c,18,1,9,4520180292.078294,170067.0,26578.820653036742,1151.0,1141.0,38683.0,12795.0,1574.0,589.0,1321.0,547.0,1500000000,3.013453528052196,1082014363648.0,0.01347704140133,0.0783052954660243,"/* This testcase is part of GDB, the GNU debugger.

   Copyright (C) 2013 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
main ()
{
  sleep (3);
  return 0;
}
"
121-8096,freecores/zet86,src/tools/ff.c,10,1,4,796575043.4668734,19171401.0,41.55017377185945,1149.0,1140.0,3039106.0,1012950.0,1592.0,586.0,1336.0,545.0,1500000000,0.5310500289779156,1082014363648.0,0.0001193965949593,0.001001713697935,"int main(int argc, char *argv[])
{
  int f = -1;
  int i, top;

  if (argc==2) top=atoi (argv[1]);
  else top = 1000000;

  for (i=0; i<top; i++)
    write (1, &f, 4);

  return 0;
}
"
021-17632,EvtimPavlov/c-programming-2014-2015-homework,A/20_Nikolay_Rangelov/homework_3/task_2.c,18,1,8,1736869.33703715,248601.0,6.986572861734265,1338.0,1318.0,53745.0,23920.0,1619.0,656.0,1341.0,613.0,1500000000,0.0011579128913581,1082014363648.0,0.0106837864690809,0.0544518122706495,"#include<stdio.h>

int main()
{
    int unsigned long firstNumber = 2;
    int unsigned long  secondNumber = 1;
    int unsigned long thirdNumber;
    int i = 1;
    printf(""%lu, %lu, "", firstNumber, secondNumber);
    for(i=1; i<=97; i++)
    {
        thirdNumber = firstNumber + secondNumber;
        printf(""%lu, "",thirdNumber);
        firstNumber = secondNumber;
        secondNumber = thirdNumber;
    }
    thirdNumber = firstNumber + secondNumber;
    printf(""%lu\n"",thirdNumber);
    return 0;
}

"
181-6389,jakob1899/primes,primes.c,16,2,7,1062400739.9892435,2520275149.0,0.4215415683567493,1341.0,1320.0,587990.0,457877.0,1619.0,700.0,1340.0,656.0,1500000000,0.708267159992829,1082014363648.0,1.055837098205661e-06,0.0041257636009167,"#include <stdio.h>
int maximum = 32767; 
int count = 2; 
int internalcount; 
int main(void)
{
    for(count;count <= maximum;count++) 
    {
        for(internalcount = (count-1); count%internalcount;internalcount--) 
        {}
        if(internalcount == 1) 
        {
            printf(""%i\n"",count);
        }
    }
    return 0;
}
"
275-23901,misizeji/StudyNote_201308,Linux_System/pthread/sem.c,33,1,13,7503120030.043647,187090.0,40104.33497247314,1533.0,1500.0,42734.0,15429.0,1679.0,751.0,1383.0,708.0,1500000000,5.002080020029098,1082014363648.0,0.0162114490352236,0.0777298282413218,"
#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>

sem_t sem;
void printer(char *p)
{
	sem_wait(&sem);
	while(*p != '\0')
	{
		sleep(1);
		printf(""%c\n"",*p);
		p++;
	}
	sem_post(&sem);
}

void *func1(void *arg)
{
	char *p = ""hello"";
	printer(p);
}

void *func2(void *arg)
{
	char *p = ""world"";
	printer(p);
}

int main(int argc, char *argv[])
{
	pthread_t tid1,tid2;
	sem_init(&sem,0,1);
	pthread_create(&tid1,NULL,func1,NULL);
	pthread_create(&tid2,NULL,func2,NULL);
	
	pthread_join(tid1,NULL);
	pthread_join(tid1,NULL);

	sem_destroy(&sem);
	return 0;
}
"
025-644,guolinp/x,gdb-example/gdb_example.c,20,1,4,1346762.99057895,169057.0,13.1669082025589,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0008978419937193,1082014363648.0,0.0134155935572026,0.0785563462891999,"int add(int a, int b)
{
	return a + b;
}

int main(int argc, char *argv[])
{
	int i;

	int sum[10] = {
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	};

	int array1[10] = {
		48, 56, 77, 33, 33, 11, 226, 544, 78, 90
	};

	int array2[10] = {
		85, 99, 66, 0x199, 393, 11, 1, 2, 3, 4
	};

	for (i = 0; i < 10; i++) {
		sum[i] = add(array1[i], array2[i]);
	}
}
"
251-26765,totalspectrum/binutils-propeller,gdb/testsuite/gdb.reverse/amd64-tailcall-reverse.c,31,1,10,1634119.42776285,169086.0,9.664425203742477,1142.0,1132.0,38461.0,12700.0,1566.0,584.0,1317.0,544.0,1500000000,0.0010894129518419,1082014363648.0,0.0134487775451545,0.078399562166494,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2012-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

volatile int v;

static __attribute__ ((noinline, noclone)) void
g (void)
{
  v = 2;
}

static __attribute__ ((noinline, noclone)) void
f (void)
{
  g ();
}

int
main (void)
{
  v = 1;
  f ();
  v = 3;
  return 0;
}
"
057-21542,hzq1001/or1k-src,gdb/testsuite/gdb.trace/trace-unavailable.c,35,1,10,1345262.9791572,169061.0,7.95725803112486,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0008968419861048,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2013 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

static void
bar (int j, char *s)
{
  unsigned char array[2];
  int i = 0;

  array[0] = 'c';
  array[1] = 'd';
}

static void
foo (void)
{}

static void
marker (void)
{}

int
main (void)
{
  char s[4];

  bar (4, s);
  foo ();
  marker ();
  return 0;
}
"
223-736,2017-fall-os/shell-dapn09,shellLabDemos/sigPrint.c,17,1,9,15002972699.934616,174766.0,85846.06101301168,1306.0,1288.0,39719.0,13543.0,1632.0,634.0,1350.0,592.0,1500000000,10.001981799956411,1082014363648.0,0.0148427039584358,0.079005670083737,"#include ""signal.h""
#include ""unistd.h""
#include <stdio.h>

void handler(int signo)
{
  printf(""signal %d caught\n"", signo);
}

int main(int argc, char**argv, char**envp)
{
  int sleepTime = 10;
  signal(SIGINT, handler);
  signal(SIGHUP, handler);

  while (sleepTime) {
    sleepTime = sleep(10);
    if (sleepTime != 0)
    sleepTime = sleep(10);	/* sleep returns early if signal handled */
  }
  printf(""exiting\n"");
  return (0);
}

"
215-29695,defunSM/code,c++/sample1.c,26,2,10,355591837.6659974,974623588.0,0.3647100864133816,1368.0,1345.0,816945.0,553881.0,1637.0,697.0,1347.0,656.0,1500000000,0.2370612251106649,1082014363648.0,2.783638764137935e-06,0.0031637859217727,"#include <stdio.h>
#include <stdlib.h>

int prime (int num);

int main()
{
  int i;
  int colcnt = 0;
  for (i=2; i <= 50000; i++)
    if (prime(i)) {
      colcnt++;
      if (colcnt%9 == 0) {
	printf(""%5d\n"", i);
	colcnt = 0;
      }
      else 
	printf(""%5d "", i);
    }
  putchar('\n');
  return 0;
}

int prime (int num) {
  int i;
  for (i=2; i < num; i++) {
    if (num %i == 0)
      return 0;
  }
  return 1;
}


"
233-17419,larbb/cexercises,evenfib.c,16,1,3,1887274.5567931498,173417.0,10.87899110237174,1338.0,1319.0,39184.0,13309.0,1618.0,636.0,1340.0,593.0,1500000000,0.0012581830378621,1082014363648.0,0.0153214506074952,0.0797630160211837,"#include <stdio.h>

int main()
{
    int x = 0;
    int y = 1;
    int z;
    int sum = 0;

    do {
        z = x + y;
        x = y;
        y = z;
        if (!(y & 01)) 
            sum += y;
    } while (y < 4000000);
    
    printf(""%d\n"", sum);
    return 0;
}
"
271-11983,benghaem/avremu,test/hex/src/simplestatemachine.c,21,1,4,1629347.68013655,169087.0,9.636145889394218,1142.0,1132.0,38460.0,12696.0,1567.0,584.0,1317.0,544.0,1500000000,0.0010862317867577,1082014363648.0,0.0134486980075345,0.0784267730080538,"enum state{
    A,
    B,
    C
};

int main(){

    enum state s = A;
    int counter = 0;

    while(s != C){
        counter++;

        if (counter == 5){
            s = B;
        }

        if (s = B){
            counter -= 2;
        }

        if (counter == -5){
            s = C;
        }
    }
}
"
171-20700,kkmonlee/Project-Euler-Solutions,CCPP/p5.c,16,2,6,48946481.89656436,109737866.0,0.4460309169853913,1336.0,1318.0,39188.0,13313.0,1618.0,636.0,1341.0,593.0,1500000000,0.0326309879310429,1082014363648.0,2.4184906238289707e-05,0.0797699091445877,"#include <stdio.h>

#define ulong unsigned long

int main() {
    const ulong val = 20;
    ulong x;
    ulong y;

    for (x = val; ; x += val) {
        for (y = val - 1; y; y--) {
            if (x % y != 0)
                break;
        }

        if (y == 0) {
            printf(""Answer = %u \n"", x);
            break;
        }
    }

    return 0;
}"
356-2654,stormspirit/heaptrack,tests/test.c,14,1,7,2321974559.8034935,1662108.0,1397.005825734549,1373.0,1350.0,392047.0,204101.0,1635.0,639.0,1357.0,596.0,1500000000,1.5479830398689955,1082014363648.0,0.001638281026263,0.0070905211457557,"#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>

int main()
{
    int i;
    // make app deterministic
    srand(0);
    void* p = malloc(1);
    for (i = 0; i < 10000; ++i) {
        malloc(rand() % 1000);
        usleep(100);
    }
    printf(""malloc: %p\n"", p);
    free(p);
    return 0;
}
"
197-26978,ILyoan/gdb,gdb/testsuite/gdb.base/cursal.c,28,1,10,2044939.5524337,169083.0,12.094290969523843,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0013632930349558,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* Copyright 2004, 2007-2012 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */


void
func2 ()
{
  int v2 = 2;
}

void
func1 ()
{
  func2 ();
}


int
main ()
{
  int v0 = 0;
  func1 ();
}
"
234-25058,swigger/gdb-ios,gdb/testsuite/gdb.btrace/unknown_functions.c,35,1,10,1732594.5664197002,169061.0,10.248336399287831,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0011550630442798,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2013-2016 Free Software Foundation, Inc.

   Contributed by Intel Corp. <markus.t.metzger@intel.com>

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

static int foo (void);

int test (void)
{
  return foo ();
}

static int
bar (void)
{
  return 42;
}

static int
foo (void)
{
  return bar ();
}

int
main (void)
{
  test ();
  test ();
  return 0;
}
"
181-28878,sshidy/glove,check_cooc.c,21,1,7,2399597.7826416004,176434.0,13.600536177834204,1365.0,1340.0,40084.0,13747.0,1637.0,646.0,1356.0,601.0,1500000000,0.0015997318550944,1082014363648.0,0.0153315120668351,0.0787650238710037,"#include <stdio.h>

#define MCR 20

typedef double real;
typedef struct cooccur_rec {
    int word1;
    int word2;
    real val;
} CREC;

char *inputfile=""cooc.bin"";

int main(){
    FILE *fin;
    CREC cr;
    int i=0;

    fin=fopen(inputfile,""rb"");
    if (fin==NULL) printf(""Error on opening file!"");
    else{
        for (i=0;i<MCR;i++){
            fread(&cr, sizeof(CREC), 1, fin);
            printf(""word1=%d,word2=%d,val=%lf\n"",cr.word1,cr.word2,cr.val);
        }
        fclose(fin);
    }
}
"
254-9226,Jadoch/LinuxProject,MPS/prog_linux/31/exemple_getprotoent.c,11,1,3,2145647.7697938,347466.0,6.175127926185584,2151.0,1825.0,78498.0,34091.0,1820.0,724.0,1473.0,653.0,1500000000,0.0014304318465292,1082014363648.0,0.0114428462065353,0.0414782971693504,"	#include <stdio.h>
	#include <netdb.h>

	int
main (void)
{
	struct protoent * proto;
	setprotoent (0);
	while ((proto = getprotoent ()) != NULL)
		fprintf (stdout, ""%s "", proto -> p_name);
	endprotoent ();
	fprintf (stdout, ""\n"");
	return (0);
}
"
028-24638,Gurgel100/gcc,gcc/testsuite/gcc.c-torture/execute/pr97695.c,16,2,6,1835192.9029449,169122.0,10.851290784167642,1144.0,1134.0,38469.0,12699.0,1569.0,585.0,1318.0,546.0,1500000000,0.0012234619352966,1082014363648.0,0.0134695663485531,0.078525641025641,"int *a, b, **c = &a, d, e;

int f(int g, int h) { return !h || (g && h == 1) ? 0 : g / h; }

static void *i(int g) {
  while (e < 2)
    if (!f(g, 9)) {
      while (b)
        ;
      return 0;
    }
  return 0;
}

void j() {
  i(1);
  *c = i(d);
}

int main() { j(); return 0; }
"
210-32113,jonarivas/EulerProject,src/Problem10.c,38,2,13,310330291.5114909,981702572.0,0.3161143709420779,1359.0,1337.0,39800.0,13606.0,1630.0,637.0,1350.0,594.0,1500000000,0.2068868610076606,1082014363648.0,2.74624929881512e-06,0.0788488184848144,"/*
 ============================================================================
 Name        : Euler.c
 Author      : Jonathan Rivas
 Version     :
 Copyright   : 
 Description : Problem #10
 ============================================================================
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define limit 2000000

int isPrime(long number) {
	int i;
	if (number != 2){
		if(number % 2 == 0) {
			return 0;
		}
		for(i= 3; (i * i) <= number; i+=2) {
			if(number % i == 0) {
				return 0;
			}
		}
	}
	return 1;
}

int main(void) {
	struct timeval stop, start;
	gettimeofday(&start, NULL);
	long i=3;
	long long sum=2;
	for(;i<=limit;i+=2){
		if(isPrime(i)){
			sum+=i;
		}
	}
	printf(""the sum is: %lld"", sum);
	gettimeofday(&stop, NULL);
	printf(""\ntook %lu usec\n"", stop.tv_usec - start.tv_usec);
	return 0;
}
"
232-31619,totalspectrum/binutils-propeller,gdb/testsuite/gdb.dwarf2/dw2-inline-param-main.c,29,1,10,1340177.9578998,169102.0,7.925258128230299,1142.0,1132.0,38461.0,12698.0,1567.0,584.0,1317.0,544.0,1500000000,0.0008934519719332,1082014363648.0,0.0134475050561199,0.0784221740065286,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2010-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

asm ("".globl cu_text_start"");
asm (""cu_text_start:"");

volatile int v;

int
main (void)
{
  asm ("".globl block_start"");
  asm (""block_start:"");

  v = 1;

  asm (""break_at:"");

  v = 2;

  asm ("".globl block_end"");
  asm (""block_end:"");

  return 0;
}

asm ("".globl cu_text_end"");
asm (""cu_text_end:"");
"
328-8224,doc-cloud/c,glibc/stdio/setbuf/setvbuf.c,14,1,0,7514748781.453818,178470.0,42106.50967109318,1344.0,1322.0,40664.0,14078.0,1641.0,636.0,1355.0,593.0,1500000000,5.009832520969212,1082014363648.0,0.0149380848321846,0.077180227247817,"
#include <stdio.h>
#include <string.h>

int main()
{
	char buffer[1024];

	memset(buffer, '\0', sizeof(buffer));

	fprintf(stdout, ""set full buffer\n"");
	setvbuf(stdout, buffer, _IOFBF, 1024);

	fprintf(stdout, ""Linkerist Heracles\n"");
	fprintf(stdout, ""This output will go into buff\n"");
	fflush(stdout);

	fprintf(stdout, ""just a test line for sleep\n"");
	fprintf(stdout, ""will come after sleeping 5 seconds\n"");

	sleep(5);

	return(0);
}

"
101-28378,zg/pe,014.c,21,2,9,277393607.88837075,797778797.0,0.3477074197047129,1335.0,1316.0,39173.0,13307.0,1617.0,636.0,1340.0,593.0,1500000000,0.1849290719255805,1082014363648.0,3.322976256036045e-06,0.0797637195121951,"#include <stdio.h>

#define SIZE 1000000

int main(void) {
    unsigned long l=0L,n,t;
    int h=0,i;
    for(i = 2; i < SIZE; i++) {
        t = 0;
        n = i;
        while(1 < n) {
            t++;
            if(n % 2 == 0)
                n = n / 2;
            else
                n = 3 * n + 1;
        }
        if(l < t) {
            l = t;
            h = i;
        }
    }
    printf(""%d\n"",h);
    return 0;
}
"
181-15257,kontais/EFI-MIPS,test/pack/pack-test.c,24,1,3,1664762.9672661,173137.0,9.61528731582504,1338.0,1319.0,39185.0,13307.0,1618.0,636.0,1340.0,593.0,1500000000,0.0011098419781774,1082014363648.0,0.0153462287090569,0.079764535548274,"#include <stdio.h>

typedef struct _xx {
  char a;
  short b;
  char c;
  int d;
} XX;

typedef union _xxu {
  XX s;
  int i[30];
} XXU;

int main()
{
  int i;
  XXU st;

  for (i = 0; i< 30; i++) {
    st.i[i] = 0;
  }
  st.s.a = '1';
  st.s.b = 0xabcd;
  st.s.c = '2';
  st.s.d = 0x12345678;

  printf(""sizeof st = %d\n"",sizeof(st));
  return 0;
}
"
129-11343,aureooms-ulb-2010-2015/2013-2014-infof403-project,2/more/tools/c/cbl/display.c,29,1,11,1655148.2258364,173198.0,9.556392106144411,1272.0,1257.0,39287.0,13363.0,1613.0,634.0,1332.0,592.0,1500000000,0.0011034321505576,1082014363648.0,0.0146017852400143,0.0792212725546058,"#include <stdio.h>

void display_si64(__int64_t it);
void display_i64(__int64_t it);
void display_string(char* string);

__int64_t i;
int main(){
	display_i64(i);
	display_string(""Hello world!\""\n"");
	return 0;
}

void display_si64(__int64_t it){
	if(it < 0){
		putchar('-');
		it = -it;
	}
	display_i64(it);
}

void display_i64(__int64_t it){
	int c = '0' + it % 10;
	it /= 10;
	if(it > 0) display_i64(it);
	putchar(c);
}

void display_string(char* string){
	while(*string != '\0'){
		putchar(*string);
		++string;
	}
	putchar('\n');
}"
198-15464,ajeshvc/git-test,print.c,9,1,2,1594218.0762066,175090.0,9.105134502255982,1303.0,1287.0,39757.0,13751.0,1613.0,638.0,1336.0,595.0,1500000000,0.0010628120508044,1082014363648.0,0.0147923924838654,0.0781565373402108,"#include<stdio.h>

int main()
{
    int i=0;
    while(i<10){
        printf(""Hello World !!!"");
        i++;
    }
    return 0;
}
"
130-6316,ChristophTWeinmann/GDB,gdb/testsuite/gdb.base/dprintf-non-stop.c,24,1,9,6002366275.526583,170157.0,35275.4589878759,1152.0,1142.0,38704.0,12811.0,1574.0,589.0,1321.0,547.0,1500000000,4.001577517017722,1082014363648.0,0.0134816669311283,0.0782490536736872,"/* This testcase is part of GDB, the GNU debugger.

   Copyright (C) 2013 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

void
foo ()
{
}

int
main ()
{
  sleep (1);
  foo ();
  sleep (3);
  return 0;
}
"
043-26859,Jadoch/LinuxProject,MPS/prog_linux/33/exemple_flush.c,14,1,1,7501978474.552743,179136.0,41878.67583288674,1342.0,1319.0,40798.0,14005.0,1653.0,640.0,1362.0,595.0,1500000000,5.001318983035162,1082014363648.0,0.0148546355841371,0.0775504990602704,"	#include <stdio.h>
	#include <termios.h>
	#include <unistd.h>

	int
main (void)
{
	struct termios terminal;
	int i;

	fprintf (stdout, ""FLUSH dans 5 secondes\n"");
	sleep (5);
	fprintf (stdout, ""FLUSH !\n"");
	if (tcgetattr (STDIN_FILENO, & terminal) == 0)
		tcsetattr (STDIN_FILENO, TCSAFLUSH, & terminal);
	while ((i = fgetc (stdin)) != EOF)
		fprintf (stdout, ""%02X "", i);
	return (0);
}
"
021-15858,JamesDillon/C-Misc,biggest_number_of_array.c,20,1,4,1942127.82662355,173999.0,11.161713573066512,1337.0,1320.0,39433.0,13392.0,1626.0,633.0,1345.0,591.0,1500000000,0.0012947518844157,1082014363648.0,0.0152702027023143,0.0794131566493137,"#include <stdio.h>

int sort(int arr[], int size);

int main(int argc, char *argv[])
{
   int arr[5] = { 1, 5, 7, 3, 5};
   printf(""The biggest is: %d\n"", sort(arr, 5));

   return 0;
}

int sort(int arr[], int size)
{
   int largestIndex = 0;
   int j;

   for (j = 1; j < size; j++)
   {
      if (arr[largestIndex] < arr[j])
      {
         largestIndex = j;
      }
   }

   return arr[largestIndex];
}
"
037-29054,zonomasa/malloc_perf,src/malloc_perf.c,19,1,7,1566121.23828375,169057.0,9.263863667283816,1139.0,1129.0,38452.0,12696.0,1568.0,588.0,1317.0,547.0,1500000000,0.0010440808255225,1082014363648.0,0.0134155935572026,0.0785954485023852,"#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/* Number of sizeArray : 14 */
int s_sizeArray[] = {8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536};

void
malloc_perf(void)
{
    struct timeval tv;

    for (int i = 0; i < 14; i++){
        
    }
}

void
free_perf(void)
{


}



int main(int argc, char *argv[])
{
    malloc_perf();

    free_perf();

    return 0;
}
"
275-33285,javimv36/SO,ejercicios/e2-hilos/hilos.c,33,2,13,7502224497.031421,180454.0,41561.02826205016,1439.0,1412.0,41288.0,14410.0,1658.0,689.0,1368.0,645.0,1500000000,5.001482998020947,1082014363648.0,0.0157990401986101,0.0782792918955797,"#include<stdio.h>
#include<string.h>
#include<pthread.h>
#include<stdlib.h>
#include<unistd.h>

void *trabajo(void *arg);

pthread_t tid[2]; //tid es el identificador de hilo (threadID)

int main(void)
{
    int i = 0;
    int err;

    while(i < 2)  //Queremos crear 2 hilos
    {
        err = pthread_create(&(tid[i]), NULL, trabajo, NULL);
        if (err != 0)
            printf(""\nError al crear el hilo :[%d]"", strerror(err));
        else
            printf(""\n Hilo creado!\n"");

        i++;
    }

    sleep(5);
    return 0;
}

void *trabajo(void *arg)
{
    unsigned long i = 0;
    pthread_t id = pthread_self();
    
    if(pthread_equal(id,tid[0]))
    {
        printf(""\n Estes es el primer hilo\n"");
    }
    else
    {
        printf(""\n Este es el segundo hilo\n"");
    }

    for(i=0; i<(0xFFFFFFFF);i++);

    return NULL;
}
"
042-30905,swigger/gdb-ios,gdb/testsuite/gdb.base/interrupt-noterm.c,18,1,10,4502084705.745801,170067.0,26472.41795880447,1151.0,1141.0,38683.0,12795.0,1574.0,589.0,1321.0,547.0,1500000000,3.001389803830534,1082014363648.0,0.01347704140133,0.0783052954660243,"/* This testcase is part of GDB, the GNU debugger.

   Copyright (C) 2013-2016 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
main ()
{
  sleep (3);
  return 0;
}
"
113-26902,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.base/condbreak-call-false.c,31,1,10,1797122.9972317498,169100.0,10.62756948551153,1142.0,1132.0,38461.0,12696.0,1567.0,584.0,1317.0,544.0,1500000000,0.0011980819981545,1082014363648.0,0.0134476641040804,0.0784252399476122,"/* Copyright 2013-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
zero (void)
{
  return 0;
}

int
foo (void)
{
  return 23;
}

void
bar (void)
{
}


int
main (void)
{
  foo ();
  bar ();
}
"
280-4047,edu1910/C_Unipe,questao10.c,22,1,8,2267822.7396681,175251.0,12.940422593879635,1340.0,1322.0,39702.0,13588.0,1627.0,635.0,1345.0,594.0,1500000000,0.0015118818264454,1082014363648.0,0.0151896422844948,0.0788328016513417,"#include <stdio.h>

#define true 1
#define false 0

typedef int boolean;

void print_arr(int* arr, int size, boolean pares)
{
    int idx;

    for (idx = 0; idx < size; idx++)
    {
        if (arr[idx] != 0)
        {
            boolean par = ((arr[idx] % 2) == 0);
            if (pares && par)
                printf(""%d\n"", arr[idx]);
            else if (!pares && !par)
                printf(""%d\n"", arr[idx]);
        }
    }
}

int main(int argc, char *argv[])
{
    int array1[] = {1, 30, 34, 80, 0, 1, 32};

    print_arr(array1+1, 5, true);

    return 0;
}"
326-22210,FreeON/spammpack,src-C/tools/print_bits.c,20,1,6,1964327.9956653,177834.0,11.0458461261626,1340.0,1319.0,40743.0,14124.0,1627.0,638.0,1347.0,594.0,1500000000,0.0013095519971102,1082014363648.0,0.0149521463837061,0.0766581004975668,"#include <stdio.h>

void
print_bits (int i)
{
  int index;

  printf(""% i = 0b"", i);
  for (index = 8; index >= 0; index--)
  {
    if (i & (1 << index)) { printf(""1""); }
    else                  { printf(""0""); }
  }
  printf(""\n"");
}

int
main ()
{
  print_bits(16);
  print_bits(-16);
  print_bits(30);
  print_bits((30 & (-16)) + 16);
}
"
355-10969,Amztion/Algorithm,Archived/algorithms/FindInPartiallySortedMatrix.c,33,1,12,2025332.8839316498,174329.0,11.61787195475222,1340.0,1321.0,39486.0,13435.0,1626.0,629.0,1346.0,591.0,1500000000,0.0013502219226211,1082014363648.0,0.0152642417497949,0.0792124109521739,"#include <stdio.h>

int findNumber(int matrix[][4], int *row, int *columns, int number){
    int minRow = 0, maxCol = *columns;
    if(matrix == NULL || row < 0 || columns < 0){
        return 0;
    }
    while(minRow < 4 && maxCol >= 0 && matrix != NULL){
        if(matrix[minRow][maxCol] == number){
            *row = minRow;
            *columns = maxCol;
            return 1;
        }
        else if(matrix[minRow][maxCol] < number){
            ++minRow;
        }else if(matrix[minRow][maxCol] > number){
            --maxCol;
        }
    }
    return 0;
}

int main(int argc, const char *argv[])
{
    int row = 3;
    int col = 3;
    int matrix[4][4] = {
        {1,2,8,9},
        {2,4,9,12},
        {4,7,10,13},
        {6,8,11,15}
    };

    int result = findNumber(matrix, &row, &col, 7);
    printf(""%d,%d\n"",row, col);
    return 0;
}
"
345-617,we3x/Skola,liste/reverse_list.c,32,2,12,2237673.03396015,179069.0,12.496149528952529,1349.0,1329.0,40577.0,14159.0,1630.0,637.0,1350.0,593.0,1500000000,0.0014917820226401,1082014363648.0,0.014955129028475,0.0769146448406898,"#include <stdio.h>

typedef struct list {
  int value;
  struct list* next;
} TList;

void print_list(TList* head) {
  while (head) {
    printf(""%d "", head->value);
    head = head->next;
  }
  printf(""\n"");
}

TList* reverse(TList* head) {
  TList* new_root = 0;
  while (head) {
    TList* next = head->next;
    head->next = new_root;
    new_root = head;
    head= next;
  }
  return new_root;
}

int main() {
  TList d = { 1, 0 };
  TList c = { 2, &d };
  TList b = { 3, &c };
  TList a = { 4, &b };

  TList* head = &a;
  print_list(head);
  head = reverse(head);
  print_list(head);

  return 0;
}
"
085-17600,efortuna/AndroidSDKClone,ndk_experimental/tests/build/graphite-loop/jni/graphite-loop-transformation.c,9,2,5,703865517.0472338,400219053.0,1.758700670854868,1139.0,1130.0,100038452.0,12696.0,100001614.0,589.0,6251376.0,555.0,1500000000,0.4692436780314892,1082014363648.0,5.6693952549030695e-06,1.061998149186654,"#define  N 10000
int A[N][N];
int main()
{
   int i, j, sum = 0;
   for(i=0; i<N; i++)
     for(j=0; j<N; j++)
       sum += A[j][i];
   return sum;
}
"
019-27946,ChrisJamesCampbell/UDP,workbeast.c,10,1,6,601097565.0278852,6000172664.0,0.0999905038732732,1297.0,1279.0,2000039075.0,1000013245.0,1607.0,634.0,1333.0,592.0,1500000000,0.4007317100185901,1082014363648.0,4.293209786204246e-07,1.3886424487423606e-06,"/* iterate.c */
#include <stdio.h>

int 
main (void)
{
  printf(""start\n"");

  volatile unsigned long long i;
  for (i = 0; i < 1000000000ULL; ++i);

  printf(""stop\n"");

  return 0;
}
"
390-3599,jstolarek/sandbox,c/fibonacci.c,29,1,8,294713091.10522264,2439922490.0,0.1207878906841831,1352.0,1333.0,526420372.0,383890102.0,1618.0,637.0,1340.0,593.0,1500000000,0.1964753940701484,1082014363648.0,1.1004447932278373e-06,4.600628158871431e-06,"#include <stdio.h>

int fib_rec(int n) {
  int result;
  if (n == 0 || n == 1) {
    result = 1;
  } else {
    result = fib_rec(n - 1) + fib_rec(n - 2);
  }
  return result;
}

int fib_it(int n) {
  int result;
  if (n == 0 || n == 1) {
    result = 1;
  } else {
    int a = 1, b = 1, c = 1;
    for (int i = 1; i < n; i++) {
      a = b;
      b = c;
      c = a + b;
    }
    result = c;
  }
  return result;
}

int main () {
  printf(""%d\n"", fib_it(40));
  printf(""%d\n"", fib_rec(40));
  return 0;
}
"
356-1859,gsvolt/TestCXX,convert.c,14,1,6,1782107.86543785,189020.0,9.428139879377843,1343.0,1324.0,42285.0,15380.0,1618.0,638.0,1340.0,595.0,1500000000,0.0011880719102919,1082014363648.0,0.0141096180298381,0.0726784011098586,"#include<stdio.h>
int main(){
	int fahr, celcius;
	int lower, upper, step;
	lower=0;
	upper=300;
	step=20;
	fahr=lower;
	while(fahr<=upper){
		celcius = 5 * (fahr-32) / 9;
		printf(""%d\t%d\n"", fahr, celcius);
		fahr = fahr + step;
	}
	return 0;
}
"
306-8066,guillermo-carrasco/algorithmics,src/even_fibonacci.c,19,1,9,1665002.8992444,173379.0,9.603250682031849,1335.0,1316.0,39176.0,13309.0,1618.0,638.0,1339.0,593.0,1500000000,0.0011100019328296,1082014363648.0,0.0152902023889859,0.0797942269219777,"/*
Each new term in the Fibonacci sequence is generated by adding the previous two terms.
 By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four
million, find the sum of the even-valued terms.
*/

#include <stdio.h>
#include <stdlib.h>

int main() {
    int n1=1;
    int n2=2;
    int sum=2;
    while (n2 <= 4000000) {
        int aux = n2;
        n2 += n1;
        n1 = aux;
        if (n2%2 == 0) sum += n2;
    }
    printf(""%d\n"", sum);
}
"
266-29346,rahul30des/myc,timer_implementation/timer_implementation.c,21,1,7,15014677765.42995,4667272372.0,3.217013400605539,1353.0,1332.0,1166813992.0,13663.0,1641.0,635.0,1357.0,591.0,1500000000,10.0097851769533,1082014363648.0,5.75282474643629e-07,3.620071894850658e-06,"#include <signal.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

volatile int stop = 0;

void sigalarm_handler(int sig)
{
    stop = 1;
}

int main(int argc, char **argv)
{
    struct sigaction sinst;
    unsigned int counter = 0;

    sigemptyset(&sinst.sa_mask);
    sinst.sa_flags = 0;
    sinst.sa_handler = sigalarm_handler;
    sigaction(SIGALRM, &sinst, NULL);

    // Invoke SIGALRM in 10 secs
    alarm(10); 

    while (!stop) {
        counter++;
    }

    printf(""Counted till %u \n"", counter);
    return 0;
}
"
368-9336,deweixu/ulcdemo,pthread/hello_multi.c,20,1,11,7507985014.468431,190730.0,39351.21546689037,1547.0,1514.0,43695.0,16174.0,1675.0,760.0,1371.0,715.0,1500000000,5.005323342978954,1082014363648.0,0.0160488648875373,0.0755148741418764,"#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

#define NUM 5

int main()
{
    pthread_t t1, t2;

    void *print_msg(void *);

    pthread_create(&t1, NULL, print_msg, (void *)""hello"");
    pthread_create(&t2, NULL, print_msg, (void *) ""world\n"");

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
}

void *print_msg(void *m)
{
    char  *cp = (char *)m;
    int i;
    for(i = 0; i < NUM; i++) {
        printf(""%s"", m);
        fflush(stdout);
        sleep(1);
    } 
    return NULL;
}"
216-445,ShooShoSha/Course-Work,COP3014/Chapters/8/Samples/pgm8-4.c,15,1,7,2129552.7694746,175995.0,12.100071024745022,1338.0,1319.0,39673.0,13627.0,1618.0,637.0,1340.0,594.0,1500000000,0.0014197018463164,1082014363648.0,0.0150970198016989,0.07859287054409,"// Function to calculate the nth triangular number

#include <stdio.h>

void calculateTriangularNumber(int n)
{
	int i, triangularNumber = 0;
	
	for(i = 1; i <= n; ++i)
		triangularNumber += i;
	
	printf(""Triangular number %i is %i\n"", n, triangularNumber);
}

int main(void)
{
	calculateTriangularNumber(10);
	calculateTriangularNumber(20);
	calculateTriangularNumber(50);
	
	return 0;
}
"
163-31548,selmentdev/selment-toolchain,source/gcc-latest/gcc/testsuite/gcc.c-torture/execute/strcpy-2.c,19,1,8,1616519.87582445,170752.0,9.46705748688156,1138.0,1130.0,38915.0,12874.0,1590.0,586.0,1333.0,546.0,1500000000,0.0010776799172163,1082014363648.0,0.0132824212893553,0.0782984803722798,"/* Test to make sure strcpy works correctly. */
#define STRING ""Hi!THE""

const char a[] = STRING;

void f(char *a) __attribute__((noinline));
void f(char *a)
{
  __builtin_strcpy (a, STRING);
}


int main(void)
{
  int i;
  char b[sizeof(a)] = {};
  f(b);
  for(i = 0; i < sizeof(b); i++)
    {
      if (a[i] != b[i])
	__builtin_abort ();
    }
  return 0;
}
"
251-27460,tudinfse/haft,src/benches/util/libc/src/main_dummy.c,30,1,12,1872843.01500765,179001.0,10.46275160473964,1364.0,1343.0,40608.0,14174.0,1636.0,647.0,1354.0,602.0,1500000000,0.0012485620100051,1082014363648.0,0.0151228205429019,0.0773794312000292,"#include <stdio.h>
#include <string.h>
#include <strings.h>
#include <stdlib.h>
#include <ctype.h>

char a[100];
char b[100];
char c[100];

int main() {
  bzero(a, 100);
  a[10] = 0;
  printf(""bzero: %s\n"", a);

  memset(a, 50, 100);
  a[10] = 0;  
  printf(""memset: %s\n"", a);

  memcpy(b, a, 100);
  printf(""memcpy: %s\n"", b);

  memmove(c, a, 100);
  printf(""memmove: %s\n"", c);

  // set some chars
  a[0] = 'a';
  b[0] = 'b';
  c[0] = 'c';
  a[0] = toupper(a[0]);
  printf(""toupper: %s\n"", a);

  // null-terminate again for sanity
  a[10] = 0;
  b[10] = 0;
  c[10] = 0;
  int r = strcmp(a, b);
  printf(""strcmp: %d\n"", r);

  size_t sz = strlen(a);
  printf(""strlen: %d\n"", sz);

  return 0;
}
"
147-24593,BelongMin/Cproject,normal/charater6/exec/exec6.1.c,10,1,2,1912082.8947051,177431.0,10.776482125445948,1338.0,1319.0,40115.0,13967.0,1618.0,636.0,1340.0,593.0,1500000000,0.0012747219298034,1082014363648.0,0.0149748352880838,0.0774194741318738,"#include <stdio.h>

int main()
{
	int i = 1;
	while(i <= 128)
	{
		printf(""%d "", i);
		i *= 2;
	}

	return 0;
}
"
063-10553,Logilin/ilt,exemples/chapitre-03/example-with-valgrind-01.c,17,3,8,3002421136.479825,179249.0,16750.002153429028,1281.0,1260.0,40424.0,15233.0,1624.0,795.0,1348.0,752.0,1500000000,2.00161409098655,1082014363648.0,0.0141758113015972,0.0811937402303394,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BLOCKS_COUNT 10
#define BLOCKS_SIZE  1024

int main (void)
{
	char *blocks[BLOCKS_COUNT];
	int i;

	fprintf(stderr, ""Allocating blocks...\n"");
	for (i = 0; i < BLOCKS_COUNT; i ++)
		blocks[i] = malloc(BLOCKS_SIZE);
	sleep(1);

	fprintf(stderr, ""Using blocks...\n"");
	for (i = 0; i < BLOCKS_COUNT; i ++)
		memset(blocks[i], 1, BLOCKS_SIZE);
	sleep(1);

	fprintf(stderr, ""Freeing block...\n"");
	for (i = BLOCKS_COUNT - 1; i > 0; i --);
		free(blocks[i]);

	return 0;
}

"
367-15234,moehuster/czq,day09/pthread.c,26,3,11,30019178344.51888,275246.0,109063.08663522812,2346.0,1813.0,64979.0,26224.0,2242.0,937.0,1654.0,839.0,1500000000,20.012785563012585,1082014363648.0,0.0151101196747636,0.0621909367016435,"#include <pthread.h>
#include <unistd.h>
#include <stdio.h>

typedef struct {
	char c;
	int rep;
}Job;

void* fun(void *p)
{
	Job* q = p;
	int i;
	for (i=0; i<q->rep; i++){
		write(1,&q->c,1);
		sleep(1);
	}
	return p;
}

int main()
{
	Job a[3]={{'a',10},{'b',20},{'c',15}};
	pthread_t ids[3];
	int i;
	for (i=0; i<3; i++)
		pthread_create(&ids[i],NULL,fun,&a[i]);
	for (i=0; i<3; i++)
		pthread_join(ids[i],NULL);
	printf(""OK\n"");
	return 0;
}
"
003-5730,haolly/understanding-unix-programming,06/signaldemo1.c,16,1,2,7507815971.737727,174859.0,42936.40001944424,1314.0,1297.0,39709.0,13581.0,1622.0,637.0,1341.0,593.0,1500000000,5.005210647825152,1082014363648.0,0.0149320309506516,0.0786826796772377,"#include <stdio.h>
#include <signal.h>
#include <unistd.h>
int main()
{
    void f(int);
    int i;
    signal(SIGINT, f);
    for(i=0;i<5;i++)
    {
        printf(""hello world\n"");
        sleep(1);
    } 
    return 0;
}
void f(int signal)
{
    printf(""oohps\n"");
}
"
392-7738,ataniazov/KOU,Trash/ders/useful/shekil_ciz.c,15,2,5,1912773.00473295,173821.0,11.004268759240828,1268.0,1253.0,39617.0,13482.0,1604.0,637.0,1331.0,593.0,1500000000,0.0012751820031553,1082014363648.0,0.0145034259381777,0.0784383886702197,"void ucgen_ciz(int x) {
	int i, j;
	for (i = 1 ; i <= x ; i++) {
		for (j = 1 ; j <= i ; j++) {
			printf(""*"");
		}
		printf(""\n"");
	}
}
int main() {
	ucgen_ciz(3);
	ucgen_ciz(2);
	ucgen_ciz(4);
	return 0;
}
"
275-6578,Gurgel100/gcc,gcc/testsuite/gcc.c-torture/execute/pr94567.c,23,1,6,1649852.95850775,170003.0,9.704840502814656,1148.0,1139.0,38672.0,12781.0,1577.0,586.0,1323.0,546.0,1500000000,0.0010999019723385,1082014363648.0,0.0134527037758157,0.0783627776806017,"/* PR target/94567 */

volatile int a = 1, b;
short c, d = 4, f = 2, g;
unsigned short e = 53736;

int
foo (int i, int j)
{
  return i && j ? 0 : i + j;
}

int
main ()
{
  for (; a; a = 0)
    {
      unsigned short k = e;
      g = k >> 3;
      if (foo (g < (f || c), b))
	d = 0;
    }
  if (d != 4)
    __builtin_abort ();
  return 0;
}
"
360-3617,pi3orama/Snitchaser,src/tests/test_flush_logger.c,14,1,8,11438779.76574,90247642.0,0.1267046844282092,1341.0,1322.0,54101.0,23912.0,1626.0,656.0,1345.0,612.0,1500000000,0.00762585317716,1082014363648.0,2.950769616784004e-05,0.0543370976632099,"#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{

	printf(""program runs normally\n"");
	int i = 0;
	int s = 0;
	while(i < 10000000) {
		s += i++;
		if (i % 100000 == 0)
			printf(""i = %d\n"", i);
	}
	printf(""end with %d\n"", s);
	return 0;
}

// vim:ts=4:sw=4

"
009-29748,guojing0/project-euler,6.c,18,1,9,1420921.52964315,174110.0,8.161053357073115,1334.0,1316.0,39171.0,13305.0,1621.0,630.0,1342.0,590.0,1500000000,0.0009472810197621,1082014363648.0,0.0152202630520935,0.079712630535864,"#include <stdio.h>
#include <math.h>

int sumOfSqr(int x)
{
    int sum = 0;

    for (int i=1; i<=x; i++) {
        sum = sum + pow(i, 2);
    }

    return sum;
}

int sqrOfSum(int x)
{
    int sum = (1 + x) * x / 2;
    return pow(sum, 2);
}

int main(int argc, char const *argv[])
{
    printf(""%d\n"", sqrOfSum(100) - sumOfSqr(100));

    return 0;
}"
064-7696,TakesxiSximada/gist,logic-fizzbuzz/FizzBuzz.c,14,1,7,1978069.4274231002,214859.0,9.206358588655815,1343.0,1323.0,48515.0,19468.0,1625.0,642.0,1345.0,600.0,1500000000,0.0013187129516154,1082014363648.0,0.0124081374296631,0.0619566656369974,"#include <stdio.h>

int main(int argc, char *argv[]){
     for(int ii = 0; ii <= 100; ii++){
          if (ii % 15 == 0){
               printf(""FizzBuzz\n"");
          } else if (ii % 3 == 0) {
               printf(""Fizz\n"");
          } else if (ii % 5 == 0) {
               printf(""Buzz\n"");
          } else {
               printf(""%d\n"", ii);
          }
     };
     return 0;
}
"
091-20728,dterei/Scraps,perf/test1.c,18,1,6,1036975906.4633399,5000174097.0,0.2073879600756629,1144.0,1134.0,1000039462.0,1000013700.0,1568.0,585.0,1317.0,546.0,1500000000,0.69131727097556,1082014363648.0,4.555841368337059e-07,2.007946626770714e-06,"void work(int n)
{
  volatile int i=0; //don't optimize away
  while(i++ < n);
}

void easy()
{
	work(1000);
}

void hard()
{
	work(1000*1000*1000);
}

int main()
{
	easy();
	hard();
}
"
150-2545,SanDisk-Open-Source/SSD_Dashboard,uefi/gcc/gcc-4.6.3/gcc/testsuite/gcc.dg/graphite/id-7.c,14,1,6,1685195.9517225,169083.0,9.966673172347308,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.001123463967815,1082014363648.0,0.0134490161636592,0.0785049652044725,"void foo (int *BM_tab)
{
  int *BM_tab_base;

  BM_tab_base = BM_tab;
  BM_tab += 0400;
  while (BM_tab_base != BM_tab)
    *--BM_tab = 6;
}

int main ()
{
  int BM_tab[0400];
  foo (BM_tab);
  return 0;
}
"
180-35123,kevinwsbr/The-Huxley,1087.c,9,1,4,2059249.2073773001,235273.0,8.752593795293128,1341.0,1322.0,52518.0,22785.0,1618.0,641.0,1340.0,598.0,1500000000,0.0013728328049182,1082014363648.0,0.0113187658592358,0.0557348312816222,"#include<stdio.h>

int main(int argc, char const *argv[])
{
	int i = 0; 
	for (;i < 100; ++i)
	{
		printf(""%d\n"", i);
	}
	return 0;
}"
382-3479,SanDisk-Open-Source/SSD_Dashboard,uefi/gcc/gcc-4.6.3/gcc/testsuite/gcc.c-torture/execute/20100430-1.c,43,2,13,1406824.2162465,169057.0,8.321595674831565,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.000937882810831,1082014363648.0,0.0134155935572026,0.0785563462891999,"/* This used to generate unaligned accesses at -O2 because of IVOPTS.  */

struct packed_struct
{
  struct packed_struct1
  {
    unsigned char cc11;
    unsigned char cc12;
  } __attribute__ ((packed)) pst1;
  struct packed_struct2
  {
    unsigned char cc21;
    unsigned char cc22;
    unsigned short ss[104];
    unsigned char cc23[13];
  } __attribute__ ((packed)) pst2[4];
} __attribute__ ((packed));

typedef struct
{
  int ii;
  struct packed_struct buf;
} info_t;

static unsigned short g;

static void __attribute__((noinline))
dummy (unsigned short s)
{
  g = s;
}

static int
foo (info_t *info)
{
  int i, j;

  for (i = 0; i < info->buf.pst1.cc11; i++)
    for (j = 0; j < info->buf.pst2[i].cc22; j++)
      dummy (info->buf.pst2[i].ss[j]);

  return 0;
}

int main(void)
{
  info_t info;
  info.buf.pst1.cc11 = 2;
  info.buf.pst2[0].cc22 = info.buf.pst2[1].cc22 = 8;
  return foo (&info);
}
"
350-29289,ClosedHouse/contest-2016,asm/encrypt.c,11,1,4,1710618.2640417,183599.0,9.317142250230122,1348.0,1328.0,41504.0,14893.0,1626.0,638.0,1345.0,596.0,1500000000,0.0011404121760278,1082014363648.0,0.0145752427845467,0.0745607035835239,"#include <stdio.h>
#include <string.h>

int main()
{
    char str[] = ""OpenHouse 2016"";
    char key = 88;

    printf(""String: "");
    for(unsigned int i = 0; i < strlen(str); i++) {
        printf(""0x%x, "", str[i] ^ key);
    }

    printf(""\nLength: %d\n"", strlen(str));

    return 0;
}
"
318-4890,devasish/c-expt,thread.c,34,2,14,3002225280.040875,180428.0,16633.207944443213,1435.0,1408.0,41286.0,14407.0,1658.0,689.0,1368.0,645.0,1500000000,2.00148352002725,1082014363648.0,0.0157569778526614,0.0782863196451977,"#include<stdio.h>
#include<string.h>
#include<pthread.h>
#include<stdlib.h>
#include<unistd.h>

pthread_t tid[2];

void* doSomeThing(void *arg)
{
    unsigned long i = 0;
    pthread_t id = pthread_self();

    if(pthread_equal(id,tid[0]))
    {
        printf(""\n First thread processing\n"");
    }
    else
    {
        printf(""\n Second thread processing\n"");
    }

//    for(i=0; i<(0xFFFFFFFF);i++) {
//        printf(""%d "", &i);
//    }

    return NULL;
}

int main(void)
{
    int i = 0;
    int err;

    while(i < 2)
    {
        err = pthread_create(&(tid[i]), NULL, &doSomeThing, NULL);
        if (err != 0)
            printf(""\ncan't create thread :[%s]"", strerror(err));
        else
            printf(""\n Thread created successfully\n"");

        i++;
    }

    sleep(2);
    return 0;
}"
024-27020,gaopinghuang0/xv6_project,xv6/threadtest.c,32,2,7,7502250168.006867,180402.0,68734.90391459074,1432.0,1405.0,41278.0,14407.0,1658.0,691.0,1367.0,645.0,1500000000,5.001500112004578,1082014363648.0,0.0157259897340384,0.0783155248271527,"#include<stdio.h>
#include<string.h>
#include<pthread.h>
#include<stdlib.h>
#include<unistd.h>

pthread_t tid[2];

void* doSomeThing(void *arg)
{
	unsigned long i = 0;
	pthread_t id = pthread_self();

	if(pthread_equal(id,tid[0]))
	{
		printf(""\n First thread processing\n"");
	}
	else
	{
		printf(""\n Second thread processing\n"");
	}

	for(i=0; i<(0xFFFFFFFF);i++);

	return NULL;
}

int main(void)
{
	int i = 0;
	int err;

	while(i < 2)
	{
		err = pthread_create(&(tid[i]), NULL, &doSomeThing, NULL);
		if (err != 0)
			printf(""\ncan't create thread :[%s]"", strerror(err));
		else
			printf(""\n Thread created successfully\n"");

		i++;
	}

	sleep(5);
	return 0;
}
"
081-24277,deweixu/ulcdemo,pthread/inprint.c,22,2,11,7502350510.563702,184267.0,40714.563703755965,1553.0,1518.0,41889.0,15000.0,1660.0,724.0,1368.0,681.0,1500000000,5.001567007042468,1082014363648.0,0.0166660335274357,0.0779236759303204,"#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

#define NUM 5

int counter = 0;

int main()
{
    pthread_t t1;
    void *print_count(void *);
    
    int i;
    pthread_create(&t1, NULL, print_count, NULL);

    for(i = 0; i < NUM; i++) {
        counter ++;
        sleep(1);
    }
    pthread_join(t1, NULL);
}

void *print_count(void *m)
{
    int i;
    for(i = 0; i < NUM; i++) {
        printf(""count = %d\n"", counter);
        sleep(1);
    }
    return NULL;
}"
053-23596,qtekfun/htcDesire820Kernel,external/valgrind/main/helgrind/tests/bar_trivial.c,30,2,12,1638181192.218326,184189.0,8894.022943824008,1523.0,1492.0,42088.0,14783.0,1678.0,694.0,1380.0,649.0,1500000000,1.0921207948122174,1082014363648.0,0.016369055698223,0.0773856622883367,"
#define _GNU_SOURCE
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <unistd.h>

int x = 0;

pthread_barrier_t bar;

void* child_fn ( void* arg )
{
   long r, n = (long)arg;

   if (n == 1) x++;

   r = pthread_barrier_wait(&bar); 
   assert(r == 0 || r == PTHREAD_BARRIER_SERIAL_THREAD);

   if (n == 0) x++;

   sleep(1); 
   return NULL;
}

#define NTHR 2

int main ( void )
{
   long i, r;
   pthread_t thr[NTHR];

   r = pthread_barrier_init(&bar, NULL, NTHR);
   assert(!r);

   for (i = 0; i < NTHR; i++) {
      r = pthread_create(&thr[i], NULL, child_fn, (void*)i);
      assert(!r);
   }

   for (i = 0; i < NTHR; i++) {
      r = pthread_join(thr[i], NULL);
      assert(!r);
   }

   r = pthread_barrier_destroy(&bar); assert(!r);

   printf(""x = %d\n"", x);
   return 0;
}
"
346-17564,danielsanfr/universitys-homeworks,operational-system/homework1/array/array.c,10,1,4,2436019.2473977497,173082.0,14.074363596445616,1338.0,1319.0,39176.0,13301.0,1618.0,636.0,1340.0,593.0,1500000000,0.0016240128315985,1082014363648.0,0.015351105256468,0.0797873354040817,"#include<stdio.h>
#include<stdlib.h>

int main()
{
	int array[5] = {123, 77, 24, 14, 48};
	int i;
	int result = 0;
	for (i = 0; i < 5; ++i) {
		result += array[i];
	}
	printf(""%d\n"", result);
}
"
183-21040,xdje42/gdb,gdb/testsuite/gdb.base/bg-execution-repeat.c,25,1,13,7507021416.211501,170067.0,44141.55254105735,1152.0,1142.0,38683.0,12795.0,1575.0,585.0,1323.0,544.0,1500000000,5.0046809441410005,1082014363648.0,0.0134888014723608,0.0782275923695559,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
foo (void)
{
  return 0; /* set break here */
}

int
main (void)
{
  foo ();
  sleep (5);
  foo ();
  return 0;
}
"
216-5214,ForceBru/PyVM,C/src/structs.c,32,1,10,1486127.84687415,169083.0,8.789334232300114,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0009907518979161,1082014363648.0,0.0134490161636592,0.0785049652044725,"#define assert(some_bool, code) do { if (!(some_bool)) return (code); } while(0)

struct Huge {
    char a;
    int b;
    long c;
    long long d;
    unsigned char e;
    unsigned int f;
    unsigned long g;
    unsigned long long h;
};

int main(void) {
    struct Huge test1 = {
        .a='y', .b=-75647, .c=-756478, .d=79647801,
        .e='z', .f=75641,  .g=258454,  .h=12345678901
    };

    assert(test1.a == 'y'        , 1);
    assert(test1.b == -75647     , 2);
    assert(test1.c == -756478    , 3);
    assert(test1.d ==  79647801  , 4);

    assert(test1.e == 'z'        , 5);
    assert(test1.f == 75641      , 6);
    assert(test1.g == 258454     , 7);
    assert(test1.h == 12345678901, 8);

    struct Huge test2;
    test2.a = test1.a - 5;
    test2.b = test1.b + test1.f;
    test2.c = test1.c + test1.g;

    assert(test2.a == (test1.a - 5)      ,  9);
    assert(test2.b == (int)(test1.b + test1.f), 10);
    assert(test2.c == (long)(test1.c + test1.g), 11);

    return 0;
}
"
185-21782,NeRaFr-Huffman/Huffman,huffman/Algorithms/testeDeCasoEspecial.c,14,2,6,1259791305.055842,7387750587.0,0.1705243416334082,1270.0,1254.0,3088422899.0,1342911337.0,1605.0,696.0,1333.0,654.0,1500000000,0.8398608700372279,1082014363648.0,3.4164661763777e-07,9.67654383901905e-07,"#include <stdio.h>

int main()
{
  int i; unsigned long long int n = 1;
  for (i = 65; i < 92; i ++)
  {
    unsigned long long int x;
    for (x = 0; x < n; x ++)
    {
      printf(""%c"", i);
    }
    n *= 2;
  }
  return(0);
}
"
037-24655,vcgato29/cygwin,gdb/testsuite/gdb.base/bfp-test.c,22,1,10,1499523.17588025,169062.0,8.869663200482663,1139.0,1129.0,38454.0,12699.0,1569.0,585.0,1318.0,546.0,1500000000,0.0009996821172535,1082014363648.0,0.0134151967917095,0.0785486677223232,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2005-2013 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <stdio.h>
#include <stdlib.h>

float b32;
double b64;
long double b128;

int main()
{
  b32 = 1.5f;
  b64 = 2.25;
  b128 = 3.375l;
 
  return 0;
}
"
145-26484,glaubitz/pos,00-attic/schedtest.c,9,1,6,420377918.7519103,840174640.0,0.500345878090298,1420.0,1397.0,39470.0,13505.0,1624.0,637.0,1344.0,594.0,1500000000,0.2802519458346069,1082014363648.0,3.3528743500279894e-06,0.0792638036809816,"#include <stdio.h>

int main () {

		long double x;
		long double i;

		x = 1;

		for (i = 1; i <= 120000000; i++)
			x= x * i;
		printf (""%d faculty: %e \n"", i - 1, x);
		return 0;
	}

"
313-30660,tiehuis/euler,c/src/034.c,23,2,7,13903219.60207065,108700060.0,0.1279044280196349,1336.0,1317.0,6548544.0,13305.0,1618.0,636.0,1341.0,593.0,1500000000,0.0092688130680471,1082014363648.0,2.440661026314061e-05,0.0006382347414577,"#include <stdio.h>

#define ulim 1088641

const int fact[10] = { 
    1, 1, 2, 6, 24, 120, 720,
    5040, 40320, 362880
};

int fact_digsum(int n)
{
    int sum = 0;
    while (n) {
        sum += fact[n % 10];
        n /= 10;
    }
    return sum;
}

int main(void)
{
    int sum = 0;
    int i;
    for (i = 3; i < ulim; ++i)
        if (fact_digsum(i) == i)
            sum += i;

    printf(""%d\n"", sum);
    return 0;
}
"
192-19955,cragwen/hello-world,c/csapp/show_bytes.c,31,1,7,1642967.92354425,182014.0,9.026596855186964,1349.0,1331.0,41215.0,14612.0,1632.0,638.0,1352.0,594.0,1500000000,0.0010953119490295,1082014363648.0,0.0147241420989594,0.0755190140971214,"#include <stdio.h>
#include <string.h>

typedef unsigned char * byte_pointer;

void show_bytes(byte_pointer start, int len)
{
	int i;
	for(i = 0; i < len; i++)
		printf("" %.2x"", start[i]);
	printf(""\n"");
}

void show_int(int x)
{
	show_bytes((byte_pointer) &x, sizeof(int));
}

void show_float(float x)
{
	show_bytes((byte_pointer) &x, sizeof(float));
}

void show_pointer(void *x)
{
	show_bytes((byte_pointer) &x, sizeof(void *));
}

int main(void)
{
	int val = 0x87654321;
	byte_pointer valp = (byte_pointer) &val;
	show_bytes(valp, 1);
	show_bytes(valp, 2);
	show_bytes(valp, 3);

	const char *s = ""abcdef"";
	show_bytes((byte_pointer) s, strlen(s));

	return 0;
}
"
015-35357,ztuowen/chill-dev,Manual/test-cases/examples/chill/test_tile.c,10,1,2,1549982.93146485,169083.0,9.16367109644376,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010333219543099,1082014363648.0,0.0134490161636592,0.0785049652044725,"void func(int n) {

	int i;
	int a[10];

	for (i = 0; i < n; i++)
		a[i] = 2;

}

int main() {

	func(10);

	return 0;
}
"
194-34049,korbenzhang/langs_demo,tasks/loop/loop.c,8,1,4,1635844.35358635,178573.0,9.16064578631708,1341.0,1322.0,40368.0,14145.0,1618.0,636.0,1340.0,593.0,1500000000,0.0010905629023909,1082014363648.0,0.0149126687685148,0.0768073670500614,"#include ""stdio.h""

int main(int argc, char *argv[])
{
	int i;
	for (i = 0; i < 10; ++i) {
		printf(""%d\n"", i);
	}
	return 0;
}
"
384-14432,VictorRodriguez/operating-systems-lecture,labs/gcc/perf_training/sleep_example.c,8,1,5,4512859183.363617,173738.0,25975.084224521983,1342.0,1322.0,39371.0,13401.0,1622.0,637.0,1342.0,593.0,1500000000,3.0085727889090776,1082014363648.0,0.0153334331004155,0.0794739634654741,"#include <unistd.h>
#include <stdio.h>

int main ( int argc, char *argv[] ){

    int a=0;
    for (int i = 0 ; i < 10000000 ; i++)
        a = i*i;

    sleep(3);
    printf(""%d\n"",a);
    return 0;
}
"
123-8798,weiqiangdragonite/blog_tmp,unix_linux/linux_program/uup_book/ch14_thread/hello_single.c,21,1,12,15005496630.328707,181808.0,82534.85341679135,1340.0,1318.0,41425.0,14736.0,1633.0,637.0,1346.0,592.0,1500000000,10.003664420219138,1082014363648.0,0.0146198187098477,0.0749274407506988,"/*
 * hello_single.c - a single threaded hello world program
 */

#include <stdio.h>

#define NUM	5


int
main(int argc, char *argv[])
{
	void print_msg(char *msg);

	print_msg(""hello"");
	print_msg(""world\n"");

	return 0;
}

void
print_msg(char *msg)
{
	int i;

	for (i = 0; i < NUM; ++i) {
		printf(""%s"", msg);
		fflush(stdout);
		sleep(1);
	}
}

"
359-22104,SanDisk-Open-Source/SSD_Dashboard,uefi/gcc/gcc-4.6.3/gcc/testsuite/gcc.c-torture/execute/20000717-4.c,23,1,7,1629965.84549535,169057.0,9.637808549779068,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010866438969969,1082014363648.0,0.0134155935572026,0.0785563462891999,"/* Extracted from gas.  Incorrectly generated non-pic code at -O0 for
   IA-64, which produces linker errors on some operating systems.  */

struct
{
  int offset;
  struct slot
  {
    int field[6];
  }
  slot[4];
} s;

int
x ()
{
  int toggle = 0;
  int r = s.slot[0].field[!toggle];
  return r;
}

int
main ()
{
  return 0;
}
"
000-5068,Jadoch/LinuxProject,MPS/prog_linux/13/exemple_malloc_2.c,16,1,8,3848765.9767269003,506451.0,7.599481489818364,1324.0,1305.0,112470.0,64340.0,1625.0,905.0,1339.0,862.0,1500000000,0.0025658439844846,1082014363648.0,0.0051910253904128,0.0267575363384423,"
	#include <stdio.h>
	#include <stdlib.h>

	#define	NB_BLOCS	257
	#define TAILLE		(1024*1024)

	int
main (void)
{

	int	i;
	char *	bloc [NB_BLOCS];

	for (i = 0; i < NB_BLOCS; i ++) {
		if ((bloc [i] = (char *) malloc (TAILLE)) == NULL) {
			fprintf (stderr, ""Echec pour i = %d\n"", i);
			break;
		}
		fprintf (stderr, ""Remplissage de %d\n"", i);
		memset (bloc [i], 0, TAILLE);
	}
	fprintf (stderr, ""Alloués : %d blocs\n"", i);
	
	return (0);
}	

"
388-30347,HenrikSamuelsson/CS50,week3/initials/initials.c,17,1,9,1725018.02444445,171686.0,10.047516978670364,1141.0,1133.0,39078.0,12945.0,1587.0,586.0,1334.0,545.0,1500000000,0.0011500120162963,1082014363648.0,0.013245110259427,0.0778886261845722,"/*
 * initials.c
 */
#include <stdio.h>
#include <ctype.h>

int main (int argc, char* argv[])
{
	char inital;

	for (int i = 1; i < argc; i++)
	{
		inital = argv[i][0];

		if (islower(inital))
		{
			inital = toupper(inital);
		}
		printf(""%c"", inital);
	}

	return 0;
}
"
111-20466,shivamdixit/euler,p3.c,32,2,12,4233278.79980205,5960667.0,0.7102020629570482,1338.0,1320.0,39183.0,13305.0,1620.0,636.0,1343.0,593.0,1500000000,0.0028221858665347,1082014363648.0,0.0004459232498644,0.0798658741045572,"#include<stdio.h>

#define NUM 600851475143

int isPrime(int a)
{
	int i;
	if(a==2)
		return 1;
	if(a%2==0)
		return 0;
	for(i=3;i<=a/2;i+=2)
	{
		if(a%i==0)
			return 0;
	}
	return 1;
}

int main(int argc, char const *argv[])
{
	unsigned long long int p,i,rem = 600851475143;
	for(i=2;rem>1;i++)
	{
		if(isPrime(i))
		{
			if(rem%i == 0)
			{
				p=i;
				rem = rem /i;
				--i;
			}
		}
	}
	printf(""%llu\n"", p);
	return 0;
}"
382-27996,mandliya/short-fun-projects,learning-pthreads/cond_variables.c,33,3,5,1443268438.2190926,8642160466.0,0.1670031982949296,1500.0,1462.0,2592634933.0,617298670.0,1694.0,669.0,1395.0,624.0,1500000000,0.9621789588127284,1082014363648.0,3.427383709956677e-07,1.3651372713456092e-06,"#include <stdio.h>
#include <pthread.h>
#include <limits.h>

long shared_data = 123456789;
pthread_mutex_t lock;
pthread_cond_t is_zero;

void * decrement( void * arg )
{
  while( shared_data > 0 ) {
    pthread_mutex_lock(&lock);
    --shared_data;
    pthread_mutex_unlock(&lock);
  }
  printf(""Sending signal...\n"");
  pthread_cond_signal(&is_zero);
  return NULL;
}

int main()
{
  pthread_t decrement_thread;
  void * exit_status;

  pthread_mutex_init(&lock, NULL);
  pthread_cond_init(&is_zero, NULL);

  printf(""Waiting for signal!...\n"");
  pthread_create(&decrement_thread, NULL, decrement, NULL);

  pthread_mutex_lock(&lock);
  while( shared_data != 0 ) {
    pthread_cond_wait(&is_zero, &lock);
  }
  pthread_mutex_unlock(&lock);
  printf(""Signal received\n"");

  pthread_join(decrement_thread, &exit_status);
  pthread_mutex_destroy(&lock);
  pthread_cond_destroy(&is_zero);
  return 0;
}
"
045-7468,TakesxiSximada/gist,c-pthread/simple_thread.c,18,1,6,16924173536.826859,185590.0,91191.19314618244,1523.0,1486.0,42632.0,15100.0,1678.0,667.0,1373.0,621.0,1500000000,11.282782357884573,1082014363648.0,0.0162131580365321,0.0751576248874107,"#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

void *func(){
     for (int ii = 0; ii < 10; ii++ ) {
          fprintf(stdout, ""."");
          fflush(stdout);
          sleep(1);
     }
     fprintf(stdout, ""\n"");
     return NULL;
}


int main(int argc, char *argv[]) {
     int rc = 0;
     pthread_t child;
     rc = pthread_create(&child, NULL, &func, NULL);
     fprintf(stdout, ""pthread_create returned %d\n"", rc);

     rc = pthread_join(child, NULL);
     fprintf(stdout, ""pthread_join returned %d\n"", rc);
     return 0;
}
"
146-10968,gritt/ufpel-aed-one,src/classes/bubbleSort/randomInput.c,8,1,5,2510927.96679585,6511187.0,0.3856327578980607,1342.0,1321.0,1332136.0,905819.0,1628.0,700.0,1345.0,656.0,1500000000,0.0016739519778639,1082014363648.0,0.0004089884071828,0.0019343552484299,"#include <stdio.h>
#include <stdlib.h>

int main()
{
    //stdout > file
    for(int i = 0 ; i < 8000; i++) {
        
        printf(""%d \n"", rand());
    }

    return 0;
}
"
338-6482,ChristophTWeinmann/GDB,gdb/testsuite/gdb.base/watchpoint-hw.c,18,1,10,1619238.0571737,169061.0,9.577832853230491,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010794920381158,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2008-2013 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int watchee;

int
main (void)
{
  return 0;
}
"
162-25371,ProcessorDesign/real-time-microkernel,waitprobe/waitprobe.c,14,1,2,22529048794.41485,176557.0,127528.28822419955,1304.0,1286.0,40159.0,13865.0,1611.0,636.0,1337.0,595.0,1500000000,15.019365862943232,1082014363648.0,0.0146694835095748,0.0773545091070635,"#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int dojpa() {

    int i;
    for(i=0;i<15;++i) {
        printf(""Hello World!\n"");
        sleep(1);
    }

    return i;
}

int main(void)
{
    int i;
    i = dojpa();

    return 0;
}

"
135-35398,hzq1001/or1k-src,gdb/testsuite/gdb.trace/qtro.c,26,1,9,1631223.13097115,169083.0,9.647468994517483,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010874820873141,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2013 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

void
subr (int parm)
{
}

void
end (void)
{
}

int
main ()
{
  subr (1);
  end ();
}
"
050-11220,damijanc/algorithms,algorithms/bitwise/modulo/standard/modulo.c,6,1,3,2130004.69375395,169083.0,12.597387082083946,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0014200031291693,1082014363648.0,0.0134490161636592,0.0785049652044725,"int main() {
	for(int i=0; i<1000000000; i++){
		int a= 131%4;
	}
	return 0;
}
"
045-3285,acarno/slicer,valgrind/drd/tests/hold_lock.c,57,1,13,2206189.5579099003,188113.0,11.72799859658822,1257.0,1242.0,43493.0,14692.0,1765.0,592.0,1416.0,550.0,1500000000,0.0014707930386066,1082014363648.0,0.013284568317979,0.0742974993555039,"/** Hold several types of synchronization objects locked as long as specified.
 */

#define _GNU_SOURCE 1

#include <assert.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>


static void delay_ms(const int ms)
{
  struct timespec ts;

  assert(ms >= 0);
  ts.tv_sec = ms / 1000;
  ts.tv_nsec = (ms % 1000) * 1000 * 1000;
  nanosleep(&ts, 0);
}

int main(int argc, char** argv)
{
  int interval = 0;
  int optchar;
  pthread_mutex_t     mutex;
  pthread_mutexattr_t mutexattr;
  pthread_rwlock_t    rwlock;

  while ((optchar = getopt(argc, argv, ""i:"")) != EOF)
  {
    switch (optchar)
    {
    case 'i':
      interval = atoi(optarg);
      break;
    default:
      fprintf(stderr, ""Usage: %s [-i <interval time in ms>].\n"", argv[0]);
      break;
    }
  }

  fprintf(stderr, ""Locking mutex ...\n"");

  pthread_mutexattr_init(&mutexattr);
  pthread_mutexattr_settype(&mutexattr, PTHREAD_MUTEX_RECURSIVE);
  pthread_mutex_init(&mutex, &mutexattr);
  pthread_mutexattr_destroy(&mutexattr);
  pthread_mutex_lock(&mutex);
  delay_ms(interval);
  pthread_mutex_lock(&mutex);
  pthread_mutex_unlock(&mutex);
  pthread_mutex_unlock(&mutex);
  pthread_mutex_destroy(&mutex);

  fprintf(stderr, ""Locking rwlock exclusively ...\n"");

  pthread_rwlock_init(&rwlock, 0);
  pthread_rwlock_wrlock(&rwlock);
  delay_ms(interval);
  pthread_rwlock_unlock(&rwlock);
  pthread_rwlock_destroy(&rwlock);

  fprintf(stderr, ""Locking rwlock shared ...\n"");

  pthread_rwlock_init(&rwlock, 0);
  pthread_rwlock_rdlock(&rwlock);
  delay_ms(interval);
  pthread_rwlock_rdlock(&rwlock);
  pthread_rwlock_unlock(&rwlock);
  pthread_rwlock_unlock(&rwlock);
  pthread_rwlock_destroy(&rwlock);

  fprintf(stderr, ""Done.\n"");

  return 0;
}
"
336-1587,chrisbcarl/quaero,computation/cx/cx1/main.c,7,1,5,1797902.8634727001,172502.0,10.422499449281748,1292.0,1274.0,39030.0,13221.0,1605.0,634.0,1332.0,592.0,1500000000,0.0011986019089818,1082014363648.0,0.0148751898528712,0.0796731163039941,"#include <stdio.h>

int main(int args, char ** argv) {
    int i;
    for(i = 0; i< args; i++) {
        printf(""%s\n"", argv[i]);
    }
    return 0;
}
"
226-27437,softwaremechanic/Miscellaneous,C/LCTHW/ex14.c,31,2,8,1522962.1203615,185707.0,8.200886342464205,1361.0,1340.0,41845.0,14995.0,1632.0,637.0,1351.0,595.0,1500000000,0.001015308080241,1082014363648.0,0.0145444167425029,0.0741555242786769,"# include <stdio.h>
# include <ctype.h>

int can_print_it(char ch);
void print_args(char arg[]);

void print_arguments(int argc, char *argv[])
{
    int i = 0;
    for(i = 0;i< argc; i++)
    {
        print_letters(argv[i]);

    }
}

void print_letters(char arg[])
{
    int i = 0;
    for(i = 0; arg[i] != '\0';i++)
    {
        char ch = arg[i];
        if(can_print_it(ch)) {
            printf(""'%c' == %d "",ch,ch);
        }
    }
    printf(""\n"");
}

int can_print_it(char ch)
{
    return isalpha(ch) || isblank(ch);
}

int main(int argc, char *argv[])
{
    print_arguments(argc,argv);
    return 0;

}
"
374-2965,TommesDee/cpachecker,test/programs/simple/loop-tests/for+continue.c,15,1,2,1842859.55037915,169061.0,10.900556603829386,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0012285730335861,1082014363648.0,0.0134152761429306,0.0785563462891999,"#include <stdlib.h>

int main(void) {

  int counter;

  for (counter = 0; counter < 5; counter++) {
    
    if (2 == counter) {
      continue;
    }
    
    if (3 == counter) {
      continue;
    }
    
    if (4 == counter) {
      continue;
    }
  }

  return (0);
}
"
179-13715,zxombie/aarch64-freebsd-binutils,gdb/testsuite/gdb.linespec/ls-errs.c,21,1,10,1613761.5311890498,169083.0,9.544194271452485,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010758410207927,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2012-2014 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int myfunction (void) { return 0; }

int
main (void)
{  
  int a;

  a = myfunction ();

 here:
  return a;
}
"
273-4367,binnips/jtexpert,algorithams/dp/fib_bottom.c,16,1,7,51197488.4429946,174023.0,294.1995483355648,1338.0,1320.0,39433.0,13403.0,1626.0,638.0,1344.0,594.0,1500000000,0.0341316589619964,1082014363648.0,0.015273843112692,0.0795291089408736,"#include <stdio.h>


int fib(int n)
{
	int  i = 0;
	int fib[n+1];
	fib[0] = 0;
	fib[1] = 1;
	for(i=2;i<=n;i++)
		fib[i] = fib[i-1] + fib[i-2];
	return fib[n];
}
int main()
{
	int n = 9;
	printf(""Fib(9) : %d \n"",fib(9));
	return 0;
}
"
336-19986,qtekfun/htcDesire820Kernel,external/valgrind/main/massif/tests/basic.c,12,2,6,1763927.8667047499,185741.0,9.49670239742437,1249.0,1233.0,42269.0,15057.0,1622.0,669.0,1353.0,626.0,1500000000,0.0011759519111365,1082014363648.0,0.0133626932125917,0.074486271499843,"#include <stdlib.h>


int main(void)
{
   
   #define N   36
   int i;
   int* a[N];

   for (i = 0; i < N; i++) {
      a[i] = malloc(400);  
   }
   for (i = 0; i < N-1; i++) {
      free(a[i]);
   }
   
   return 0;
}
"
233-7853,vifino/benchmark_loop,tests/benchmark_loop.c,9,1,4,1509105195.0585098,197762752.0,7.630886907358571,1342.0,1323.0,2497266.0,504996.0,1635.0,636.0,1352.0,593.0,1500000000,1.0060701300390065,1082014363648.0,1.3475742894192737e-05,0.0014042745103525,"#include <time.h>
#include <stdio.h>

int main() {
	unsigned long long iter = 0;
	struct timespec t;
	while (iter % 128 != 0 || (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &t), t.tv_sec) < 1) {
		iter++;
	}
	printf(""%llu iterations\n"", iter);
	return 0;
}
"
163-2096,2017-fall-os/shell-dapn09,shellLabDemos/sigIgn.c,13,1,9,15002570833.428762,174792.0,85830.99245388804,1309.0,1291.0,39727.0,13543.0,1632.0,634.0,1350.0,592.0,1500000000,10.001713888952509,1082014363648.0,0.0148748226463453,0.078993805143608,"#include ""signal.h""
#include ""unistd.h""
#include <stdio.h>

int main(int argc, char**argv, char**envp)
{
  int sleepTime = 10;
  signal(SIGINT, SIG_IGN);
  signal(SIGHUP, SIG_IGN);

  while (sleepTime) {
    sleepTime = sleep(10);	/* sleep returns early if signal handled */
    if (sleepTime != 0)
      printf(""sleep returned %d\n"", sleepTime);
  }
  printf(""exiting\n"");
  return (0);
}

"
038-1219,lijia577/AI,review/t1.c,24,1,4,22527134917.44362,178149.0,126451.08822951574,1231.0,1217.0,40883.0,13953.0,1620.0,588.0,1350.0,546.0,1500000000,15.018089944962412,1082014363648.0,0.0137413064345014,0.0748413451017579,"#include <stdio.h>

int main()
{

   char buff[1024];

   memset( buff, '\0', sizeof( buff ));
   setvbuf(stdout, buff, _IONBF, 1024); 
   
   fprintf(stdout, ""Print Without Buffer\n"");

	//set buffer
   setvbuf(stdout, buff, _IOFBF, 1024);
   fprintf(stdout, ""This Should Come Out With Some '#'s\n"");
   fprintf(stdout, ""###########################"");
   fflush( stdout );
   sleep(5);  

   fprintf(stdout, ""This output will go into buff\n"");
   fflush( stdout );
   sleep(5);

   fprintf(stdout, ""Wait for 5 secs again plz!\n"");
   fflush( stdout );

   fprintf(stdout, ""and this will appear when programm\n"");
   fprintf(stdout, ""will come after sleeping 5 seconds\n"");
   sleep(5);
   
  // fflush( stdout );
   memset( buff, '\0', sizeof( buff ));
   return(0);
}
"
211-16219,orangebook/FlyLab,example/demo-c_language/pthread/pthread2.c,18,2,10,7504124364.000745,184251.0,40718.576490765314,1550.0,1515.0,41886.0,15005.0,1660.0,724.0,1368.0,681.0,1500000000,5.002749576000497,1082014363648.0,0.0166349164997747,0.077920936527746,"#include <stdio.h>
#include <unistd.h>
#include <pthread.h>
#define NUM 5
int counter = 0;
void *print_counter(void* m) {
  for (int i=0; i< NUM ; ++i) {
    printf(""count = %d \n"", counter);
    sleep(1);
  }
  return NULL;
}

int main(int argc, char * argv[]) {
  pthread_t t1;
  pthread_create(&t1, NULL, print_counter, NULL);
  for (int i=0; i <NUM; ++i) {
    counter++;
    sleep(1);
  }
  pthread_join(t1, NULL);
  return 0;
}

"
000-35264,SanDisk-Open-Source/SSD_Dashboard,uefi/gcc/gcc-4.6.3/gcc/testsuite/gcc.c-torture/execute/align-nest.c,22,1,2,1494244.32311205,169057.0,8.838699373584058,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0009961628820747,1082014363648.0,0.0134155935572026,0.0785563462891999,"
void foo(int n)
{
  typedef struct
  {
    int value;
  } myint;
  
  struct S
  {
    int i[n];
    unsigned int b:1;
    myint mi;
  } __attribute__ ((packed)) __attribute__ ((aligned (4)));

  struct S s[2];
  int k;
  
  for (k = 0; k < 2; k ++)
    s[k].mi.value = 0;
}

int main ()
{
  foo (2);
  return 0;
}

"
221-5741,Furzoom/demo-C,src/pthread/demo1.c,18,1,9,2196859.4519421,252213.0,8.710332139897627,2192.0,1764.0,59651.0,22912.0,2150.0,835.0,1632.0,753.0,1500000000,0.0014645729679614,1082014363648.0,0.0156851550078703,0.0650412412339667,"#include <pthread.h>
#include <stdio.h>

void *child_thread(void *arg)
{
    long num = (long)arg;
    long i = 0, sum = 0;
    while (++i <= num)
        sum += i;
    pthread_exit((void *)sum);
    return 0;
}

int main(void)
{
    long total;
    pthread_t h_thread;
    pthread_create(&h_thread, NULL, child_thread, (void *)100);
    pthread_join(h_thread, (void *)&total);
    printf(""Total is %ld\n"", total);
    return 0;
}
"
101-28994,huoxinghuilai/project1,beifen/code/pthread1.c,18,1,11,7503130912.547931,190740.0,39336.95560448778,1547.0,1514.0,43695.0,16174.0,1677.0,758.0,1372.0,715.0,1500000000,5.002087275031954,1082014363648.0,0.0160480234874698,0.0755315772770549,"#include<stdio.h>
#include<pthread.h>

#define NUM 5

int main(){

pthread_t t1,t2;
void *print_msg(void *);

pthread_create(&t1,NULL,print_msg,(void *)""hello"");
pthread_create(&t2,NULL,print_msg,(void *)""world\n"");

pthread_join(t1,NULL);
pthread_join(t2,NULL);
}

void *print_msg(void *m){
char *cp=(char *)m;
int i;
for(i=0;i<NUM;i++){
printf(""%s"",m);
fflush(stdout);
sleep(1);
}
return NULL;
}


"
297-32183,phaziz/NothingButC,2017-02-22-Strings.c,30,1,5,4035022.69182345,179108.0,22.52842977421444,1411.0,1387.0,40838.0,14260.0,1644.0,641.0,1361.0,597.0,1500000000,0.0026900151278823,1082014363648.0,0.0156218594367644,0.0770082398635159,"# include <stdio.h>
# include <stdlib.h>

int main(void)
{
    system(""cls"");

    printf(""\n\n"");

    printf(""\n\t\tHALLO WELT als Stringkonstante!\n\t\t"");

    char stringArray[11];
    stringArray[0] = 'H';
    stringArray[1] = 'A';
    stringArray[2] = 'L';
    stringArray[3] = 'L';
    stringArray[4] = 'O';
    stringArray[5] = ' ';
    stringArray[6] = 'W';
    stringArray[7] = 'E';
    stringArray[8] = 'L';
    stringArray[9] = 'T';
    stringArray[10] = '\0';

    for (int i = 0; i < 11; i++)
    {
        printf(""%c"", stringArray[i]);
    }

    printf(""\n\t\t"");

    char halloWelt[] = {'H','A','L','L','O',' ','W','E','L','T','\0'};

    printf(""%s"", halloWelt);

    printf(""\n\t\t"");

    char hW[] = {""HALLO WELT\0""};
    printf(""%s"", hW);

    printf(""\n\n"");

    return EXIT_SUCCESS;
}"
281-14488,wolfdale/Spaghetti-code,garbage/count_set_bits.c,14,1,3,1628553.14556495,172976.0,15.559256775506428,1331.0,1312.0,39158.0,13294.0,1617.0,638.0,1339.0,593.0,1500000000,0.0010857020970433,1082014363648.0,0.0152795763574137,0.079825364142454,"#include<stdio.h>
int main()
{
    int n=3,count=0;
    while(n>0)
    {
        if((n&1)==1)
        {
            count++;
        }
        n=n>>1;
    }

    printf(""%d"",count);
    return 0;
}
"
267-32913,victorvarallo/cuddly-meme,param.c,9,1,6,1754553.05725335,174043.0,10.077469361019975,1351.0,1330.0,39378.0,13441.0,1619.0,637.0,1341.0,594.0,1500000000,0.0011697020381689,1082014363648.0,0.015404239182271,0.0793464473011605,"#include <stdio.h>

int main(int argc, char* argv[])
{
	int i;
	
	printf(""Nosso programa recebeu %i argumentos.\n"", argc);

	for( i = 0 ; i < argc ; i ++) {
		printf(""Parâmetro %i tem valor %s.\n"", i, argv[i]);
	}
	return 0;
}
"
339-11645,omni-compiler/omni-compiler,tests/openacc/data/bug_array.c,21,2,4,1635842.9566024502,170516.0,9.593480963663234,1146.0,1138.0,38734.0,12798.0,1582.0,587.0,1326.0,546.0,1500000000,0.0010905619710683,1082014363648.0,0.0133946374533768,0.0784172941085151,"#define N 10

void func(int a[])
{
  int i;
#pragma acc data copyout(a[0:N])
  {
#pragma acc parallel loop
    for(i=0;i<N;i++){
      a[i] = 100;
    }
  }
}

int main()
{
  int a[N];
  int i;

  func(a);
  
  for(i=0;i<N;i++){
    if(a[i] != 100){
      return 1;
    }
  }

  return 0;
}
"
355-26831,jnuyens/linux-c-programming,1_4_basics/while4.c,18,1,7,15004301493.172537,187924.0,79842.39103573785,1356.0,1329.0,42409.0,15455.0,1630.0,637.0,1350.0,594.0,1500000000,10.002867662115024,1082014363648.0,0.0142876907686085,0.0727740909719341,"#include <stdio.h>
#include <time.h>

int main(void)
{ 
	struct timespec tim;
   	tim.tv_sec = 0;
   	tim.tv_nsec = 500000000L;	
	int i = 0;    
	while ( i < 20 ) { 
		printf( ""%d\n"", i );
		i++;            
		nanosleep(&tim , NULL);
		/*nanosecond sleep
		there are one million microseconds in 
		one second and a thousand nanoseconds
		in one microsecond.
		nanosleep() is defined in <time.h> */
	}
	return 0;
}

"
028-20456,mdolz/PMLib,Python/client/test/vt/vt_test.c,15,1,3,3001803359.831683,173338.0,17317.6300580369,1304.0,1286.0,39298.0,13355.0,1611.0,633.0,1337.0,592.0,1500000000,2.001202239887789,1082014363648.0,0.0149419054102389,0.0792547433194689,"#include <stdio.h>


void busy()
{
	int i;
	for ( i= 0; i < 1e8; i++);
}


int main (int argc, char *argv[])
{
	
	printf(""Hello\n"");
	busy();
	sleep(1);
	busy();
	sleep(1);
	printf(""Bye\n"");

	return 0;
}
"
059-15768,huoxinghuilai/project1,beifen/code/pthread2.c,20,2,11,7503006053.972058,184264.0,40718.7842063561,1548.0,1516.0,41887.0,15006.0,1660.0,724.0,1368.0,681.0,1500000000,5.002004035981372,1082014363648.0,0.016628315894586,0.0779181973177719,"#include<stdio.h>
#include<pthread.h>

#define NUM 5
int counter=0;

int main(){

pthread_t t1;
void *print_count(void *);
int i;

pthread_create(&t1,NULL,print_count,NULL);

for(i=0;i<NUM;i++){
counter++;
sleep(1);
}

pthread_join(t1,NULL);
}

void *print_count(void *m){

int i;
for(i=0;i<NUM;i++){
printf(""counter= %d \n"",counter);
sleep(1);
}
return NULL;
}

"
008-3866,jin13417/Linux-C-C--learning,C/linux_IO/tmpnam.c,17,1,10,90339415.4738634,4460024.0,20.255365217765643,1368.0,1340.0,879804.0,717597.0,13564.0,13651.0,1356.0,13590.0,1500000000,0.0602262769825756,1082014363648.0,0.0006071716206011,0.0263934979382133,"#include <stdio.h>
int main()
{
	char *path;
	int i;
	for(i=0;i<2000;i++)
	{
		path = tmpnam(NULL);
//		printf(""%s\n"",path);
		FILE *fp = fopen(path,""w+"");
		if(NULL == fp)
		{

			printf(""%d\n"",i);
			return -1;
		}

	}
	return 0;
}

"
366-18398,skuhl/sys-prog-examples,simple-examples/setvbuf.c,20,1,5,4639430730.021559,178915.0,25930.92099600369,1384.0,1360.0,40846.0,14159.0,1647.0,650.0,1355.0,607.0,1500000000,3.0929538200143725,1082014363648.0,0.015336891820138,0.0774293246068539,"// Scott Kuhl
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(void)
{
	printf(""'Hello world' will be printed after one second:\n"");
	printf(""Hello "");
	sleep(1);
	printf(""World\n"");
	


	printf(""'Hello' will be printed, program sleeps for 1 second, and then world will be printed.\n"");
	printf(""Hello "");
	fflush(stdout);
	sleep(1);
	printf(""World\n"");

	// disable buffering:
	setvbuf(stdout, (char *) NULL, _IONBF, 0);
	printf(""First example (stdout buffering turned off):\n"");
	printf(""Hello "");
	sleep(1);
	printf(""World"");

	return 0;
}
"
172-10241,EvtimPavlov/c-programming-2014-2015-homework,A/16_Kristiana_Ivanova/Homework_4/reverse_number.c,20,1,9,1581646.2691872,176536.0,8.959339738070422,1344.0,1323.0,39761.0,13723.0,1619.0,639.0,1340.0,594.0,1500000000,0.0010544308461248,1082014363648.0,0.0151074001903294,0.078378580510059,"#include <stdio.h>
int reverse_a_number( long int number)
{
	int rev_num = 0;
	while(number != 0)
	{
		rev_num = rev_num * 10;
		rev_num = rev_num + number % 10;
		number = number / 10;
	}
	return rev_num;
	}
int main()
{
	printf(""5170984 %d\n"", reverse_a_number(5170984));
	printf(""406567 %d\n"", reverse_a_number(406567));
	printf(""368750 %d\n"", reverse_a_number(368750));
	printf(""2369510 %d\n"", reverse_a_number(2369510));
	printf(""2183293 %d\n"", reverse_a_number(2183293));
	return 0;
}

"
119-22198,iamyooon/study_linux,language/c/file_io_API/setvbuf.c,15,1,3,4506785551.551729,141012504.0,31.960183835895855,1308.0,1290.0,30656574.0,9198566.0,1625.0,633.0,1343.0,591.0,1500000000,3.0045237010344863,1082014363648.0,1.842389806793304e-05,0.0001051809126752,"#include <stdio.h>
#include <time.h>

void delay(unsigned int sec)
{
	clock_t ticks1 = clock();
	clock_t ticks2 = ticks1;
	while ((ticks2 / CLOCKS_PER_SEC - ticks1 / CLOCKS_PER_SEC)
		< (clock_t)sec)
		ticks2 = clock();
}

int main()
{
	setvbuf(stdout, NULL, _IOFBF, 5);

	printf(""Hello, world!\n"");

	delay(3);

	return 0;
}
"
373-16799,vitlav/darling,tests/src/pthread_threads.c,19,1,8,4502514771.0694,180352.0,24965.15021180802,1464.0,1430.0,41158.0,14410.0,1654.0,691.0,1362.0,647.0,1500000000,3.0016765140462667,1082014363648.0,0.0160463981547196,0.0783544486035128,"// CFLAGS: -lpthread
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

void* mythread(void*);

int main()
{
	pthread_t th, th2;
	void* rv;
	pthread_create(&th, 0, mythread, 0);
	sleep(1);
	pthread_create(&th2, 0, mythread, 0);
	printf(""Waiting for thread...\n"");
	pthread_join(th, &rv);
	pthread_join(th2, &rv);
	printf(""Thread joined!\n"");
	return 0;
}

void* mythread(void* p)
{
	sleep(2);
}

"
265-30986,acarno/slicer,valgrind/exp-sgcheck/tests/globalerr.c,11,1,6,2119398.09378225,169083.0,12.534660492184312,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0014129320625215,1082014363648.0,0.0134490161636592,0.0785049652044725,"
#include <stdio.h>

short a[7];
static short b[7];

int main ( void )
{
  int i;
  short sum;
  for (i = 0; i < 7+1; i++) {
     sum += a[i] * b[i];
  }
  return 1 & ((unsigned int)sum / 1000000);
}
"
110-4422,SamuraiT/extensionpy,ctypesexample/fizzbuzz.c,17,1,9,1610029.4888018998,177315.0,9.080049629190988,1339.0,1320.0,40034.0,13912.0,1619.0,636.0,1340.0,594.0,1500000000,0.0010733529925346,1082014363648.0,0.0149959112314243,0.0776517257998739,"#include <stdio.h>

void fizzbuzz(int n){

    for (int i=1; i <= n; i++){
        if (i % 3 == 0 && i % 5 ==0){
            printf(""fizzbuzz %d \n"", i);
        }
        else if (i % 3 == 0){
            printf(""fizz %d \n"", i);
        }
        else if(i % 5 == 0){
            printf(""buzz %d \n"", i);
        }
    }
}

int main(void){
    fizzbuzz(15);
    return 0;
}
"
255-6658,ningkang/Playground,ex12.c,22,1,5,2476923.28412085,173826.0,14.24943909426668,1291.0,1276.0,39457.0,13390.0,1626.0,635.0,1348.0,592.0,1500000000,0.0016512821894139,1082014363648.0,0.0147676412044228,0.079493632561924,"#include <stdio.h>

int main(int argc, char *argv[])
{
	int i = 0;

	if (argc == 1)
	{
		printf(""You only have one argument. You suck.\n"");
	}
	else if (argc > 1 && argc < 4)
	{
		printf(""Here's your argument:\n"");

		for (i = 0; i < argc; i++)
		{
			printf(""argv %d = %s\n"", i, argv[i] );
		}

		printf(""\n"");
	}
	else
	{
		printf(""You have too many arguments. You suck\n"");
	}
	
	return 0;
}"
152-13608,mattstock/binutils-bexkat1,gdb/testsuite/gdb.compile/compile-setjmp.c,18,1,10,1418551.5465214502,169061.0,8.390764280348513,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0009457010310143,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

static int done;

int
main (void)
{
  return 0;
}
"
097-6208,kkmonlee/Project-Euler-Solutions,CCPP/p14.c,19,2,10,333037996.6646433,1061649960.0,0.3136984962538877,1335.0,1316.0,39246.0,13349.0,1617.0,636.0,1340.0,593.0,1500000000,0.2220253311097622,1082014363648.0,2.4970565627864764e-06,0.0795893145736286,"#include <stdio.h>

int main() {
    int longest = 0, terms = 0, i;
    unsigned long j;

    for (i = 1; i <= 1000000; i++) {
        j = i;
        int current_term = 1;

        while (j != 1) {
            current_term++;

            if (current_term > terms) {
                terms = current_term;
                longest = i;
            }

            if (j % 2 == 0) j /= 2;
            else j = 3 * j + 1;
        }
    }

    printf(""Longest: %d (%d)\n"", longest, terms);

    return 0;
}"
209-14052,AungWinnHtut/POL,C/FileIO/fiotemplate.c,17,1,9,2084057.8945352999,173026.0,12.044762058881323,1295.0,1274.0,39254.0,13367.0,1608.0,640.0,1338.0,598.0,1500000000,0.0013893719296902,1082014363648.0,0.0148474795695444,0.0795119819083635,"//This program is example code
//for Green Hackers C fundamentals Online Course
//By Dr. Aung Win Htut
//fiotemplate.c

#include<stdio.h>

int main()
{
	FILE * fp = NULL;
	fp = fopen(""test.txt"",""r"");
	if(fp==NULL)
	{
		return 1;
	}


	if(fp!=NULL)
	{
		fclose(fp);
	}
}"
237-5788,ComputationWithBoundedResources/ara-inference,doc/tpdb_trs/C_Integer/Stroeder_15/Sequence.c,11,2,2,1389721.2920709,169057.0,8.220428612834725,1139.0,1129.0,38452.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0009264808613806,1082014363648.0,0.0134155935572026,0.0785172440760147,"typedef enum {false,true} bool;

extern int __VERIFIER_nondet_int(void);

int main() {
    int i;
    int j;
    i = 0;
    j = 5;
    
    while (i < 100) { i = i+1; }
    
    while (j < 21) { j = j+3; }
    
    return 0;
}
"
391-24817,wedusk101/C,pattern_3.c,13,2,5,1963743.00867315,173334.0,11.329242964450136,1270.0,1255.0,39431.0,13392.0,1605.0,634.0,1332.0,592.0,1500000000,0.0013091620057821,1082014363648.0,0.0145672516644166,0.0788103666963254,"#include <stdio.h>

int main()
{
	int i = 0, j = 0;
	for(i = 5; i >= 1; i--)
	{
		for(j = i; j >= 1; j--)
		{
			printf(""*"");
		}
		printf(""\n"");
	}
	return 0;
}
 
"
317-851,Gurgel100/gcc,gcc/testsuite/gcc.c-torture/execute/pr68185.c,26,5,2,1506226.25369565,169992.0,8.860569909172197,1148.0,1139.0,38670.0,12782.0,1577.0,586.0,1323.0,546.0,1500000000,0.0010041508357971,1082014363648.0,0.0134535742858487,0.0783643007074555,"
int a, b, d = 1, e, f, o, u, w = 1, z;
short c, q, t;

int
main ()
{
  char g;
  for (; d; d--)
    {
      while (o)
	for (; e;)
	  {
	    c = b;
	    int h = o = z;
	    for (; u;)
	      for (; a;)
		;
	  }
      if (t < 1)
	g = w;
      f = g;
      g && (q = 1);
    }

  if (q != 1)
    __builtin_abort ();

  return 0;
}
"
159-1247,daconex/clcolors,testcolors.c,8,1,4,2605671.0630654,315846.0,8.249814783153816,1340.0,1321.0,69659.0,34910.0,1618.0,674.0,1339.0,629.0,1500000000,0.0017371140420436,1082014363648.0,0.0084249919264451,0.0407386510342453,"#include <stdio.h>

int main (void) {
    int i;
    for (i = 0; i < 110; i++) {
        printf(""\x1b[%im"", i);
        printf(""%i This is text\n"", i);
    }
    printf(""\x1b[0m"");
}"
395-33600,jonarivas/EulerProject,src/Problem14.c,38,1,15,275491319.94601333,757173672.0,0.3638416511132997,1358.0,1335.0,39785.0,13597.0,1629.0,637.0,1349.0,594.0,1500000000,0.1836608799640089,1082014363648.0,3.5566477012951394e-06,0.0788468022929077,"/*
 ============================================================================
 Name        : Euler.c
 Author      : Jonathan Rivas
 Version     :
 Copyright   : 
 Description : Problem #14
 ============================================================================
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define limit (1000000)

int numberofSequences(long number){
	if (number == 1){
		return 1;
	}
	else {
		if(number % 2 == 0){
			return 1 + numberofSequences(number/2);
		}
		else {
			return 1 + numberofSequences(3 * number + 1);
		}
	}
}

int main(void) {
	struct timeval stop, start;
	gettimeofday(&start, NULL);

	long i=0, maxNumber = 0, maxSequence = 0, sequence;
	for (i=1;i<limit;i++){
		sequence = numberofSequences(i);
		if (sequence > maxSequence){
			maxSequence = sequence;
			maxNumber = i;
		}
	}
	printf(""%ld"",maxNumber);
	gettimeofday(&stop, NULL);
	printf(""\ntook %lu usec\n"", stop.tv_usec - start.tv_usec);
	return 0;
}
"
150-15628,anooptoffy/Masters-Course-Work-Repository,Semester_1/CS501/Day4/random.c,14,1,8,82797895.53489524,636380714.0,0.1301074862554681,1416.0,1389.0,142748141.0,97017566.0,1654.0,774.0,1367.0,731.0,1500000000,0.0551985970232635,1082014363648.0,4.407738855517863e-06,1.887676122090304e-05,"#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int a[10000000];
int main(){
	long int i,n;	
	FILE *fp;
	fp = fopen(""data.in"",""w"");
	time_t t;
	n = 1000000; // 10^6
	srand((unsigned) time(&t));
	for(i = 0; i < n; i++){
		fprintf(fp,""%d"",rand() % 10);
	}
	printf(""\nCount %ld"",i);	
	return 0;
}
"
163-6215,laodouya/quiz,randomPhoneNumber.c,23,2,9,5074285.4364216,13135819.0,0.3862937666848181,1378.0,1352.0,2366880.0,1491817.0,1649.0,704.0,1365.0,659.0,1500000000,0.0033828569576144,1082014363648.0,0.0002078286858246,0.0011343207305471,"#include<stdio.h>
#include<stdlib.h>
#include<time.h>
int main()
{
    long long billion = 1000000000;
    long max = 3000;
    int header[]={13,15,18};
    printf(""姓名,手机\n"");
    long num = 0;
    srandom(time(NULL));
    for (int i = 0; i<3; i++)
    {
        while (num < max)
        {
            long a = random();
            if (a >= billion)
                a %= billion;
            long long number = header[i]*billion + a;
            printf(""\""%lld\"",\""%lld\""\n"",number,number);
            num++;
        }
        num = 0;
    }
    return 0;
}
"
213-24434,asheemchhetri/C-programming,programs/bubbleSort.c,15,1,5,1765142.89341855,176957.0,9.97497697180671,1339.0,1321.0,40084.0,13862.0,1626.0,637.0,1344.0,594.0,1500000000,0.0011767619289457,1082014363648.0,0.0150319004051831,0.077874170466763,"#include <stdio.h>
void printLoop(int array[],int length);
int main(int argc, char **argv)
{
	int x[] = {9,4,0,1,2,8};
	printLoop(x,6);
	return 0;
}

void printLoop(int array[], int length)
{
	int i;
	for(i=0;i<length;i++)
	{
		printf(""%d\n"",array[i]);
	}
}"
181-28264,EvtimPavlov/c-programming-2014-2015-homework,B/10_Emil_Karbanov/Homework_3/task_4.c,9,1,4,1682223.1700642998,173242.0,9.710249246718464,1338.0,1319.0,39192.0,13314.0,1618.0,636.0,1340.0,593.0,1500000000,0.0011214821133762,1082014363648.0,0.0153369275348933,0.0797432674361025,"#include <stdio.h>
int main(){
	int fact=1;
	int c;
	int test=10;
 	for (c = 1; c <= test; c++)
		fact = fact * c;
 		printf(""Factoriel 10 = %d\n"", fact);
 





return 0;
}
"
194-11630,EvtimPavlov/c-programming-2014-2015-homework,A/28_Hristo_Ezekiev/Homework_3/task_4.c,12,1,3,1832164.5911782498,173196.0,10.578558396267812,1338.0,1319.0,39184.0,13309.0,1618.0,636.0,1340.0,593.0,1500000000,0.0012214430607855,1082014363648.0,0.015341000946904,0.0797630160211837,"#include <stdio.h>
int main(){
	int tenf = 10;
	int b = 10;
	while(b != 1)
	{
		b = b - 1;
		int f = tenf;
		tenf = f*b;
	}
	printf(""%d\n"", tenf);
	return 0;
}
"
023-32585,dje42/gdb,gdb/testsuite/gdb.python/py-arch.c,17,1,9,1688343.0071175,169083.0,9.985291247493834,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.001125562004745,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2013 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see  <http://www.gnu.org/licenses/>.  */

int
main (void)
{
  return 0;
}
"
048-34449,ShivamSarodia/ShivyC,tests/feature_tests/while.c,25,4,9,1836903.1604378999,169083.0,10.86391298947854,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0012246021069586,1082014363648.0,0.0134490161636592,0.0785049652044725,"int main() {
  int a = 0;
  while(a != 5) a = a + 1;

  if(a != 5) return 1;

  int b = 0;
  a = 0;
  while(a != 5) {
    b = b + a;
    a = a + 1;
  }

  if(a != 5) return 2;
  if(b != 10) return 3;

  // While statement never runs
  while(b == 100) return 4;

  // While statement runs once
  int num_times_run = 0;
  while(b == 10) {
    b = b + 1;
    num_times_run = num_times_run + 1;

    if(num_times_run != 1) {
      return 5;
    }
  }

  return 0;
}
"
177-3105,lilianglaoding/codeprimer,CLab/DataStruct/Stack/converse/converse1.c,20,2,9,2017894.2941128497,180849.0,11.15789415479212,1351.0,1333.0,40923.0,14429.0,1631.0,644.0,1352.0,601.0,1500000000,0.0013452628627419,1082014363648.0,0.014841110539732,0.0763838705015175,"#include <stdio.h>

#define LEN 200

void converse(int N, int r)
{
  int array[LEN], top;
  top = -1;
  
  while (N)
  {
    array[++top] = N % r;
    N = N / r;
  }
  
  while (top != -1)
  {
    printf(""%d\t"", array[top--]);
  }
}

int main()
{
  int N = 1025, r = 2;
  converse(N, r);
  printf(""\n"");
}
"
119-18423,borsesagar/TechnicalStudy,threads/threads.c,31,2,7,7675371688.557789,180426.0,42540.27517098423,1435.0,1408.0,41286.0,14407.0,1658.0,689.0,1368.0,645.0,1500000000,5.116914459038526,1082014363648.0,0.0157571525168213,0.0782863196451977,"#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>

pthread_t tid[2];

void* threadFunc(void *arg)
{
	unsigned long i = 0;
	pthread_t id = pthread_self();
	
	if (pthread_equal(id, tid[0]))
	{
		printf(""First thread processing\n"");
	}
	else
	{
		printf(""Second thread processing\n"");
	}

	for(i = 0; i < 0xffffffff; i++);
}

int main(void)
{
	int i = 0;
	int err;

	while (i<2)
	{
		err = pthread_create(&(tid[i]), NULL, &threadFunc, NULL);
		if (err != 0)
			printf(""cann't create thread : [%s]"", strerror(err));
		else
			printf(""thread created successfully\n"");

		i++;
	}
	sleep(5);
	return 0;
}
"
369-15781,tendoasan/ProgrammingInC,chapter08/exce14c.c,34,4,11,2023730.8926879,204451.0,9.898361954698192,1374.0,1353.0,46388.0,18141.0,1637.0,639.0,1357.0,596.0,1500000000,0.0013491539284586,1082014363648.0,0.0133381592655452,0.0655364254831161,"// ¸ÄÐ´exce12µÄÈ«¾Ö±äÁ¿ 
#include <stdio.h>

int matrix_ij[4][5] = {
		{1, 5, 5, 1, 0},
		{9, 6, 9, 8, 2},
		{8, 1, 8, 2, 5},
		{9, 4, 6, 2, 0}
	};
int matrix_ji[5][4];

int transposeMatrix(int nRows, int nCols, int matrix_ij[nRows][nCols], 
				int matrix_ji[nCols][nRows]){
	int i, j;
	
	for(i = 0; i < nRows; ++i)
		for(j = 0; j < nCols; ++j){
			matrix_ji[j][i] = matrix_ij[i][j];
		}
	
	return 0;
}

int displyMatrix(int nRows, int nCols, int matrix[nRows][nCols]){
	int i, j;
	
	for(i = 0; i < nRows; ++i){
		for(j = 0; j < nCols; ++j){
			printf(""%2i"", matrix[i][j]);
		}
		printf(""\n"");
	}
}

int main(void){ 
	printf(""×ªÖÃÇ°µÄ¾ØÕó:\n"");
	displyMatrix(4, 5, matrix_ij);
	
	transposeMatrix(4, 5, matrix_ij, matrix_ji);
	
	printf(""×ªÖÃºóµÄ¾ØÕó:\n"");
	displyMatrix(5, 4, matrix_ji);
	
	return 0;
} 
"
260-10897,TommesDee/cpachecker,test/programs/simple/loop-tests/while2.c,13,3,6,2089669.5787086,169083.0,12.358835601450176,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0013931130524724,1082014363648.0,0.0134490161636592,0.0785049652044725,"#include <stdlib.h>

int main(void) {

  int counter = 0;

  while (counter < 5) {
    counter++;
  }

  while (counter < 10) {
    counter++;
  }
  
  while (counter < 15) {
    counter++;
  }

  return (0);
}
"
392-34144,rhuitl/uClinux,uClibc/test/malloc/tst-mcheck.c,67,1,18,1530542.8532883,175968.0,8.69784278959811,1251.0,1233.0,39954.0,13629.0,1609.0,638.0,1339.0,594.0,1500000000,0.0010203619021922,1082014363648.0,0.0141162029459901,0.0780098165462926,"/* Copyright (C) 2005 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Jakub Jelinek <jakub@redhat.com>, 2005.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <features.h>

static int errors = 0;

static void
merror (const char *msg)
{
  ++errors;
  printf (""Error: %s\n"", msg);
}

int
main (void)
{
  void *p, *q;

  errno = 0;

  p = malloc (-1);

  if (p != NULL)
    merror (""malloc (-1) succeeded."");
  else if (errno != ENOMEM)
    merror (""errno is not set correctly."");

  p = malloc (10);
  if (p == NULL)
    merror (""malloc (10) failed."");

  p = realloc (p, 0);
  if (p != NULL)
    merror (""realloc (p, 0) failed."");

  p = malloc (0);
#if !defined(__UCLIBC__) || defined(__MALLOC_GLIBC_COMPAT__)
  if (p == NULL)
#else
  if (p != NULL)
#endif
    merror (""malloc (0) failed."");

  p = realloc (p, 0);
  if (p != NULL)
    merror (""realloc (p, 0) failed."");

  q = malloc (256);
  if (q == NULL)
    merror (""malloc (256) failed."");

  p = malloc (512);
  if (p == NULL)
    merror (""malloc (512) failed."");

  if (realloc (p, -256) != NULL)
    merror (""realloc (p, -256) succeeded."");
  else if (errno != ENOMEM)
    merror (""errno is not set correctly."");

  free (p);

  p = malloc (512);
  if (p == NULL)
    merror (""malloc (512) failed."");

  if (realloc (p, -1) != NULL)
    merror (""realloc (p, -1) succeeded."");
  else if (errno != ENOMEM)
    merror (""errno is not set correctly."");

  free (p);
  free (q);

  return errors != 0;
}
"
151-5515,manchicken/gist_per_day,internals/play_nice.c,37,1,9,15041945183.998905,1335987425.0,11.259046980176478,1423.0,1400.0,246460038.0,200799946.0,1663.0,641.0,1372.0,599.0,1500000000,10.02796345599927,1082014363648.0,2.1130438409628e-06,9.558199152464308e-06,"#include <stdio.h>
#include <unistd.h>
#include <time.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>

#define SECONDS 1

int did_alarm;

void trap_alarm(int signum);

void demo(int nice, int seconds);

int main() {
  signal(SIGALRM, trap_alarm);
  
  demo( -10, SECONDS );
  demo(  -5, SECONDS );
  demo(   0, SECONDS );
  demo(   5, SECONDS );
  demo(  10, SECONDS );
}

void trap_alarm(int signum) {
  did_alarm = 1;
}

void demo(int nice, int seconds) {
  did_alarm = 0;
  char op_pad[5];
  memset(op_pad,'\0', sizeof(op_pad));
  
  long long counter = 0;
  long int next_op = 2;
  
  alarm(seconds);
  while (!did_alarm) {
    sprintf(op_pad, ""%ld"", next_op);
    next_op = strtol(op_pad, NULL, 10);
    
    counter += next_op;
    
    switch (next_op) {
      case 2:
        next_op = -1;
        break;
      default:
        next_op = 2;
    }
  }
  printf(""With a nice of %+.2d, we have counted to %lld in %d seconds.\n"", nice, counter, seconds);
  sleep(1);
  
  return;
}

"
175-12244,jingleyang/nacl_nginx,nexe_min/hello/hello_01.c,12,1,6,2562324.05081385,173089.0,14.803505710934838,1335.0,1316.0,39176.0,13306.0,1618.0,636.0,1340.0,593.0,1500000000,0.0017082160338759,1082014363648.0,0.0153158201849915,0.0797797340040394,"#include <stdio.h>

void my_strcpy(char * dest, const char * src){
    for(int i=0;src[i];i++){
        dest[i]=src[i];
    }
}
int main(int argc, const char *argv[]){
    char buff[16];
    int a=1;
    printf(""hello world,a=%d\n"",a);
    my_strcpy(buff,""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"");
    return 0;
}
"
267-27432,tutufan/subterfugue,test/trapkid.c,20,1,6,15002614063.443617,176122.0,85183.07799707021,1202.0,1189.0,40293.0,13484.0,1622.0,587.0,1357.0,546.0,1500000000,10.00174270896241,1082014363648.0,0.0135758167633799,0.0764639158004351,"/* child for trap */

#include <signal.h>
#include <stdio.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
  sigset_t ss;
  struct sigaction sa;

  fprintf(stderr, ""starting kid\n"");
  sleep(5);

#if 0
  fprintf(stderr, ""ignoring SIGTRAP\n"");
  sa.sa_handler = SIG_IGN;
  sigemptyset(&sa.sa_mask);
  sa.sa_flags = 0;
  sigaction(SIGTRAP, &sa, NULL);
  sleep(5);
#endif

  fprintf(stderr, ""unblocking SIGTRAP\n"");
  sigemptyset(&ss);
  sigaddset(&ss, SIGTRAP);
  if (-1 == sigprocmask(SIG_UNBLOCK, &ss, 0))
    perror(""block failed"");
  sleep(5);

  fprintf(stderr, ""kid exiting\n"");
}
"
253-1006,weierstrass/project-euler,5/e5.c,16,2,9,63752201.96787255,186929430.0,0.3410495661384085,1334.0,1315.0,39177.0,13303.0,1618.0,636.0,1342.0,593.0,1500000000,0.0425014679785817,1082014363648.0,1.4171123295031711e-05,0.0798208841463414,"#include <stdio.h>

int main(){
  unsigned long t;
  int mod;

  for(t = 20; t < -1; t += 20){
    for(mod = 3; mod < 20; mod++){
      if((t % mod) != 0) {
	break;
      }else if(mod == 19){
	printf(""%ld"", t);
	return 0;
      }
    }
    //printf(""%ld\n"", t);
  } 

  return 0;
}
"
218-34843,mattstock/binutils-bexkat1,gdb/testsuite/gdb.base/nofield.c,29,1,12,1653633.1968381,169083.0,9.780007451961463,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0011024221312254,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2007-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

struct empty {};
union empty_union {};

struct not_empty
{
  void *e;
  void *u;
};

int
main (void)
{
  struct empty e = {};
  union empty_union u;
  struct not_empty n = {0, 0};

  n.e = &e;
  n.u = &u;

  return 0;
}

"
156-1817,goodpaperman/apue,01.chapter/tmpname.c,7,1,7,2434453302.179463,608676514.0,3.999584748229665,1428.0,1406.0,114783218.0,85458788.0,1634.0,698.0,1352.0,656.0,1500000000,1.622968868119642,1082014363648.0,4.656003533594529e-06,2.167377408314617e-05,"#include <stdio.h> 

int main (int argc, char *argv[])
{
  int i = 0; 
  for (; i<TMP_MAX+10; ++ i)
    printf (""%6d: %s\n"", i+1, tmpnam (0)); 
  return 0; 
}
"
213-5019,marko-asplund/daemon,test/test58.client.c,11,1,3,7502535383.915528,178527.0,42024.65387868501,1353.0,1331.0,40511.0,14082.0,1636.0,637.0,1347.0,592.0,1500000000,5.001690255943686,1082014363648.0,0.0150341404941549,0.0771527485208726,"#include <stdlib.h>
#include <signal.h>
#include <stdio.h>

int main()
{
	int i;

	setvbuf(stdout, NULL, _IOLBF, 0);

	for (i = 0; i < 5; ++i)
	{
		sleep(1);
		printf(""%d\n"", i);
	}

	return EXIT_SUCCESS;
}
"
001-9431,gsliu/Work,leak.c,11,1,6,1596286.6600602,169083.0,9.4408426630708,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010641911067068,1082014363648.0,0.0134490161636592,0.0785049652044725,"#include<stdio.h>

int main()
{
	char * p;
	int i = 0;
	for(;i < 1024*1024; i++)
	{
		p = malloc( sizeof(char));
		//free(p);
	}
	return 0;
}
"
003-5965,EvtimPavlov/c-programming-2014-2015-homework,A/07_Viktoria_Admasu/homework_4/christmas_tree.c,29,3,10,2189869.2939429,188542.0,11.61475427225764,1269.0,1254.0,45718.0,16138.0,1604.0,642.0,1331.0,598.0,1500000000,0.0014599128626286,1082014363648.0,0.0133816338004264,0.0674954733574754,"#include <stdio.h>

void ChristmasTree(int height)
{
	int m,a,b;

	for (m = 0; m < height; m++)
	{
		a = m;

		while (a != height - 1)
		{
			printf ("" "");
			a++;
		}	

		b = m + m + 1;

		for (a = 0; a < b; a++)
		{
			printf (""*"");
		}
		
		printf (""\n"");
	}
}

int main()
{
	ChristmasTree(4);
	printf (""\n"");
	ChristmasTree(7);
	printf (""\n"");
	ChristmasTree(11);
	printf (""\n"");	
	
	return 0;
}
"
385-12512,jprice-stmarytx/eg1302,Assignment02/kmcashan1.c,8,1,6,1697329.8043012498,176661.0,9.607830817214891,1429.0,1407.0,39993.0,13806.0,1633.0,638.0,1351.0,595.0,1500000000,0.0011315532028675,1082014363648.0,0.0160533451072958,0.0783843565865536,"#include <stdio.h>
#include <stdlib.h>

int main()
{
    printf(""Hello world from Hudson McAshan!\n"");
    printf(""I learned that %d+%d=%d\n"", 2,2,4);
    printf(""The grade I am looking for is: %c\n"", 'A');
    printf(""The temperature outside is barely %f degrees\n"", 32);
    return 0;
}
"
034-3448,mayankjohri/explore_advance_c,profiling/code/5_per.c,40,3,14,135420118.57498425,377778226.0,0.3584645929275977,1340.0,1320.0,47531.0,19055.0,1618.0,655.0,1340.0,612.0,1500000000,0.0902800790499895,1082014363648.0,7.041168116449358e-06,0.0634517766497461,"#include <stdio.h>

/* Computes the length of Collatz sequences */

unsigned int step (unsigned int x)
{
  if (x % 2 == 0)
    {
      return (x / 2);
    }
  else
    {
      return (3 * x + 1);
    }
}

unsigned int nseq (unsigned int x0)
{
  unsigned int i = 1, x;
  
  if (x0 == 1 || x0 == 0)
    return i;

  x = step (x0);

  while (x != 1 && x != 0)
    {
      x = step (x);
      i++;
    }

  return i;
}

int main (void)
{
  unsigned int i, m = 0, im = 0;

  for (i = 1; i < 500000; i++)
    {
      unsigned int k = nseq (i);

      if (k > m)
        {
          m = k;
          im = i;
          printf (""sequence length = %u for %u\n"", m, im);
        }
    }

  return 0;
}
"
128-3246,jbaldwin/project_euler,p014/p14.c,19,2,10,280307101.5514433,800778751.0,0.3500431307024029,1332.0,1313.0,39167.0,13304.0,1616.0,636.0,1340.0,593.0,1500000000,0.1868714010342955,1082014363648.0,3.303034698032341e-06,0.0797583427035886,"#include <stdio.h>

typedef unsigned long long i64;

int main(int argc, char* argv[]) {

	int max = 0;
	int result = 0;

	for(int i = 1; i < 1000000; i++) {
		i64 n = i;
		int count = 1;
		while(n != 1) {
			n = (n % 2 == 0) ? n / 2 : n * 3 + 1;
			count++;
		}

		if(count > max) {
			max = count;
			result = i;
		}
	}

	printf(""%i"", result);

	return 0;
}

"
249-5128,ibc/MediaSoup,worker/deps/libuv/libuv/docs/code/cgi/tick.c,10,1,2,15003032232.052647,178667.0,83943.9920018806,1314.0,1297.0,40769.0,14124.0,1624.0,633.0,1342.0,591.0,1500000000,10.002021488035098,1082014363648.0,0.0146137787056367,0.0763303153407538,"#include <stdio.h>
#include <unistd.h>

int main() {
    int i;
    for (i = 0; i < 10; i++) {
        printf(""tick\n"");
        fflush(stdout);
        sleep(1);
    }
    printf(""BOOM!\n"");
    return 0;
}
"
121-32740,Xilinx/binutils-gdb,gdb/testsuite/gdb.multi/dummy-frame-restore.c,28,1,9,1465337.9330410499,169061.0,8.66750462850687,1139.0,1129.0,38452.0,12696.0,1568.0,584.0,1318.0,544.0,1500000000,0.0009768919553607,1082014363648.0,0.0134152761429306,0.0784781418628294,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

static void
f1 (void)
{}

static void
f2 (void)
{}

void
commonfun (void)
{}

int
main (void)
{
  f1 ();
  f2 ();
  return 0;
}
"
316-2342,afronski/playground-low-level,c/learn-c-the-hard-way/ex12.c,16,1,4,2048929.6875894002,173821.0,11.787580326888005,1291.0,1276.0,39456.0,13389.0,1626.0,635.0,1348.0,592.0,1500000000,0.0013659531250596,1082014363648.0,0.0147680659989299,0.0794966411202573,"#include <stdio.h>

int main(int argc, char* argv[])
{
  int i = 0;

  if (argc == 1) {
    printf(""You have only one argument. You suck.\n"");
  } else if (argc > 1 && argc < 4) {
    printf(""Here's your arguments:\n"");

    for (i = 0; i < argc; ++i) {
      printf(""%s "", argv[i]);
    }

    printf(""\n"");
  } else {
    printf(""You have too many arguments. You suck.\n"");
  }

  return 0;
}"
370-26971,tendoasan/ProgrammingInC,chapter05/prog56.c,9,1,5,2162449.64394705,175509.0,12.321014876729969,1338.0,1319.0,39706.0,13675.0,1618.0,636.0,1340.0,593.0,1500000000,0.0014416330959647,1082014363648.0,0.0151388247896119,0.0784361476929993,"// ½éÉÜwhileÓï¾ä
#include <stdio.h>

int main (void){
	int count = 1;
	
	while( count <=5 ) {
		printf(""%i\n"", count);
		++count;
	}
	
	return 0;
} 
"
226-11700,sahutd/cachediff,test_samples/test_file.c,12,2,5,2326608.16982385,6292297.0,0.3696127185350596,1348.0,1327.0,1355596.0,957164.0,2297.0,720.0,1871.0,675.0,1500000000,0.0015510721132159,1082014363648.0,0.0004251229717859,0.0024053511821373,"#include <stdio.h>
int main()
{
    int i, j;
    int a[100][100];
    for (i = 0; i < 100; ++i)
    {
        for (j = 0; j < 100; ++j)
        {
            printf(""%d "", a[i][j]);
        }
    }
}
"
267-24954,Reesli/os_source,lesson_3/sleep.c,9,2,7,15667382427.142002,217420.0,72060.44718517156,1448.0,1425.0,48259.0,19361.0,1645.0,646.0,1361.0,603.0,1500000000,10.444921618094668,1082014363648.0,0.0132140557446417,0.0629251700680272,"#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int main(int argc, char ** argv) {
    for(int i = 0; i<20;i++){
        unsigned int wait_time = (unsigned int) abs(rand() % 1000000);
        double sec_wait = (double) wait_time/1000000;
        printf(""Waiting for %e seconds \n"", sec_wait);
        usleep(wait_time);
    }
return 0;
}"
220-18705,JogleLew/Shell-Program,Demo.c,11,1,2,15003626767.429523,184807.0,81185.38132754712,1371.0,1348.0,42028.0,15000.0,1646.0,637.0,1355.0,594.0,1500000000,10.002417844953015,1082014363648.0,0.0147126461660002,0.0742091604124289,"#include <stdio.h>

int main(){
	int i = 0;
	printf(""Demo is running\n"");
	while(i < 10){
		i = i + 1;
		sleep(1);
		printf(""Demo has running %d seconds.\n"", i);
		fflush(stdout);
	}
	printf(""Demo is ending.\n"");
	
}
"
180-15104,misizeji/StudyNote_201308,Linux_System/pthread/pthread_detach.c,20,1,6,4519915479.118936,179681.0,25155.22219377675,1446.0,1417.0,41042.0,14232.0,1654.0,665.0,1365.0,620.0,1500000000,3.0132769860792905,1082014363648.0,0.0159337937789749,0.0778666280710641,"
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

void *func1(void *arg)
{
	int i = 0;
	for (i = 0;i < 3;i++)
	{
		printf(""in func1\n"");
		sleep(1);
	}
}

int main(int argc, char *argv[])
{
	int *save = NULL;
	pthread_t pid1;
	
	pthread_create(&pid1,NULL,func1,NULL);


	pthread_detach(pid1);
	pthread_join(pid1,NULL);

	printf(""after join \n"");
	sleep(3);
	return 0;
}
"
276-22153,jmaq-cr/SO-Pr2-Synchronization,examples/random.c,31,1,16,4505805958.528071,229229.0,19656.35219802032,1373.0,1350.0,51785.0,20663.0,1643.0,661.0,1360.0,618.0,1500000000,3.0038706390187144,1082014363648.0,0.0118789507435795,0.059104461130742,"#include <stdio.h>
#include <unistd.h>

int random_number(int min_num, int max_num);

int main(void)
{
    int i = 0;
    // Seed random number generator
    srand(time(NULL));
    do
    {
        printf(""Min : 1 Max : 30 = %d\n"", random_number(1, 30));
        printf(""Min : 100 Max : 1000 = %d\n"", random_number(100, 1000));
        usleep(100 * 1000);
        i++;
    } while (i != 30);

    return 0;
}

int random_number(int min_num, int max_num)
{
    int result = 0, low_num = 0, hi_num = 0;

    if (min_num < max_num)
    {
        low_num = min_num;
        hi_num = max_num + 1; // include max_num in output
    }
    else
    {
        low_num = max_num + 1; // include max_num in output
        hi_num = min_num;
    }

    result = (rand() % (hi_num - low_num)) + low_num;
    return result;
}"
394-20669,Logilin/ils,exemples/chapitre-01/test_gcov.c,14,1,4,2657644.4506644,364739.0,7.286426732540255,1192.0,1179.0,88080.0,39980.0,1591.0,585.0,1330.0,546.0,1500000000,0.0017717629671096,1082014363648.0,0.0065005387414013,0.0316414180852725,"#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>



int main(void)
{
	int i;
	for (i = 0; i < 1000; i ++) {
		if (i < 800)
			fprintf(stderr, ""-"");
		else
			fprintf(stderr, ""+"");
	}
	fprintf(stderr, ""sortie\n""); 
	if (i < 100)
		fprintf(stderr, ""jamais exécuté\n"");
	return 0;
}




"
097-11523,livinsunny/alpha,reverse_bits.c,23,1,11,2401279.4019653997,174448.0,13.765013069797304,1343.0,1323.0,39453.0,13508.0,1618.0,638.0,1339.0,593.0,1500000000,0.0016008529346436,1082014363648.0,0.0152824910575071,0.0790770567021015,"
#include<stdio.h>

#define CHAR_BIT 8
int swap_nibble(unsigned int);
int main(){
	unsigned int v=0x50; //	0101 0000
	unsigned int r=v;

    int a=0;
	int s=sizeof(v)*CHAR_BIT-1;
    printf( ""sizeof %d"",sizeof(unsigned int));
	for(v=v>>1;v;v=v>>1)
	{
		r<<=1;
		r|=v&1;
		s--;
	}

	r<<=s;
	printf(""%x\n"",r);
    r=0x5a;
    printf(""sw : %d \n"",swap_nibble(r)); //1010 0101
	return 0;
}

int swap_nibble(unsigned int n)
{
   return (((n & 0xf0) >> 4 | (n & 0x0f) << 4));
}
"
048-22728,NikolayGenov/HackBG,Week0/beginer_1.c,14,1,4,1646597.9861095499,174754.0,15.389879487737048,1279.0,1261.0,39720.0,13555.0,1637.0,638.0,1351.0,597.0,1500000000,0.0010977319907397,1082014363648.0,0.0145347173741373,0.0792679493195682,"#include <stdio.h>

void printFileContent(char* filename){
    FILE* fp = fopen(filename,""r"");
    char c;
    if (fp){
        while ((c = getc(fp)) != EOF)
            putchar(c);
        fclose(fp);
    }
}


int main(int argc, char* argv[]){
    char* filename = argv[1];
    printFileContent(filename);
    return 0;

}
"
071-13357,zuiko21/minimOS,forge/shell/coder.c,16,1,8,4116891.1848216,195140.0,21.0971148918725,1351.0,1328.0,45743.0,18142.0,1620.0,650.0,1347.0,609.0,1500000000,0.0027445941232144,1082014363648.0,0.0137286051040278,0.0661501134851686,"/* (c) 2020-2022 Carlos J. Santisteban */
#include <stdio.h>

int main(void)
{
	int i;

	FILE* f;

	f=fopen(""test.bin"",""wb"");
	fputc(0,f);
	for (i=1;i<256;i++)
	{
		fputc(i,f);
		fputc(i,f);
		fputc(i,f);
	}
	fclose(f);
	
	return 0;
}
"
187-9759,chikoski/wasm-asm-demo,emscripten/pthread/th.c,23,2,6,30005299800.192005,192618.0,155776.1984861228,1472.0,1448.0,44464.0,16227.0,1663.0,663.0,1370.0,620.0,1500000000,20.003533200128004,1082014363648.0,0.0151595385685657,0.0711143332619334,"#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

static void *thread_func(void *vptr_args) {
    int i;

    for (i = 0; i < 20; i++) {
        fputs(""  b\n"", stderr);
        sleep(1);
    }

    return NULL;
}

int main(void) {
    int i;
    pthread_t thread;

    if (pthread_create(&thread, NULL, thread_func, NULL) != 0) {
        return EXIT_FAILURE;
    }

    for (i = 0; i < 20; i++) {
        puts(""a"");
        sleep(1);
    }

    if (pthread_join(thread, NULL) != 0) {
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}
"
114-22978,raydudu/DMM,tests/tls_verify.c,26,4,11,1522310104.6867669,212171.0,7174.920719608241,1513.0,1471.0,50117.0,19893.0,2093.0,1219.0,1391.0,1025.0,1500000000,1.0148734031245112,1082014363648.0,0.0140641275197835,0.0818168833023853,"#include <unistd.h>
#include <stdio.h>
#include <pthread.h>

static __thread int tid;

void *tid_check(void *arg) {
    long id = (long)arg;
    tid = id;
    sleep(1);
    if (id != tid) {
        printf(""FAIL!\n"");
    }
    return NULL;
}

#define THREADS 16

int main(int argc, char **argv) {
    pthread_t threads[THREADS];
    int i;

    for(i = 0; i < THREADS; i++) {
        if (pthread_create(&(threads[i]), NULL, tid_check, (void *)(long)random()) != 0) {
            printf(""Fail to alloacte thread %d\n"", i);
        }
    }

    printf(""Waiting for threads\n"");
    for(i = 0; i < THREADS; i++) {
        if (pthread_join(threads[i], NULL) != 0) {
            printf(""Fail to wait for thread %d\n"", i);
        }
    }

    return 0;
}
"
007-31877,totalspectrum/binutils-propeller,gdb/testsuite/gdb.compile/compile-print.c,24,1,11,1627084.21703415,169074.0,9.623502135159752,1139.0,1129.0,38455.0,12697.0,1569.0,588.0,1318.0,547.0,1500000000,0.0010847228113561,1082014363648.0,0.0134142446502714,0.0786284016265248,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2015-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <stdlib.h>

int varint = 10;
int vararray[] = { 1, 2, 3, 4, 5 };
int *vararrayp = vararray;
struct object
{
  int field;
} varobject = { 1 };

int
main (void)
{
  return 0;
}
"
061-3062,cyumeng/CPrimerPlus,plist.6.11.c,9,2,4,1695302.7807175498,175761.0,9.645495872235593,1293.0,1275.0,39964.0,13702.0,1607.0,643.0,1332.0,599.0,1500000000,0.0011302018538117,1082014363648.0,0.0146107498250465,0.0779078000968956,"// a counting loop using for
#include <stdio.h>
int main(void)
{
	const int NUMBER = 22;
	int count;

	for (count = 1; count <= 22; count++)
		printf(""Be my Valentine!\n"");

	return 0;
}
"
378-15174,kgaipal/workspace,test-code/Google/cache4.c,9,2,6,98893330.3160592,100194085.0,0.987017646800208,1142.0,1132.0,25038460.0,12696.0,1564115.0,594.0,1563817.0,546.0,1500000000,0.0659288868773728,1082014363648.0,2.2695950564347188e-05,0.1249072897075089,"int main() {
    static int x[5000][5000];
    for (int j = 0; j < 5000; j++) {
	    for (int i = 0; i < 5000; i++) {
            x[j][i]++;
        }
    }

    return 0;
}
"
040-27018,jmaq-cr/SO-Pr2-Synchronization,examples/thread_test.c,31,2,15,6039073233.143427,200981.0,30047.9808190824,1494.0,1464.0,45204.0,17440.0,1677.0,841.0,1364.0,795.0,1500000000,4.026048822095618,1082014363648.0,0.0147178091461381,0.0746599833982504,"#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <time.h>

static void sleep(int ms)
{
    struct timespec waittime;

    waittime.tv_sec = (ms / 1000);
    ms = ms % 1000;
    waittime.tv_nsec = ms * 1000 * 1000;

    nanosleep(&waittime, NULL);
}

void *threadfunc(void *c)
{
    int id = (int)c;
    int i = 0;

    for (i = 0; i < 12; ++i)
    {
        printf(""thread %d, iteration %d\n"", id, i);
        sleep(1000);
    }

    return 0;
}

int main()
{
    int i = 4;

    for (; i; --i)
    {
        pthread_t *tcb = malloc(sizeof(*tcb));

        pthread_create(tcb, NULL, threadfunc, (void *)i);
    }

    sleep(4000);

#ifdef USE_PTHREAD_EXIT
    pthread_exit(0);
#endif

    return 0;
}"
035-11693,megastallman/hello_world_playground,C/memfuck.c,6,1,2,15001903636.730274,170089.0,88200.31651664717,1154.0,1144.0,38691.0,12795.0,1575.0,586.0,1322.0,546.0,1500000000,10.001269091153516,1082014363648.0,0.0135105738760296,0.0782542827176319,"#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
	for(long i=0; i<99999999; i++){
		malloc(1);
	}
	sleep(10);
}
"
234-24632,jpoirier/picoc,tests/csmith/rand22.c,87,3,14,2050895.94237495,216616.0,9.46456402112494,1359.0,1338.0,39816.0,14388.0,1620.0,654.0,1342.0,611.0,1500000000,0.0013672639615833,1082014363648.0,0.0124506038335118,0.0779831746734558,"#include <stdio.h>
int print_hash_value = 1;
static void platform_main_begin(void)
{
}
static unsigned crc32_tab[256];
static unsigned crc32_context = 0xFFFFFFFFUL;
static void
crc32_gentab (void)
{
 unsigned crc;
 unsigned poly = 0xEDB88320UL;
 int i, j;
 for (i = 0; i < 256; i++) {
  crc = i;
  for (j = 8; j > 0; j--) {
   if (crc & 1) {
    crc = (crc >> 1) ^ poly;
   } else {
    crc >>= 1;
   }
  }
  crc32_tab[i] = crc;
 }
}
static void
crc32_byte (unsigned char b) {
 crc32_context =
  ((crc32_context >> 8) & 0x00FFFFFF) ^
  crc32_tab[(crc32_context ^ b) & 0xFF];
}
extern int strcmp ( char *, char *);
static void
crc32_8bytes (unsigned val)
{
 crc32_byte ((val>>0) & 0xff);
 crc32_byte ((val>>8) & 0xff);
 crc32_byte ((val>>16) & 0xff);
 crc32_byte ((val>>24) & 0xff);
}
static void
transparent_crc (unsigned val, char* vname, int flag)
{
 crc32_8bytes(val);
 if (flag) {
    printf(""...checksum after hashing %s : %X\n"", vname, crc32_context ^ 0xFFFFFFFFU);
 }
}
static void
platform_main_end (int x, int flag)
{
  if (!flag) printf (""checksum = %x\n"", x);
}
static long __undefined;
void csmith_compute_hash(void);
void step_hash(int stmt_id);
static unsigned short g_2 = 0xB55BL;
static unsigned char func_1(void);
static unsigned char func_1(void)
{
    step_hash(1);
    return g_2;
}
void csmith_compute_hash(void)
{
    transparent_crc(g_2, ""g_2"", print_hash_value);
}
void step_hash(int stmt_id)
{
    int i = 0;
    csmith_compute_hash();
    printf(""before stmt(%d): checksum = %X\n"", stmt_id, crc32_context ^ 0xFFFFFFFFUL);
    crc32_context = 0xFFFFFFFFUL;
    for (i = 0; i < 256; i++) {
        crc32_tab[i] = 0;
    }
    crc32_gentab();
}
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    csmith_compute_hash();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}
"
262-19610,fangdingjun/example1,c/strcpy.c,15,1,7,1831939.6767765,174125.0,10.516669059583633,1327.0,1307.0,39458.0,13419.0,1625.0,636.0,1344.0,594.0,1500000000,0.001221293117851,1082014363648.0,0.0151270638908829,0.0794107078692059,"#include <stdio.h>
#include <string.h>

int main()
{
    char str2[10],str1[10];
    int i;

    for (i=0; i<10; i++)
    {
        str2[i]='a';
    }

    char *p;
    p=str1;
    //strcpy(str1,p);
    memcpy(str1,str2,10);
    printf(""%s\n%s\n"",str1,str2);

    return 0;
}
"
359-28910,djtuBIG-MaliceX/my-random-tools,vgm-rip-aids/nmk112/okimtest.c,25,1,8,3877072.7114751,299931.0,12.926546439014306,1447.0,1417.0,70484.0,36154.0,1643.0,731.0,1358.0,688.0,1500000000,0.0025847151409834,1082014363648.0,0.0095488629051348,0.0414486393218177,"
#include <stdio.h>

int main(int argc, char **argv)
{
   FILE *fp = fopen(""bgaregga_0-test.vgm"", ""a"");
   
   char i = (char)(0x80 & 0xFF);
   
   while (i != 0)
   {
      printf(""Writing OKIM6295 Sample 0x%X Playback...\n"", (i-0x80)&0xFF);
      
      fputc(0x61, fp);
      fputc(0xFF, fp);
      fputc(0xFF, fp);
   
      fputc(0xB8, fp);
      fputc(0x00, fp);
      fputc(0x78, fp);
      
      fputc(0xB8, fp);
      fputc(0x00, fp);
      fputc(i & 0xFF, fp);
      
      fputc(0xB8, fp);
      fputc(0x00, fp);
      fputc(0x10, fp);
      
      i++;
   }
   
   fputc(0x66, fp);
   
   fclose(fp);
   
   return 0;
}"
292-31553,SanDisk-Open-Source/SSD_Dashboard,uefi/userspace/glibc/stdio-common/tst-fdopen.c,37,1,12,1975922.9617192498,182735.0,10.813046214463569,1500.0,1473.0,41603.0,14606.0,1680.0,645.0,1386.0,601.0,1500000000,0.0013172819744795,1082014363648.0,0.0162694612416887,0.0767136935366222,"/* Test for fdopen bugs.  */

#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>

#undef assert
#define assert(x) \
  if (!(x)) \
    { \
      fputs (""test failed: "" #x ""\n"", stderr); \
      retval = 1; \
      goto the_end; \
    }

char buffer[256];

int
main (int argc, char *argv[])
{
  char *name;
  FILE *fp = NULL;
  int retval = 0;
  int fd;

  name = tmpnam (NULL);
  fp = fopen (name, ""w"");
  assert (fp != NULL)
  fputs (""foobar and baz"", fp);
  fclose (fp);
  fp = NULL;

  fd = open (name, O_RDONLY);
  assert (fd != -1);
  assert (lseek (fd, 5, SEEK_SET) == 5);
  /* The file position indicator associated with the new stream is set to
     the position indicated by the file offset associated with the file
     descriptor.  */
  fp = fdopen (fd, ""r"");
  assert (fp != NULL);
  assert (getc (fp) == 'r');
  assert (getc (fp) == ' ');

the_end:
  if (fp != NULL)
    fclose (fp);
  unlink (name);

  return retval;
}
"
243-33252,phil-opp/binutils-gdb,gdb/testsuite/gdb.base/paginate-inferior-exit.c,24,1,14,4524864577.688276,170086.0,26603.392266265306,1153.0,1144.0,38691.0,12795.0,1573.0,585.0,1322.0,544.0,1500000000,3.016576385125518,1082014363648.0,0.0135049327987018,0.078157168939129,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2016 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

static void
after_sleep (void)
{
  return; /* after sleep */
}

int
main (void)
{
  sleep (3);
  after_sleep ();
  return 0;
}
"
009-2796,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.base/disasm-end-cu-1.c,22,1,12,1869737.8691284498,169061.0,11.059540639177577,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0012464919127523,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright (C) 2010-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
dummy_1 (int a, int b, int c)
{
  return a + b + c;
}

int
main ()
{
  return 0;
}
"
060-34067,jimuyouyou/nodeinpractice,listings/child-process/detached/longrun.c,8,1,0,30002768483.944237,176229.0,170248.75862088532,1324.0,1307.0,40097.0,13719.0,1631.0,635.0,1350.0,593.0,1500000000,20.001845655962825,1082014363648.0,0.0149294384011712,0.0782109409840939,"#include <unistd.h>
#include <stdio.h>

int main () {
  printf(""going to sleep for 20 seconds\n"");
  fflush(stdout);

  sleep(20);
  printf(""finished sleeping\n"");
  fprintf(stderr, ""error output!\n"");
  return 0;
}
"
130-17355,totalspectrum/binutils-propeller,gdb/testsuite/gdb.threads/hand-call-new-thread.c,36,2,14,1568464.3294662,172575.0,9.088593365203534,1150.0,1140.0,39352.0,13036.0,1600.0,586.0,1342.0,544.0,1500000000,0.0010456428863108,1082014363648.0,0.0132695929306098,0.077727723906238,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2015-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>
#include <stdlib.h>
#include <pthread.h>
#include <assert.h>

static int
foo (void)
{
  usleep (1);
}

static void *
thread_function (void *arg)
{
  while (1)
    foo ();
}

void
new_thread (void)
{
  pthread_t thread;
  int res;

  res = pthread_create (&thread, NULL, thread_function, NULL);
  assert (res == 0);
}

int
main (int argc, char **argv)
{
  return 0;
}
"
096-32406,qeedquan/misc_utilities,snippets/posix/signal.c,40,3,8,16536815887.782722,4403410880.0,3.755456017540657,1481.0,1455.0,1467587395.0,281849.0,1693.0,660.0,1388.0,615.0,1500000000,11.024543925188482,1082014363648.0,6.667558581315038e-07,2.967566775995478e-06,"#define _GNU_SOURCE
#include <stdio.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>

volatile sig_atomic_t cond;

void
sigalarm(int sig)
{
	cond = 1;
	(void)sig;
}

void
strsig(void)
{
	int i;
	char *s;

	for (i = 0; i < 1024; i++) {
		s = strsignal(i);
		if (!s || strncasecmp(s, ""Unknown"", 7) == 0)
			continue;

		printf(""%d %s\n"", i, s);
	}
}

void
sirens(void)
{
	int i;

	signal(SIGALRM, sigalarm);
	cond = 0;
	for (i = 0; i <= 10; i++) {
		alarm(1);

		while (!cond)
			;

		printf(""%d\n"", i);
		cond = 0;
	}
}

int
main(void)
{
	strsig();
	sirens();
	return 0;
}
"
170-18272,totalspectrum/binutils-propeller,gdb/testsuite/gdb.base/vdso-warning.c,17,1,10,1368514.72780095,169061.0,8.09479418671367,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0009123431518673,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
main (void)
{
  return 0;
}
"
264-20591,Siarkowy/CP,Sem1/ascii.c,7,1,5,1985147.9446514999,286631.0,6.925793092861554,1348.0,1329.0,61488.0,28432.0,1619.0,648.0,1341.0,605.0,1500000000,0.001323431963101,1082014363648.0,0.0093395341048246,0.0468527580071174,"#include <stdio.h>

#define START_CODE 32
#define LAST_CODE 126

int main()
{
    char ch;

    for (ch = START_CODE; ch <= LAST_CODE; ++ch)
        printf(""%X %d %c\n"", ch, ch, ch);

    return 0;
}
"
162-29900,zxombie/aarch64-freebsd-binutils,gdb/testsuite/gdb.base/term.c,16,1,10,1552171.3066845,169083.0,9.177013656015092,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.001034780871123,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2012-2014 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int main ()
{
  return 0;
}
"
116-31734,TommesDee/cpachecker,test/programs/simple/loop-tests/for+init.c,7,1,4,1652867.9989278,169057.0,9.776980545023276,1139.0,1129.0,38452.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0011019119992852,1082014363648.0,0.0134155935572026,0.0785172440760147,"#include <stdlib.h>

int main(void) {

  for (int counter = 0; counter < 5; counter++) {
    int a;
    a++;
  }

  return (0);
}
"
166-1816,zxombie/aarch64-freebsd-binutils,gdb/testsuite/gdb.btrace/unknown_functions.c,35,1,9,1718702.9588966998,169061.0,10.162615860547376,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0011458019725978,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2013 Free Software Foundation, Inc.

   Contributed by Intel Corp. <markus.t.metzger@intel.com>

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

static int foo (void);

int test (void)
{
  return foo ();
}

static int
bar (void)
{
  return 42;
}

static int
foo (void)
{
  return bar ();
}

int
main (void)
{
  test ();
  test ();
  return 0;
}
"
132-1440,evaautomation/binutils,gdb/testsuite/gdb.compile/compile-print.c,24,1,10,1468936.5634693499,169074.0,8.68812472645114,1139.0,1129.0,38455.0,12697.0,1569.0,588.0,1318.0,547.0,1500000000,0.0009792910423129,1082014363648.0,0.0134142446502714,0.0786284016265248,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <stdlib.h>

int varint = 10;
int vararray[] = { 1, 2, 3, 4, 5 };
int *vararrayp = vararray;
struct object
{
  int field;
} varobject = { 1 };

int
main (void)
{
  return 0;
}
"
280-27836,SaiNayLynnOo/First,displayingno.c,11,3,3,1675807.52167845,186459.0,8.987536133949018,1338.0,1320.0,42059.0,15271.0,1626.0,639.0,1345.0,595.0,1500000000,0.0011172050144523,1082014363648.0,0.0142551445626116,0.0733472876330019,"#include <stdio.h>
#include <stdlib.h>
int main()
{
	int i=0;
	printf(""Displaying number for one to twenty using while loop: \n"");
	while(i<20)
	{
		i++;
		printf("" %d\n"",i);
	}
	return 0;
}"
126-6073,alpine9000/BitOS,tests/gcc.c-torture/pr65053-2.c,24,1,13,1480518.2581767,169976.0,8.710159081282063,1146.0,1137.0,38667.0,12779.0,1577.0,586.0,1323.0,546.0,1500000000,0.0009870121721178,1082014363648.0,0.0134313079493575,0.078373440111962,"/* { dg-do run } */
/* PR tree-optimization/65053 */

int i;
unsigned int x;

int
main ()
{
  asm volatile ("""" : ""+g"" (x));
  unsigned int n = x;
  unsigned int u = 32;
  if (n >= 32)
    __builtin_abort ();
  if (n != 0)
    u = n + 32;

  while (u != 32)
    {
      asm ("""" : : ""g"" (u));
      u = 32;
      i = 1;
    }

  if (i)
    __builtin_abort ();
  return 0;
}
"
046-7581,hanumanum/notes-on-c,code/prog08b.c,6,1,4,1843353.0349284,170003.0,10.843061593030711,1146.0,1137.0,38670.0,12779.0,1577.0,586.0,1324.0,546.0,1500000000,0.0012289020232856,1082014363648.0,0.0134291747792686,0.0783883068669945,"
#include <stdio.h>


int main( int argc, char** argv )
{
  for( int c = 1; c < argc; ++c )
    puts( argv[c] );

  return 0;
}

"
139-16762,rockwotj/mjc,src/test/resources/test.c,9,1,4,1822578.1386717,175586.0,10.37997334639436,1351.0,1331.0,39781.0,13693.0,1620.0,636.0,1340.0,594.0,1500000000,0.0012150520924478,1082014363648.0,0.0152745663093868,0.0783558364812806,"#include <stdlib.h>
#include <stdio.h>

int main() {
    int *array = calloc(4, 4);
    int i = 0;
    while (i < 4) {
        printf(""%d\n"", array[i]);
        i++;
    }
    return 0;
}
"
270-5135,lilianglaoding/codeprimer,CLab/DataStruct/Sort/Quick_Sort/quick_sort.c,43,4,13,1706178.30008265,180843.0,9.434581377216702,1356.0,1336.0,40906.0,14373.0,1630.0,637.0,1350.0,593.0,1500000000,0.0011374522000551,1082014363648.0,0.0148858402039338,0.076159120099857,"#include <stdio.h>
#include <stdlib.h>

int Partion(int R[], int low, int high)
{
  int temp;
  temp = R[low];
  while (low < high)
  {
    while (low < high && R[high] > temp)
      high--;
    if (low < high)
    {
      R[low] = R[high];
      low++;
    }
    while (low < high && R[low] < temp)
      low++;
    if (low < high)
    {
      R[high] = R[low];
      high--;
    }
  }
  R[low] = temp;
  return low;
}

void Quick_Sort(int R[], int s, int t)
{
  int i;
  if (s < t)
  {
    i = Partion(R, s, t);
    Quick_Sort(R, s, i - 1);
    Quick_Sort(R, i + 1, t);
  }
}

int main()
{
  int array[10] = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
  Quick_Sort(array, 0, 9);
  for (int i = 0; i < 10; i++)
    printf(""%d "", array[i]);
  printf(""\n"");
  return 0;
}
"
169-9136,lovejavaee/sp_c,src/hfc_for_loop.c,13,2,6,2544589.34068665,184832.0,13.767037093144044,1337.0,1318.0,41737.0,15109.0,1618.0,649.0,1339.0,604.0,1500000000,0.0016963928937911,1082014363648.0,0.0143643957756232,0.074059740351124,"#include <stdio.h>

int main()
{
    int counter = 1;
    while (counter < 11) {
        printf(""%i green bottles, hanging on a wall\n"", counter);
        counter++;
    }

    int i;
    for (i = 1; i < 11; i++) {
        printf(""%i green bottles, hanging on a wall\n"", i);
    }

    return 0;
}
"
041-25768,swigger/gdb-ios,gdb/testsuite/gdb.guile/scm-math.c,23,1,11,2217291.0394146,169057.0,13.115641470036731,1139.0,1129.0,38452.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0014781940262764,1082014363648.0,0.0134155935572026,0.0785172440760147,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2016 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

enum e
  {
    ONE = 1,
    TWO = 2
  };

enum e evalue = TWO;

int
main (int argc, char *argv[])
{
  return 0;
}
"
397-22068,redox-os/ion,sh-interrupt/hardguy.c,10,1,2,30004639300.63415,172508.0,173931.87156537667,1166.0,1156.0,39335.0,13237.0,1582.0,585.0,1326.0,546.0,1500000000,20.003092867089435,1082014363648.0,0.013460245321956,0.0768279692612036,"#include <stdio.h>
#include <unistd.h>
#include <signal.h>

int main(void)
{
  int i;
  signal(SIGINT, SIG_IGN);
  signal(SIGQUIT, SIG_IGN);
  for (i=20 ; i>0; i--) {
    sleep(1);
  }
  return 0;
}
"
359-5231,ILyoan/gdb,gdb/testsuite/gdb.dwarf2/fission-base.c,22,1,11,1774984.29547995,169061.0,10.49907429862594,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0011833228636533,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2012 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
func (int arg)
{
  return arg + 1;
}

int
main ()
{
  return func (-1);
}
"
344-10567,zdravkoandonov/sysprog,week3/task1.c,10,1,3,1551661.40757495,172353.0,14.704588838024288,1155.0,1146.0,39270.0,13050.0,1590.0,586.0,1334.0,546.0,1500000000,0.0010344409383833,1082014363648.0,0.0133505073889053,0.0775229357798165,"#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

int main(int argc, char* argv[]) {
  int fd = open(argv[1], O_WRONLY|O_CREAT, 0777);
  close(1);
  dup(fd);
  int i;
  for (i = 0; i < 10; ++i) {
    write(1, ""EXAMPLE"", 7);
  }

  return 0;
}
"
078-23777,thlorenz/libuv-dox,examples/18-cgi/tick.c,10,1,2,16090327693.498692,178495.0,90118.03462281857,1306.0,1288.0,40690.0,14092.0,1623.0,633.0,1342.0,591.0,1500000000,10.726885128999127,1082014363648.0,0.0145326199613434,0.0764667226461246,"#include <stdio.h>
#include <unistd.h>

int main(void) {
  int i;
  for (i = 0; i < 10; i++) {
    fprintf(stdout, ""tick\n"");;
    fflush(stdout);
    sleep(1);
  }
  fprintf(stdout, ""BOOM!\n"");;
  return 0;
}
"
175-30089,jpoirier/picoc,tests/csmith/rand69.c,86,3,15,1512799.4120121,174109.0,8.688804139935328,1349.0,1330.0,39383.0,13446.0,1619.0,637.0,1342.0,594.0,1500000000,0.0010085329413414,1082014363648.0,0.0153869127960071,0.0793503568115996,"#include <stdio.h>
int print_hash_value = 1;
static void platform_main_begin(void)
{
}
static unsigned crc32_tab[256];
static unsigned crc32_context = 0xFFFFFFFFUL;
static void
crc32_gentab (void)
{
 unsigned crc;
 unsigned poly = 0xEDB88320UL;
 int i, j;
 for (i = 0; i < 256; i++) {
  crc = i;
  for (j = 8; j > 0; j--) {
   if (crc & 1) {
    crc = (crc >> 1) ^ poly;
   } else {
    crc >>= 1;
   }
  }
  crc32_tab[i] = crc;
 }
}
static void
crc32_byte (unsigned char b) {
 crc32_context =
  ((crc32_context >> 8) & 0x00FFFFFF) ^
  crc32_tab[(crc32_context ^ b) & 0xFF];
}
extern int strcmp ( char *, char *);
static void
crc32_8bytes (unsigned val)
{
 crc32_byte ((val>>0) & 0xff);
 crc32_byte ((val>>8) & 0xff);
 crc32_byte ((val>>16) & 0xff);
 crc32_byte ((val>>24) & 0xff);
}
static void
transparent_crc (unsigned val, char* vname, int flag)
{
 crc32_8bytes(val);
 if (flag) {
    printf(""...checksum after hashing %s : %X\n"", vname, crc32_context ^ 0xFFFFFFFFU);
 }
}
static void
platform_main_end (int x, int flag)
{
  if (!flag) printf (""checksum = %x\n"", x);
}
static long __undefined;
void csmith_compute_hash(void);
void step_hash(int stmt_id);
static unsigned func_1(void);
static unsigned func_1(void)
{
    int l_2 = (-1L);
    step_hash(1);
    return l_2;
}
void csmith_compute_hash(void)
{
}
void step_hash(int stmt_id)
{
    int i = 0;
    csmith_compute_hash();
    printf(""before stmt(%d): checksum = %X\n"", stmt_id, crc32_context ^ 0xFFFFFFFFUL);
    crc32_context = 0xFFFFFFFFUL;
    for (i = 0; i < 256; i++) {
        crc32_tab[i] = 0;
    }
    crc32_gentab();
}
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    csmith_compute_hash();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}
"
047-8651,digwiz/Euler,c/problem_two.c,23,1,10,39202012.354507945,368498478.0,0.1063831042471768,1352.0,1332.0,61389369.0,33791436.0,1620.0,651.0,1341.0,605.0,1500000000,0.0261346749030053,1082014363648.0,7.2836121727482415e-06,4.430515165321411e-05,"#include <stdio.h>

long int fibonacci(long int n);


int main(int argc, char *argv[])
{
  long int i;
  long int sum = 0;
  
  for(i = 0; fibonacci(i) < 4000000; i++)
  {
    printf(""fibonacci(i) is: %lu\n"", fibonacci(i));
    
    if( (fibonacci(i) % 2) == 0 )
      sum += fibonacci(i);
  }
  printf(""The sum of the even fibonacci numbers below 4000000 is: %lu\n"", sum);
  return 0;
  
}

long int fibonacci(long int n)
{
  if (n == 0)
    return 0;
  else if (n == 1)
    return 1;
  else
    return fibonacci(n-1) + fibonacci(n-2);
}"
328-27095,selmentdev/selment-toolchain,source/gcc-latest/gcc/testsuite/gcc.c-torture/execute/pr57344-4.c,25,1,10,2025362.9190846,170005.0,11.913543719302371,1148.0,1139.0,38673.0,12786.0,1577.0,587.0,1323.0,547.0,1500000000,0.0013502419460564,1082014363648.0,0.0134525455133672,0.0783925066557842,"/* PR middle-end/57344 */

struct __attribute__((packed)) S
{
  long long int a : 59;
  long long int b : 54;
  char c;
  long long int : 0;
} s[2];
int i;

__attribute__((noinline, noclone)) void
foo (long long int x)
{
  if (x != -1220975898975746LL)
    __builtin_abort ();
  asm volatile ("""" : : : ""memory"");
}

int
main ()
{
  struct S t = { 0, -1220975898975746LL };
  s[1] = t;
  for (; i < 1; i++)
    foo (s[1].b);
  return 0;
}
"
295-21387,endlessm/chromium-browser,third_party/llvm/polly/lib/External/ppcg/tests/struct4.c,20,3,8,1801534.67226765,170520.0,10.564942528735632,1146.0,1138.0,38734.0,12801.0,1582.0,587.0,1326.0,546.0,1500000000,0.0012010231148451,1082014363648.0,0.0133943232465399,0.0784127292131561,"#include <stdlib.h>

struct s {
	int a;
	int b;
};

int main()
{
	int a[10];

	for (int i = 0; i < 10; ++i)
		a[i] = 0;
#pragma scop
	for (int i = 0; i < 10; ++i) {
		struct s b;
		b.a = 1;
		b.b = i;
		a[i] = b.a + b.b;
	}
#pragma endscop
	for (int i = 0; i < 10; ++i)
		if (a[i] != 1 + i)
			return EXIT_FAILURE;

	return EXIT_SUCCESS;
}
"
354-6478,totalspectrum/binutils-propeller,gdb/testsuite/gdb.python/py-objfile.c,18,1,10,1527274.2602972998,169057.0,9.034077263881413,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010181828401982,1082014363648.0,0.0134155935572026,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2011-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
main ()
{
  int some_var = 0;
  return 0;
}
"
158-18444,AiJiaZone/linux-4.0,virt/scripts/check-lc_ctype.c,8,1,7,2353204.297833,188254.0,12.50015404719156,1394.0,1365.0,42368.0,14493.0,1765.0,705.0,1417.0,658.0,1500000000,0.001568802865222,1082014363648.0,0.0146557310867232,0.0799317634230843,"/*
 * Check that a specified locale works as LC_CTYPE.  Used by the
 * DocBook build system to probe for C.UTF-8 support.
 */

#include <locale.h>

int main(void)
{
	return !setlocale(LC_CTYPE, """");
}
"
380-9718,Irishsmurf/C-Stuff,cancelgood.c,31,2,10,1503020188.654773,272481.0,5516.0550203500425,2171.0,1748.0,64501.0,25220.0,2195.0,800.0,1666.0,726.0,1500000000,1.002013459103182,1082014363648.0,0.0143826542034123,0.0600416847783685,"#include <stdio.h>
#include <unistd.h>
#include <pthread.h>

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cv = PTHREAD_COND_INITIALIZER;
const int flag = 1;

static void *
cancelme(void *bb_in)
{
  pthread_mutex_lock(&mutex);

  /* Install a cleanup handler */
  pthread_cleanup_push(pthread_mutex_unlock, &mutex);

  while (flag) {
    pthread_cond_wait(&cv, &mutex);
  }

  /* Uninstall cleanup handler */
  pthread_cleanup_pop(1);

  return (NULL);
}

int
main()
{
  pthread_t t;

  pthread_create(&t, NULL, cancelme, NULL);

  sleep(1);

  pthread_cancel(t);

  printf(""Waiting for thread to finish...\n"");
  pthread_join(t, NULL);
  printf(""Thread finished...\n"");

  printf(""Waiting to acquire lock...\n"");
  pthread_mutex_lock(&mutex);
  printf(""Lock acquired\n"");

  return (0);
}
"
286-486,goblint/analyzer,tests/regression/13-privatized/46-refine-protected1.c,20,1,6,2369072.9867665498,176707.0,13.406780716100664,1310.0,1288.0,40106.0,13703.0,1629.0,652.0,1351.0,609.0,1500000000,0.0015793819911777,1082014363648.0,0.0147023038136576,0.0788158114813507,"#include <pthread.h>
#include <assert.h>

int g = 0;

pthread_mutex_t A = PTHREAD_MUTEX_INITIALIZER;

void *t_fun(void *arg) {
  // just for going to multithreaded mode
  return NULL;
}

int main() {
  pthread_t id;
  pthread_create(&id, NULL, t_fun, NULL);

  pthread_mutex_lock(&A);
  if (g) // protected globals should be refined
    assert(g);
  else
    assert(!g);
  pthread_mutex_unlock(&A);

  pthread_mutex_lock(&A);
  g = 1;
  pthread_mutex_unlock(&A);
  return 0;
}
"
192-11574,cancro7/gem5,tests/test-progs/mem_set/src/mem_set.c,10,1,3,2494984.5392255997,880778.0,2.832704722415864,1348.0,1328.0,185687.0,116688.0,1625.0,698.0,1345.0,656.0,1500000000,0.0016633230261504,1082014363648.0,0.0030382230255524,0.0143001240181893,"#include <stdio.h>

int main()
{
  char v[1024];
  int i;

  printf(""BEFORE\n"");

  for (i=0; i<1024; i++)
    printf(""i=%d\n"",i);

  printf(""AFTER\n"");

  return 0;
}
"
287-2577,baotiao/Asenal,apue/thread.c,20,1,13,7527022211.928852,182141.0,41325.24918057988,1498.0,1465.0,41591.0,14649.0,1664.0,672.0,1372.0,629.0,1500000000,5.018014807952568,1082014363648.0,0.0162676168462894,0.0771159317211948,"#include<pthread.h>
#include<stdio.h>
void *msg(void *m)
{
    char *cp = (char *)m;
    int i;
    for(i=0; i<5; i++) {
        printf(""%s"", cp);
        sleep(1);
    }
    return NULL;
}

int main()
{
    pthread_t t1,t2;
    pthread_create(&t1,NULL,msg,(void *)""hello"");

    printf(""hhhhhhhhhhhhhhhhhhhhhhhhhhhhh\n"");
    //pthread_create(&t2,NULL,msg,(void *)""hello"");
    pthread_join(t1,NULL);
    //pthread_join(t2,NULL);
    return 0;
}
"
094-2253,ducis/operating-system-labs,p1/ticker.c,8,1,3,30921004102.681763,179964.0,284011.71243693185,1349.0,1329.0,40755.0,14384.0,1622.0,635.0,1343.0,593.0,1500000000,20.614002735121176,1082014363648.0,0.0148807539285634,0.0760441792560619,"#include <stdio.h>
#include <unistd.h>
int main(void){
    int i;
    for(i=0;i<10;++i){
        sleep(2);
        printf(""%d\n"",i);
    }
    return 0;
}
"
286-1472,wcnnbdk1/hello_world,CLearning/understandC_ja/m_chap02/countdown.c,23,2,9,15020193367.497995,513888244.0,29.228521069261895,1495.0,1464.0,139169984.0,32121618.0,1663.0,637.0,1371.0,594.0,1500000000,10.013462244998664,1082014363648.0,5.758061279954091e-06,2.4899060725697457e-05,"#include <stdio.h>
#include <time.h>

int sleep(unsigned long x)
{
    clock_t c1 = clock(), c2;
    do {
        if ((c2 = clock()) == (clock_t)-1)
            return 0;
    } while (1000.0 * (c2 - c1) / CLOCKS_PER_SEC < x);
    return 1;
}

int main(void)
{
    int i;
    clock_t c;

    for (i = 10; i > 0; i--) {
        printf(""\r%2d"", i);
        fflush(stdout);
        sleep(1000);
    }
    printf(""\r\aFIRE!!\n"");

    c = clock();
    printf(""After excute the program %.1f seconds.\n"", (double)c / CLOCKS_PER_SEC);
    return 0;
}
"
182-26410,LinuxKernelDevelopment/ITA,15/cut/cutrod.c,21,1,8,36797582.753933854,250870084.0,0.1466798328970942,1349.0,1329.0,53373536.0,37928084.0,1629.0,704.0,1345.0,661.0,1500000000,0.0245317218359559,1082014363648.0,1.06748479424115e-05,4.752380078250528e-05,"#include <stdio.h>

int cut_rod(int*, int);

int
main(void)
{
	int p[] = { 0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30};
	int max;
	max = cut_rod(p, 12);
	printf(""the max:%d\n"", max);
	return 0;
}

#define max(a, b) (a > b ? a : b)

int cut_rod(int* p, int n)
{
	printf(""my cut:%d\n"", n);
	int i;
	int q = 0;
	if (n == 0)
		return 0;
	for (i = 1; i <= n; i++)
		q = max(q, p[i] + cut_rod(p, n-i));
	return q;
}
"
342-24042,Gurgel100/gcc,gcc/testsuite/gcc.dg/torture/pr87168.c,28,2,8,1502191.7643025501,169086.0,8.884183196716464,1142.0,1132.0,38461.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010014611762017,1082014363648.0,0.0134487775451545,0.078503430615556,"/* { dg-do compile } */

int a, b, c, d, e, f, *g;

int main ()
{ 
  unsigned i;
  while (b)
    { 
      int j, m;
L1:
      f = j;
L2:
      if (i && e)
	{ 
	  i = f;
	  goto L2;
	}
      j = f;
      if (a)
	goto L3;
      for (m = 0; m < 2; m++)
	if (d)
	  goto L1;
      goto L2;
L3:
      (&j != g) | c;
    }
  return 0;
}
"
024-33274,weiqiangdragonite/blog_tmp,unix_linux/test/my_test/program/random.c,32,1,17,15016961527.406239,182211.0,82415.230293451,1359.0,1336.0,41200.0,14632.0,1628.0,638.0,1349.0,594.0,1500000000,10.011307684937492,1082014363648.0,0.0147905450274681,0.0753868749104456,"/*
 *
 */


#include <stdio.h>
#include <time.h>


static unsigned long next = 1;

int rand(int range);
void srand(unsigned seed);

int
main(void)
{
	printf(""sizeof(unsigned) = %d\n"", sizeof(unsigned));

	int number;
	int i;

	for (i = 0; i < 10; ++i) {
		srand(time(NULL));
		number = rand(10);
		printf(""number = %d\n"", number);
		sleep(1);
	}

	return 0;
}

/* RAND_MAX assumed to be 32767 */
int
rand(int range)
{
	next = next * 1103515245 + 12345;
	return ((unsigned) (next / 65536) % range);
}

void
srand(unsigned seed)
{
	next = seed;
}
"
196-3484,freak97/binutils,gdb/testsuite/gdb.trace/qtro.c,26,1,10,1997582.8472524502,169083.0,11.814209589373268,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0013317218981683,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2013-2016 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

void
subr (int parm)
{
}

void
end (void)
{
}

int
main ()
{
  subr (1);
  end ();
}
"
381-6056,biesigrr/yeecc,testing/tests/success/t03.c,9,1,1,1618173.20622495,169037.0,9.572892325348889,1138.0,1128.0,38451.0,12696.0,1567.0,585.0,1317.0,546.0,1500000000,0.0010787821374833,1082014363648.0,0.0134053491247478,0.0784992277161905,"int main () {
  int i;
  i = 0;
  while (i < 10) {
    i = i + 1;
  }
  i = 0;

  return i;
}
"
049-30249,mattstock/binutils-bexkat1,gdb/testsuite/gdb.base/structs3.c,31,1,14,1409281.5108597002,169087.0,8.334650209655385,1139.0,1129.0,38461.0,12699.0,1569.0,585.0,1318.0,546.0,1500000000,0.0009395210072398,1082014363648.0,0.0134132133162218,0.0785379202501954,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2008-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

struct One
{
  int x;
};

struct Two
{
  struct One one;
  int x, y;
};

struct Two two = { { 1 }, 2, 3 };

typedef struct One tOne;
typedef struct Two tTwo;

tOne *onep = &two.one;
tTwo *twop = &two;

int main()
{
  onep->x = twop->y;
  return 0;
}
"
388-6469,codercheng/task_manager,test_time.c,11,1,3,15003938392.270357,171757.0,87355.61515396752,1156.0,1144.0,39108.0,12950.0,1591.0,586.0,1331.0,545.0,1500000000,10.002625594846904,1082014363648.0,0.0133910117200463,0.077855468900073,"#include <stdio.h>
#include <time.h>
#include <unistd.h>

int main()
{
	time_t timer;
	int n = 10;
	while(n--) {
		sleep(1);
		timer = time(NULL);
		printf(""%ld\n"", timer);
	}
	return 0;
}
"
252-11796,jencce/stuff,c/pprogress.c,11,1,3,15003866374.609064,186187.0,80557.37002046329,1359.0,1335.0,42397.0,15400.0,1634.0,635.0,1348.0,592.0,1500000000,10.002577583072709,1082014363648.0,0.0144693238518263,0.0728238489887018,"#include <stdio.h>

int main()
{
	int i = 10000;
	while (i < 10010) {
		printf(""i = %d"", i++);
		sleep(1);
		printf(""\b\b\b\b\b\b\b\b\b\b\b\b"");
		fflush(stdout);
	}

	return 0;
}
"
096-30172,edgaregonzalez/uade-fi,TpsFundamentoAna/12-5/ejercicioenclase3.c,27,1,7,1989993.0339306002,169061.0,11.770857856040127,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0013266620226204,1082014363648.0,0.0134152761429306,0.0785563462891999,"#include <stdio.h>

/*
    Una empresa de micros trabaja con un vector de 24 posiciones, en cada posición se indica, cuantos micros 
    salen por hora. En otro vector, tmb de 24 posicones, esta la cantidad total de pasajeros q sale por 
    hora. Determinar cual es la cantidad promedio de pasajeros, por micro, en cada hora, y cual es la hora que
    mas partida de micro hubo. Sabiendo que cada boleto cuesta $800 en promedio, cargar un vector con la 
    recaudación por hora.
*/

int main()
{
    int microsxhora[24];
    int pasajerosxhora[24];
    int recaudaciónxhora[24];
    int promediopxh[24];
    int cantmaxmicros = 0;
    int recaudacionxhora[24];
    int i = 0;

    for (i=0; i<24; i=i+1)
    {
        promediopxh[i] = pasajerosxhora[i] / microsxhora[i];
        
        if(cantmaxmicros < microsxhora[i])
        {
            cantmaxmicros = microsxhora[i];
        }
        
        recaudacionxhora[i] = pasajerosxhora[i] * 800;
    }

    return 0;
}"
235-16000,desaiankitb/MTech,sttp_ttt/cprogs/optimise1.c,9,1,2,1507066.5394887,169085.0,8.913067392140048,1142.0,1132.0,38460.0,12698.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010047110263258,1082014363648.0,0.0134488570837152,0.0785018960866335,"#include <stdio.h>
int i, a=5;
int f1(int b){
	for(i=0;i<10;i++){
		a = b;
	}
}
int main(){
	a = f1(7);
}
"
334-6939,phaziz/NothingButC,2017-02-16-Fibonacci.c,21,1,7,435457767.22021395,3671302861.0,0.1186112351628186,1348.0,1329.0,690054381.0,522433287.0,1625.0,647.0,1346.0,605.0,1500000000,0.2903051781468093,1082014363648.0,7.291689357578173e-07,3.482922021768555e-06,"#include <stdio.h>
#include <stdlib.h>

int fibonacci ( int zahl )
{
    if( zahl <= 2 )
    {
        return 1;
    }
    else
    {
        return fibonacci( zahl - 1 ) + fibonacci( zahl - 2 );
    }
}

int main()
{
    int i;

    for ( i = 1; i <= 40; i++ )
    {
        printf( ""\n\t\tGeneration %d: %d"", i, fibonacci( i ) );
    }

    printf(""\n"");

    return 0;
}"
160-22052,Elitos/ls2,Practicas/ejemplo_pthreads/mutex/malo.c,26,2,10,2326323.18511605,183281.0,12.692657722295271,1541.0,1511.0,41627.0,14911.0,1663.0,758.0,1364.0,714.0,1500000000,0.0015508821234107,1082014363648.0,0.0166520261238208,0.0795747992500619,"#include<stdio.h>
#include<string.h>
#include<pthread.h>
#include<stdlib.h>
#include<unistd.h>

pthread_t tid[2];
int contador;

void* function(void *arg)
{
    unsigned long i = 0;
    contador += 1;
    printf(""\n Trabajo %d comenzado\n"", contador);

    for(i=0; i<(0xFFFFFFFF);i++);

    printf(""\n Trabajo %d terminado\n"", contador);

    return NULL;
}

int main(void)
{
    int i = 0;
    int err;

    while(i < 2)
    {
        err = pthread_create(&(tid[i]), NULL, function, NULL);
        if (err != 0)
            printf(""\nNo es posible crear thread :[%s]"", strerror(err));
        i++;
    }

    pthread_join(tid[0], NULL);
    pthread_join(tid[1], NULL);

    return 0;
}
"
093-15576,lijiaying/InvariantGenerationPaperZILU,testcases/blast/21.c,14,1,4,2169184.5031455,169063.0,12.830625269869811,1141.0,1131.0,38459.0,12696.0,1568.0,585.0,1318.0,546.0,1500000000,0.001446123002097,1082014363648.0,0.0134387772605478,0.0785260482846251,"#include <assert.h>

int main() {
	int n;
	int k;

int i;
i=0;
	int flag;
	if(!(n>0 && n<10)) 
		return 0;
	while(i<n) {
		i++; if(flag) k+=4000; else k+=2000;
	}
	assert(k>n);
	return 0;
}"
370-21436,jprice-stmarytx/eg1302,Assignment02/csandoval5.c,8,1,6,1711982.7680289,177406.0,9.650079478709852,1452.0,1428.0,40216.0,13947.0,1641.0,640.0,1356.0,595.0,1500000000,0.0011413218453526,1082014363648.0,0.0162339492463614,0.0781345198751915,"#include <stdio.h>
#include <stdlib.h>

int main()
{
    printf(""Hello world from Carlos Sandoval!\n"");
    printf(""I learned that %d+%d=%d\n"",2,2,4);
    printf(""The grade I am working for is: %c\n"",'A');
    printf(""The temperature outside is barely %f degrees\n"",32.000000);
    return 0;
}
"
019-14152,redcap97/cyanurus,src/init/init.c,16,1,10,2455414.27284465,172501.0,14.234201540860631,1292.0,1274.0,39030.0,13222.0,1606.0,634.0,1333.0,592.0,1500000000,0.0016369428485631,1082014363648.0,0.014875276085356,0.0797098675648779,"/*
Copyright 2014 Akira Midorikawa

Licensed under the Apache License, Version 2.0 (the ""License"");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <stdio.h>

int main(void) {
  printf(""%s\n"", ""Hello, World!"");
  return 0;
}
"
312-77,cyumeng/CPrimerPlus,plist.5.12.c,12,1,7,1467091.49703375,353592.0,4.143272472227879,1349.0,1329.0,78003.0,39027.0,1629.0,700.0,1346.0,656.0,1500000000,0.0009780609980225,1082014363648.0,0.0075737007624606,0.0370076048876356,"#include <stdio.h>
#define MAX 100
int main(void)
{
	int count = MAX + 1;

	while (--count > 0)
	{
		printf(""%d bottles of spring water on the wall, ""
				""%d bottles of sprint water!\n"", count, count);
		printf(""Take one down and pass it around,\n"");
		printf(""%d bottles of sprint water!\n\n"", count - 1);
	}

	return 0;
}
"
005-9009,chaosink/output-source-code,test/tt.c,29,2,10,2244692.87786625,178839.0,12.545786992770031,1284.0,1264.0,40898.0,14039.0,1673.0,639.0,1383.0,598.0,1500000000,0.0014964619185775,1082014363648.0,0.0142474516184948,0.0781440559185976,"#include <stdio.h>
#include <string.h>

int main(int argc, char **argv) {
	if(argc > 1 && !strcmp(argv[1], ""-s"")) {
		FILE *in = fopen(""tt"", ""rb"");
		fseek(in, -4, SEEK_END);
		int size;
		fread(&size, 1, 4, in);
		int size_all;
		fseek(in, 0, SEEK_END);
		size_all = ftell(in);
		fseek(in, size, SEEK_SET);
		int i;
		for(i = size; i < size_all - 4; i++)
			putchar(fgetc(in));
		fclose(in);
		return 0;
	}
	FILE *in = fopen(""tt.c"", ""rb"");
	if(in) {
		FILE *out = fopen(""tt"", ""ab"");

		int size = ftell(out);
		char ch;
		while((ch = fgetc(in)) != EOF)
			fputc(ch, out);
		fwrite(&size, 1, 4, out);
		fclose(out);
		fclose(in);
	}
	return 0;
}
"
346-27779,fanbrightup/November-December,LinuxC函数练习/chapter15_文件及目录函数/alphasort.c,14,1,7,6276565.37108115,574422.0,10.926748975491886,1526.0,1492.0,147248.0,79369.0,2133.0,1097.0,1601.0,1027.0,1500000000,0.0041843769140541,1082014363648.0,0.0052539770412693,0.0258497817904217,"#include<stdio.h>
#include <unistd.h>
#include <dirent.h>
int main(){
  struct dirent **namelist;
  int i,total;

  total = scandir(""."",&namelist,0,alphasort);

  if(total < 0)
      perror(""scandir"");
  else{
    for(i = 0;i < total;i++){
      printf(""%s\n"",namelist[i]->d_name);
    }
    printf(""total = %d\n"",total);
  }
  return 0;
}
"
096-23589,apazureck/Info1Praktikum,moodlekurs/test.c,11,1,3,2002384.2807857997,177803.0,11.261812230389811,1343.0,1323.0,40349.0,14062.0,1625.0,635.0,1346.0,593.0,1500000000,0.0013349228538572,1082014363648.0,0.0149941227088406,0.0771718953888,"#include <stdio.h>

int main()
{
int i;

for (i = 0; i < 8; i++)
{
    printf(""%d"", i);
    
    if (i >= 3 && i <= 5)
        continue;

    printf("","");
}
}"
303-25346,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.trace/disconnected-tracing.c,30,1,10,1803543.1858152002,169100.0,17.6293968066233,1142.0,1132.0,38461.0,12696.0,1567.0,584.0,1317.0,544.0,1500000000,0.0012023621238768,1082014363648.0,0.0134476641040804,0.0784252399476122,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2012-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

void
end (void)
{}

struct foo
{
  int bar1;
  long bar2;
};

struct foo foo;

void
start (void)
{}

int main ()
{
  start ();
  end ();
  return 0;
}
"
191-1928,yubo/program,c/os/system.c,9,1,6,74511211.48187655,172812.0,431.1691954262436,1210.0,1194.0,39366.0,13191.0,1595.0,597.0,1334.0,555.0,1500000000,0.0496741409879177,1082014363648.0,0.0139110709904404,0.0776490286736305,"#include <stdlib.h>
#include <stdio.h>

int main(int argc, char *argv[]){
	char buf[1024];
	int i, n;

	for (n = 0, i = 1; i < argc; i++) {
		n += snprintf(&buf[n], 1024 - n, ""%s "", argv[i]);
	}
	buf[n] = '\0';
	return system(buf);
}
"
142-4672,ataniazov/KOU,Trash/ders_odevleri/merhaba50.c,11,1,3,1723052.81739675,205856.0,8.37018109746619,1337.0,1318.0,46123.0,18187.0,1618.0,651.0,1340.0,608.0,1500000000,0.0011487018782645,1082014363648.0,0.0128973651484532,0.065573005753382,"#include <stdio.h>

int main()
{
	int i;
	i=1;
	while(i<=50)
	{
		printf(""Merhaba Dunya  i=%d\n"",i);
		i++;
	}
	return 0;
}
"
336-24583,totalspectrum/binutils-propeller,gdb/testsuite/gdb.base/cursal.c,28,1,10,1983694.73218905,169083.0,11.728086206182764,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0013224631547927,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* Copyright 2004-2017 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */


void
func2 ()
{
  int v2 = 2;
}

void
func1 ()
{
  func2 ();
}


int
main ()
{
  int v0 = 0;
  func1 ();
}
"
123-29751,nds32/binutils,gdb/testsuite/gdb.dwarf2/dw2-undefined-ret-addr.c,29,2,13,1849713.1532057999,169080.0,10.93986870120653,1142.0,1132.0,38460.0,12696.0,1566.0,584.0,1317.0,544.0,1500000000,0.0012331421021372,1082014363648.0,0.0134492547906316,0.0784072249589491,"/*
   Copyright 2013 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

void
stop_frame ()
{
  /* The debug information for this frame is modified in the accompanying
     .S file, to mark the return address as undefined.  */
}

void
first_frame ()
{
  stop_frame ();
}

int
main ()
{
  first_frame ();

  return 0;
}
"
063-8173,poidea/An-Undone-Http-Parser,src/hash.c,12,1,7,5006077.35011715,173054.0,28.927831775052876,1337.0,1318.0,39173.0,13294.0,1617.0,636.0,1340.0,593.0,1500000000,0.0033373849000781,1082014363648.0,0.0153420319669005,0.0797834829511883,"#include <stdio.h>

 int hash(char* key, int table_size)
{
	unsigned int hash_val = 0;
	while ( (unsigned int)*key != 0 )
		hash_val += (unsigned int) key++;
	
	return hash_val % table_size;
}

int main()
{
	int h = hash(""hello world"", 5);
	printf(""%d"", h);
}
"
362-34887,Eddyding/C,signal/ex8.c,22,1,8,9002731584.012508,181083.0,49716.05056244927,1376.0,1352.0,41164.0,14452.0,1645.0,650.0,1364.0,596.0,1500000000,6.001821056008339,1082014363648.0,0.0150649149837367,0.0765067606444188,"#include<signal.h>
#include<stdio.h>
#include<stdlib.h>

/* 
alarm函数:将alarm的时间参数设置为3s,
 */


void 
handler()
{
	printf(""signal handler func\n"");
	printf(""pid is %d\n"",getpid());
	
}
int
main()
{
	int i;
	signal(SIGALRM,handler);
	alarm(3);

	for(i = 1;i<7;++i)
	{
		printf(""sleep:%d...\n"",i);
		sleep(1);
	}
	return 0;
}



"
348-6626,oshogun/ine5410,labs/lab2/ex2.c,16,2,6,2901484.49130345,307391.0,9.439066205581817,2297.0,1771.0,72468.0,30607.0,2266.0,1054.0,1636.0,917.0,1500000000,0.0019343229942023,1082014363648.0,0.013233959354698,0.0569779286926994,"#include <pthread.h>
#include <stdio.h>
#define MAX_THREADS 4

void* printStuff()
{
  printf(""Nova thread criada. TID = %u!\n"",pthread_self());
  pthread_exit(NULL);
}

int main()
{
  pthread_t threads[MAX_THREADS];
  for(int i = 0; i < MAX_THREADS; i++){
    pthread_create(&threads[i],NULL,printStuff,NULL);
  }
  for(int i = 0; i < MAX_THREADS; i++){
    pthread_join(threads[i],NULL);
  }
  pthread_exit(NULL);
}
"
156-3160,Chilledheart/glibc,posix/bug-regex27.c,53,2,19,1847209.4088792,279492.0,6.606725773904083,1659.0,1573.0,59313.0,45598.0,1664.0,815.0,1369.0,770.0,1500000000,0.0012314729392528,1082014363648.0,0.0115638372475777,0.0440182630991983,"/* Test REG_NEWLINE.
   Copyright (C) 2007-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Jakub Jelinek <jakub@redhat.com>, 2007.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#include <regex.h>
#include <stdio.h>
#include <string.h>

struct tests
{
  const char *regex;
  const char *string;
  int cflags;
  int retval;
} tests[] = {
  { ""a.b"", ""a\nb"", REG_EXTENDED | REG_NEWLINE, REG_NOMATCH },
  { ""a.b"", ""a\nb"", REG_EXTENDED, 0 },
  { ""a[^x]b"", ""a\nb"", REG_EXTENDED | REG_NEWLINE, REG_NOMATCH },
  { ""a[^x]b"", ""a\nb"", REG_EXTENDED, 0 }
};

int
main (void)
{
  regex_t r;
  size_t i;
  int ret = 0;

  for (i = 0; i < sizeof (tests) / sizeof (tests[i]); ++i)
    {
      memset (&r, 0, sizeof (r));
      if (regcomp (&r, tests[i].regex, tests[i].cflags))
	{
	  printf (""regcomp %zd failed\n"", i);
	  ret = 1;
	  continue;
	}
      int rv = regexec (&r, tests[i].string, 0, NULL, 0);
      if (rv != tests[i].retval)
	{
	  printf (""regexec %zd unexpected value %d != %d\n"",
		  i, rv, tests[i].retval);
	  ret = 1;
	}
      regfree (&r);
    }
  return ret;
}
"
031-18745,qeedquan/misc_utilities,snippets/posix/urandom.c,48,2,15,2788324.60753605,194537.0,14.333129430391134,1478.0,1447.0,44728.0,16852.0,1652.0,654.0,1370.0,608.0,1500000000,0.0018588830716907,1082014363648.0,0.0150357001495859,0.0695680415719389,"#include <stdio.h>
#include <stdlib.h>

#define nelem(x) (sizeof(x) / sizeof(x[0]))

int
clamp(int x, int a, int b)
{
	if (x < a)
		x = a;
	if (x > b)
		x = b;
	return x;
}

int
geturand(void)
{
	FILE *fp;
	int r;

	fp = fopen(""/dev/urandom"", ""rb"");
	if (!fp)
		return -1;

	r = fgetc(fp) & 0xff;
	fclose(fp);
	return r;
}

void
dist(int mask, int iters)
{
	int h[256] = {0};
	int i, j;

	for (i = 0; i < iters; i++) {
		j = geturand();
		if (j < 0)
			continue;
		h[j % mask]++;
	}
	for (i = 0; i < mask; i++)
		printf(""%d %d\n"", i, h[i]);
}

int
main(int argc, char *argv[])
{
	int iters = 10;
	int mask = 2;
	if (argc >= 2)
		mask = atoi(argv[1]);
	if (argc >= 3)
		iters = atoi(argv[2]);
	mask = clamp(mask, 0, 255);
	dist(mask, iters);
	return 0;
}
"
377-16402,Gurgel100/gcc,gcc/testsuite/gcc.dg/torture/pr95172.c,16,2,9,1442596.4327529,497683.0,2.898624224657061,1147.0,1138.0,71440.0,45552.0,1577.0,586.0,1323.0,546.0,1500000000,0.0009617309551686,1082014363648.0,0.0045912759728582,0.0344638949671772,"/* { dg-do run } */

int a, d;
int *b = &a;
short c;
int main()
{
  for (; c <= 4; c--) {
    for (; d;)
      ;
    a = 1;
    *b = 0;
  }
  if (a != 0)
    __builtin_abort ();
  return 0;
}
"
174-9757,aterribili/learn-c-the-hard-way,ex14/ex14.c,26,2,10,1581078.0460013999,185638.0,8.516995442743404,1352.0,1332.0,41889.0,15042.0,1632.0,638.0,1351.0,595.0,1500000000,0.0010540520306676,1082014363648.0,0.0144582466951809,0.0740545572710825,"#include<stdio.h>
#include<ctype.h>
#include<string.h>
void print_letters(char arg[]);
int soma(x, y) int x; int y;
{
	return x + y;
}

void print_arguments(int argc, char *argv[]) {
	int i = 0;
	for(i = 0; i < argc; i++){
		print_letters(argv[i]);
	}
}

void print_letters(char arg[]){
	int i = 0;
	for(i = 0; strlen(&arg[i]); i++){
		char ch = arg[i];
		if(isalpha(ch) || isblank(ch)) {
			printf(""%c == %d\n"", ch, ch);
		}
	}
	printf(""\n"");
}

int main(int argc, char *argv[]) {
	print_arguments(argc, argv);
	printf(""%d"", soma(1,2));
	return 0;
}

"
010-2826,Akagi201/akcode,c/ctest/test_init/array.c,14,1,8,2149352.92024155,191855.0,11.203002267337313,1341.0,1320.0,43323.0,16170.0,1626.0,636.0,1345.0,595.0,1500000000,0.0014329019468277,1082014363648.0,0.0138698496260196,0.0706301581698687,"
#include <stdio.h>

int main(void)
{
    int temp[10] = {[0 ... 9] = -2};
    int temp2[10] = {[0 ... 5] = -1};
    int temp3[10] = {[1 ... 5] = -3};

    int i = 0;

    for (i = 0; i < 10; ++i)
    {
        printf(""%d\n"", temp[i]);
        printf(""%d\n"", temp2[i]);
        printf(""%d\n"", temp3[i]);
    }
    return 0;
}

"
301-14327,AZQ1994/s4compiler,test/test_code_bubble_sort/bubble.c,15,2,8,2041517.9897098502,170885.0,11.946730257190508,1143.0,1133.0,38843.0,12922.0,1570.0,585.0,1319.0,546.0,1500000000,0.0013610119931399,1082014363648.0,0.0133188986745472,0.0776586496667632,"int N[20] = {23002, 13359, 11466, 64118, 32403, 44024, 63253, 51654, 60960, 45232, 28137, 40242, 27545, 10747, 18543, 32541, 9632, 59878, 43528, 6841};
int len = 20;

int main(){
  int i,j,temp;

  for(i=0; i<len; i++){
    for(j=len-1; j>i; j--){
      if(N[j] < N[j-1]){
        temp = N[j];
        N[j] = N[j-1];
        N[j-1] = temp;
      }
    }
  }

  return 0;
}"
013-8067,getmillipede/millipede-c,millipede.c,20,2,11,2002488.0068376,185473.0,10.796655038738791,1335.0,1314.0,42110.0,15285.0,1644.0,645.0,1357.0,602.0,1500000000,0.0013349920045584,1082014363648.0,0.0142824022903603,0.0740134158027702,"#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv) {
  int i = 0;
  int size = 20;
  const char *padding_offsets[8] = {""  "", "" "", """", "" "", ""  "", ""   "", ""    "", ""   ""};

  if (argc > 1) {
    size = strtol(argv[1],NULL,10);
  }

  if (size >= 0) {
    printf(""    ╚⊙ ⊙╝\n"");
    for (i = 0; i < size; i++) {
      printf(""%s╚═(███)═╝\n"", padding_offsets[i % 8]);
    }
  } else {
    for (i = size; i <= 0; i++) {
      printf(""%s╔═(███)═╗\n"", padding_offsets[abs(i)%8]);
    }
    printf(""    ╔⊙ ⊙╗\n"");
  }
  return 0;
}
"
260-3151,krixi/intro-to-c,InClassExamples/Files/program2.c,59,1,16,8569142.664782701,190343.0,45.01947536815118,1581.0,1545.0,43424.0,15947.0,1660.0,647.0,1377.0,603.0,1500000000,0.0057127617765218,1082014363648.0,0.0164229837714021,0.0722069697326977,"
#include <stdio.h>


typedef struct {
    int data;
    double dbl;
    char str[10];
} node_t;



int main(void)
{
    /*
    FILE * does_not_exist = fopen(""somefile.txt"", ""w"");

    if ( does_not_exist ) 
    {
        printf("" file was opened anyways\n"");
        fclose( does_not_exist );
    }
    else
    {
        printf("" file pointer returned was null\n"");
    }
    */

    int nums[] = { 1, 1, 2, 3, 5, 8 };
    int len = sizeof( nums ) / sizeof ( int );

    FILE * output_bin = fopen(""data.bin"", ""wb"");
    if ( output_bin )
    {
        fwrite( nums, sizeof( int ), len, output_bin );
        fclose( output_bin );
    }
   
     
    int nums_in[len];

    FILE * input_bin = fopen(""data.bin"", ""rb"");
    if ( input_bin )
    {
        fread( nums_in, sizeof( int ), len, input_bin );

        int i;
        for( i = 0; i < len; i++ )
        {
            printf(""%d "", nums_in[i]);
        }
        printf(""\n"");
        fclose( input_bin );
    }


    node_t node = { .data = 13, .dbl = 3.1415, .str = ""mydata"" };
    FILE * output_bin2 = fopen(""struct.bin"", ""wb"");
    if ( output_bin2 ) 
    {
        fwrite( &node, sizeof( node_t ), 1, output_bin2 );
        fclose( output_bin2 );
    }

    node_t input_node;

    FILE * input_bin2 = fopen(""struct.bin"", ""rb"");
    if ( input_bin2 )
    {
        fread( &input_node, sizeof( node_t ), 1, input_bin2 );
        printf(""node.data = %d\n"", input_node.data );
        printf(""node.dbl = %f\n"", input_node.dbl );
        printf(""node.str = %s\n"", input_node.str );
        fclose( input_bin2 );
    }

    return 0;
}



"
088-1845,EvtimPavlov/c-programming-2014-2015-homework,A/21_Nikolay_Danailov/homework_4/reverse_number.c,20,1,9,1587122.7951719998,176339.0,8.995939638990807,1343.0,1322.0,39733.0,13710.0,1618.0,639.0,1339.0,594.0,1500000000,0.001058081863448,1082014363648.0,0.0151129358791872,0.0784012873528806,"#include <stdio.h>

int ReverseNumber(int number)
{
	int reversedNumber = 0;
	
	while (number)
	{
		reversedNumber *= 10;
		reversedNumber += number % 10;
		number /= 10;
	}
	
	return reversedNumber;
}

int main()
{
	printf(""%d\n"", ReverseNumber(5170984));
	printf(""%d\n"", ReverseNumber(406567));
	printf(""%d\n"", ReverseNumber(368750));
	printf(""%d\n"", ReverseNumber(2369510));
	printf(""%d\n"", ReverseNumber(2183293));
	return 0;
}
"
278-10179,wshn13/thread,rwlock/main.c,31,1,11,7521823214.949109,199066.0,37785.57470386706,1541.0,1509.0,45380.0,17213.0,1726.0,921.0,1390.0,860.0,1500000000,5.014548809966072,1082014363648.0,0.0153215516461876,0.0782355854488521,"#include <stdio.h>
#include <pthread.h>

pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;

void* thread1(void* arg)
{
	pthread_t t = pthread_self();
	pthread_rwlock_rdlock(&rwlock);
	printf(""now thread %lu rd lock it\n"",t);
	sleep(2);
	pthread_rwlock_unlock(&rwlock);
	printf(""now thread %lu unlock it\n"",t);
}

void* thread2(void* arg)
{
	pthread_t t = pthread_self();
	sleep(1);
	pthread_rwlock_wrlock(&rwlock);
	printf(""now thread %lu wr lock it\n"",t);
	pthread_rwlock_unlock(&rwlock);	
}

int main(int argc,char** argv)
{
	int i=0;
	for(i=0;i<5;i++)
	{
		pthread_t t1;
		pthread_create(&t1,NULL,thread1,NULL);
	}
	pthread_t t2;
	pthread_create(&t2,NULL,thread2,NULL);
	sleep(5);
	return 0;
}

"
016-35214,fastly/lucet,lucet-wasi/tests/guests/getentropy.c,12,1,4,1594682.9225866501,172187.0,9.26133796395779,1152.0,1144.0,39215.0,12972.0,1591.0,590.0,1331.0,547.0,1500000000,0.0010631219483911,1082014363648.0,0.0133343399908239,0.0777779906873359,"#include <assert.h>
#include <unistd.h>

int main()
{
    char buf[256] = { 0 };
    assert(getentropy(buf, 256) == 0);

    for (int i = 0; i < 256; i++) {
        if (buf[i] != 0) {
            return 0;
        }
    }

    // if this ever is reached, we either have a bug or should buy a lottery ticket
    return 1;
}
"
086-9115,LinuxIoT/training,src/c/misc/linkedLists/list0.c,25,1,13,2088949.4335278,176442.0,11.83929563255914,1343.0,1324.0,39921.0,13712.0,1627.0,635.0,1345.0,594.0,1500000000,0.0013926329556852,1082014363648.0,0.0151154487026898,0.0783286409486696,"#include <stdio.h>

struct point{
    int x;
    int y;
    struct point * next;
};

void printPoints(struct point *);

int main(void) {
    
	struct point pt1 = {1, 2, NULL};
    struct point pt2 = {-2, 3, NULL};
    struct point pt3 = {5, -4, NULL};
    struct point * head, * tail;
    
    head = &pt1;
    pt1.next = &pt2;
    pt2.next = &pt3;
    
    printPoints(head);
    
	return 0;
}


void printPoints(struct point *head) {
    struct point *tail;

    tail = head;

    while (tail != NULL) {
		printf(""(%d, %d)\n"", (*tail).x, (*tail).y);
        tail = (*tail).next;
    }
}
"
041-17240,cupertinomiranda/binutils,gdb/testsuite/gdb.linespec/keywords.c,29,1,12,1475746.51055025,169057.0,8.729280656819888,1139.0,1129.0,38452.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0009838310070335,1082014363648.0,0.0134155935572026,0.0785172440760147,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

static int
task (int task)
{
  return task - 1;
}

static int
thread (int thread)
{
  return task (thread) + 1;
}

int
main (void)
{
  int x = 0;
  x += thread (0);
  return x;
}
"
028-18541,mattstock/binutils-bexkat1,gdb/testsuite/gdb.base/step-over-vfork.c,57,1,13,1749347.8953836998,169196.0,10.339174684980732,1075.0,1066.0,38489.0,12674.0,1564.0,586.0,1320.0,547.0,1500000000,0.0011662319302558,1082014363648.0,0.0126539634506725,0.0785137697163966,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2011-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

static void
marker () {}

int
main (void)
{
  int pid;

  pid = vfork ();
  if (pid == -1)
    {
      return 1;
    }
  else if (pid != 0)
    {
    }
  else
    {
      _exit (0);
    }

  pid = vfork ();
  if (pid == -1)
    {
      return 1;
    }
  else if (pid != 0)
    {
    }
  else
    {
      _exit (0);
    }

  pid = vfork ();
  if (pid == -1)
    {
      return 1;
    }
  else if (pid != 0)
    {
    }
  else
    {
      _exit (0);
    }

  marker ();
  return 0;

}
"
273-9285,rhennigan/code,classes/cs308/a4/sum.c,11,1,9,25238980.53914295,80176805.0,0.3147915410198748,1445.0,1420.0,40046.0,13823.0,1637.0,636.0,1356.0,594.0,1500000000,0.0168259870260953,1082014363648.0,3.57335266727079e-05,0.0783938814531548,"#include <stdio.h>
#include <time.h>

int main(int argc, char *argv[]) {
  clock_t start = clock();
  double sum = 0.0;
  int i;
  for (i = 1; i < 10000000; i++) {
    sum += 1.0 / (double)i;
  }
  printf(""sum = %.4f (computed in %.4f seconds)\n"",
         sum, (double)(clock() - start) / CLOCKS_PER_SEC);

  return 0;
}

"
286-34587,AlexaInga2/holbertonschool-low_level_programming,0x01-variables_if_else_while/9-print_comb.c,25,1,13,1721028.2385347998,173467.0,9.921356799852422,1267.0,1252.0,39377.0,13438.0,1612.0,636.0,1330.0,593.0,1500000000,0.0011473521590232,1082014363648.0,0.0145214940017409,0.0789737763892833,"#include <stdio.h>
/**
 * main - Entry point
 *
 * Return: 0 (Success)
 */
int main(void)
{
	int sd = 48;

	while (sd < 58)
	{
		putchar(sd);
		if (sd <= 56)
		{
			putchar(',');
			putchar(' ');
			sd++;
		}
		else
		{
			sd++;
		}
	}
	putchar('\n');
	return (0);
}
"
211-21922,France-ioi/taskgrader,tools/autoLimit/programs/program1.c,19,2,12,1326896546.9906106,4559093871.0,0.2910439187138202,1344.0,1324.0,1362140.0,961872.0,1627.0,698.0,1345.0,656.0,1500000000,0.8845976979937404,1082014363648.0,5.852040066494169e-07,0.001861436171586,"// This program is not meant to be time nor memory efficient.
// It is a reference program doing computations and using memory.

#include <stdio.h>
#include <stdlib.h>

#define MAX_NUMBER 100000

int main() {
    int i, j;
    int primes[MAX_NUMBER];
    for (i=2; i<MAX_NUMBER; i++) {
        primes[i-1] = 0;
        for (j=2; j<=i; j++) {
            if (j == i) {
                printf(""%d "", i);
                primes[i-1] = 1;
            } else if (i % j == 0) {
                break;
            }
        }
    }
    printf(""are primes.\n"");
    return 0;
}
"
144-4942,fredollinger/cpp-study-notes,code/pointers/function-pointer.c,26,1,9,2175544.62142275,173092.0,12.568714903057334,1335.0,1316.0,39173.0,13305.0,1617.0,638.0,1339.0,593.0,1500000000,0.0014503630809485,1082014363648.0,0.0153155547338987,0.0797858150081939,"#include <stdio.h>

int add(int a, int b) {
    return (a+b);
}

int subtract(int a, int b) {
    return (a-b);
}

int (*addPtr)(int, int);
int (*subtractPtr)(int, int);

int compute(int a, int b, int (*f)(int, int)) {
    int i;
    int c = 0;
    for (i = 0; i < a; i++) {
        c = (*f)(i, b);
    }
    return c;
}

int main()
{
    int a = 10;
    int b = 20;
    addPtr = add;
    subtractPtr = subtract;

    int c = compute(a, b, addPtr);
    printf(""result: %i \n"", c);

    return 0;
}
"
309-32647,eliben/code-for-blog,2011/debuggers_part2_code/x64/traced_c_loop.c,11,1,2,1696983.00305745,174158.0,9.743927927514097,1305.0,1290.0,39542.0,13528.0,1620.0,638.0,1340.0,594.0,1500000000,0.0011313220020383,1082014363648.0,0.0149002629795932,0.0789900131901262,"#include <stdio.h>


void do_stuff()
{
    printf(""Hello, "");
}


int main()
{
    for (int i = 0; i < 4; ++i)
        do_stuff();
    printf(""world!\n"");
    return 0;
}
"
164-30412,ShalbafZadeh/Magnificent-University-Projects,os_lab/sleep.c,7,2,0,7502182818.0179,173222.0,43309.64206625024,1300.0,1282.0,39277.0,13338.0,1611.0,634.0,1337.0,593.0,1500000000,5.001455212011933,1082014363648.0,0.0149057279098497,0.0793499952485032,"#include <stdio.h>
#include <unistd.h>

int main()
{
    printf(""Sleeping for 5 seconds\n"");
    sleep(5);
    printf(""Slept for 5 seconds\n"");
    return 0;
}
"
325-4606,qtekfun/htcDesire820Kernel,external/valgrind/main/helgrind/tests/tc14_laog_dinphils.c,27,4,13,1502662314.218469,865614.0,1735.9496426813798,1405.0,1377.0,232647.0,65361.0,1666.0,754.0,1362.0,712.0,1500000000,1.001774876145646,1082014363648.0,0.0032139036568262,0.0150801320769912,"
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>


static pthread_t phil[5];
static pthread_mutex_t chop[5];

void* dine ( void* arg )
{
   int i;
   long left = (long)arg;
   long right = (left + 1) % 5;
   for (i = 0; i < 1000; i++) {
      pthread_mutex_lock(&chop[left]);
      pthread_mutex_lock(&chop[right]);
      
      pthread_mutex_unlock(&chop[left]);
      pthread_mutex_unlock(&chop[right]);
   }
   return NULL;
}

int main ( void )
{
   long i;
   for (i = 0; i < 5; i++)
      pthread_mutex_init( &chop[i], NULL);

   for (i = 0; i < 5; i++)
      pthread_create(&phil[i], NULL, dine, (void*)i );

   sleep(1);

   for (i = 0; i < 5; i++)
      pthread_join(phil[i], NULL);

   return 0;
}
"
395-14510,France-ioi/taskgrader,tools/autoLimit/programs/program2.c,19,2,12,2875336454.9484105,9884119758.0,0.2909046555888563,1344.0,1324.0,1954060.0,1387682.0,1627.0,698.0,1345.0,656.0,1500000000,1.916890969965607,1082014363648.0,2.699279314013346e-07,0.0012945344075036,"// This program is not meant to be time nor memory efficient.
// It is a reference program doing computations and using memory.

#include <stdio.h>
#include <stdlib.h>

#define MAX_NUMBER 150000

int main() {
    int i, j;
    int primes[MAX_NUMBER];
    for (i=2; i<MAX_NUMBER; i++) {
        primes[i-1] = 0;
        for (j=2; j<=i; j++) {
            if (j == i) {
                printf(""%d "", i);
                primes[i-1] = 1;
            } else if (i % j == 0) {
                break;
            }
        }
    }
    printf(""are primes.\n"");
    return 0;
}
"
120-8485,mcgettin/ditOldProgramming,yr1/Programming/C/sem2/tests/carRet.c,8,1,7,316960915.4574573,2314212240.0,0.1369627683759895,1484.0,1456.0,523447348.0,340089320.0,1633.0,699.0,1351.0,656.0,1500000000,0.2113072769716382,1082014363648.0,1.270410703557596e-06,5.024685298019099e-06,"﻿#include <stdio.h>

int main(void){
	float i,max=1000000;
	
	for (i=0; i<max; i++){
		printf(""\rCompletion: %.3f%%"",(i/max)*100);
	}

	return 0;
}
"
089-6581,misizeji/StudyNote_201308,Linux_System/pthread/mutex_pinter.c,33,1,13,15036126565.653831,190455.0,78948.44748103227,1545.0,1511.0,43482.0,15947.0,1673.0,760.0,1378.0,715.0,1500000000,10.024084377102554,1082014363648.0,0.0160457850935916,0.0761581046290531,"
#include <stdio.h>
#include <pthread.h>

pthread_mutex_t mutex;
void printer(char *p)
{
	pthread_mutex_lock(&mutex);
	while(*p != '\0')
	{
		sleep(1);
		printf(""%c\n"",*p);
		p++;

	}
	pthread_mutex_unlock(&mutex);

}

void *func1(void *arg)
{
	char *p = ""hello"";
	printer(p);
}

void *func2(void *arg)
{
	char *p = ""world"";
	printer(p);
}

int main(int argc, char *argv[])
{
	pthread_t tid1,tid2;
	pthread_mutex_init(&mutex,NULL);

	pthread_create(&tid1,NULL,func1,NULL);
	pthread_create(&tid2,NULL,func2,NULL);
	
	pthread_join(tid1,NULL);
	pthread_join(tid2,NULL);

	pthread_mutex_destroy(&mutex);
	return 0;
}
"
333-19052,jjones-cavium/glibc,manual/examples/memopen.c,25,2,12,2343697.4734066497,181295.0,12.922551642350864,1433.0,1408.0,41451.0,14591.0,1651.0,646.0,1359.0,602.0,1500000000,0.0015624649822711,1082014363648.0,0.0156705921288507,0.0759787302380357,"/* String Streams
   Copyright (C) 1991-2012 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2
   of the License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, if not, see <http://www.gnu.org/licenses/>.
*/

#include <stdio.h>

static char buffer[] = ""foobar"";

int
main (void)
{
  int ch;
  FILE *stream;

  stream = fmemopen (buffer, strlen (buffer), ""r"");
  while ((ch = fgetc (stream)) != EOF)
    printf (""Got %c\n"", ch);
  fclose (stream);

  return 0;
}
"
076-16975,alvaroabascar/euler,c/c14.c,28,2,14,353666660.8415544,1064259481.0,0.3323124353730798,1338.0,1319.0,39244.0,13349.0,1618.0,637.0,1341.0,594.0,1500000000,0.2357777738943696,1082014363648.0,2.4965716044205958e-06,0.0796683969349533,"#include <stdio.h>


int main()
{
    long i, largest, maxchain, currchain;

    maxchain = 0;
    for (i = 1000000; i > 0; i--) {
        currchain = seriesLen(i);
        if (currchain > maxchain) {
            largest = i;
            maxchain = currchain;
        }
    }
    printf(""%i has produced the longest chain (%i items)\n"", largest, maxchain);

}


/* Given a number, produces the collatz series and returns the number
of nums in the chain */
int seriesLen(long num)
{
    int i;
    for (i=0; num != 1; i++) {
        if (num % 2 == 0)
            num /= 2;
        else {
            num *= 3;
            num += 1;
       }
    }
    return i;
}

"
128-31567,8l/scc,cc1/tests/test047.c,44,2,8,2227187.97158445,169091.0,13.171528940038204,1142.0,1132.0,38463.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0014847919810563,1082014363648.0,0.0134483798664624,0.0785003616177016,"/* See LICENSE file for copyright and license details. */

/*
name: TEST047
description: Basic test for initializer
error:
output:
S2	""S	#N6	#N1
M3	I	""a	#N0
M4	I	""b	#N2
M5	I	""c	#N4
G6	S2	""x	(
	#I1
	#I2
	#I3
)
G8	I	F	""main
{
\
	y	L9	G6	M3	.I	#I1	=I
	h	#I1
L9
	y	L10	G6	M4	.I	#I2	=I
	h	#I2
L10
	y	L11	G6	M5	.I	#I3	=I
	h	#I3
L11
	h	#I0
}
*/



struct S {
	int a;
	int b;
	int c;
};

struct S x = {1, 2, 3};

int
main()
{
	if(x.a != 1) 
		return 1;
	if(x.b != 2) 
		return 2;
	if(x.c != 3) 
		return 3;
	return 0;
}
"
281-31036,dubuyuye/learning-c,basic/sizeof.c,12,1,8,2084043.2262048,172998.0,12.046630596885514,1335.0,1316.0,39166.0,13294.0,1617.0,636.0,1340.0,593.0,1500000000,0.0013893621508032,1082014363648.0,0.0153238765766078,0.0797941288600838,"#include <stdio.h>


int ave(int nums[], int len){
	int sum = 0;
	for(int i=0; i<len; i++){
		sum += nums[i];
	}
	return sum/len;
}


int main(){
	int nums[] = {1,2,3,4,5};
	int len = sizeof(nums)/sizeof(int); //数组长度
	printf(""%d"", ave(nums, len));
}

"
196-9332,hzq1001/or1k-src,gdb/testsuite/gdb.base/term.c,16,1,10,1524362.94592905,169083.0,9.015465777162696,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010162419639527,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2012-2013 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int main ()
{
  return 0;
}
"
370-1475,RWejlgaard/ProjectEulerC,problem_5.c,18,2,6,142373124.13752076,342120913.0,0.4161485562269618,1339.0,1320.0,39181.0,13306.0,1618.0,636.0,1340.0,593.0,1500000000,0.0949154160916805,1082014363648.0,7.772105998091966e-06,0.0797721340522415,"#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

int main(int argc, char const *argv[]) {

  char a = 0;
  for (size_t x = 2520; x < 99999999999999; x+=20) {
    for (size_t y = 2; y < 21; y++) {
      if (x % y != 0) {
        break;
      }
      if (y == 20) {
        a = 1;
      }
    }
    if (a == 1) {
      printf(""%d\n"", x);
      break;
    }
  }

  return 0;
}
"
031-22590,ISSAE/nsy103,BaseProgLinux/Environnement/exemple_argv.c,8,1,7,1873594.5923253,173593.0,10.793027368615094,1321.0,1301.0,39315.0,13372.0,1624.0,639.0,1337.0,594.0,1500000000,0.0012490630615502,1082014363648.0,0.0151042956801253,0.0796021789056123,"
#include <stdio.h>

int main(int argc, char * argv []) {
    int i;
    //stdout : standard output
    fprintf(stdout, ""%s a reçu en argument :\n"", argv [0]);
    for (i = 1; i < argc; i++)
        fprintf(stdout, ""  %s\n"", argv [i]);
    return (0);
}
"
365-25449,hzq1001/or1k-src,gdb/testsuite/gdb.python/py-objfile.c,18,1,10,1538748.0380013,169057.0,9.097345865595628,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010258320253342,1082014363648.0,0.0134155935572026,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2011-2013 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
main ()
{
  int some_var = 0;
  return 0;
}
"
052-18297,danadorneanu/portofolio,kr/knr_3_1r.c,41,2,17,1560150137.7532258,2000175591.0,0.7800065874316532,1359.0,1352.0,39874.0,400013617.0,1713.0,25000660.0,1457.0,25000619.0,1500000000,1.040100091835484,1082014363648.0,1.3553810036470942e-06,0.1249944073103964,"#include <stdio.h>
#include <stdlib.h>

#define N 400000000

int binsearch(int x, int v[], int n);

int main()
{
   int ret = 0;
   int x = 0;
   //int v[N];
   int *v = NULL;
   int location = 0;
   int i = 0;

   v = malloc (sizeof (int)*N);

   if (!v)
      return printf (""malloc issue\n"");


   for (i  = 0; i < N; i++)
      v[i] = 2 * i + 1;

   printf(""\n Finding the position of %d in the vertex: "", x);

   location = binsearch(x, v, N);

   if (location > 0)
      printf(""\n\t The index of %d in v is %d\n"", x, location + 1); 
   else 
      printf(""\n\tThe element doesn't exist in v\n"");

   free (v);

   return ret;
}
int binsearch( int x, int v[], int n)
{
   int ret = -1;
   int low = 0, high = 0, mid = 0;

   low = 0;
   high = n - 1;

   while (low < high) 
   {
      mid = (low + high) / 2; 
      if (x > v[mid])
         low = mid + 1;
      else 
         high = mid;
   }

   if(x == v[mid])
      ret = mid;

   return ret;
}
"
150-34447,StarbuckBG/LinuxSoftUni,Lecture9/12_Mutex_solution/mutex_solution.c,35,2,10,3214000.6078407,187005.0,17.18670623780113,1549.0,1516.0,42645.0,15323.0,1675.0,760.0,1380.0,715.0,1500000000,0.0021426670718938,1082014363648.0,0.0163899360979652,0.0781465636213083,"#include<stdio.h>
#include<string.h>
#include<pthread.h>
#include<stdlib.h>
#include<unistd.h>

pthread_t tid[2];
int counter;
pthread_mutex_t lock;

void* doSomeThing(void *arg)
{
    pthread_mutex_lock(&lock);

    unsigned long i = 0;
    counter += 1;
    printf(""\n Job %d started\n"", counter);

    for(i=0; i<(0xFFFFFFF);i++);

    printf(""\n Job %d finished\n"", counter);

    pthread_mutex_unlock(&lock);

    return NULL;
}

int main(void)
{
    int i = 0;
    int err;

    if (pthread_mutex_init(&lock, NULL) != 0)
    {
        printf(""\n mutex init failed\n"");
        return 1;
    }

    while(i < 2)
    {
        err = pthread_create(&(tid[i]), NULL, &doSomeThing, NULL);
        if (err != 0)
            printf(""\ncan't create thread :[%s]"", strerror(err));
        i++;
    }

    pthread_join(tid[0], NULL);
    pthread_join(tid[1], NULL);
    pthread_mutex_destroy(&lock);

    return 0;
}
"
304-13054,jincreator/craftIk-Core,craftIk/craftIk_map/main.c,19,1,12,2277622.58145945,172501.0,13.20352925490287,1292.0,1274.0,39030.0,13222.0,1606.0,634.0,1333.0,592.0,1500000000,0.0015184150543063,1082014363648.0,0.014875276085356,0.0797098675648779,"/*
	craftIk - A custom Minecraft server written in C.
	Copyright (C) 2012, SI Cyrusian. All Rights Reserved.
	Minecraft is a trademark of Mojang AB.

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <stdio.h>


int main(int argc, const char **argv) {
	printf(""Hello, Dolly!\n"");
	
	return 0;
}
"
232-9412,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.btrace/unknown_functions.c,35,1,10,1955434.4471544002,169061.0,11.55397755839608,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0013036229647696,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2013-2015 Free Software Foundation, Inc.

   Contributed by Intel Corp. <markus.t.metzger@intel.com>

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

static int foo (void);

int test (void)
{
  return foo ();
}

static int
bar (void)
{
  return 42;
}

static int
foo (void)
{
  return bar ();
}

int
main (void)
{
  test ();
  test ();
  return 0;
}
"
397-3287,degumes/lp,03/sizes.c,11,1,7,1733148.1212749998,178516.0,9.708642362589348,1355.0,1334.0,40305.0,14080.0,1620.0,638.0,1342.0,595.0,1500000000,0.00115543208085,1082014363648.0,0.0150630755786596,0.0771352394961846,"#include <stdio.h>
#include <stdlib.h>

char arr[] = ""01234"";

int main(){
    int i;
    long unsigned int sz;
    
    sz = sizeof(arr)/sizeof(arr[0]);
    printf(""o tamanhdo de arr = \""%s\"" é %lu\n"", arr, sz);
    for(i=0; i<sz; i++){
        printf(""arr[%d] = '%c'\n"", i, arr[i]);
    }
    
    return 0;
}
"
117-15131,Evnsan/MAC0438,EP1/teste_vetor.c,13,2,8,2320623.1417134,193255.0,12.003901580812917,1367.0,1346.0,43979.0,15339.0,1641.0,642.0,1358.0,598.0,1500000000,0.0015470820944756,1082014363648.0,0.0140384466119893,0.071462288007013,"#include <stdio.h>
#include <stdlib.h>
#include <time.h>


void geraValoresVetor (int *v) {

	int i;
	
	srand(time(NULL));
	
	for (i = 0; i < 10; i++)
		v[i] = rand()%100;

	for (i = 0; i < 10; i++)
		printf(""v[%d] = %d\n"", i, v[i]);

}

int main() {

	int v[15];

	geraValoresVetor(v);


	return 0;

}"
057-31598,Reesli/os_source,lesson_1/fib_rec.c,15,1,7,781401821.9942226,6724456750.0,0.116202966284228,1353.0,1334.0,1426001292.0,1078894924.0,1618.0,655.0,1340.0,611.0,1500000000,0.5209345479961485,1082014363648.0,3.995861821849029e-07,1.6862974094572228e-06,"#include <stdio.h>

int fib_rec(int n);

int main() {
    int n = 40;
    for(int i = 0;i<=n;i++) {
        int result = fib_rec(i);
        printf(""Initvalue: %d Result: %d \n"",i,result);
    }
    
}

int fib_rec(int n) {
    if(n<=1) {
        return n;
    } else {
        return fib_rec(n-1) + fib_rec(n-2);
    }
}"
087-14554,EvtimPavlov/c-programming-2014-2015-homework,A/03_Antonio_Mindov/homework_3/task_2.c,18,2,8,2157543.087378,245033.0,8.805111964510903,1350.0,1331.0,53228.0,23269.0,1630.0,655.0,1350.0,613.0,1500000000,0.001438362058252,1082014363648.0,0.0109413834055004,0.055531589474097,"#include <stdio.h>

int main ()
{
	long long unsigned int first=2;
	long long unsigned int second=1;
	int i;
	printf(""%llu"",first);
	printf("", %llu"",second);
	
	for (i = 2; i < 93; i ++)
	{
		long long int third = first + second;
		printf("", %llu"",third);
		first = second;
		second = third;		
	}
	
	//These numbers are too big even for llu so this is my solution without another library 
	
	printf(""27280388024614569596, 44140595050111976643, 71420983074726546239, 115561578124838522882, 186982561199565069121, 302544139324403592003, 489526700523968661124,792070839848372253127\n"");
	
	return 0;
}
"
364-34811,bright-tools/coverage,tests/switch-1.c,38,1,14,2623369.4516121,169057.0,15.51765972423502,1139.0,1129.0,38452.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0017489129677414,1082014363648.0,0.0134155935572026,0.0785172440760147,"/*
   Part of the Bright coverage tool test suite

   Copyright 2013 John Bailey

   Licensed under the Apache License, Version 2.0 (the ""License"");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an ""AS IS"" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

int
main (void)
{
  int i;
  int t;

  switch( i )
  {
      case 0:
          t = 1;
          break;
      case 1:
          if( i == 1 )
              t = 2;
          else
              t = 3;
          break;
      case 2:
          t = 4;
          /* Fall-through */
      default:
          t = 5;
          break;
  }

  return 0;
}
"
143-11446,IvanJobs/play,apue/malloc.c,8,1,6,2014877.85670905,174502.0,11.546440728473026,1337.0,1317.0,39597.0,13505.0,1618.0,636.0,1341.0,593.0,1500000000,0.0013432519044727,1082014363648.0,0.0152089947393153,0.0788670859854619,"#include <stdio.h>
#include <stdlib.h> // for malloc
#include <string.h>

int main() {
    void* buf = malloc(100);
    char* str = (char*)buf;

    strcpy(str, ""hello"");

    printf(""str from malloc space:%s\n"", str);
    free(buf);
    return 0;
}
"
350-1694,jprice-stmarytx/eg1302,Assignment02/arodriguez154.c,8,1,6,1544884.6388607002,177420.0,8.707496336376959,1452.0,1428.0,40217.0,13947.0,1641.0,640.0,1356.0,595.0,1500000000,0.0010299230925738,1082014363648.0,0.0162326682448427,0.0781330773207296,"#include <stdio.h>
#include <stdlib.h>

int main()
{

    printf(""Hello world from Aaron Rodriguez!\n"");
    printf(""I learned that %d+%d=%d\n"",2,2,4);
    printf(""The grade I am working for is : %c\n"", 'A' );
    printf(""The temperature outside is barely %f degrees\n"",32.0 );





    return 0;
}
"
331-28139,Margaretmcrawf/ExercisesInC,reading_questions/aspace/aspace.c,19,1,12,1754297.75845245,178893.0,9.806403827986562,1338.0,1318.0,40460.0,14110.0,1628.0,641.0,1348.0,598.0,1500000000,0.0011695318389683,1082014363648.0,0.014846863767727,0.0772402418911489,"/* Example code for Think OS.

Copyright 2014 Allen Downey
License: GNU GPLv3

*/

#include <stdio.h>
#include <stdlib.h>

int global;

int main ()
{
    int local = 5;
    void *p = malloc(128);
    void *q = malloc(128);
    int local_2 = 7;

    printf (""Address of main is %p\n"", main);
    printf (""Address of global is %p\n"", &global);
    printf (""Address of local is %p\n"", &local);
    printf (""Address of local_2 is %p\n"", &local_2);
    printf (""Address of p is %p\n"", p);
    printf (""Address of q is %p\n"", q);
    
    return 0;
}
"
059-16241,ElsevierSoftwareX/SOFTX-D-15-00010,files/extrae/tests/functional/launcher/pi.c,23,1,13,2120447.9271546,189429.0,11.193887947463166,1435.0,1410.0,40015.0,13868.0,1633.0,637.0,1352.0,594.0,1500000000,0.0014136319514364,1082014363648.0,0.0150188197160941,0.0782436018781433,"
#include <stdio.h>
#include <math.h>

double pi_kernel (int n, double h)
{
	double tmp = 0;
	double x;
	int i;

	for (i = 1; i <= n; i++)
	{
		x = h * ((double)i - 0.5);
		tmp += (4.0 / (1.0 + x*x));
	}

	return tmp;
}

int main(void)
{
	int n = 1000;
	double PI25DT = 3.141592653589793238462643;
	double pi, h, area;

	h = 1.0 / (double) n;
	area = pi_kernel (n, h);
	pi = h * area;

	printf(""pi is approximately %.16f, Error is %.16f\n"",pi,fabs(pi - PI25DT));

	return 0;
}
"
129-6068,ankitpokhrel/academic-c,Eular/longest_collatz_sequence.c,42,2,19,146871738.01939934,458313442.0,0.3204613361525626,1151.0,1139.0,38672.0,12784.0,1570.0,585.0,1320.0,544.0,1500000000,0.0979144920129329,1082014363648.0,4.996580484322779e-06,0.078105565920398,"/**
 * Longest Collatz sequence.
 * https://projecteuler.net/problem=14
 */

#include <assert.h>

unsigned long next_collatz_sequence(unsigned long n)
{
    if (n % 2 == 0) {
        return n / 2;
    }

    return 3 * n + 1;
}

int collatz_sequence(unsigned long n)
{
    int num_sequence = 1;

    while (n > 1) {
        ++num_sequence;

        n = next_collatz_sequence(n);
    }

    return num_sequence;
}

unsigned long longest_collatz_sequence(unsigned long limit)
{
    int sequence, largest = 0;
    unsigned long num = limit;

    for (unsigned long i = limit / 2; i <= limit; i++) {
        sequence = collatz_sequence(i);

        if (sequence > largest) {
            num = i;
            largest = sequence;
        }
    }

    return num;
}

int main()
{
    assert(9 == longest_collatz_sequence(13));
    assert(871 == longest_collatz_sequence(1000));
    assert(6171 == longest_collatz_sequence(10000));
    assert(77031 == longest_collatz_sequence(100000));
    assert(837799 == longest_collatz_sequence(1000000));

    return 0;
}
"
101-14001,lekum/head-first-c,chapter_3/order_pizza/order_pizza.c,32,2,8,2438465.71538595,177197.0,13.761322144280095,1322.0,1301.0,40335.0,13727.0,1696.0,641.0,1355.0,595.0,1500000000,0.0016256438102573,1082014363648.0,0.0148027336805927,0.0792978432170471,"#include <stdio.h>
#include <unistd.h>

int main(int argc, char *argv[])
{
    char *delivery = """";
    int thick = 0;
    int count = 0;
    char ch;

    while ( (ch = getopt(argc, argv, ""d:t"")) != EOF)
    {
        switch(ch)
        {
            case 'd':
                delivery = optarg;
                break;
            case 't':
                thick = 1;
                break;
            default:
                fprintf(stderr, ""Unknown option: '%s'\n"", optarg);
                return 1;
        }
    }

    argc -= optind;
    argv += optind;

    if (thick)
        puts(""Thick crust."");
    if (delivery[0])
        printf(""To be delivered %s.\n"", delivery);

    puts(""Ingredients:"");
    for (count = 0 ; count < argc; count++)
        puts(argv[count]);
    return 0;
}
"
260-20762,BOT-Man-JL/BUPT-Projects,1-2-Discrete-Math/Caesar-Decryption.c,35,1,15,3801201.12095025,179424.0,21.185577180310325,1369.0,1346.0,41009.0,14230.0,1654.0,652.0,1377.0,607.0,1500000000,0.0025341340806335,1082014363648.0,0.0151317549491706,0.0776625210449139,"
#include <stdio.h>

void fnDecryption ()
{
	FILE *pf, *pfo;
	int key, ch;
	
	pfo = fopen (""out.dat"", ""w"");
	if (!pfo)
	{
		printf (""Can not create the file\n"");
		return;
	}

	pf = fopen (""in.dat"", ""r"");
	if (!pf)
	{
		printf (""Can not open the file\n"");
		fclose (pfo);
		return;
	}

	ch = fgetc (pf);
	key = (tolower (ch) - 'c' + 26) % 26;
	printf (""%d\n"", key);
	fprintf (pfo, ""%d\n"", key);
	while (ch != EOF)
	{
		ch = tolower (ch) - 'a';
		ch = (ch - key + 26) % 26;
		printf (""%c"", ch + 'A');
		fprintf (pfo, ""%c"", ch + 'A');
		ch = fgetc (pf);
	}
}

int main ()
{
	fnDecryption ();
	return 0;
}
"
112-9710,racing19th/MiraiOS,sh/rm.c,15,1,5,1949223.1076582999,175524.0,11.10516510562658,1299.0,1282.0,39832.0,13544.0,1634.0,635.0,1356.0,592.0,1500000000,0.0012994820717722,1082014363648.0,0.0147045418290376,0.0790055455635491,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

int main(int argc, char **argv) {
	if (argc < 2) {
		printf(""rm: Need filename\n"");
	}

	int error = 0;
	for (int i = 1; i < argc; i++) {
		error = remove(argv[i]);
		if (error) {
			printf(""rm: %s\n"", strerror(errno));
			error = errno;
			break;
		}
	}
	return error;
}"
290-13709,Gurgel100/gcc,gcc/testsuite/gcc.c-torture/execute/pr83298.c,9,1,3,1822862.7741336,169978.0,10.724105472472909,1146.0,1137.0,38668.0,12780.0,1577.0,586.0,1323.0,546.0,1500000000,0.0012152418494224,1082014363648.0,0.0134311499135182,0.0783703934069351,"
int a, b, c = 1;

int main ()
{
  for (; b < 1; b++)
    ;
  if (!(c * (a < 1))) 
    __builtin_abort ();
  return 0; 
}
"
093-32830,lijiaying/InvariantGenerationPaperZILU,testcases/blast/fm11.c,11,1,3,1927984.4127594,169083.0,11.402589260895535,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0012853229418396,1082014363648.0,0.0134490161636592,0.0785049652044725,"#include <assert.h>

int main() {
	int i;
	int j;

	if(!(i==0 && j==0)) 
		return 0;
	while(i<100) {
		j+=2; i++;
	}
	assert(j==200);
	return 0;
}"
187-26512,SanDisk-Open-Source/SSD_Dashboard,uefi/gcc/gcc-4.6.3/gcc/testsuite/gcc.dg/tree-ssa/pr23386.c,21,1,13,1555850.9621769001,169991.0,9.152543369943114,1147.0,1138.0,38673.0,12779.0,1579.0,586.0,1325.0,546.0,1500000000,0.0010372339747846,1082014363648.0,0.0134418880999582,0.0784420430692684,"/* { dg-do run } */
/* { dg-options ""-O2"" } */

int f[100];
int g[100];
unsigned char
f1 (int a, int b)
{
  __SIZE_TYPE__ ix;
  if (a)
    return 1;
  for (ix = 4; ix--;)
      if (f[ix] != g[ix])
	  return 0;
  return 1;
}

int main(void)
{
  if (!f1 (0, 2))
    __builtin_abort();
  return 0;
}

"
224-22132,zxombie/aarch64-freebsd-binutils,gdb/testsuite/gdb.cell/data-spu.c,27,1,14,1592506.4217298501,169057.0,9.419935288098095,1139.0,1129.0,38452.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010616709478199,1082014363648.0,0.0134155935572026,0.0785172440760147,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2009-2014 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

   Contributed by Markus Deuling <deuling@de.ibm.com>  */

#include <stdio.h>

int
main (unsigned long long speid, unsigned long long argp,
      unsigned long long envp)
{
  char var_char = 'c';
  short var_short = 7;
  int var_int = 1337;
  long var_long = 123456;
  long long var_longlong = 123456789;
  float var_float = 1.23;
  double var_double = 2.3456;
  long double var_longdouble = 3.45678;
  return 0; /* Marker SPU End */
}

"
015-22699,IAmRasputin/euler,5/c/multiple.c,19,2,6,1318182235.7000782,4028006376.0,0.3272542573055748,1335.0,1316.0,39173.0,13306.0,1618.0,636.0,1340.0,593.0,1500000000,0.8787881571333855,1082014363648.0,6.58141957221172e-07,0.079784294670249,"#include <stdio.h>

int main()
{
	int i;
	int answer;
	int found = 0;
	int cur = 20;

	while( !found ){
		cur++;
		found = 1;
		for( i = 1; i <= 20; i++ ){
			if( ( cur % i ) != 0 ){
				found = 0;
				break;
			}
		}
		
	}

	printf(""%d\n"", cur);
	
	return 0;
}
"
008-28943,totalspectrum/binutils-propeller,gdb/testsuite/gdb.base/infcall-input.c,26,1,16,1502205862.3144403,170067.0,8833.023820023873,1152.0,1142.0,38683.0,12795.0,1574.0,589.0,1321.0,547.0,1500000000,1.0014705748762935,1082014363648.0,0.0134888014723608,0.0783052954660243,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2016-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
some_function (void)
{
  /* Sleep a bit to make sure the next command is queued before this
     function returns.  */
  sleep (1);
  return 1;
}

int
main (int argc, char **argv)
{
  some_function ();
  return 0;
}
"
017-4843,antoyo/c--,tests/test7.c,12,2,6,3186994.46506785,174789.0,18.23337853068557,1293.0,1278.0,39888.0,13613.0,1613.0,634.0,1339.0,593.0,1500000000,0.0021246629767119,1082014363648.0,0.0147091636201362,0.078110689519822,"#include <stdio.h>

int main() {
    int i;
    for(i = 0 ; i < 5 ; i++) {
        puts(""Hello World!"");
    }
    for(int j = 0 ; j < 10 ; j++) {
        printf(""%c"", 'j');
        printf(""%c"", ' ');
    }
    puts("""");
    return 0;
}
"
329-33660,ShooShoSha/Course-Work,COP3530/Samples/DelayTest.c,27,1,10,12753007957.36257,430494669.0,29.62407870607104,1299.0,1280.0,93587460.0,28077813.0,1613.0,634.0,1339.0,593.0,1500000000,8.50200530490838,1082014363648.0,5.990782664024116e-06,3.434833865864091e-05,"/*
 * DelayTest.c
 * Jim Lewis
*/

#include <time.h>
#include <stdio.h>
#include <stdlib.h>

void pause2( unsigned long msecs );

int main()
{
    unsigned long delay = 500;
    printf(""Starting ... \ndelay 1/2 second ... \n"");
    pause2( delay );
    printf(""now delay 3 seconds ... \n"");
    delay = 3000;
    pause2( delay );
    printf(""now delay 5 seconds ... \n"");
    pause2( 5000 );
    printf(""Done \n"");
}

void pause2( unsigned long msecs )
{
    unsigned long finish = 0, start = 0;
    start = clock();
    while( finish < msecs )
    {
        finish = clock() - start;
        finish = finish / (CLOCKS_PER_SEC / 1000);
    }
}
"
193-15762,VincentLee0211/K-R,ch03_control_flow/trim.c,22,1,12,2265365.79430095,174144.0,13.008573364571848,1302.0,1284.0,39495.0,13398.0,1624.0,634.0,1346.0,591.0,1500000000,0.0015102438628673,1082014363648.0,0.0148497794928335,0.0793110619552681,"/*
 * trim.c
 *
 * 删除字符串尾部的空白符
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int trim(char s[]);

int main(void)
{
    char s[] = ""hello, world     \t\n"";

    trim(s);

    printf(""%s\n"", s);

    return EXIT_SUCCESS;
}

int trim(char s[])
{
    int n;

    for (n = strlen(s) - 1; n >= 0; n--)
        if (s[n] != ' ' && s[n] != '\t' && s[n] != '\n')
            break;
    s[n+1] = '\0';
    return n;
}
"
392-11095,puneet222/Data-Structures,DS/DS/disjoint_set/fast_union_slow_find.c,42,2,11,2665204.5780792,179398.0,14.85637521042598,1344.0,1325.0,40561.0,14182.0,1626.0,634.0,1345.0,592.0,1500000000,0.0017768030520528,1082014363648.0,0.0148775348666094,0.0766673364631094,"#include<stdio.h>

void makeSet(int *S , int size)
{
	int i ;
	for(i = 0 ; i < size ; i++)
		S[i] = i ;
}

int find(int *S , int size , int x)
{
	if(x < 0 || x >= size)
		return -1 ;
	if(S[x] == x)
		return x ;
	find(S , size , S[x]) ;
}

void Union(int *S , int root1 , int root2 , int size)
{
	if(find(S , size , root1) == find(S , size , root2))
		return ;
	if((root1 < 0 || root1 > size)&&(root2 < 0 || root2 > size))
		return ;
	S[root1] = root2 ;
}

void display(int *S , int size)
{
	int i ;
	for(i = 0 ; i < size ; i++)
	{
		printf("" %d "", S[i]);
	}
}

int main()
{
	int S[8] ;
	makeSet(S , 8) ;
	Union(S , 5,6 , 8) ;
	Union(S , 1 , 2 , 8) ;
	Union(S , 0 , 2 , 8) ;
	Union(S , 2 , 3 , 8) ;
	display(S , 8) ;

	int p = find(S , 8 , 0);
	printf(""%d is the parent of 0\n"", p);
}"
095-27673,jdh8/metallic,test/wasm/soft/integer/lshrti3.c,15,3,4,1944985662.0049105,11765838799.0,0.1652883560809356,1152.0,1140.0,38678.0,12781.0,1572.0,586.0,1320.0,546.0,1500000000,1.2966571080032736,1082014363648.0,1.948012410466478e-07,0.0781981771896072,"#include <assert.h>

static void run(unsigned __int128 x)
{
    unsigned __int128 y = x;

    for (int shift = 0; shift < 128; ++shift) {
        assert(x >> shift == y);
        y >>= 1;
    }
}

int main(void)
{
    for (unsigned __int128 x = 1; x; x *= 2)
        run(x);

    for (unsigned __int128 x = 1; x >> 104 != 0x313370; x *= 3)
        run(x);
}

"
088-15797,SanDisk-Open-Source/SSD_Dashboard,uefi/gcc/gcc-4.6.3/gcc/testsuite/gcc.dg/tree-ssa/vrp30.c,27,1,15,1576220.73311355,169083.0,9.322167219649522,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010508138220757,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* { dg-do link } */
/* { dg-options ""-O2"" } */

extern int link_error (int);

int tst2 (int x, int y)
{
  /* VRP should be able to extract range information for
     x and y out of this TRUTH_AND_EXPR.  */
  if ((x > 5555) && (y < 6666))
    {
      if (x > 5555)
        if (y < 6666)
          return 1111;
        else
          return link_error (2222);
      else
        if (y < 6666)
          return link_error (3333);
        else
          return link_error (4444);
    }
  else
    return 0;
}

int main()
{
  return 0;
}
"
005-7068,Arclite/Jotdown,libmarkdown/echo.c,15,1,8,2197728.02665815,174044.0,12.627427547057064,1272.0,1259.0,39513.0,13434.0,1625.0,632.0,1342.0,591.0,1500000000,0.0014651520177721,1082014363648.0,0.0145422996483647,0.079135739513098,"#include <stdio.h>
#include <string.h>


int main(int argc, const char* argv[])
{
    int nl = 1;
    int i;

    if ( (argc > 1) && (strcmp(argv[1], ""-n"") == 0) ) {
	++argv;
	--argc;
	nl = 0;
    }

    for ( i=1; i < argc; i++ ) {
	if ( i > 1 ) putchar(' ');
	fputs(argv[i], stdout);
    }
    if (nl) putchar('\n');
}
"
119-1370,ekasteel/MyPlayground,c/cla/q_4_2.c,12,2,8,2471224.2884560497,175733.0,14.062378722266166,1344.0,1324.0,39818.0,13673.0,1626.0,636.0,1345.0,594.0,1500000000,0.0016474828589707,1082014363648.0,0.0151821228795957,0.0785365762464713,"#include <stdio.h>
int main(void) {
  int i,t[5];
  for(i=0;i<5;i++)
    t[i]=2*i;
  i=0;
  for(i=0;i<5;i++) {
    i+=t[i];
    printf(""%d\n"",i);
  }
  printf(""%d"",i);
  return 0;
}
"
053-9812,wcnnbdk1/hello_world,CLearning/CPrimerPlus/chap10/day_mon3.c,8,1,7,2269219.3742841003,187548.0,12.099403885938534,1356.0,1334.0,42170.0,15196.0,1630.0,639.0,1348.0,598.0,1500000000,0.0015128129161894,1082014363648.0,0.0143429948599825,0.0734755778684238,"#include <stdio.h>
#define MONTHS 12
int main(void)
{
    int days[MONTHS] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    int index;

    for(index = 0; index < MONTHS; index++)
        printf(""Month %2d has %d days.\n"", index + 1, *(days + index));
    return 0;
}
"
242-16051,EvtimPavlov/c-programming-2014-2015-homework,A/27_Hristo_Ezekiev/Homework_4/reverse_number.c,21,1,5,1798053.0392377498,176368.0,10.194893631497775,1337.0,1318.0,39737.0,13714.0,1618.0,639.0,1339.0,594.0,1500000000,0.0011987020261585,1082014363648.0,0.0150537512473918,0.0783895530485865,"#include<stdio.h>

int reverse(int num)
{
	int rev = 0;
	while (num != 0)
	{
		rev = rev * 10;
		rev = rev + num % 10;
		num = num/10;
	}
	printf(""%d\n"",rev);
	return 0;
}

int main()
{
	reverse(5170984);
	reverse(406567);
	reverse(368750);
	reverse(2369510);
	reverse(2183293);
	return 0;
}
"
121-17894,Jadoch/LinuxProject,MPS/prog_linux/13/exemple_calloc_2.c,14,1,9,3586700.88462525,255297.0,14.049127095108831,1320.0,1301.0,57244.0,25535.0,1625.0,904.0,1339.0,861.0,1500000000,0.0023911339230835,1082014363648.0,0.0102664739499484,0.0571280155595018,"
	#include <stdio.h>
	#include <stdlib.h>

	#define	NB_BLOCS	257
	#define TAILLE		(1024*1024)

	int
main (void)
{

	int	i;
	char *	bloc [NB_BLOCS];

	for (i = 0; i < NB_BLOCS; i ++) {
		if ((bloc [i] = (char *) calloc (1, TAILLE)) == NULL) {
			fprintf (stderr, ""Echec pour i = %d\n"", i);
			break;
		}
	}
	fprintf (stderr, ""Alloués : %d blocs de %d Ko\n"", i, TAILLE / 1024);
	
	return (0);
}	

"
077-31448,iovisor/bpftrace,tests/testprogs/watchpoint_func_many_probes.c,11,1,6,1909249.46218725,175451.0,10.879282534724794,1225.0,1212.0,39583.0,13685.0,1592.0,637.0,1327.0,599.0,1500000000,0.0012728329747915,1082014363648.0,0.0138899179827986,0.0780018022077044,"#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

__attribute__((noinline)) void increment(int *i)
{
  (*i)++;
}

int main()
{
  for (int i = 0; i < 20; ++i)
  {
    increment(malloc(sizeof(int)));
  }
}
"
193-9112,rrrichter/ufrgs,complexidade/assignment1/MaiorDivisor.c,30,1,7,4780312.53442155,5189634.0,0.9211270004782612,1353.0,1331.0,39865.0,13645.0,1636.0,639.0,1352.0,594.0,1500000000,0.0031868750229477,1082014363648.0,0.0005171848342291,0.0788824518781536,"#include <stdio.h>
#include <stdlib.h>

long int FATORACAO(long int n)
{
    long int numero = n;
    long int divisor = 1;
    long int resto;
    long int i=2;

    while(numero!=1)
    {
        resto = numero%i;
        if(resto==0)
        {
            divisor = i;
            numero/=i;
        }
        else
            i++;
    }
    return divisor;
}


int main()
{
    long int n;
    long int MAIOR_DIVISOR;
    char Sensor[] = ""1620694973"";

    n=atol(Sensor);
    printf(""Problema sensor: %ld\n"",n);
    MAIOR_DIVISOR = FATORACAO(n);
    printf(""Maior divisor de %ld: %ld\n"",n,MAIOR_DIVISOR);
    return 0;
}
"
271-30182,aswanipranjal/basic-programs,Cprograms/circularlinked.c,49,1,13,1735878.1769871,178417.0,9.729330725211163,1337.0,1319.0,40385.0,14157.0,1616.0,642.0,1339.0,598.0,1500000000,0.0011572521179914,1082014363648.0,0.0148864738225617,0.0769132045029518,"#include<stdio.h>
#include<stdlib.h>

struct node
{
	int value;
	struct node *link;
} *head, *top, *ptr,*node;
int i = 0;

void init()
{
	top = NULL;
}

void insert(int value)
{
	node = (struct node*)malloc(sizeof(struct node));
	node->value = value;
	node->link = NULL;
	if(top == NULL)
	{
		top = node;
		head = top;
	}
	else
	{
		top->link = node;
		node->link = head;
		top = node;
	}
}

void display()
{
	ptr = head;
	do
	{
		printf(""this node contains: %d\n"", ptr->value);
		ptr = ptr->link;
	}while(ptr != head);
	printf(""End of list"");
}

int main()
{
	init();
	insert(1);
	insert(2);
	insert(3);
	insert(4);
	insert(5);
	insert(6);
	display();
	return 0;
}

		
		"
083-5307,jdh8/metallic,test/wasm/soft/integer/ashlti3.c,15,3,4,1939788730.4658074,11765838799.0,0.1647989003695001,1152.0,1140.0,38678.0,12781.0,1572.0,586.0,1320.0,546.0,1500000000,1.293192486977205,1082014363648.0,1.948012410466478e-07,0.0781981771896072,"#include <assert.h>

static void run(unsigned __int128 x)
{
    unsigned __int128 y = x;

    for (int shift = 0; shift < 128; ++shift) {
        assert(x << shift == y);
        y <<= 1;
    }
}

int main(void)
{
    for (unsigned __int128 x = 1; x; x *= 2)
        run(x);

    for (unsigned __int128 x = 1; x >> 104 != 0x313370; x *= 3)
        run(x);
}

"
336-31698,zhangrxiang/learn-c,books/csapp/ch02/zero_sign_extension.c,30,1,11,1518451.2594714,185146.0,13.395574303522626,1370.0,1349.0,41847.0,15075.0,1635.0,634.0,1356.0,591.0,1500000000,0.0010123008396476,1082014363648.0,0.014685707495706,0.0740662661185481,"
#include<stdio.h>

typedef unsigned char *byte_pointer;

void show_bytes(byte_pointer start, int len) {
    for (int i = 0; i < len; i++)
        printf("" %.2x"", start[i]);
    printf(""\n"");
}

void show_int(int x) {
    show_bytes((byte_pointer) &x, sizeof(int));
}

void show_float(float x) {
    show_bytes((byte_pointer) &x, sizeof(float));
}

void show_pointer(void *x) {
    show_bytes((byte_pointer) &x, sizeof(void *));
}


int main() {
    short sx = -12345;
    unsigned short usx = sx;
    int x = sx;
    unsigned int ux = usx;

    printf(""xs = %d:\t"", sx);
    show_bytes((byte_pointer) &sx, sizeof(short));
    printf(""usx = %u:\t"", usx);
    show_bytes((byte_pointer) &usx, sizeof(unsigned short));
    printf(""x = %d:\t"", x);
    show_bytes((byte_pointer) &x, sizeof(int));
    printf(""ux = %u:\t"", ux);
    show_bytes((byte_pointer) &ux, sizeof(unsigned));

    return 0;
}
"
166-22145,genos/online_problems,euler/previous/nim.c,31,1,16,1167402769.5553377,11811333282.0,0.0988375097990906,1336.0,1318.0,39188.0,13321.0,1618.0,636.0,1341.0,593.0,1500000000,0.7782685130368918,1082014363648.0,2.2469944219122069e-07,0.0797577558132891,"//project euler, quesiton 301
#include <stdio.h>

unsigned int X(unsigned long n1, unsigned long n2, unsigned long n3)
{
    return n1 ^ n2 ^ n3;
}

unsigned int power(unsigned int base, unsigned int exp)
{
    if (exp == 0) {
        return 1;
    }
    else if (exp % 2) {
        return base * power(base, exp - 1);
    }
    else {
        unsigned int tmp = power(base, exp/2);
        return tmp * tmp;
    }
}

int main(int argc, char *argv[])
{
    unsigned long c = 0;
    unsigned long n;
    unsigned long upper_limit = power(2, 30) + 1;
    for (n = 1; n < upper_limit; n++) {
        if (X(n, 2*n, 3*n) == 0) {
            c++;
        }
    }

    printf(""%lu\n"", c);
    
    return 0;
}
"
108-8723,pacampbell/cse506,bin/hello/helloworld.c,15,1,6,2692848.09473895,174228.0,15.455885391555892,1289.0,1274.0,39590.0,13490.0,1618.0,641.0,1343.0,598.0,1500000000,0.0017952320631593,1082014363648.0,0.0147106090869435,0.0791258477769404,"#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
    printf(""\n=========================================================\n"");
    printf(""PLEASE READ THE README\n"");
    printf(""\n"");
    printf(""This is NOT a shell\n"");
    printf(""You can make your program run by changing the\n"");
    printf(""start_shell function in sys/kmain.c\n"");
    printf(""\n"");
    printf(""to make this less annoying remove the schedualing of hello\n"");
    printf(""in the start_shell\n"");
    printf(""\n"");
    //printf(""sleeping for 10 seconds...\n"");
    //sleep(10);
    printf(""=========================================================\n\n"");
}

"
047-29636,gritt/ufpel-aed-one,src/classes/mergeSort/200t.c,8,1,5,26022459.03108255,149085880.0,0.1745467712971879,1347.0,1325.0,31546031.0,21513532.0,1628.0,698.0,1346.0,656.0,1500000000,0.0173483060207217,1082014363648.0,1.792255577791807e-05,8.156870798200882e-05,"#include <stdio.h>
#include <stdlib.h>

int main ()
{
    printf(""%d \n"", 200000);
    
    for(long int i = 0 ; i < 200000; i++) {
        printf(""%d \n"", rand()%200000);
    }
    
    return 0;
}"
234-30273,mattstock/binutils-bexkat1,gdb/testsuite/gdb.multi/watchpoint-multi.c,37,1,12,2030852.716416,176584.0,11.500770171702984,1364.0,1338.0,40215.0,13799.0,1635.0,661.0,1354.0,615.0,1500000000,0.001353901810944,1082014363648.0,0.0153014995696099,0.0789610101084904,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2012-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <pthread.h>
#include <assert.h>

static volatile int a, b, c;

static void
marker_exit (void)
{
  a = 1;
}

static void *
start (void *arg)
{
  b = 2;
  c = 3;

  return NULL;
}

int
main (void)
{
  pthread_t thread;
  int i;

  i = pthread_create (&thread, NULL, start, NULL);
  assert (i == 0);
  i = pthread_join (thread, NULL);
  assert (i == 0);

  marker_exit ();
  return 0;
}
"
290-2868,fgr/whz-cprog,zuul/player/player2.c,36,1,17,2576014.49266065,178083.0,14.460324680064913,1385.0,1363.0,40532.0,13970.0,1652.0,642.0,1366.0,597.0,1500000000,0.0017173429951071,1082014363648.0,0.0154310068900456,0.0781072254229202,"// Player (Ausbaustufe 2: player_t.name als Array statt als Zeiger)

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#define PLAYER_NAME_MAX_LEN 100 // Maximum length of player_t.name including terminating null

void read_line(char *buf, int buf_sz) {
  int c, i = 0;
  while ((i < buf_sz - 1) && ((c = getc(stdin)) != EOF)) { // buf_sz -1 wegen \0
    if (c == '\n') {
      break;
    }
    buf[i] = c;
    ++i;
  }
  buf[i] = 0; // Null-Terminierung
}

typedef struct player_t {
  char name[PLAYER_NAME_MAX_LEN];
  int energy;
} player_t;

player_t player_new(const char *name) {
  player_t p;
  p.energy = 100;
  strncpy(p.name, name, PLAYER_NAME_MAX_LEN);
  return p;
}

player_t player_new_ask_user_for_name() {
  char buf[PLAYER_NAME_MAX_LEN];
  read_line(buf, PLAYER_NAME_MAX_LEN);

  player_t p = player_new(buf);
  printf(""Created player '%s'\n"", p.name);
  return p;
}

int main(void) {
  struct player_t p = player_new_ask_user_for_name();
  printf(""Test\n"");
  printf(""Test\n"");
  printf(""New player: '%s'\n"", p.name);

  return EXIT_SUCCESS;
}
"
016-2341,SaravanaPunith/c_complete,system_c/test.c,16,1,6,4841933.841817049,380747.0,12.716930139961708,1464.0,1439.0,95918.0,46819.0,1786.0,874.0,1474.0,829.0,1500000000,0.0032279558945447,1082014363648.0,0.0076244855507725,0.0347702417733313,"
#include <stdlib.h>
#include <stdio.h>
#include <dirent.h>
int main(void)
{
    struct dirent **namelist;
    int n;

    n = scandir(""."", &namelist, NULL, alphasort);
    if (n < 0)
        perror(""scandir"");
    else {
        while (n--) {
            printf(""%s\n"", namelist[n]->d_name);
            free(namelist[n]);
        }
        free(namelist);
    }
    return 0;
}

"
190-4874,Bytewerk/uClinux-ipcam,uClibc/test/pthread/ex6.c,34,1,13,403746499.6799826,5482887.0,73.63757432899857,19488.0,1465.0,1414501.0,927615.0,1685.0,672.0,1380.0,628.0,1500000000,0.2691643331199884,1082014363648.0,0.003821526870789,0.0018636993214682,"#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <pthread.h>
#include <time.h>

static void *
test_thread (void *v_param)
{
  return NULL;
}

int
main (void)
{
  unsigned long count;
  struct timespec ts;
  ts.tv_sec = 0;
  ts.tv_nsec = 10 * 1000;

  setvbuf (stdout, NULL, _IONBF, 0);

  for (count = 0; count < 2000; ++count)
    {
      pthread_t thread;
      int status;

      status = pthread_create (&thread, NULL, test_thread, NULL);
      if (status != 0)
	{
	  printf (""status = %d, count = %lu: %s\n"", status, count,
		  strerror (errno));
	  return 1;
	}
      else
	{
	  printf (""count = %lu\n"", count);
	}
      /* pthread_detach (thread); */
      pthread_join (thread, NULL);
      nanosleep (&ts, NULL);
    }
  return 0;
}
"
312-3522,zhangrxiang/learn-c,basic/csapp/chapter02/show-bytes.c,35,1,15,1468007.9184472498,193202.0,7.598301259821327,1362.0,1342.0,43608.0,16327.0,1633.0,638.0,1353.0,594.0,1500000000,0.0009786719456315,1082014363648.0,0.0139957143300793,0.0703762409276716,"/*
 * p28
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef unsigned char *byte_pointer;

void show_bytes(byte_pointer start, int len) {
    int i;
    for (i = 0; i < len; i++)
        printf("" %.2x"", start[i]);
    printf(""\n"");
}

void show_int(int x) {
    show_bytes((byte_pointer) &x, sizeof(int));
}

void show_float(float x) {
    show_bytes((byte_pointer) &x, sizeof(float));
}

void show_pointer(void *x) {
    show_bytes((byte_pointer) &x, sizeof(void *));
}

void test_show_bytes(int val) {
    int ival = val;
    float fval = (float) ival;
    int *pval = &val;
    show_int(ival);
    show_float(fval);
    show_pointer(pval);
}


int main() {
    test_show_bytes(12345);


    show_bytes(""12345"", 6);
    // 练习题2.7
    const char *s = ""abcdef"";
    show_bytes((byte_pointer) s, strlen(s));
    return 0;
}
"
045-22501,robbertkrebbers/ch2o,tests/undefined-ellison/unsorted/j009a.c,9,1,4,1688463.1477296,169083.0,9.986000958109331,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0011256420984864,1082014363648.0,0.0134490161636592,0.0785049652044725,"int main(void){
	int* p;
	{
		int x = 5;
		p = &x;
	} // the memory for x should not be accessible now
	int y = *p;
	return 0;
}
"
179-28343,jdh8/metallic,test/wasm/soft/integer/ashrti3.c,16,3,5,1642826733.1793904,11770959351.0,0.139566086672488,1153.0,1141.0,38680.0,12783.0,1572.0,586.0,1320.0,546.0,1500000000,1.0952178221195936,1082014363648.0,1.9488640913581217e-07,0.0781920991780502,"#include <assert.h>

static void run(__int128 x)
{
    __int128 y = x;

    for (int shift = 0; shift < 128; ++shift) {
        assert(x >> shift == y);
        y >>= 1;
    }
}

int main(void)
{
    __int128 max = (unsigned __int128)-1 >> 1;

    for (unsigned __int128 x = 1; x; x *= 2)
        run(x);

    for (unsigned __int128 x = 1; x >> 104 != 0x313370; x *= 3)
        run(x & max);
}

"
165-32200,ywyz/C-Primer-Plus,第六章代码/for_none.c/for_none.c,10,1,7,1803438.0627795,173466.0,10.396492684445366,1336.0,1317.0,39242.0,13344.0,1618.0,636.0,1340.0,593.0,1500000000,0.001202292041853,1082014363648.0,0.0152940633899438,0.0796219526109611,"/* for_none.c */
#include<stdio.h>
int main(void)
{
	int ans, n;
	ans = 2;
	for (n = 3; ans <= 25;)
		ans = ans * n;
	printf(""n = %d; ans = %d.\n"", n, ans);
	return 0;
}"
389-7792,chubbymaggie/reverse,tests/nestedloop3.c,10,3,0,3780411.2071169997,169057.0,22.36175372803256,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.002520274138078,1082014363648.0,0.0134155935572026,0.0785563462891999,"#include <stdio.h>
#include <stdlib.h>

int main() {
    int i = 123, j = 5, k = 1;

    while (i < 5) {
        while (j < 2) {
            while (k < 4) {
            }
        }
    }

    return 0;
}




"
166-2034,millken/c-example,t1.c,28,3,13,1548716.9148399,178995.0,8.652286376714434,1386.0,1363.0,40578.0,13963.0,1647.0,638.0,1365.0,595.0,1500000000,0.0010324779432266,1082014363648.0,0.0153579708930417,0.0778313562274252,"#include <stdio.h>
#include<string.h>
int main()
{
    char str[] = ""1.1.1.1"";
    char aa[10][16] = {0};
    char *p;
    char *buff;
    buff=str;
    p = strsep(&buff, "","");
    int i = 0;
    while(p)
    {
    	strcpy(aa[i] , p);
        printf(""%s\n"", p);
        p = strsep(&buff, "","");
        ++i;
    }
    for (i = 0; i < 10; ++i)
    {
    	if(strlen(aa[i]) >= 7)
    	printf(""aa[%d]=%s\n"", i, aa[i] );
    }
     for (i = 0; i < 10; ++i)
    {
    	if(strlen(aa[i]) >= 7)
    	printf(""aa[%d]=%s\n"", i, aa[i] );
    }   
    return 0;
}
"
023-20852,hzq1001/or1k-src,gdb/testsuite/gdb.base/disp-step-vfork.c,57,1,13,1903008.08753805,169176.0,11.248687757128671,1075.0,1066.0,38486.0,12672.0,1564.0,586.0,1320.0,547.0,1500000000,0.0012686720583587,1082014363648.0,0.012655459403225,0.0785214433715156,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2011-2013 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

static void
marker () {}

int
main (void)
{
  int pid;

  pid = vfork ();
  if (pid == -1)
    {
      return 1;
    }
  else if (pid != 0)
    {
    }
  else
    {
      _exit (0);
    }

  pid = vfork ();
  if (pid == -1)
    {
      return 1;
    }
  else if (pid != 0)
    {
    }
  else
    {
      _exit (0);
    }

  pid = vfork ();
  if (pid == -1)
    {
      return 1;
    }
  else if (pid != 0)
    {
    }
  else
    {
      _exit (0);
    }

  marker ();
  return 0;

}
"
132-8757,r-lyeh/scriptorium,tests/prime.c,22,2,8,4989829721.977003,13692891912.0,0.3644102175835535,1338.0,1319.0,39184.0,13306.0,1618.0,636.0,1340.0,593.0,1500000000,3.3265531479846686,1082014363648.0,1.940422824539711e-07,0.0797675747761478,"#include <stdio.h>

int isprime(int n)
{
    int i;
    for (i = 2; i < n; ++i)
        if (n % i == 0)
            return 0;
    return 1;
}



int primes(int n)
{
    int count = 0;
    int i;
    for (i = 2; i <= n; ++i)
        if (isprime(i))
            ++count;
    return count;
}



int main()
{
    int N = 200000;
    printf(""primes: %d\n"", primes(N));
}
"
133-32003,jjones-cavium/glibc,stdio-common/tst-fileno.c,28,1,15,2250577.3231386,179688.0,12.524915408931037,1365.0,1340.0,40574.0,14101.0,1632.0,639.0,1345.0,595.0,1500000000,0.0015003848820924,1082014363648.0,0.0150538711544454,0.0770187471422039,"/* Copyright (C) 1994, 1997, 2000 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

static int
check (const char *name, FILE *stream, int fd)
{
  int sfd = fileno (stream);
  printf (""(fileno (%s) = %d) %c= %d\n"", name, sfd,
	  sfd == fd ? '=' : '!', fd);
  return sfd != fd;
}

int
main (void)
{
  return (check (""stdin"", stdin, STDIN_FILENO) ||
	  check (""stdout"", stdout, STDOUT_FILENO) ||
	  check (""stderr"", stderr, STDERR_FILENO));
}
"
369-9898,JasonVann/TheCProgrammingLanguage,C2_TypesOperatorsExpressions/atoi.c,14,1,9,1814958.2901969,173196.0,10.479214300561214,1334.0,1316.0,39191.0,13314.0,1618.0,636.0,1340.0,593.0,1500000000,0.0012099721934646,1082014363648.0,0.0153005843091064,0.079744786210837,"#include <stdio.h>

int atoi(char s[])
{
    // convert s to integer
    int i, n;

    n = 0;
    for (i = 0; s[i] >= '0' && s[i] <= '9'; ++i)
        n = 10 * n + (s[i] - '0');
    return n;
}

int main()
{
    char *s = ""1234567911"";
    printf(""abcdefg = %u\n"", atoi(s));
}

             
"
226-27868,GHackAnonymous/ConguntoComandos,MV/mv.c,21,1,7,1586551.4287725,176127.0,9.007994231435273,1289.0,1272.0,40126.0,13696.0,1641.0,634.0,1366.0,592.0,1500000000,0.001057700952515,1082014363648.0,0.0145406439671373,0.0786481364497789,"#include<stdio.h>

int main(int argc, char *argv[]){

	if(argc != 3){
		printf(""Falta un argumento\n"");
		return 0;
	}else if(argc == 3){
		FILE *pFOrigen;
		FILE *pFDestino;
		unsigned char byte;
		pFOrigen = fopen(argv[1],""r+b""); 
		pFDestino = fopen(argv[2],""ab+"");
		while(!feof(pFOrigen)){
			byte = fgetc(pFOrigen);
			fputc(byte,pFDestino);
		}
		fclose(pFOrigen);
		fclose(pFDestino);

		// depues de copiar de bit a bit hay que borrar el origen

		remove(argv[1]);	
	
	}
	return 0;
}
"
343-33554,rohitjha/ProjectEuler,C/PE002.c,31,1,16,2441959.5720246,173250.0,14.095001443001443,1338.0,1319.0,39184.0,13309.0,1618.0,636.0,1340.0,593.0,1500000000,0.0016279730480164,1082014363648.0,0.0153362193362193,0.0797630160211837,"/*

Author: Rohit Jha
File: PE002.c
July 5, 2013

Problem 2:
Each new term in the Fibonacci sequence is generated by adding the previous
two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed
four million, find the sum of the even-valued terms.

*/

#include <stdio.h>

int main() {
	long limit = 4000000;
	long x = 1;
	long y = 1;
	long sum = 0;
	
	while(sum < limit)
	{
		sum += (x+y);
		x = x + 2*y;
		y = 2*x - y;
	}
	
	printf (""%d\n"", sum);
	return 0;
}

/*
4613732

real	0m0.001s
user	0m0.000s
sys	0m0.000s
*/
"
214-3322,EvtimPavlov/c-programming-2014-2015-homework,B/07_Vanessa_Stoinova/Homework_4/reverse_number.c,22,2,10,1851859.6189096498,180435.0,10.263302574334247,1367.0,1343.0,40515.0,14084.0,1632.0,639.0,1350.0,596.0,1500000000,0.0012345730792731,1082014363648.0,0.0150192590129409,0.0772358468103811,"#include<stdio.h>

int ReverseNumbers(int num) 
  {
     int reverseNum = 0;
     while(num > 0) {
        reverseNum = reverseNum*10 + num % 10 ;
        num = num / 10 ;
     }
     return reverseNum;
  } 

int main () 
  {
     int OriginalNumber[5] = { 5170984, 406567, 368750, 2369510, 2183293 }, ReverseNumber, br;
     for(br = 0 ; br < 5 ; br ++ ) {
         ReverseNumber = ReverseNumbers(OriginalNumber[br]);
         if(br == 1 ) {
             printf(""%6.3d       % 7.3d\n"", OriginalNumber[br], ReverseNumber);
         }else{
             printf(""%6.3d      % 7.3d\n"", OriginalNumber[br], ReverseNumber);
         }      
    }
  return 0;
 }
"
052-3232,danielcabralsilveira/the-c-programming-language,ch01/ex1-15.c,11,1,10,2237568.2601705003,213584.0,10.476290358828376,1497.0,1466.0,47992.0,18788.0,1636.0,638.0,1354.0,596.0,1500000000,0.001491712173447,1082014363648.0,0.0138727620046445,0.0632524707996406,"#include <stdio.h>

#define LOWER 0
#define UPPER 300
#define STEP  20

/*  Function temperature conversion */

float fahrenheit_celsius(fahr) {
	return (5.0/9.0)*(fahr-32);
}

int main () {

	int fahr;
	for(fahr = LOWER; fahr <= UPPER; fahr = fahr+STEP){
		printf(""%3d %6.1f\n"", fahr, fahrenheit_celsius(fahr));
	}	
	return 0;
}
"
230-5892,fredrickprashanth/sugarnspice,test_free.c,17,2,10,2222837.76383835,207030.0,10.736786939090951,1380.0,1355.0,46693.0,18373.0,1629.0,639.0,1351.0,596.0,1500000000,0.0014818918425589,1082014363648.0,0.0132106458001255,0.0647803768481234,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
	char *a = NULL, *b;
	int i;
	a = malloc(20);
	strcpy(a, ""AAAAAAAAAAA"");
	b = a;
	for(i=0; i<20 ; i++)
		printf(""%3d "", b[i]);
	printf(""\n"");
	free(a);
	for(i=0; i<20 ; i++)
		printf(""%3d "", b[i]);
	printf(""\n"");
	printf(""a=%p b=%p\n"", a, b);	
	
	return 0;
}
"
163-25833,digwiz/Euler,c/problem_twelve.c,24,2,12,192385678.64522326,703996277.0,0.2732765559781504,1336.0,1316.0,39174.0,13304.0,1619.0,638.0,1340.0,593.0,1500000000,0.1282571190968155,1082014363648.0,3.767065376114198e-06,0.0798429818209535,"#include <stdio.h>

int main(int argc, char *argv[])
{
  long int num, triangle, count, i;
  num = 1;
  while(num != 0)
  {
    triangle = num * (num + 1) / 2;
    count = 2;
    for (i = 2; i * i < triangle; i++)
    {
      if((triangle % i) == 0)
      {
	count += 2;
      }
      if(count >= 500)
      {
	printf(""%ld\n"", triangle);
	return 0;
      }
    }
    num++;
  }
  return 0;
}"
239-14369,AllenDowney/ExercisesInC,examples/aspace/aspace.c,15,1,10,2228613.2443695,177233.0,12.574481050368725,1337.0,1317.0,40115.0,13852.0,1626.0,639.0,1347.0,596.0,1500000000,0.001485742162913,1082014363648.0,0.0149746379060333,0.0779735764448644,"/* Example code for Think OS.

Copyright 2015 Allen Downey
License: Creative Commons Attribution-ShareAlike 3.0

*/

#include <stdio.h>
#include <stdlib.h>

int global;

int main ()
{
    int local = 5;
    void *p = malloc(128);

    printf (""Address of main is %p\n"", main);
    printf (""Address of global is %p\n"", &global);
    printf (""Address of local is %p\n"", &local);
    printf (""Address of p is %p\n"", p);
    
    return 0;
}
"
290-11990,acgtyrant/UULP,7/sleep1.c,13,1,6,6002095168.456435,174740.0,34348.71905688451,1317.0,1298.0,39711.0,13534.0,1630.0,639.0,1350.0,593.0,1500000000,4.001396778970957,1082014363648.0,0.0149650909923314,0.0791060193445394,"#include <stdio.h>
#include <stdlib.h>
#include <curses.h>
#include <signal.h> // signal()
#include <unistd.h> // alarm(), pause()


//#define SHHHH

extern void wakeup(int);

int main(void) {
  printf(""about to sleep for 4 seconds\n"");
  signal(SIGALRM, wakeup);
  alarm(4);
  pause();
  printf(""Morning so soon? \n"");
  return EXIT_SUCCESS;
}

extern void wakeup(int signum) {
#ifndef SHHHH
  printf(""Alarm received from kernel\n"");
#endif
}
"
134-31000,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.trace/trace-unavailable.c,35,1,11,1803708.0299109,169061.0,10.668977469670711,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0012024720199406,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2013-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

static void
bar (int j, char *s)
{
  unsigned char array[2];
  int i = 0;

  array[0] = 'c';
  array[1] = 'd';
}

static void
foo (void)
{}

static void
marker (void)
{}

int
main (void)
{
  char s[4];

  bar (4, s);
  foo ();
  marker ();
  return 0;
}
"
173-16731,Galazka/lab-WBzyl,2a.c,13,2,8,1708802.8835131503,204962.0,8.337164937890925,1325.0,1307.0,46639.0,18935.0,1624.0,637.0,1346.0,595.0,1500000000,0.0011392019223421,1082014363648.0,0.0128414047481972,0.0640802757190349,"#include <stdio.h>

void print_pattern(int ile_gwiazdek, char *pattern) {
  for(int i = 0; i < ile_gwiazdek; i++) {
    printf(""%s"", pattern);
  }
  printf(""\n"");
}

int main() {
  int n = 4;

  for(int i = 0; i < n; i++) {
    print_pattern(8, "" *"");
    print_pattern(8, ""* "");
  }
}
"
039-14676,totalspectrum/binutils-propeller,gdb/testsuite/gdb.trace/status-stop.c,36,2,16,1465098.0010627501,169057.0,8.663728801528478,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0009767320007085,1082014363648.0,0.0134155935572026,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2011-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

static void
func1 (void)
{}

int buf[1024];

static void
func2 (void)
{}

static void
end (void)
{}

int
main (void)
{
  int i;

  func1 ();

  /* We call func2 as many times as possible to make sure that trace is
     stopped due to trace buffer is full.  */
  for (i = 0; i < 10000; i++)
    {
      func2 ();
    }

  end ();
  return 0;
}
"
177-28728,wjn740/direct_io,test2.c,31,1,11,14981741552.939642,1420781.0,10544.722622276058,1268.0,1250.0,236591.0,79142.0,1622.0,639.0,1355.0,597.0,1500000000,9.98782770195976,1082014363648.0,0.0017722646910396,0.0133435529387172,"#define _GNU_SOURCE
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#define BLOCKSIZE 512
char image[] =
{
    'P', '5', ' ', '2', '4', ' ', '7', ' ', '1', '5', '\n',
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 3, 3, 3, 3, 0, 0, 7, 7, 7, 7, 0, 0,11,11,11,11, 0, 0,15,15,15,15, 0,
    0, 3, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0,11, 0, 0, 0, 0, 0,15, 0, 0,15, 0,
    0, 3, 3, 3, 0, 0, 0, 7, 7, 7, 0, 0, 0,11,11,11, 0, 0, 0,15,15,15,15, 0,
    0, 3, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0,11, 0, 0, 0, 0, 0,15, 0, 0, 0, 0,
    0, 3, 0, 0, 0, 0, 0, 7, 7, 7, 7, 0, 0,11,11,11,11, 0, 0,15, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
};
int main()
{
    void *buffer;
    int i;
    posix_memalign(&buffer, BLOCKSIZE, BLOCKSIZE);
    memcpy(buffer, image, sizeof(image));
    int f = open(""feep.pgm"", O_CREAT|O_TRUNC|O_WRONLY|O_DIRECT, S_IRWXU);
    //int f = open(""feep.pgm"", O_CREAT|O_TRUNC|O_WRONLY|O_SYNC, S_IRWXU);
    //int f = open(""feep.pgm"", O_CREAT|O_TRUNC|O_WRONLY, S_IRWXU);
    while(i<0xFFFF) {
        write(f, buffer, BLOCKSIZE);
        i++;
    }
    //fdatasync(f);
    //fsync(f);
    close(f);
    free(buffer);
    return 0;
}
"
043-18725,mseaborn/nacl-glibc,pwd/tst-getpw.c,30,2,12,6734660125.337542,331470458.0,20.31752743709064,3532705.0,3054.0,65732931.0,52878564.0,292240.0,182386.0,4239.0,1466.0,1500000000,4.489773416891694,1082014363648.0,0.0106668902602475,0.0040496159330931,"/* Copyright (C) 1999 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#include <pwd.h>

static void
check (uid_t uid)
{
  char buf[1024];

  (void) getpw (uid, buf);
}

int
main (void)
{
  uid_t uid;

  /* Just call it a different number of times the range should be
     large enough to find some existing and some non existing uids.  */

  for (uid = 0; uid < 2000; ++uid)
    check (uid);

  return 0;
}
"
052-4669,xdje42/gdb,gdb/testsuite/gdb.base/vla-stub.c,29,1,10,1508673.0709299,169057.0,8.924049285152345,1139.0,1129.0,38452.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010057820472866,1082014363648.0,0.0134155935572026,0.0785172440760147,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

struct dynamic_struct;
typedef struct dynamic_struct dynamic_struct_t;

struct static_struct
{
  int field;
};
typedef struct static_struct static_struct_t;

struct local_struct
{
  static_struct_t here;
  dynamic_struct_t *ptr;
} local_struct;

int
main (void)
{
  return 0;
}
"
313-32371,EvtimPavlov/c-programming-2014-2015-homework,A/20_Nikolay_Rangelov/homework_3/task_4.c,11,1,4,1586267.84104845,173200.0,9.15858545034642,1338.0,1319.0,39184.0,13309.0,1618.0,636.0,1340.0,593.0,1500000000,0.0010575118940323,1082014363648.0,0.0153406466512702,0.0797630160211837,"#include<stdio.h>

int main()
{
    int i = 0;
    int result = 1;
    for(i = 1;i<=10;i++)
    {
        result = result * i;
    }
    printf(""%d\n"",result);
    return 0;
}

"
269-29513,SMERM/SPERM,INCONTRI/A.A.2019-2020/20200403/cap.c,8,1,8,1864491.1469890499,188051.0,9.914815661708792,1346.0,1327.0,42223.0,15375.0,1626.0,648.0,1346.0,606.0,1500000000,0.0012429940979927,1082014363648.0,0.0142142291186965,0.0733706031459425,"#include <stdio.h>

int main()
{
  char string[] = ""bella flate'"";
  char *p = string;
  char s;
  while((s = *p++) != '\0')
    printf(""indirizzo: %p , carattere %c , stringa : %s\n"", p-1 , s, string);
}
"
074-12869,vmpaisante/sraa,tests/email.c,8,2,6,2076318.2546943,169083.0,12.279874381221058,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0013842121697962,1082014363648.0,0.0134490161636592,0.0785049652044725,"#define MAX(X,Y)    ( ((X)>(Y))?(X):(Y) )

int main(int argc, char **argv){
    int j ,k;
    for( j = 0; j < argc; j++ ){
        for( k = 0; k < argc; k++ ) {
	    if( MAX(j,k) ||  j ) continue;
	}
    }
}
"
223-33519,TakesxiSximada/gist,c-pthread/ret_thread.c,27,1,12,17547131251.660175,189789.0,92455.99719161808,1565.0,1527.0,43662.0,15755.0,1688.0,715.0,1382.0,670.0,1500000000,11.698087501106784,1082014363648.0,0.0162917766572351,0.0749785414948583,"#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>


void *func(){
     void *rc_p;
     rc_p = malloc(sizeof(int));
     if (rc_p == NULL) {
          fprintf(stderr, ""Cannot allocate memory"");
          return NULL;
     }
     for (int ii = 0; ii < 10; ii++ ) {
          fprintf(stdout, ""."");
          fflush(stdout);
          sleep(1);
     }

     fprintf(stdout, ""\n"");

     *(int *)rc_p = 3;
     return rc_p;
}


int main(int argc, char *argv[]) {
     int rc = 0;
     void *child_rc_p;
     pthread_t child;

     rc = pthread_create(&child, NULL, &func, NULL);
     fprintf(stdout, ""pthread_create returned %d\n"", rc);

     rc = pthread_join(child, &child_rc_p);
     fprintf(stdout, ""pthread_join returned %d\n"", *(int *)child_rc_p);
     free(child_rc_p);
     return 0;
}
"
324-31749,Dimitur-Matev/elsys-c-programming-2013-2014,10G/Stanimir_Bogdanov_24/Homework_1/print_ascii.c,9,1,5,3463190.7474249,386108.0,8.969485221751427,1333.0,1315.0,83193.0,44312.0,1618.0,672.0,1339.0,627.0,1500000000,0.0023087938316166,1082014363648.0,0.0068581847565966,0.0333790831732088,"#include <stdio.h>

int main()
{
    int i;
    for ( i = 0; i <= 255; i++ )
    {
        printf(""%c - %d \n"", i, i);
    }

    return 0;
}
"
253-1139,WooJaeWoo/Smith_Network,Part2/thread2.c,33,1,19,7503931540.413759,184285.0,40719.16618281466,1547.0,1513.0,42037.0,14909.0,1663.0,717.0,1376.0,674.0,1500000000,5.002621026942506,1082014363648.0,0.0166047155221531,0.0777929968742317,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
void* thread_main(void* arg);

int main(int argc, char* argv[])
{
	pthread_t t_id;
	int thread_param = 5;
	void* thr_ret;

	if (pthread_create(&t_id, NULL, thread_main, (void*)&thread_param) != 0)
	{
		puts(""pthread create error"");
		return -1;
	}

	if (pthread_join(t_id, &thr_ret) != 0)
	{
		puts(""pthread join error"");
		return -1;
	}

	printf(""Thread return message: %s\n"", (char*)thr_ret);
	free(thr_ret);
	return 0;
}

void* thread_main(void* arg)
{
	int i;
	int cnt = *((int*)arg);
	char* msg = (char*)malloc(sizeof(char)*50);
	strcpy(msg, ""Hello, World\n"");

	for (i = 0; i < cnt; i++)
	{
		sleep(1);
		puts(""running thread"");
	}
	return (void*)msg;
}
"
253-662,EZchip/gdb,gdb/testsuite/gdb.base/code_elim1.c,26,1,10,2727004.3501629,169057.0,16.13067781872386,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0018180029001086,1082014363648.0,0.0134155935572026,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2010-2012 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int my_global_symbol = 42;

static int my_static_symbol;

int
main ()
{
  int v_in_main;

  return v_in_main;
}

int
my_global_func ()
{
  int v_in_global_func;

  return v_in_global_func;
}
"
070-18259,alpine9000/BitOS,tests/gcc.c-torture/pr64957.c,21,1,13,1463567.95448805,170388.0,8.589613118294716,1147.0,1138.0,38697.0,12811.0,1577.0,586.0,1323.0,546.0,1500000000,0.0009757119696587,1082014363648.0,0.0134105688194004,0.0782791022753747,"/* { dg-do run } */
/* PR rtl-optimization/64957 */

__attribute__((noinline, noclone)) int
foo (int b)
{
  return (((b ^ 5) | 1) ^ 5) | 1;
}

__attribute__((noinline, noclone)) int
bar (int b)
{
  return (((b ^ ~5) & ~1) ^ ~5) & ~1;
}

int
main ()
{
  int i;
  for (i = 0; i < 16; i++)
    if (foo (i) != (i | 1) || bar (i) != (i & ~1))
      __builtin_abort ();
  return 0;
}
"
205-3607,Gurgel100/gcc,gcc/testsuite/gcc.dg/torture/pr94988.c,17,1,12,1588893.12297105,169995.0,9.34670431483279,1147.0,1138.0,38668.0,12784.0,1577.0,586.0,1323.0,546.0,1500000000,0.0010592620819807,1082014363648.0,0.0134415718109356,0.0783643007074555,"/* { dg-do run } */

short *b;

void __attribute__((noipa))
bar (short x, int j)
{
  for (int i = 0; i < j; ++i)
    *b++ = x;
}

int
main()
{
  b = (short *)&b;
  bar (0, 1);
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
  if ((short)(__UINTPTR_TYPE__)b != 0)
    __builtin_abort ();
#endif
  return 0;
}
"
153-18211,tecknicaltom/cgdb-working,tgdb/testsuite/tgdb.base/basic.c,59,4,21,13503109748.940914,200302.0,67413.75397150303,1196.0,1182.0,46601.0,16595.0,1590.0,585.0,1329.0,546.0,1500000000,9.00207316596061,1082014363648.0,0.011872073169514,0.0640863345781378,"#include <stdio.h>
#include <unistd.h>

struct global_software_watchpoint {
	int i;
	char string[1000];
} software_watchpoint;

int two(int a){
   return a*a;
}

int one(int a, int b){
   return two(a) + two(b);
}

void short_func(void){
   int i = 0;
   sleep(1);
   i = 1;
   i = 2;
}

void long_func(void){
   int k = 0;
   sleep(3);
   k = 1;
   k = 2;
}

#define SIZE 100000

struct test {
   int a;
   int b;
   int c;  
} a = { 1, 2, 3 };

int main(int argc, char **argv){
   int i = 3;
   int j = 4;
   char temp[SIZE];

   long_func();

   fprintf(stderr, ""ABCDEFGHI\n"");
   fprintf(stderr, ""ABCDEFGH\n"");
   fprintf(stderr, ""ABCDEFG\n"");
   fprintf(stderr, ""ABCDEF\n"");
   fprintf(stderr, ""ABCDE\n"");
   fprintf(stderr, ""ABCD\n"");
   fprintf(stderr, ""ABC\n"");
   fprintf(stderr, ""AB\n"");
   fprintf(stderr, ""A\n"");

   for ( i = 0; i < 100; i++)
       fprintf(stderr, ""Yo\n"");

   long_func();

   short_func();
   short_func();
   short_func();

   /* A simple loop */
   for(i = 0; i < 100000; ++i)
      j++;

   i = one(i, j);
   j = two(i);

   for(i = 0; i < 6; ++i)
      fprintf(stderr, ""returned from init\n"");

   for(i = 0; i < SIZE; ++i)
      temp[i] = (i % 40) + 40;

   i += j;
   
   return 0;
}

"
115-21676,T-J-Teru/gdb,gdb/testsuite/gdb.dwarf2/dw2-ifort-parameter.c,24,1,11,1704966.06733635,169074.0,10.08414067213173,1139.0,1129.0,38455.0,12697.0,1569.0,584.0,1319.0,544.0,1500000000,0.0011366440448909,1082014363648.0,0.0134142446502714,0.0785111041601501,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2011-2013 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int value = 0xdeadf00d;
int *ptr = &value;

void
func (void)
{
}

int
main (void)
{
  func ();
  return 0;
}
"
170-15898,dlutxx/memo,Euler/p12.c,21,2,12,212731742.76575446,595766172.0,0.3570725428834855,1336.0,1317.0,39176.0,13304.0,1619.0,636.0,1342.0,593.0,1500000000,0.1418211618438363,1082014363648.0,4.453089357346056e-06,0.0798399390243902,"#include <stdio.h>


int nfactors(long long n)
{
    long long f;
    int c=2;
    for (f=2; f*f<n; ++f) {
        if (n % f == 0)
            c += 2;
    }
    if (f*f == n) ++c;
    return c;
}

int main()
{
    long long t=0;
    long i;
    for (i=1; nfactors(t)<500; ++i) {
        t += i;
    }
    printf(""%lld\n"", t);
    return 0;
}
"
372-9437,kunth/myapue,mutex.c,42,2,20,1502185844.9326832,187308.0,8017.966803339953,1571.0,1540.0,42766.0,15299.0,1685.0,760.0,1387.0,718.0,1500000000,1.001457229955122,1082014363648.0,0.0166090076238067,0.0783604581072935,"#include <stdio.h>
#include <semaphore.h>
#include <pthread.h>

pthread_mutex_t lock;
int count;

void* task1() {
	pthread_mutex_lock(&lock);
	int i = 0;
	for (; i<100000; ++i) {
		++count;
	}
	printf(""in task1, count=%d\n"", count);
	sleep(1);
	printf(""task1 sleep over\n"");
	pthread_mutex_unlock(&lock);
	return NULL;
}

void* task2() {
	//pthread_mutex_lock(&lock);
	int i = 0;
	for (; i<100000; ++i) {
		++count;
	}
	printf(""in task2, count=%d\n"", count);
	sleep(1);
	printf(""task2 sleep over\n"");
	//pthread_mutex_unlock(&lock);
	return NULL;
}

int main(void)
{
	int ret=0;
	pthread_t t1;
	pthread_t t2;

	if (pthread_mutex_init(&lock, NULL) != 0) {
		printf(""mutex init failed\n"");
		return 1;
	}

	ret=pthread_create(&t1, NULL, task1, NULL); //创建子线程
	ret=pthread_create(&t2, NULL, task2, NULL);
	pthread_join(t1, NULL); //等待子线程结束
	pthread_join(t2, NULL);

	pthread_mutex_destroy(&lock);
	return 0;
}

"
051-31004,mlipinski2/C_zadania2,7_funkcje/zadanie3.c,18,2,11,149742200.73781905,500205617.0,0.2993612924582572,1340.0,1321.0,39802.0,13698.0,1626.0,636.0,1346.0,594.0,1500000000,0.0998281338252127,1082014363648.0,5.319812312303562e-06,0.0785420560747663,"#include <stdio.h>
int main() {
int liczba, i, suma;
 printf (""Liczby doskonałe w przedziale 1=><=10000: \n"");
  for (liczba = 1; liczba <= 10000; liczba++) /*petla*/
 {   
 i = 1;
 suma = 0;
 while (i < liczba)    
 {
if (liczba%i == 0)
 suma = suma + i;
 i++; 
 }
 if (suma == liczba)
 printf(""%d \n"", liczba);
 }   
return 0;
}

"
057-11576,DeLaSalleUniversity-Manila/LBYEC72_AY_2015_16,Hello.c,7,1,3,1889132.8945755,169083.0,11.172808620618277,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.001259421929717,1082014363648.0,0.0134490161636592,0.0785049652044725,"#include <stdio.h>
#include <stdlib.h>

  
int main(){
  
  int i;
  int sum;

  for(i = 1; i <= 10; i++)
    sum = sum + i;
    
  return 0;
}
"
027-7716,zxombie/aarch64-freebsd-binutils,gdb/testsuite/gdb.base/watch-vfork.c,32,1,12,1567441.73727915,171464.0,9.138536369150376,1150.0,1141.0,39106.0,12950.0,1595.0,590.0,1335.0,546.0,1500000000,0.0010449611581861,1082014363648.0,0.0133614053095693,0.0781081911787306,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2009-2014 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int *global;

int
main (void)
{
  int pid;

  pid = vfork ();
  if (pid == -1)
    {
      return 1;
    }
  else if (pid != 0)
    {
      global = &pid;
    }
  else
    {
      _exit (0);
    }
  return 0;
}
"
397-10867,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.base/dprintf-non-stop.c,24,1,10,6020967349.293642,170155.0,35385.192024918455,1152.0,1142.0,38704.0,12811.0,1574.0,589.0,1321.0,547.0,1500000000,4.013978232862428,1082014363648.0,0.0134818253944932,0.0782490536736872,"/* This testcase is part of GDB, the GNU debugger.

   Copyright (C) 2013-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

void
foo ()
{
}

int
main ()
{
  sleep (1);
  foo ();
  sleep (3);
  return 0;
}
"
236-3034,PassingTheKnowledge/Batchography,fib.c,13,1,8,1593421.44615945,181963.0,8.756840676401247,1340.0,1322.0,40973.0,14598.0,1617.0,637.0,1340.0,594.0,1500000000,0.0010622809641063,1082014363648.0,0.0146293477245374,0.0753630490723578,"#include <stdio.h>

int fib(int n)
{
	if (n == 0 || n == 1)
		return n;
	else
		return fib(n-2) + fib(n-1);
}

int main(int argc, char *argv[])
{
	for (int i=1; i<=8; i++)
		printf(""fib(%d)=%d\n"", i, fib(i));

	return 0;
}"
263-24559,jbaldwin/project_euler,p001/p1.c,8,1,7,1774595.93396625,182543.0,9.721517669809304,1332.0,1314.0,39175.0,13304.0,1617.0,636.0,1341.0,593.0,1500000000,0.0011830639559775,1082014363648.0,0.0144952148260957,0.079784294670249,"#include <stdio.h>

int main(int argc, char* argv[]) {

	int sum = 0;
	for(int i = 0; i < 1000; i++) {
		if(i % 3 == 0 || i % 5 == 0) sum += i;
	}

	printf(""%i"", sum);

	return 0;
}

"
274-8828,totalspectrum/binutils-propeller,gdb/testsuite/gdb.base/new-ui-pending-input.c,19,1,14,3001962382.3463917,170106.0,17640.468819441994,1153.0,1144.0,38692.0,12795.0,1574.0,585.0,1322.0,544.0,1500000000,2.0013082548975945,1082014363648.0,0.0135033449731343,0.0781750733194787,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2016-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <unistd.h>

int
main (void)
{
  sleep (2);
  return 0; /* set breakpoint here */
}
"
151-29222,mattstock/binutils-bexkat1,gdb/testsuite/gdb.base/gdb1821.c,15,1,11,1409431.33737885,169083.0,8.335734520915763,1142.0,1132.0,38461.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0009396208915859,1082014363648.0,0.0134490161636592,0.078503430615556,"/* Test printing of structure member names in gdb. PR exp/1821

   Copyright 2005-2020 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

struct foo { double x__0, y__0, z__1; } bar;


int main(void) { return (int) bar.x__0; }
"
044-33647,tenlee2012/AllCode,CSAPP/buflab-handout/chansheng.c,9,1,2,2444091.0201519,308351.0,7.926327464480414,1303.0,1287.0,75181.0,40692.0,1613.0,660.0,1336.0,617.0,1500000000,0.0016293940134346,1082014363648.0,0.0083995187302781,0.036470963900132,"#include <stdio.h>
int main()
{
    int i;
    for(i = 0; i < 509; i++)
    {
        printf(""90 "");
    }
    return 0;
}
"
260-5963,DavidBrandly/projectEulerSolutions,002/solution.c,13,1,8,2137429.6629800997,214276.0,9.975120872146205,1337.0,1317.0,39177.0,13307.0,1618.0,636.0,1340.0,593.0,1500000000,0.0014249531086534,1082014363648.0,0.0123858948272321,0.0797766938495541,"#include <stdio.h>

int main() {
	int sum = 2, a = 1, b = 2;
	//Every third fib is an even
	do {
		a += b;
		b += a;
		sum += (a += b);
		a = a^b;
		b = b^a;
		a = a^b;
	} while(a+b < 4000000);
	printf(""Problem 2: %d\n"", sum);
}
"
083-4225,mattstock/binutils-bexkat1,gdb/testsuite/gdb.base/break-unload-file.c,27,1,10,1764633.3435548998,169061.0,10.437847877393368,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0011764222290366,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

void
foo (void)
{
}

void
bar (void)
{
}

int
main (void)
{
  foo ();
  bar ();

  return 0;
}
"
327-20440,mattstock/binutils-bexkat1,gdb/testsuite/gdb.base/new-ui-pending-input.c,19,1,14,3001995467.8136854,170106.0,17647.79294675085,1153.0,1144.0,38692.0,12795.0,1574.0,585.0,1322.0,544.0,1500000000,2.0013303118757904,1082014363648.0,0.0135033449731343,0.0781750733194787,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2016-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <unistd.h>

int
main (void)
{
  sleep (2);
  return 0; /* set breakpoint here */
}
"
172-5462,JianpingZeng/xcc,xcc/java/test/jlang/CodeGen/hello.c,21,1,9,1744593.26080965,170604.0,10.221008886075357,1143.0,1135.0,38901.0,12866.0,1589.0,586.0,1332.0,546.0,1500000000,0.0011630621738731,1082014363648.0,0.0133525591428102,0.0782931211003148,"#include <stdio.h>
#include <math.h>
#include <stdlib.h>

float sqrt2(float a)
{
  float x0, x1;
  x0 = 1.0;
  do
  {
    x1 = a / (2 * x0) + x0 / 2;
    if (fabs(x0 - x1) < 10e-3)
      break;
    x0 = x1;
  }  while (1);
  return x0;
}

int main(int argc, char *argv[])
{
  if (argc != 2)
    return 0;
  float a = atof(argv[1]);
  printf(""sqrt(%f) = %f\n"", a, sqrt2(a));
  return 0;
}
"
273-19149,crazyleen/msp430-gdb-7.2a,gdb/testsuite/gdb.base/cursal.c,28,1,9,1567968.05094915,169083.0,9.273362786323876,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010453120339661,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* Copyright 2004, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */


void
func2 ()
{
  int v2 = 2;
}

void
func1 ()
{
  func2 ();
}


int
main ()
{
  int v0 = 0;
  func1 ();
}
"
327-9013,hacktoberfest17/programming,c_programming/multiples.c,11,1,6,1815618.0158256001,181880.0,16.304755882999782,1338.0,1319.0,40914.0,14448.0,1618.0,638.0,1340.0,595.0,1500000000,0.0012104120105504,1082014363648.0,0.0146085330987464,0.0757017448791589,"#include <stdio.h>

#define MAX 1000
#define THREE 3
#define FIVE 5

int main(){
	int i;
	int multiplesof3;
	int multiplesof5;
	int sum;

	for(i = 1; i < 10; i++){
		multiplesof3 = 3 * 3;
		multiplesof5 = 5 * 5;
		printf(""3: %d \t 5: %d\n"", multiplesof3, multiplesof5);
	}

}
"
140-3879,brucexiejiaming/E_language_compiler,part5/t04.c,28,2,12,2472438.26743215,174360.0,14.180075705437028,1333.0,1315.0,39444.0,13500.0,1617.0,636.0,1340.0,593.0,1500000000,0.0016482921782881,1082014363648.0,0.0151869694884147,0.0790646721063765,"#include<stdio.h>

int main(){

int i0;
i0 = 0;
 if( 20 <= 0 ){
 printf(""%d\n"", 2341 );
 }
 else if( 12 <= 0 ){
 printf(""%d\n"", 9999 );
 }
 else{printf(""%d\n"", 8888 );
}int i1;
for(i1=0; i1 - 9 <= 0;i1 = i1 + 1){
int i3;
for(i3=0; i3 - 9 <= 0;i3 = i3 + 1){
i0 = i0 + 10;
 }
}
printf(""%d\n"", i0 );
if( 20 <= 0 ){
 printf(""%d\n"", 2341 );
 }
 else if( 12 <= 0 ){
 printf(""%d\n"", 9999 );
 }
 else{printf(""%d\n"", 8888 );
}
return 0;
}
"
254-6490,MicroTrustRepos/microkernel,src/l4/pkg/valgrind/src/valgrind-3.6.0-svn/drd/tests/rwlock_race.c,35,1,20,152614714.57779405,184401.0,827.6241126675018,1479.0,1450.0,42212.0,14799.0,1695.0,705.0,1391.0,661.0,1500000000,0.1017431430518627,1082014363648.0,0.0158838618011832,0.0780901931206258,"/** Cause a race inside code protected by a reader lock.
 */


/* Needed for older glibc's (2.3 and older, at least) who don't
   otherwise ""know"" about pthread_rwlock_anything or about
   PTHREAD_MUTEX_RECURSIVE (amongst things). */

#define _GNU_SOURCE 1

#include <pthread.h>
#include <stdio.h>
#include <unistd.h>



static pthread_rwlock_t s_rwlock;
static int s_racy;

static void sleep_ms(const int ms)
{
  struct timespec delay = { ms / 1000, (ms % 1000) * 1000 * 1000 };
  nanosleep(&delay, 0);
}

static void* thread_func(void* arg)
{
  pthread_rwlock_rdlock(&s_rwlock);
  s_racy++;
  pthread_rwlock_unlock(&s_rwlock);
  sleep_ms(100);
  return 0;
}

int main(int argc, char** argv)
{
  pthread_t thread1;
  pthread_t thread2;

#if 0

  VALGRIND_DO_CLIENT_REQUEST_EXPR(0, VG_USERREQ__DRD_TRACE_ADDR,
                                  &s_racy, 0, 0, 0, 0);
#endif

  pthread_rwlock_init(&s_rwlock, 0);
  pthread_create(&thread1, 0, thread_func, 0);
  pthread_create(&thread2, 0, thread_func, 0);
  pthread_join(thread1, 0);
  pthread_join(thread2, 0);
  pthread_rwlock_destroy(&s_rwlock);

  fprintf(stderr, ""Result: %d\n"", s_racy);

  return 0;
}
"
314-22530,jonarivas/EulerProject,src/Problem12.c,37,2,18,195438190.7125935,595744871.0,0.3280568570769953,1362.0,1339.0,39924.0,13694.0,1630.0,637.0,1350.0,594.0,1500000000,0.130292127141729,1082014363648.0,4.533819981473244e-06,0.0785370584505203,"/*
 ============================================================================
 Name        : Euler.c
 Author      : Jonathan Rivas
 Version     :
 Copyright   : 
 Description : Problem #12
 ============================================================================
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int numberofDivisors(long long trianglenumber){
	long long i = 2;
	int divisorcounter = 2; //1 & trianglenumber
	while(i*i <= trianglenumber)
	{
		if(trianglenumber%i == 0){
			divisorcounter+=2;
		}
		i++;
	}
	return divisorcounter;
}

int main(void) {
	struct timeval stop, start;
	gettimeofday(&start, NULL);

	long long trianglenumber = 1, i=2;
	int divcounter = 0;
	while(divcounter < 500){
		trianglenumber+=i;
		i++;
		divcounter = numberofDivisors(trianglenumber);
	}
	printf(""%d\n"",divcounter);
	printf(""%lld"",trianglenumber);
	gettimeofday(&stop, NULL);
	printf(""\ntook %lu usec\n"", stop.tv_usec - start.tv_usec);
	return 0;
}
"
363-6788,igorioshi/prog1-2016,cont2.c,11,1,9,1937582.7396288,1804751.0,1.0736007349490315,1343.0,1323.0,381210.0,257802.0,1620.0,699.0,1340.0,656.0,1500000000,0.0012917218264192,1082014363648.0,0.0014772120918619,0.006752611844535,"#include <stdio.h>
//imprime numeros de 0 - 5000
    int main()
{
    int cont;
    
    for(cont=0; cont<5000; cont+=2)   //""cont+=2"" para add de 2 em 2
    {
        
        printf(""\n%d"", cont);
    }
    
    printf(""\nEste num = %d"", cont);
    return 0;   
}"
166-30377,dyladan/euler,c/4.1.c,39,3,19,100529767.34004915,732660954.0,0.1372118528374585,1369.0,1346.0,132315578.0,112039095.0,1643.0,638.0,1362.0,594.0,1500000000,0.0670198448933661,1082014363648.0,3.705670385704764e-06,1.7339549712642493e-05,"#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>



void reverse_string(char *str){
  char temp;
  size_t len = strlen(str) - 1;
  size_t i;
  size_t k = len;
  for(i = 0; i < (len +1)/2; i++){
    temp = str[k];
    str[k] = str[i];
    str[i] = temp;
    k--;
  }
}

int isPalindrome(int n){
  char str[10];
  char rev[10];
  sprintf(str, ""%d"", n);
  strcpy(rev, str);
  reverse_string(rev);
  if(strcmp(str,rev) == 0){
    return 1;
  } else {
    return 0;
  }
}

int main(int argc, char *argv[]){
  int a, b, product, large;
  for(a = 100; a < 1000; a++){
    for(b = 100; b < 1000; b++){
      product = a*b;
      if(isPalindrome(product)){
        //printf(""%d\n"", product);
        if(product > large){
          large = product;
        }
      }
    }
  }
  printf(""Largest is %d\n"", large);
}

"
372-30425,Ivan-Killer/po-homework,2015-2016/A/23/02/task1.c,9,1,4,2144747.76294075,385145.0,5.568674135715121,1345.0,1326.0,82694.0,43805.0,1618.0,658.0,1340.0,615.0,1500000000,0.0014298318419605,1082014363648.0,0.0069350504355502,0.0334469047186143,"#include <stdio.h>
int main()
{
	int i=0;
	for (i=0;i<=255;i++)
	{
		printf(""%d %c\n"",i,i);
	}
	return 0;
}
"
198-5510,totalspectrum/binutils-propeller,gdb/testsuite/gdb.trace/qtro.c,26,1,10,1582219.38181665,169083.0,9.354240225214836,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010548129212111,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2013-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

void
subr (int parm)
{
}

void
end (void)
{
}

int
main ()
{
  subr (1);
  end ();
}
"
221-27221,Enether/algos,modular_exponential/modular_exponential.c,20,1,8,2081644.60491375,173204.0,19.6301413362278,1339.0,1320.0,39176.0,13303.0,1621.0,634.0,1343.0,590.0,1500000000,0.0013877630699425,1082014363648.0,0.0153518394494353,0.0798033499113931,"#include <stdio.h>

// Time Complexity : O(log (power))
long long modularExponential(long long base, long power, long long mod) {
	long long answer = 1;
	base = base % mod;
	while (power) {
		if (power & 1) {
			answer = (answer * base) % mod;
		}
		power = power >> 1;
		base = (base * base) % mod;
	}
	return answer;
}

int main() {
	long long base = 2;
	long power = 10;
	long long mod = 100000;
	printf(""%lld\n"", modularExponential(base, power, mod));
	return 0;
}
"
077-18017,xdje42/gdb,gdb/testsuite/gdb.base/annota-input-while-running.c,18,1,13,7502106628.613546,170060.0,44114.46917558509,1150.0,1141.0,38683.0,12795.0,1575.0,581.0,1324.0,544.0,1500000000,5.001404419075698,1082014363648.0,0.0134717158649888,0.0781693150472046,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
main (void)
{
  sleep (5);
  return 0; /* set break here */
}
"
260-11765,Junnplus/leetcode,algorithms/easy/majority-element.c,41,4,14,2015133.1555098,178294.0,11.295730647133386,1346.0,1328.0,40312.0,14008.0,1626.0,638.0,1344.0,594.0,1500000000,0.0013434221036732,1082014363648.0,0.0149977004273839,0.0773564064801178,"#include <stdio.h>
#include <stdlib.h>

int partition(int *nums, int start, int end) {
    if (start >= end)
        return start;
    int v = nums[start], i = start, j = end, tmp;
    while (i != j) {
        while (i < j && nums[j] >= v)
            j --;
        while (i < j && nums[i] <= v)
            i ++;
        if (i < j) {
            tmp = nums[i];
            nums[i] = nums[j];
            nums[j] = tmp;
        }
        printf(""%d,%d\n"", i,j);
    }
    nums[start] = nums[i];
    nums[i] = v;
    return i;
}

int majorityElement(int* nums, int numsSize){
    int start =0, end = numsSize - 1;
    int index = partition(nums, start, end);
    int mid = numsSize / 2;
    while (index != mid) {
        printf(""%d,\n"", index);
        if (index > mid) {
            end = index - 1;
            index = partition(nums, start, end);
        }
        else {
            start = index + 1;
            index = partition(nums, start, end);
        }
    }
    return nums[mid];
}


int main() {
    int nums1[5] = {6,6,6,7,7};
    printf(""%d\n"", majorityElement(nums1, 5));
}
"
169-6354,tecknicaltom/cgdb-working,tgdb/tgdb-base/src/test.c,52,4,21,12002958523.342386,172501.0,69581.96487556594,1292.0,1274.0,39030.0,13222.0,1606.0,634.0,1333.0,592.0,1500000000,8.001972348894924,1082014363648.0,0.014875276085356,0.0797098675648779,"#include <stdio.h>
#include <unistd.h>

int two(int a){
   return a*a;
}

int one(int a, int b){
   return two(a) + two(b);
}

void short_func(void){
   int i = 0;
   sleep(1);
   i = 1;
   i = 2;
}

void long_func(void){
   int k = 0;
   sleep(5);
   k = 1;
   k = 2;
}

#define SIZE 100000

struct test {
   int a;
   int b;
   int c;  
} a = { 1, 2, 3 };

int main(int argc, char **argv){
   int i = 3;
   int j = 4;
   char temp[SIZE];

   long_func();

   fprintf(stderr, ""HAHAAHA\n"");
   fprintf(stderr, ""AHAAHA\n"");
   fprintf(stderr, ""HAAHA\n"");
   fprintf(stderr, ""AAHA\n"");
   fprintf(stderr, ""AHA\n"");
   fprintf(stderr, ""HA\n"");
   fprintf(stderr, ""A\n"");

   for ( i = 0; i < 100; i++)
       fprintf(stderr, ""Yo\n"");

   /*long_func();*/

   short_func();
   short_func();
   short_func();

   for(i = 0; i < 100000; ++i)
      j++;

   i = one(i, j);
   j = two(i);

   for(i = 0; i < 6; ++i)
      fprintf(stderr, ""returned from init\n"");

   for(i = 0; i < SIZE; ++i)
      temp[i] = (i % 40) + 40;

   i += j;
   
   return 0;
}

"
177-34275,EvtimPavlov/c-programming-2014-2015-homework,A/03_Antonio_Mindov/homework_3/task_4.c,11,1,3,2052197.93133435,173200.0,11.84871247113164,1338.0,1319.0,39184.0,13309.0,1618.0,636.0,1340.0,593.0,1500000000,0.0013681319542229,1082014363648.0,0.0153406466512702,0.0797630160211837,"#include <stdio.h>

int main ()
{
	int i;
	int numb = 1;
	
	for (i = 1; i < 11; i += 1)
	{
		numb *= i;
	}
	
	printf(""%d\n"",numb);
	return 0;
}
"
300-27185,EvtimPavlov/c-programming-2014-2015-homework,B/24_Plamen_Neshkov/First_Term/homework_3/task_2.c,17,1,4,1816818.024963,251145.0,7.234139640446754,1339.0,1319.0,54115.0,23979.0,1620.0,656.0,1342.0,613.0,1500000000,0.001211212016642,1082014363648.0,0.010583527444305,0.054178297948626,"#include <stdio.h>

int main() {
	int i;
	long long unsigned x=2,y=1,z=0;
	for (i=0; i<100; i++) {
		if (i==0)
			z=2;
		else if (i==1)
			z=1;
		else {
			z=x+y;
			x=y;
			y=z;
		}
		printf(""%llu, "", z);
	}
	return 0;
}
"
323-1618,todaygood/my_c,basic/fopen.c,13,1,6,15003893950.372004,182295.0,82305.57036671329,1431.0,1401.0,41383.0,14730.0,1635.0,643.0,1355.0,600.0,1500000000,10.002595966914669,1082014363648.0,0.0155352587838393,0.0754370644948585,"#include <stdio.h>
#include <unistd.h>

int main()
{
    FILE* fp = NULL;
    int i=0;

    fp= fopen(""/tmp/file"",""w"");
    for(i=0; i<10;i++)
    {
        sleep(1);
        fprintf(fp,""%d\n"",i);

    }

    fclose(fp);
    return 0;

}



"
244-15100,orangebook/FlyLab,example/demo-c_language/pthread/pthread.c,17,1,10,7504184259.334579,187357.0,40052.86303153872,1523.0,1494.0,42932.0,15513.0,1671.0,739.0,1368.0,696.0,1500000000,5.002789506223053,1082014363648.0,0.0161029478482255,0.0765506031311489,"#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

#define NUM 5
void *print(void *m) {
  char *cp = (char*) m;
  for (int i=0;i<NUM; ++i) {
    printf(""%s\n"", cp);
    fflush(stdout);
    sleep(1);
  }
  return NULL;
}

int main(int argc, char* argv[]) {
  pthread_t t1, t2;
  pthread_create(&t1, NULL, print, (void *) ""t1 thread"");
  pthread_create(&t2, NULL, print, (void *)""t2 thread"");
  pthread_join(t1, NULL);
  pthread_join(t2, NULL);
  return 0;
}"
209-3688,Eddyding/C,niukewang/time_diff6.c,19,2,11,4520880006.020888,176421.0,25186.299374790982,1461.0,1435.0,39962.0,13759.0,1644.0,638.0,1360.0,593.0,1500000000,3.013920004013926,1082014363648.0,0.0164152793601668,0.0788332309525139,"#include<stdio.h>
#include<time.h>
#include<unistd.h>

int
main()
{
	clock_t start,finish;
	double duration;
	
	long i,j;

	start = clock();

	sleep(3);// do not affect clock()

	for(i=0;i<100;++i)
	{
		for(j=0;j<1000000;++j)
		 ;
	}

	finish=clock();

	duration = (double)(finish-start)/CLOCKS_PER_SEC;
	
	printf(""Time to do %ld empty loops is "",i*j);
	printf(""%lf seconds\n"",duration);
	return 0;
}
"
178-27654,AlienCowEatCake/ImageViewer,src/ThirdParty/aom/aom-v3.2.0/tools/auto_refactor/c_files/struct_code.c,42,3,16,1909593.1202172001,169057.0,11.295557119788,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0012730620801448,1082014363648.0,0.0134155935572026,0.0785563462891999,"/*
 * Copyright (c) 2021, Alliance for Open Media. All rights reserved
 *
 * This source code is subject to the terms of the BSD 2 Clause License and
 * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License
 * was not distributed with this source code in the LICENSE file, you can
 * obtain it at www.aomedia.org/license/software. If the Alliance for Open
 * Media Patent License 1.0 was not distributed with this source code in the
 * PATENTS file, you can obtain it at www.aomedia.org/license/patent.
 */

typedef struct S1 {
  int x;
} T1;

struct S3 {
  int x;
};

typedef struct {
  int x;
  struct S3 s3;
} T4;

typedef union U5 {
  int x;
  double y;
} T5;

typedef struct S6 {
  struct {
    int x;
  };
  union {
    int y;
    int z;
  };
} T6;

typedef struct S7 {
  struct {
    int x;
  } y;
  union {
    int w;
  } z;
} T7;

int main() {}
"
186-11448,wchuanghard/C-Programming,000F_perf_001.c,16,1,13,15041287317.057138,174551.0,86171.30418616909,1348.0,1327.0,39576.0,13486.0,1630.0,637.0,1350.0,592.0,1500000000,10.027524878038092,1082014363648.0,0.015325033944234,0.0793223022125061,"#include <stdio.h>
#include <unistd.h>

double compute_pi_baseline(size_t N) {
  double pi = 0.0;
  double dt = 1.0 / N;
  for (size_t i = 0; i < N; i++) {
    double x = (double) i / N;
    pi += dt / (1.0 + x * x);
  }
  return pi * 4.0;
}
int main() {
  printf(""pid: %d\n"", getpid());
  sleep(10);
  compute_pi_baseline(50000000);
  return 0;
}

//perf top -p $pid
"
282-30350,racing19th/LN-DOS,sh/echo.c,10,1,4,1818721.7647209,173436.0,10.486409972554718,1270.0,1257.0,39324.0,13350.0,1620.0,632.0,1336.0,592.0,1500000000,0.0012124811764806,1082014363648.0,0.0145702161027698,0.0793560390325397,"#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv) {
	for (int i = 1; i < argc; i++) {
		if (i != 1) {
			putc(' ', stdout);
		}
		fputs(argv[i], stdout);
	}
	putc('\n', stdout);
	return 0;
}"
029-28187,misizeji/StudyNote_201308,Linux_System/pthread/pthread_exit.c,23,1,10,6004043902.619741,253047.0,23726.991041189976,2192.0,1735.0,59979.0,23080.0,2151.0,822.0,1631.0,752.0,1500000000,4.002695935079828,1082014363648.0,0.0155188561808675,0.0644842822571906,"
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>


void *func1(void *arg)
{
	int i = 0;
	static char buf[] = ""hello"";
	for (i = 0;i < 5;i++)
	{
		printf(""in func1\n"");
		sleep(1);
		if (i == 3)
		{
			pthread_exit((void *)buf);
		}
	}
}

int main(int argc, char *argv[])
{
	int *save = NULL;
	pthread_t tid;

	pthread_create(&tid,NULL,func1,NULL);

	
	pthread_join(tid,((void*)&save));
	
	printf(""%s\n"",((char *)save));
	return 0;
}
"
280-8387,ksk9687/go_for_it_3,gen.c,7,1,8,3992287.5585033,10685151.0,0.3734859713260018,1268.0,1252.0,2742109.0,1814798.0,1612.0,696.0,1331.0,655.0,1500000000,0.0026615250390022,1082014363648.0,0.0002358413091214,0.0009423058227872,"#include<stdio.h>


int main(void){
	unsigned long long r = 16;
	
	for(int i = 0; i < 300000 ; i++){
		r = ( r * 1103515245 + 12345 ) & 0xFFFFFFFF;
		putc(0x61 + ( 26 * ( r / 0x10000) ) / 0x10000,stdout);
	}
}
"
103-18945,andremilke/utility,portscan.c,31,1,8,2136949.4497776,177503.0,12.038945820634018,1342.0,1320.0,40384.0,13809.0,1649.0,638.0,1366.0,595.0,1500000000,0.0014246329665184,1082014363648.0,0.0149969296293583,0.0783865074825161,"#include <stdio.h>
#include <netdb.h>
int main(int argc, char *argv[])
{
	int mysocket;
	int conn;
	int port;
	int start = 0;
	int end  = 65535;
	char * destiny;
	if(argc < 2)
	{
		printf(""How to use portscan\n"");
		printf(""%s 10.1.1.101\n"",argv[0]);
		return 0;	
	}

	destiny = argv[1];
	struct sockaddr_in alvo;
	
	for(port = start; port < end; port++)
	{
		mysocket = socket(AF_INET, SOCK_STREAM, 0);
		alvo.sin_family = AF_INET;
		alvo.sin_port = htons(port);
		alvo.sin_addr.s_addr = inet_addr(destiny);
	
		conn = connect(mysocket, (struct sockaddr *)&alvo, sizeof alvo);
		if(conn == 0)
		{
			printf(""Port %d - status [OPENNED] \n"", port);
		}
		close(mysocket);
		close(conn);
	}
}
"
341-32127,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.multi/watchpoint-multi.c,37,1,12,1563426.1071681,176584.0,8.853724006705024,1364.0,1338.0,40215.0,13799.0,1635.0,661.0,1354.0,615.0,1500000000,0.0010422840714454,1082014363648.0,0.0153014995696099,0.0789610101084904,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2012-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <pthread.h>
#include <assert.h>

static volatile int a, b, c;

static void
marker_exit (void)
{
  a = 1;
}

static void *
start (void *arg)
{
  b = 2;
  c = 3;

  return NULL;
}

int
main (void)
{
  pthread_t thread;
  int i;

  i = pthread_create (&thread, NULL, start, NULL);
  assert (i == 0);
  i = pthread_join (thread, NULL);
  assert (i == 0);

  marker_exit ();
  return 0;
}
"
245-19113,ledongthuc/example,c-programming-language/src/5_control_flows/break.c,10,1,3,2092984.621413,174415.0,12.0000229338073,1343.0,1325.0,39543.0,13504.0,1626.0,636.0,1346.0,594.0,1500000000,0.001395323080942,1082014363648.0,0.0152968494682223,0.0792127735781476,"#include <stdio.h>

int main() {
    int counter;
    for(counter = 1; counter < 7; counter++) {
        if(counter == 3) {
            printf(""We call break and you won't see counter = 3 or higher\n"");
            break;
        }        
        
        printf(""Number of counter: %d\n"", counter);
    }
}
"
112-5069,kgraves/ctci,edition4/c/ch01/1-4.c,33,2,11,1749632.88009165,172394.0,10.14903070872536,1157.0,1150.0,39245.0,13230.0,1588.0,588.0,1334.0,546.0,1500000000,0.0011664219200611,1082014363648.0,0.0133821362692437,0.0772939494997617,"#include <assert.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void markSeen(char *str, int *hasSeen) {
  int length = strlen(str);
  for (int i=0; i<length; i++) {
    hasSeen[str[i]] += 1;
  }
}

int isAnagram(char *str1, char *str2) {
  int len1 = strlen(str1);
  int len2 = strlen(str2);

  if (len1 != len2) {
    return 0;
  } else {
    int hasSeen1[256] = {0};
    int hasSeen2[256] = {0};

    markSeen(str1, hasSeen1);
    markSeen(str2, hasSeen2);

    for (int i=0; i < len1; i++) {
      if (hasSeen1[i] != hasSeen2[i]) {
        return 0;
      }
    }

    return 1;
  }
}

int main() {
  // tests
  char str1[] = ""This is a test string"";
  char str2[] = ""string test a is This"";
  char str3[] = ""Not an anagram"";
  assert(isAnagram(str1, str2) == 1);
  assert(isAnagram(str1, str3) == 0);

  return 0;
}
"
179-34725,kujenga/euler,Euler_10/PrimeSum.c,26,2,16,529567441.6702241,1803994191.0,0.2935527418225483,1336.0,1317.0,39193.0,13319.0,1620.0,636.0,1342.0,593.0,1500000000,0.3530449611134827,1082014363648.0,1.4706255780842478e-06,0.0798103290676416,"#include <stdio.h>

int isPrime ( int n )
{
	if ( n == 2 ) return 1;
	if ( n < 2 ) return 0;
	//if ( n%2 == 0 )	return 0;
	int i = 2;
	while ( i*i <= n ) {
		if ( n%i == 0 ) return 0;
		i++;
	}
	return 1;
}

int main(void) {
	// your code goes here
	long long unsigned sum = 0;
	int i = 0;
	while ( i < 2000000 ) {
		if ( isPrime(i) ){
			sum+=i;
			//printf("" %i "",i);
		}
		i++;
	}
	printf(""\nsum: %llu\n"",sum);
	
	return 0;
}
"
176-23964,wuzhouhui/leetcode,70_climbing_stair.c,16,1,6,1721298.2056662,170391.0,10.102047643361445,1142.0,1134.0,38713.0,12787.0,1581.0,590.0,1325.0,547.0,1500000000,0.0011475321371108,1082014363648.0,0.013357513014185,0.078504854368932,"
int climbStairs(int n)
{
	if (!n || n == 1 || n == 2)
		return(n);

	int	x[n + 1], i;

	for (i = 1; i <= n; i++) {
		if (i == 1 || i == 2) {
			x[i] = i;
			continue;
		}
		x[i] = x[i - 1] + x[i - 2];
	}
	return(x[n]);
}

int main(void)
{}
"
004-27100,AtomicSushi/CS1020,cmdLine.c,11,1,9,2112962.8876224,173396.0,12.18575976377771,1351.0,1330.0,39233.0,13339.0,1618.0,637.0,1340.0,594.0,1500000000,0.0014086419250816,1082014363648.0,0.0154617176866825,0.0796811991174009,"/* File: cmdLine.c 
   Author: Cindy_
   Description: Gets arguments from command line and prints
*/
#include <stdio.h>

int main( int argc, char *argv[]){
   int i, n = argc;
   for ( i = 0; i < n; i++ ) {
      printf(""Argument %d is %s\n"", i, argv[i] );
   }
   return( 0 );
}
"
367-12487,Rjerk/snippets,c/CPractice/test.c,13,1,6,1614440.8145919,175577.0,9.195054021882138,1412.0,1389.0,39598.0,13573.0,1631.0,642.0,1349.0,598.0,1500000000,0.0010762938763946,1082014363648.0,0.0159531145879016,0.0793665720035357,"#include <stdio.h>

int main ()
{
	float sum = 0;
	int i = 1;
	for (i=1; i<= 100; i++)
	{
		if (i%2 == 0)
			sum += i;
		else 
			sum -= i;
	}
	printf (""%f\n"", sum);
}

"
185-16371,EvtimPavlov/c-programming-2014-2015-homework,B/26_Russi_Russev/Homework-3/Zada4aNo2.c,17,1,8,1878108.2471832,338228.0,5.552786877490924,1344.0,1324.0,69721.0,35379.0,1622.0,689.0,1342.0,646.0,1500000000,0.0012520721647888,1082014363648.0,0.0078881701101032,0.0409039010466222,"#include <stdio.h>

  int main()
    {
      long long unsigned int x,y,z;
    x=2;
        printf(""%i, "" ,x);
    y=1;
        printf(""%i, "" ,y);
    z=0;
      while(z<98){
    x=y+x;
    y=x+y;
        printf(""%llu, "" ,x);
        printf(""%llu, "" ,y);
    z++;
    }
return 0;
}   
"
332-3388,LorhanSohaky/UFSCar,2017/cap/aula_03-05/ex1.c,7,1,3,2120972.8438407,178527.0,11.880399043281969,1336.0,1318.0,40359.0,14145.0,1617.0,636.0,1340.0,593.0,1500000000,0.0014139818958938,1082014363648.0,0.0148660986853529,0.0768017026273301,"#include <stdio.h>

int main(){
	int i;
	
	for(i=0;i<10;i++){
		printf(""%d\n"",i);
	}
	return 0;
}
"
117-4062,CCoder123/codemisc,threadpool/src/threadpool/thread_test.c,56,2,16,10537835368.537344,193812.0,54371.428848574906,1582.0,1539.0,44256.0,16099.0,1695.0,714.0,1397.0,670.0,1500000000,7.025223579024896,1082014363648.0,0.0161032340618743,0.0741612128241239,"#include <pthread.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>

#define PID (unsigned int)pthread_self()

pthread_mutex_t mymutex1 = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t mymutex2 = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t mycond = PTHREAD_COND_INITIALIZER;

int a = 0;

void *mythread1(void *param)
{
    printf(""AAAAAAAAAAAAAAA begin mythread1.  %u\n"", PID);
    
    pthread_mutex_lock(&mymutex1);
    while(a != 1)
    {
        printf(""AAAAAAAAAAAAAA wait in mythread1.....\n"");
        pthread_cond_wait(&mycond,&mymutex1);
    }
    pthread_mutex_unlock(&mymutex1);
    
    printf(""AAAAAAAAAAAAA end mythread1.  %u\n"", PID);
    return NULL;
}

void *mythread2(void *param)
{
    printf(""begin mythread2.  %u\n"", PID);

    pthread_mutex_lock(&mymutex1);
    while(a != 1)
    {
        printf(""wait in mythread2.\n"");
        pthread_cond_wait(&mycond,&mymutex1);
    }
    pthread_mutex_unlock(&mymutex1);

    printf(""end mythread2.  %u\n"", PID);
    return NULL;
}

int main(void)
{
    printf(""begin main thread.  %u\n"", PID);
    
    int i;
    pthread_t tid1,tid2;
    pthread_create(&tid1,NULL,mythread1,NULL);
    pthread_create(&tid2,NULL,mythread2,NULL);
    sleep(2);
    
    a = 2;
    printf(""\n==============try to wake up mythread1 and mythread2 in main thread. a=%d  %u\n"", PID, a);
    if(pthread_cond_broadcast(&mycond)){
        printf(""error\n"");
        return -1;
    }

    sleep(5);
    a = 1;
    printf(""\n===============try to wake up mythread1 and mythread2 in main thread.  a=%d   %u\n"", PID, a);
    if(pthread_cond_broadcast(&mycond)){
        printf(""error\n"");
        return -1;
    }
    
    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);
    
    printf(""end main thread.  %u\n"", PID);
    return 0;
}
"
366-4006,IntelBuap2014/Gcc,0g/Ofast/ejemploOptimizacion.c,17,2,9,258690771.18113625,2400175638.0,0.107779933645006,1448.0,1420.0,39764.0,13658.0,1633.0,634.0,1351.0,590.0,1500000000,0.1724605141207575,1082014363648.0,1.1949125533120672e-06,0.0787690464602598,"#include <stdio.h>
double funcion(double a, unsigned valor){
	double x = 1.0;
	unsigned j;
	for (j = 0;  j < valor; j++) {
		x *= a;
	}	 
	return x;
}

int main(int argc, const char *argv[]){
	double suma = 0.0;
	unsigned i;
	for (i = 0;  i < 100000000; i++) {
		suma += funcion(i, i % 5);	
	}	 
	printf(""suma = %g\n"", suma);
	
	return 0;
}
"
169-25663,SanDisk-Open-Source/SSD_Dashboard,uefi/gcc/gcc-4.6.3/gcc/testsuite/gcc.c-torture/execute/loop-12.c,21,1,14,1528596.1562767501,169112.0,9.038956431240834,1143.0,1133.0,38467.0,12702.0,1569.0,585.0,1318.0,546.0,1500000000,0.0010190641041845,1082014363648.0,0.0134585363546052,0.0785241063925423,"/* Checks that pure functions are not treated as const.  */

char *p;

static int __attribute__ ((pure))
is_end_of_statement (void)
{
  return *p == '\n' || *p == ';' || *p == '!';
}

void foo (void)
{
  /* The is_end_of_statement call was moved out of the loop at one stage,
     resulting in an endless loop.  */
  while (!is_end_of_statement ())
    p++;
}

int
main (void)
{
  p = ""abc\n"";
  foo ();
  return 0;
}
"
374-11259,bt3gl/My-Gray-Hacker-Resources,Reverse_Engineering/Tools/IntroX86/IntroToAsm_code_for_class/Example5/Example5.c,7,1,5,3117874.4975476502,179013.0,17.411333255126724,1338.0,1319.0,40432.0,14187.0,1618.0,637.0,1340.0,594.0,1500000000,0.0020785829983651,1082014363648.0,0.0148424974722506,0.0766949230121386,"//Simple loop with single variable
#include <stdio.h>

int main(){
   int i;
   for(i = 0; i < 10; i++){
      printf(""i = %d\n"", i);
   }
}"
268-7369,mattstock/binutils-bexkat1,gdb/testsuite/gdb.multi/stop-all-on-exit.c,19,1,9,1501948060.4678392,170067.0,8831.507935107928,1151.0,1141.0,38683.0,12795.0,1574.0,589.0,1321.0,547.0,1500000000,1.0012987069785595,1082014363648.0,0.01347704140133,0.0783052954660243,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

static unsigned int duration = 1;

int
main ()
{
  sleep (duration);
  return 0;
}
"
202-1516,paramsingh/cp,src/practice/numbers/euler/47.c,36,4,14,142325169.1740006,199247127.0,0.7143147865815902,1356.0,1335.0,10637610.0,30143749.0,640377.0,19684189.0,1341.0,625594.0,1500000000,0.0948834461160004,1082014363648.0,1.3505840914835376e-05,0.5137519080715285,"#include <stdio.h>
#include <stdlib.h>
#define MAX 10000000

int* seive;

int distinct(int n) {
    int x = seive[n], prev = 1;
    int count = 0;
    while (n != 1) {
        if (x != prev) {
            count++;
        }
        prev = x;
        n /= x;
        x = seive[n];
    }
    return count;
}
int main(void) {
    seive = (int *) calloc(MAX, sizeof(int));
    int i, j;
    for (i = 2; i < MAX; i++) {
        if (seive[i] == 0) {
            for (j = i; j < MAX; j+=i)
                seive[j] = i;
        }
    }
    int c = 0;
    int x = 1;
    int n = 4;
    while (c != n) {
        if (distinct(x) == n)
            c++;
        else
            c = 0;
        x++;
    }
    printf(""%d\n"", x-n);
    return 0;
}

"
329-30853,tperdue321/learn-c-the-hard-way,ex14.c,19,2,10,1717759.2962979,185706.0,9.249884225603912,1361.0,1340.0,41845.0,14995.0,1632.0,637.0,1351.0,595.0,1500000000,0.0011451728641986,1082014363648.0,0.0145444950620873,0.0741555242786769,"#include <stdio.h>
#include <ctype.h>

int isAlphaOrBlank(char ch);
void printLetters(char arg[]);

void printArgs(int argc, char *argv[]) {
  for(int i = 0; i < argc; i++)
    printLetters(argv[i]);
}

void printLetters(char arg[]) {
  for(int i = 0; arg[i]; i++) 
    if(isAlphaOrBlank(arg[i]))
      printf(""'%c' == %d "", arg[i], arg[i]);

  printf(""\n"");
}

int isAlphaOrBlank(char ch) {
  return isalpha(ch) || isblank(ch);
}

int main(int argc, char *argv[]) {
  printArgs(argc, argv);
  return 0;
} // end main
"
372-11428,totalspectrum/binutils-propeller,gdb/testsuite/gdb.base/continue-all-already-running.c,18,1,14,15001924130.832777,170055.0,88218.07138866837,1149.0,1140.0,38683.0,12795.0,1574.0,581.0,1323.0,544.0,1500000000,10.001282753888518,1082014363648.0,0.0134603510628914,0.0781304634989704,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
main (void)
{
  sleep (10);
  return 0; /* set break here */
}
"
288-34432,swigger/gdb-ios,gdb/testsuite/gdb.base/paginate-after-ctrl-c-running.c,18,1,14,15001986451.330595,170055.0,88218.4378642204,1149.0,1140.0,38683.0,12795.0,1575.0,581.0,1324.0,544.0,1500000000,10.001324300887063,1082014363648.0,0.0134603510628914,0.0781693150472046,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2016 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
main (void)
{
  sleep (10);
  return 0; /* after sleep */
}
"
109-9410,mattstock/binutils-bexkat1,gdb/testsuite/gdb.base/double-prompt-target-event-error.c,18,1,14,4501811827.649363,170064.0,26471.280382679462,1150.0,1141.0,38683.0,12795.0,1574.0,581.0,1323.0,544.0,1500000000,3.001207885099575,1082014363648.0,0.0134713990027283,0.0781304634989704,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
main (void)
{
  sleep (3);
  return 0; /* after sleep */
}
"
146-40,SMERM/SPERM,INCONTRI/A.A.2019-2020/20200320/struct3.c,26,1,14,1794097.47943275,176257.0,10.175437003920411,1333.0,1313.0,39865.0,13715.0,1626.0,643.0,1345.0,600.0,1500000000,0.0011960649862885,1082014363648.0,0.0150121697294291,0.0786487495334079,"#include <string.h>
#include <stdio.h>
struct persona
{
  char nome    [20] ;
  char cognome [20] ;
  char numero  [128];
  char soprannome[34];
};
/*utilizzare la struttura dopo averla definita*/
int main()
{
  const int num = 2;
  struct persona aggendina [num];
  int i;

  strcpy(aggendina[0].nome, ""Giulio"");
  strcpy(aggendina[0].cognome, ""De Mattia"");
  strcpy(aggendina[0].numero, ""342-3232-342"");
  strcpy(aggendina[0].soprannome, ""er patata"");
  strcpy(aggendina[1].nome, ""TRUMP"");
  strcpy(aggendina[1].cognome, ""DONUTS"");
  strcpy(aggendina[1].numero, ""342-3232-666"");
  strcpy(aggendina[1].soprannome, ""er CHICCO FRESCO"");

  for (i = 0; i < num; ++i)
  {
    printf(""nome:\t%s,\ncognome:\t%s,\nnumero:\t%s,\nsoprannome:\t%s,\n\n"", aggendina[i].nome , aggendina[i].cognome , aggendina[i].numero , aggendina[i].soprannome);
  }

}
"
317-2728,Prabudh/Miscellaneous,revision/binarySearch.c,35,1,13,3389601.1300384495,181221.0,18.69841243564488,1345.0,1326.0,40926.0,14545.0,1619.0,638.0,1340.0,594.0,1500000000,0.0022597340866923,1082014363648.0,0.0147389099497298,0.0755529916532963,"#include<stdio.h>
int arr[10] = {0,1,2,3,4,5,6,7,8,9};

void binarySearch(int * ar, int num, int sizeOfArray)
{
int i = 0;
int iOld = -1;
for(i= sizeOfArray/2; i< sizeOfArray && i>=0;)
{
printf(""%d\n"",i);
if(iOld==i)
break;
if(ar[i] == num)
{
printf(""%d Found\n"", num);
return;
}
else if(ar[i]>num)
{
iOld =i;
i= i-i/2-1;
}
else
{
iOld = i;
i = i+(sizeOfArray-i)/2;
}
}
printf(""%d Not found\n"", num);
}

int main()
{
binarySearch(arr,8,10);
binarySearch(arr,-1,10);
binarySearch(arr,10,10);
return 0;
}

"
316-26034,ayueha/infomatic-pj,src/compilers/libmax.c,14,1,5,2122534.6717983,173073.0,12.26380775742028,1338.0,1319.0,39177.0,13302.0,1618.0,636.0,1340.0,593.0,1500000000,0.0014150231145322,1082014363648.0,0.0153519035320356,0.079784294670249,"#include <stdio.h>
 int max(int *m, int count) {
      int largest = -99999;
      int i;
      for (i = 0; i < count; i++) {
          if (m[i] > largest) {
              largest = m[i];
          }
      }
      return largest;
 }


 int main() {
     int nums[5] = {5,9,21,17,39};
     printf(""largest number is: %d"", max(nums, 5));
 }

"
319-1927,jsj2008/gnustep-base,config/config.proccmd.c,32,1,16,1769929.6586214,179027.0,9.886380266663688,1432.0,1400.0,40785.0,14108.0,1649.0,645.0,1368.0,600.0,1500000000,0.0011799531057476,1082014363648.0,0.0158188429678204,0.0776419579910006,"/*
 * Check to see if the final cmdline arg recorded in the /proc filesystem
 * is terminated by a nul.
 */
/*
  Copyright (C) 2005 Free Software Foundation

  Copying and distribution of this file, with or without modification,
  are permitted in any medium without royalty provided the copyright
  notice and this notice are preserved.
*/
#include <stdio.h>
int main()
{
  char	buf[32];
  FILE	*fptr;
  int	result = 1;
  int	c;

  sprintf(buf, ""/proc/%d/cmdline"", getpid());
  fptr = fopen(buf, ""r"");
  if (fptr != 0)
    {
      while ((c = fgetc(fptr)) != EOF)
	{
	  result = c;
	}
      fclose(fptr);
    }
  if (result != 0)
    {
      result = 1;
    }
  return result;
}
"
311-19741,alpine9000/BitOS,tests/gcc.c-torture/20081218-1.c,35,2,11,1437108.03240525,175302.0,8.197898483759456,1146.0,1137.0,39700.0,12913.0,1576.0,598.0,1322.0,556.0,1500000000,0.0009580720216035,1082014363648.0,0.0130232398945819,0.0770151863607853,"/* { dg-do run } */
struct A { int i, j; char pad[512]; } a;

int __attribute__((noinline))
foo (void)
{
  __builtin_memset (&a, 0x26, sizeof a);
  return a.i;
}

void __attribute__((noinline))
bar (void)
{
  __builtin_memset (&a, 0x36, sizeof a);
  a.i = 0x36363636;
  a.j = 0x36373636;
}

int
main (void)
{
  int i;
  if (sizeof (int) != 4 || __CHAR_BIT__ != 8)
    return 0;

  if (foo () != 0x26262626)
    __builtin_abort ();
  for (i = 0; i < sizeof a; i++)
    if (((char *)&a)[i] != 0x26)
      __builtin_abort ();

  bar ();
  if (a.j != 0x36373636)
    __builtin_abort ();
  a.j = 0x36363636;
  for (i = 0; i < sizeof a; i++)
    if (((char *)&a)[i] != 0x36)
      __builtin_abort ();
  return 0;
}
"
387-17584,CS-CLUB/contests,2011/solutions/1/solution.c,8,1,7,1994043.2393922,231249.0,8.622925936977024,1351.0,1329.0,50543.0,21030.0,1618.0,642.0,1340.0,599.0,1500000000,0.0013293621595948,1082014363648.0,0.0115892393048186,0.0586673745686222,"#include <stdio.h>

int main(void)
{
	for(int i = 1 ; i < 51 ; ++i)
	{
		printf(""%d %s %s\n"", i, i%2 ? """" : ""Huff"", i%5 ? """" : ""Puff"");
	}
	return 0;
}
"
041-25976,PrasadG193/gcc_gimple_fe,gcc/testsuite/gcc.c-torture/execute/bitfld-7.c,16,1,13,1494827.9131202998,169059.0,8.842043310323614,1139.0,1129.0,38453.0,12696.0,1569.0,585.0,1318.0,546.0,1500000000,0.0009965519420802,1082014363648.0,0.013415434848189,0.0785548104557273,"/* { dg-require-effective-target int32plus } */
union U
{
  const int a;
  unsigned b : 24;
};

static union U u = { 0x12345678 };

/* Constant folding used to fail to account for endianness when folding a
   union.  */

int
main (void)
{
#ifdef __BYTE_ORDER__
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
  return u.b - 0x345678;
#else
  return u.b - 0x123456;
#endif
#endif
  return 0;
}
"
227-35208,ipwndev/DSLinux-Mirror,user/gdb/gdb/testsuite/gdb.base/gdb1090.c,39,2,12,1458708.1968783,169083.0,8.627171270914285,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0009724721312522,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* Test program for multi-register variable.
   Copyright 2003 Free Software Foundation, Inc.

   This file is part of the gdb testsuite.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.
 
   This file was written by Michael Elizabeth Chastain (mec@shout.net).  */

struct s_2_by_4
{
  int field_0;
  int field_1;
};

void marker (struct s_2_by_4 s_whatever)
{
  s_whatever = s_whatever;
  return;
}

void foo ()
{
  /* I want this variable in a register but I can't really force it */
  register struct s_2_by_4 s24;
  s24.field_0 = 1170;
  s24.field_1 = 64701;
  marker (s24);
  return;
}

int main ()
{
  foo ();
}
"
292-28029,b3h3moth/L-LP,src/C/C_lang/array/find_duplicate_members.c,17,2,11,2018462.8665447,177403.0,11.377834647666612,1344.0,1325.0,40335.0,13691.0,1625.0,634.0,1345.0,591.0,1500000000,0.0013456419110298,1082014363648.0,0.0150448414062896,0.0776477992077888,"#include <stdio.h>
#include <stdlib.h>

void find_duplicates(int vec[], int size);

/* Lo scopo del programma e' di scrivere una funzione che consenta di trovare
elementi duplicati in un array */

int main(void) {
    int vector[] = {1,12,2,3,4,5,6,7,8,9,10,5,11,12,13,14,15,16,17,15,18,7};

    find_duplicates(vector, sizeof(vector)/sizeof(vector[0]));

    return(EXIT_SUCCESS);
}

void find_duplicates(int vec[], int size) {
    for (int i=0; i<size; i++) {
        for (int j=i+1; j<size; j++) {
            if (vec[i] == vec[j]) {
                printf(""%d\n"", vec[i]);
            }
        }
    }
}
"
358-34301,plast-lab/llvm-datalog,examples/vararrays.c,10,1,5,3914976.02686275,174048.0,22.49365692222835,1340.0,1322.0,39426.0,13406.0,1627.0,635.0,1345.0,594.0,1500000000,0.0026099840179085,1082014363648.0,0.0152946313660599,0.0795162023016353,"#include<stdlib.h>
#include<stdio.h>

void foo(int);

int main(void) {
  foo(17);
}

void foo(int n) {
  char s[n];

  for (int i = 0; i < n; i++)
    s[i] = i*i;
 

  printf(""%d\n"", s[n/2]);
}
"
074-14042,mattstock/binutils-bexkat1,gdb/testsuite/gdb.dwarf2/dw2-param-error-main.c,28,1,12,1497092.77320645,169103.0,8.849837081542018,1142.0,1132.0,38462.0,12697.0,1567.0,584.0,1317.0,544.0,1500000000,0.0009980618488043,1082014363648.0,0.0134474255335505,0.0784221740065286,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2011-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

asm ("".globl f_start"");
asm (""f_start:"");

volatile int v;

void
f (int x)
{
  v++;
}

asm ("".globl f_end"");
asm (""f_end:"");

int
main (void)
{
  f (1);
  return 0;
}
"
029-17241,javimv36/SO,ejercicios/e2-hilos/hilosyvariables2.c,39,2,21,15013995666.056871,195892.0,76644.25125068915,1491.0,1460.0,44650.0,16796.0,1666.0,724.0,1372.0,678.0,1500000000,10.009330444037914,1082014363648.0,0.0150644232536295,0.07225856849917,"#include<stdio.h>
#include<string.h>
#include<pthread.h>
#include<stdlib.h>
#include<unistd.h>

void *trabajo(void *arg);
int variable_global = 0;

pthread_t tid[2]; //tid es el identificador de hilo (threadID)

int main(void)
{
    int i = 0;
    int err;

    while(i < 2)  //Queremos crear 2 hilos
    {
        err = pthread_create(&(tid[i]), NULL, trabajo, NULL);
        if (err != 0)
            printf(""\nError al crear el hilo :[%d]"", strerror(err));
        else
            printf(""\n Hilo creado!\n"");

        i++;
    }

	sleep(10);

    return 0;
}

void *trabajo(void *arg)
{
    int j = 0;
    /* i es un avariable local*/

    pthread_t id = pthread_self();

    for(j=0; j<10; j++)
    {
    	variable_global++;
    
     	if(pthread_equal(id,tid[0]))
     	{
        	printf(""\n El valor de variable global para el primer hilo es: %d\n"",variable_global);
     	}
    	else
    	{
        	printf(""\n El valor de variable global para el segundo hilo es: %d\n"",variable_global);
    	}
    	sleep(1);
   }

    return NULL;
}
"
241-1403,lzhouAlan/ccode_test,C_api_test/random/random.c,12,1,6,15005940254.77767,213702.0,70218.99773516392,1368.0,1345.0,48129.0,18318.0,1639.0,643.0,1356.0,602.0,1500000000,10.00396016985178,1082014363648.0,0.012695248523645,0.0638102547895315,"#include <unistd.h>


int main()
{
	int i;
	sleep(10);
	srandom(0);

	for (i = 0; i < 10; i++) {
		printf(""%ld\n"", random());
		printf(""%ld\n"", rand());
		printf(""%ld\n"", random());
		printf(""%ld\n"", rand());
	}
}
"
027-12319,dterei/Scraps,c/infin.c,9,1,7,2184957388.672046,169083.0,14883.1191130983,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,1.4566382591146976,1082014363648.0,0.0134490161636592,0.0785049652044725,"#include <stdio.h>

#define INF_LIM 1000000000

int main(void)
{
	double v, i;

	for (v = 0, i = 1; i < INF_LIM; i++) {
		v += 1.0 / i;
	}

	printf(""lim (n-> infinity) (1/n) = %f\n"", v);
	return 0;
}

"
382-17602,bindatype/Fibonacci,fibonacci.c,13,1,11,373032870.0039535,1578643574.0,0.2362996157864828,1356.0,1337.0,250791828.0,139135423.0,1618.0,641.0,1340.0,598.0,1500000000,0.2486885800026357,1082014363648.0,1.7058948861879066e-06,1.0763546249297668e-05,"#include <stdio.h>

int fibonacci(int n);

int main(void){
  
  for ( int n = 0 ; n < 38; n++ ) 
	printf(""%d %d\n"",n,fibonacci(n));

  return 0;
}

int fibonacci(int n) {
  // returns n term in natural fib sequence.
  // where n starts at 0.
  if ( 0 == n ) return 0;
  if ( 1 == n ) return 1;
return fibonacci(n-1)+fibonacci(n-2);
}
"
380-20047,anshbansal/general,C/project_euler/001_050/007.c,22,2,11,868787860.6142476,1988710787.0,0.4368598318464292,1333.0,1314.0,39173.0,13304.0,1618.0,636.0,1342.0,593.0,1500000000,0.5791919070761651,1082014363648.0,1.3310130448847413e-06,0.0798254473388341,"/**
By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.

What is the 10001st prime number?
*/
#include<stdio.h>
#include<stdlib.h>

int main()
{
    int primes = 1;
    long long int i, number = 1;

    while (primes < 10001)
    {
        number += 2;
        for (i = 3; i < number; i += 2)
        {
            if(number % i == 0)
                break;
        }

        if(i == number)
            primes++;
    }

    printf(""%lld"",number);
    return 0;
}
"
009-28727,kidmaple/CoolWall,user/threaddemos/mtdm.c,25,4,14,7503343158.052303,139798360.0,53.672612167982514,2303.0,1792.0,40176498.0,10492425.0,2243.0,1019.0,1637.0,902.0,1500000000,5.002228772034869,1082014363648.0,2.9292189121531895e-05,0.0001144883225562,"#include <stdio.h>
#include <unistd.h>
#include <pthread.h>

#define THREADS 4
#define LOOPTIME 5

pthread_t t[THREADS];
int cnt;
int loop;

pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;

void* thread_code(void* arg) {
  while(loop) {
    pthread_mutex_lock(&m);
    cnt++;
    pthread_mutex_unlock(&m);
    sched_yield();
  };
  pthread_exit(0);
  return 0;
};

int main(int argc, char* argv[]) {
  int i;

#ifdef FSUTHREADS
  pthread_init();
#endif

  loop=1;
  for(i=0;i<THREADS;i++) pthread_create(&t[i],0,thread_code,(void*)i);

  for(i=0;i<LOOPTIME;i++) sleep(1);

  loop=0;
  for(i=0;i<THREADS;i++) pthread_join(t[i],0);

  printf(""total runs: %i\n"",cnt/LOOPTIME);

  return 0;
};
"
225-697,Gurgel100/gcc,gcc/testsuite/gcc.dg/torture/pr77988.c,22,1,11,1482183.11369415,169086.0,8.76585287959973,1142.0,1132.0,38461.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0009881220757961,1082014363648.0,0.0134487775451545,0.078503430615556,"/* { dg-do compile } */

static int a = 2;
int b[1], c, d;

int main ()
{ 
  int e = a, *f = &b[0];
  if (d)
    for (e = 0; e < 1; e++)
      ;
  if (e)
    {
L1:
      if (b < f)
	__builtin_abort ();
      if (*f)
	c++;
      return 0;
    }
  f = 0;
  goto L1;
  return 0;
}
"
246-8116,SaberMod/binutils-saber,gdb/testsuite/gdb.base/sepdebug2.c,17,1,10,1668216.3113727001,169083.0,9.862493568247547,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0011121442075818,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2009-2014 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
main (void)
{
  return 0;
}
"
304-13086,yyhclimacool/Linux-Program-Design,ch3/envtime.c,8,1,4,30005913284.95648,182579.0,164344.82215369784,1357.0,1334.0,41169.0,14620.0,1628.0,639.0,1348.0,596.0,1500000000,20.003942189970985,1082014363648.0,0.0147388253851757,0.0754808295542132,"#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <time.h>

int main(){
    time_t the_time;
    for(int i = 0; i < 10; ++i){
        the_time = time((time_t *)0);
        printf(""the_time is: %ld\n"", the_time);
        sleep(2);
    }
}
"
065-23636,tommythorn/yari,shared/testcases/regress/bubblesort.c,22,4,11,2033389.6391092502,222412.0,9.142442853802851,1351.0,1328.0,50250.0,19687.0,1634.0,646.0,1353.0,601.0,1500000000,0.0013555930927395,1082014363648.0,0.0120452133877668,0.0605402004661338,"#include <stdio.h>

int sorted[99];

int main(void)
{
    int swapped;
    int size;
    int i;

    for (size = 0; size < 50; ++size)
        sorted[size] = random() & 0xFFFF;

    do {
        swapped = 0;
        for (i = 0; i < size-1; ++i)
            if (sorted[i] > sorted[i+1]) {
                int tmp = sorted[i];
                sorted[i] = sorted[i+1];
                sorted[i+1] = tmp;
                swapped = 1;
            }
    } while (swapped);

    for (i = 0; i < size; ++i)
        printf(""%d "", sorted[i]);
    printf(""\n"");
}
"
310-17151,ShooShoSha/Course-Work,COP3014/Chapters/7/Samples/pgm7-6.c,9,1,3,2191562.7876295503,173523.0,12.629806999648462,1271.0,1258.0,39396.0,13352.0,1616.0,634.0,1341.0,592.0,1500000000,0.0014610418584197,1082014363648.0,0.0145744368181739,0.079301584894214,"#include <stdio.h>

int main(void)
{
	char word[] = {'H', 'e', 'l', 'l', 'o', '!'};
	int i;
	
	for(i = 0; i < 6; ++i)
		printf(""%c"", word[i]);
	printf(""\n"");
	
	return 0;
}
"
260-28473,ChrisJamesCampbell/UDP,workbeast2.c,15,1,8,5792560.40509785,30517443.0,0.1898114465225674,1459.0,1433.0,6180309.0,4283840.0,1651.0,705.0,1365.0,658.0,1500000000,0.0038617069367319,1082014363648.0,9.476547560029847e-05,0.0004184764570917,"//test to put some strain on the CPU 
//so that it its usage can be monitored

#include <stdio.h>
#include <math.h>
#include <stdlib.h>

int main(void)
{
  printf(""Start of test\n"");

  long double a = 0;
  int i = rand();
  
  for(int c = 0; c<10000; c++)
  {
    a = i * i;
    printf(""%f"", a);
  }
  
  printf(""End of test\n"");

  return 0;

}
"
226-15616,EZchip/gdb,gdb/testsuite/gdb.mi/mi-stepn.c,25,2,11,2620714.4837826,169057.0,15.501954961935915,1139.0,1129.0,38452.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0017471429891884,1082014363648.0,0.0134155935572026,0.0785172440760147,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2012 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see  <http://www.gnu.org/licenses/>.
*/

void
do_nothing (void)
{
}

int
main ()
{
  int i;

  for (i = 0; i < 2; i++)
    do_nothing ();
  return 0;
}
"
332-17490,robbertkrebbers/ch2o,tests/undefined-ellison/unsorted/j014c.c,4,1,3,1937538.0361452,169083.0,11.45909405439932,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0012916920240968,1082014363648.0,0.0134490161636592,0.0785049652044725,"#include <limits.h>
int main(void) {
      -3 | INT_MAX; // All ones, negative zero for ones' complement.
      return 0;
}
"
168-9630,jjones-cavium/glibc,stdlib/tst-random2.c,47,3,16,2526354.161091,195599.0,12.915986278048456,1181.0,1170.0,45725.0,14389.0,1623.0,593.0,1361.0,550.0,1500000000,0.001684236107394,1082014363648.0,0.0120194888521924,0.0686528928369431,"/* Test initstate saving the old state.
   Copyright (C) 2005 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Jakub Jelinek <jakub@redhat.com>, 2005.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#include <stdio.h>
#include <stdlib.h>

int
main (void)
{
  int pass;
  int ret = 0;
  long int r[2];

  for (pass = 0; pass < 2; pass++)
    {
      srandom (0x12344321);

      int j;
      for (j = 0; j < 3; ++j)
	random ();
      if (pass == 1)
	{
	  char state[128];
	  char *ostate = initstate (0x34562101, state, 128);
	  if (setstate (ostate) != state)
	    {
	      puts (""setstate (ostate) != state"");
	      ret = 1;
	    }
	}

      random ();
      r[pass] = random ();
    }

  if (r[0] != r[1])
    {
      printf (""%ld != %ld\n"", r[0], r[1]);
      ret = 1;
    }
  return ret;
}
"
245-10337,wuzhouhui/leetcode,217_contain_dup.c,19,1,11,1832298.0031371,169941.0,10.7819655056755,1143.0,1134.0,38658.0,12779.0,1577.0,589.0,1322.0,547.0,1500000000,0.0012215320020914,1082014363648.0,0.0133987678076508,0.0784454769912708,"#include <stdlib.h>

#ifndef bool 
#define bool int 
#endif 

static int intcmp(const void *a, const void *b)
{
	return(*(int *)a - *(int *)b);
}

bool containsDuplicate(int *nums, int numsSize)
{
	if (!numsSize || numsSize == 1)
		return(0);

	int	i;
	qsort(nums, numsSize, sizeof(int), intcmp);
	for (i = 1; i < numsSize; i++) {
		if (nums[i] == nums[i - 1])
			return(1);
	}

	return(0);
}

int main(void)
{

}
"
239-14204,8l/AutoCorres,autocorres/tests/parse-tests/struct_init.c,20,1,13,1896574.627608,169057.0,11.218547590457655,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.001264383085072,1082014363648.0,0.0134155935572026,0.0785563462891999,"/*
 * Copyright 2014, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See ""LICENSE_BSD2.txt"" for details.
 *
 * @TAG(NICTA_BSD)
 */

struct bar {
    int a;
};

struct foo {
    struct bar *x;
};

int main(void)
{
    struct foo y = {0};
    return 0;
}
"
082-31406,totalspectrum/binutils-propeller,gdb/testsuite/gdb.threads/thread-specific-bp.c,30,1,12,2029099.50166935,176016.0,11.52792359785474,1363.0,1340.0,40001.0,13705.0,1630.0,655.0,1352.0,612.0,1500000000,0.0013527330011129,1082014363648.0,0.0153565584946823,0.0791159274568949,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2013-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <pthread.h>

static void *
start (void *arg)
{
  return NULL;
}

static void
end (void)
{
}

int
main (void)
{
  pthread_t thread;

  pthread_create (&thread, NULL, start, NULL);
  pthread_join (thread, NULL);
  end ();
  return 0;
}
"
034-16301,totalspectrum/binutils-propeller,gdb/testsuite/gdb.base/breakpoint-in-ro-region.c,30,1,10,1735009.6022709,169112.0,10.259526231136762,1143.0,1133.0,38461.0,12708.0,1567.0,584.0,1317.0,544.0,1500000000,0.0011566730681806,1082014363648.0,0.0134585363546052,0.0784068478961871,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

volatile int i;

int
main (void)
{
  i = 0;
  i = 0;
  i = 0;
  i = 0;
  i = 0;
  i = 0;
  i = 0;
  i = 0;
  i = 0;
  i = 0;
  i = 0;
  i = 0;

  return 0;
}
"
048-17125,weiqiangdragonite/blog_tmp,unix_linux/linux_program/uup_book/ch6_signal/sigdemo1.c,21,1,12,7512830258.812756,174879.0,42960.16250092921,1314.0,1297.0,39710.0,13582.0,1622.0,633.0,1342.0,591.0,1500000000,5.00855350587517,1082014363648.0,0.0149303232520771,0.0785859040756586,"/*
 * sigdemo1.c - shows how a signal handler works.
 *            - run this and press Ctrl-C a few times
 */

#include <stdio.h>
#include <signal.h>

void f(int sig);

int
main(int argc, char *argv[])
{
	int i;
	signal(SIGINT, f);
	for (i = 0; i < 5; ++i) {
		printf(""hello\n"");
		sleep(1);
	}
	return 0;
}

void
f(int sig)
{
	printf(""OUCH!\n"");
}
"
041-6896,cxsjabc/basic,c/_topics/printf/parse_data.c,20,1,11,1486893.0447846001,176488.0,8.424895743619963,1347.0,1329.0,39998.0,13772.0,1630.0,637.0,1350.0,593.0,1500000000,0.0009912620298564,1082014363648.0,0.0151625039662753,0.0782964478333643,"/*
   Xi Chen(511272827@qq.com)
   cxsjabcabc
*/
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>

void dump_data(void *data, int bytes)
{
	int i;
	unsigned char *p;

	p = (unsigned char *)data;
	for (i = 0; i < bytes; ++i) {
		printf(""%x "", p[i]);
	}
	printf(""\n"");
}

int main(int argc, char *argv[])
{
	float d = 5.0f;

	dump_data(&d, sizeof(d));

	return 0;
}
"
047-32078,lmokto/ilovec,modificadores/ascii2.c,8,1,4,1994248.5960199498,181586.0,10.982388510127432,1294.0,1279.0,41754.0,15007.0,1621.0,636.0,1342.0,594.0,1500000000,0.0013294990640133,1082014363648.0,0.0141695945722687,0.0738711439192403,"#include <stdio.h>

int main(void){
    char i;
    for (i=64; i<=90;i++){
        printf(""%c"", i);
        printf(""/n"");
    }
    return 0;
}"
188-7878,Charnelx/CS50,pset5/structs/structs.c,24,1,14,1726696.50055455,175829.0,9.820314055133112,1353.0,1331.0,39812.0,13661.0,1628.0,637.0,1346.0,596.0,1500000000,0.0011511310003697,1082014363648.0,0.0152648311711947,0.0786752192695379,"#include <stdio.h>


// typedef - creates alias with name 'node' for unnamed data-type
typedef struct node
{
    int n;
    struct node *next;
}
node;

void getStruct(node *s, char text[]);

int main(void)
{
    node nd;
    nd.n = 10;
    
    // Realy need to define node as struct?
    struct node *md = &nd;
    
    printf(""Accessing struct member with 'member access operator': %i\n"", nd.n);
    
    char text1[] = ""Sending pointer variable to function"";
    getStruct(md, text1);
    
    char text2[] = ""Sending pointer to function"";
    getStruct(&nd, text2);
}

void getStruct(node *s, char text[])
{
    printf(""%s: %i\n"", text, s->n);
}"
069-31895,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.base/disabled-location.c,23,1,14,1541476.69672965,169061.0,9.117868698280502,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010276511311531,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright (C) 2012-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

static int
function (void)
{
  return 1; /* step stops here */
}

int
main ()
{
  function ();
  return 0;
}
"
017-19342,EvtimPavlov/c-programming-2014-2015-homework,B/02_Atanas_Chompolov/homework_3/task_5.c,14,1,6,1721178.0650541,1104343.0,1.557861099314253,1341.0,1321.0,139453.0,83629.0,1621.0,699.0,1341.0,656.0,1500000000,0.0011474520433694,1082014363648.0,0.0024104829749452,0.0193516285491433,"#include <stdio.h>

int main() {
	
	long int number;
	
	for (number = 0; number < 30000; number++)
	{	
		if (number%2!=0)
		{
			if (number%3==0 && number%7==0)
			{ 
				printf(""%ld\n"",number);
			}
		}
	}	

	return 0;
}
"
230-5234,8l/scc,cc1/tests/test049.c,29,2,10,2281548.1061115,169099.0,13.492380203312852,1142.0,1132.0,38465.0,12697.0,1569.0,585.0,1318.0,546.0,1500000000,0.001521032070741,1082014363648.0,0.0134477436294714,0.0785348500840467,"/* See LICENSE file for copyright and license details. */

/*
name: TEST049
description: Basic test for initializer
error:
output:
G1	I	""x	(
	#I5
)
G3	P	""p	(
	G1	'P
)
G5	I	F	""main
{
\
	y	L6	G3	@I	#I5	=I
	h	#I1
L6
	h	#I0
}
*/

int x = 5;
int *p = &x;

int
main()
{
	if(*p != 5)
		return 1;
	return 0;
}
"
206-3603,TakesxiSximada/gist,c-pthread/arg_thread.c,24,1,13,15003451201.482676,186089.0,80625.13743961223,1531.0,1495.0,42742.0,15183.0,1679.0,674.0,1373.0,629.0,1500000000,10.00230080098845,1082014363648.0,0.0162610363858153,0.0751834268450582,"#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

typedef struct FunctionArgument {
     int count;
     char *message;
} function_argument_t;

void *func(void *p){
     function_argument_t *func_arg = (function_argument_t *)p;
     for (int ii = 0; ii < func_arg->count; ii++ ) {
          fprintf(stdout, ""."");
          fflush(stdout);
          sleep(1);
     }
     fprintf(stdout, ""%s\n"", func_arg->message);
     return NULL;
}


int main(int argc, char *argv[]) {
     int rc = 0;
     pthread_t child;
     function_argument_t func_arg = {10, ""OK!!\n""};

     rc = pthread_create(&child, NULL, &func, &func_arg);
     fprintf(stdout, ""pthread_create returned %d\n"", rc);

     rc = pthread_join(child, NULL);
     fprintf(stdout, ""pthread_join returned %d\n"", rc);
     return 0;
}
"
238-34893,fenglyu/projecteuler,c/10.c,25,2,14,610336203.1280994,1783994177.0,0.3421178223946635,1339.0,1321.0,39194.0,13314.0,1619.0,636.0,1342.0,593.0,1500000000,0.4068908020853996,1082014363648.0,1.4910362568969304e-06,0.0797973642111678,"#include <stdio.h>
/*
 *   gcc -O3 -o 10 10.c
 */

int prime(int n){
    int i = 2;
    if (i <= 1)
        return 0;
    for(i =2; i * i <=n ; i++){
        if( n % i == 0 ){
            return 0;
        }
    }
    return 1; 
}

int main(){

    int i = 3;
    long int sum = 2;
    int max = 2000000;
    for (i =3; i < max; i=i+2){
        if(prime(i)){
            sum += i;
        }
    }
    printf(""result is %ld\n"", sum);
}
"
018-1674,EverlastingFire/informatica,c/mem.c,14,1,12,1982073.1831714502,195553.0,10.135733023783834,1342.0,1323.0,43666.0,16415.0,1617.0,644.0,1341.0,601.0,1500000000,0.0013213821221143,1082014363648.0,0.013628019002521,0.069955559994008,"#include <stdio.h>
#include <stdlib.h>

char foo[10];

int main(){
    char *array[] = {""Foo"", ""Bar"", ""Baz""};

    foo[0] = 'a';

    char *ptr = foo - 10;
    int i;

    for (i = 0; i < 20; i++)
    {
        printf(""Addr: %p, val: %d\n"", ptr + i, *(ptr + i));
    }

    printf(""Addr of foo: %p\n"", foo);
    printf(""Addr of array[0]: %p\n"", array[0]);
    return 0;
}"
295-17082,milekb/Laboratorium-2016-2017,LAB8/zad4.c,8,1,8,1504888.6416478502,173656.0,8.662568526281845,1338.0,1319.0,39306.0,13392.0,1618.0,636.0,1340.0,593.0,1500000000,0.0010032590944319,1082014363648.0,0.0153003639379002,0.0794527306539147,"#include <stdio.h>
#define PETLA(komenda1, warunek, komenda2) komenda1; while(warunek){komenda2; komenda1;}
int main()
{
  int a=0, b=0, i=0;
  PETLA(a++, i<5, b++; i++);
  printf(""%i\n"", a);
  printf(""%i\n"", b);
  return 0;
}
"
379-30801,goblint/analyzer,tests/regression/13-privatized/57-singlethreaded-unlock.c,16,1,6,2043782.849796,176966.0,11.549009414237764,1310.0,1286.0,40274.0,13780.0,1630.0,652.0,1354.0,609.0,1500000000,0.001362521899864,1082014363648.0,0.0146694845337522,0.0785325785325785,"#include <pthread.h>
#include <assert.h>

int g = 0;

pthread_mutex_t A = PTHREAD_MUTEX_INITIALIZER;

void *t_fun(void *arg) {
  // just for going to multithreaded mode
  return NULL;
}

int main() {
  pthread_mutex_lock(&A);
  g = 1;
  pthread_mutex_unlock(&A); // singlethreaded mode unlock

  g = 2;

  pthread_t id;
  pthread_create(&id, NULL, t_fun, NULL);

  assert(g == 2);
  return 0;
}
"
200-11788,ataniazov/KOU,poligon/epsilon.c,9,1,4,1549877.8084293,173138.0,8.95168593838441,1338.0,1319.0,39184.0,13309.0,1618.0,636.0,1340.0,593.0,1500000000,0.0010332518722862,1082014363648.0,0.0153461400732363,0.0797630160211837,"#include <stdio.h>

int main(){

	int transaction = 0;
	int i;

	for(i = 1; i < 501; i++){
		transaction += i;
	}

	printf(""Transactions: %d"", transaction);
	return 0;
}"
144-10577,EvtimPavlov/c-programming-2014-2015-homework,A/23_Petko_Georgiev/homework_3/task_4.c,7,1,4,1865778.1183719002,173144.0,10.775874416670517,1334.0,1315.0,39178.0,13306.0,1617.0,636.0,1340.0,593.0,1500000000,0.0012438520789146,1082014363648.0,0.0152994039643302,0.0797576404237482,"#include<stdio.h>
int main()
{
	int a=10,b=1;
	while(a>0) { b*=a; a--; }
	printf(""%d"",b);
	return 0;
}
"
279-22351,Lucasgscruz/analisadorSintatico,entrada/arq.c,13,1,8,2173938.08998155,175197.0,17.76914559039253,1304.0,1289.0,39756.0,13805.0,1606.0,636.0,1333.0,595.0,1500000000,0.0014492920599877,1082014363648.0,0.0148004817434088,0.0778551558036631,"int main() {
  int a= -90;
  int d=0;
  float lucas = 7.54; //Comentario
  a >= 9 ;
  for(d=0 ;d<=10 ;d= d+1){
    printf(""Hello World!"",d);
  }
  return 0;
}
/*Comentario
sdfsdfsdfs
sdfsfdsdfsdf*/"
021-35305,nslu2/glibc,posix/bug-regex4.c,48,2,12,2607214.38098685,203588.0,12.806324537792012,1617.0,1583.0,44703.0,25059.0,1670.0,821.0,1372.0,776.0,1500000000,0.0017381429206579,1082014363648.0,0.0157180187437373,0.0664975201399042,"/* Test for re_search_2.
   Copyright (C) 2001 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Jakub Jelinek <jakub@redhat.com>, 2001.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#include <locale.h>
#include <stdio.h>
#include <string.h>
#include <regex.h>

int
main (void)
{
  struct re_pattern_buffer regex;
  const char *s;
  int match[3];
  int result = 0;

  memset (&regex, '\0', sizeof (regex));

  setlocale (LC_ALL, ""C"");

  setlocale (LC_ALL, ""C"");
  s = re_compile_pattern (""ab[cde]"", 7, &regex);
  if (s != NULL)
    {
      puts (""re_compile_pattern return non-NULL value"");
      result = 1;
    }
  else
    {
      match[0] = re_search_2 (&regex, ""xyabez"", 6, """", 0, 1, 9, NULL, 10);
      match[1] = re_search_2 (&regex, NULL, 0, ""abc"", 3, 0, 3, NULL, 3);
      match[2] = re_search_2 (&regex, ""xya"", 3, ""bd"", 2, 2, 6, NULL, 8);
      if (match[0] != 2 || match[1] != 0 || match[2] != 2)
	{
	  printf (""re_match returned %d,%d,%d, expected 2,0,2\n"",
		  match[0], match[1], match[2]);
	  result = 1;
	}
      else
	puts ("" -> OK"");
    }

  return result;
}
"
299-32708,GuilhermeCFernandes/Arquivos,geradorTemporadas.c,8,1,5,1423276.49518845,356111.0,3.9967201237816297,1365.0,1342.0,83909.0,41136.0,1643.0,650.0,1359.0,605.0,1500000000,0.0009488509967923,1082014363648.0,0.0076015624341848,0.0340437442520692,"#include<stdio.h>
#include<time.h>
#include<stdlib.h>

int main (void){
	int i;
	srand(time(NULL));
	for(i = 0; i < 250; i ++){
		printf(""%d"", (rand() % 20) + 1);
		printf(""\n"");
	}
}
"
077-8165,zhangrxiang/learn-c,basic/csapp/exercise/ex9-20/t-malloc.c,11,2,5,553875452.9552534,115523338.0,4.792670975279472,1299.0,1281.0,30890252.0,10137663.0,6640295.0,306580.0,59705.0,261336.0,1500000000,0.3692503019701689,1082014363648.0,2.233314968790116e-05,0.1771456336496748,"#include <stdlib.h>

#ifndef MAX_ITEM
#  define MAX_ITEM (1<<17)
#endif

int main(void) {
    int i;
    char *buf[MAX_ITEM];
    for (i = 1; i < MAX_ITEM; i++) {
        buf[i] = malloc(i);
    }
    for (i = 1; i < MAX_ITEM; i++) {
        free(buf[i]);
    }

    return 0;
}
"
044-16186,robbertkrebbers/ch2o,tests/undefined-ellison/unsorted/j014b.c,4,1,2,1627276.6515612002,169083.0,9.62412542952278,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010848511010408,1082014363648.0,0.0134490161636592,0.0785049652044725,"#include <limits.h>
int main(void) {
      ~INT_MAX; // Negative zero for ones' and two's complement.
      return 0;
}
"
265-33605,hzq1001/or1k-src,gdb/testsuite/gdb.server/server.c,17,1,12,1304688.2813795998,169083.0,7.716257695924487,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0008697921875864,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2005-2013 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
main (int argc, char **argv)
{
  return 0;
}
"
071-13291,SanDisk-Open-Source/SSD_Dashboard,uefi/gcc/gcc-4.6.3/gcc/testsuite/gcc.dg/graphite/run-id-pr46758.c,17,1,6,1589886.0292509,169061.0,9.40421504663997,1140.0,1130.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010599240195006,1082014363648.0,0.0134271061924394,0.0785563462891999,"int
movegt (int y, long long a)
{
  int i;
  int ret = 0;
  for (i = 0; i < y; i++)
    if (a == -1LL << 33)
      ret = -1;
  return ret;
}

int
main ()
{
  if (movegt (1, -1LL << 33) != -1)
    __builtin_abort ();
  return 0;
}
"
392-20285,ysleu/RTL8685,uClinux-dist/uClibc/test/misc/dirent.c,15,1,7,60034117.5450012,24810721.0,2.419684498487569,1366.0,1346.0,5691976.0,4026107.0,31475.0,765.0,1872.0,658.0,1500000000,0.0400227450300008,1082014363648.0,0.0001093075852168,0.0035778661285358,"#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <dirent.h>

int main(int argc, char **argv)
{

    DIR *dirh;
    struct dirent *dirp;
    static char mydir[20] = ""/tmp"";

    if ((dirh = opendir(mydir)) == NULL) {
	perror(""opendir"");
	return 1;
    }

    for (dirp = readdir(dirh); dirp != NULL; dirp = readdir(dirh)) {
	printf(""Got dir entry: %s\n"",dirp->d_name);
    }

    closedir(dirh);
    return 0;
}

"
093-9291,AzerC/Mentorovo-maslo,Random_ispis.c,17,1,8,2165147.9182764,173900.0,12.450529039677976,1337.0,1318.0,39415.0,13386.0,1626.0,638.0,1344.0,594.0,1500000000,0.0014434319455176,1082014363648.0,0.015267395054629,0.0795818261017783,"#include <stdio.h>
#include <stdlib.h>

int f2(char* x, char p)
{
    char* q = x;
    while (*q < p && *q != '\0')
    {
        q++;
    }
    return q - x;
}

int main()
{
    int q = 1;
    char s[8] = ""Gorazde"";
    q = f2(s , 's');
    printf(""%d\n"", q);
    return 0;
}
"
278-12978,qtekfun/htcDesire820Kernel,external/valgrind/main/none/tests/pth_cvsimple.c,50,3,12,1502926570.479758,202537.0,7420.50375980685,1591.0,1555.0,46277.0,17549.0,1695.0,801.0,1391.0,757.0,1500000000,1.0019510469865054,1082014363648.0,0.015532964347255,0.0727603171121486,"#include <unistd.h>
#include <stdio.h>
#include <pthread.h>

#define NUM_THREADS  3
#define TCOUNT 10
#define COUNT_THRES 12

int     condvar_was_hit = 0;
int     count = 0;
int     thread_ids[3] = {0,1,2};
pthread_mutex_t count_lock=PTHREAD_MUTEX_INITIALIZER; 
pthread_cond_t count_hit_threshold=PTHREAD_COND_INITIALIZER; 

void *inc_count(void *null)
{
  int i=0;

  for (i=0; i<TCOUNT; i++) {
    pthread_mutex_lock(&count_lock);
    count++;
    printf(""inc_counter(): count = %d, unlocking mutex\n"", count);
    if (count == COUNT_THRES) {
      printf(""hit threshold!\n"");
      pthread_cond_signal(&count_hit_threshold);
    }
    pthread_mutex_unlock(&count_lock);
  }
  
  return(NULL);
}

void *watch_count(void *null)
{
  pthread_mutex_lock(&count_lock);

  while (count < COUNT_THRES) {
    pthread_cond_wait(&count_hit_threshold, &count_lock);
    condvar_was_hit = 1;
  }

  pthread_mutex_unlock(&count_lock);
  
  return(NULL);
}

extern int
main(void)
{
  int       i;
  pthread_t threads[3];

  pthread_create(&threads[0], NULL, watch_count, NULL);
  sleep(1);
  pthread_create(&threads[1], NULL, inc_count,   NULL);
  pthread_create(&threads[2], NULL, inc_count,   NULL);

  for (i = 0; i < NUM_THREADS; i++) {
    pthread_join(threads[i], NULL);
  }

  
  
  
  
  
  
  if (condvar_was_hit == 1)
    printf(""condvar was hit!\n"");
  else if (condvar_was_hit > 1)
    printf(""condvar was multi-hit...\n"");
  else
    printf(""condvar was missed...\n"");
  
  return 0;
}


"
352-11585,EZchip/gdb,gdb/testsuite/gdb.ada/info_types.c,26,1,14,2778755.96657385,169057.0,16.436793507515215,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0018525039777159,1082014363648.0,0.0134155935572026,0.0785563462891999,"/* This test program is part of GDB, the GNU debugger.

   Copyright 2010-2012 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */

typedef int new_integer_type;

void
do_something (int *val)
{
  *val = *val + 1;
}

int
main (void)
{
  new_integer_type toto = 30;

  do_something(&toto);
  return 0;
}

"
327-2475,Heatwave/The-C-Programming-Language-2nd-Edition,chapter-4-functions-and-program-structure/6.register-variable.c,26,2,10,1952507.76596355,176819.0,11.04240494516992,1428.0,1403.0,40004.0,13831.0,1637.0,634.0,1355.0,591.0,1500000000,0.0013016718439757,1082014363648.0,0.0160107228295601,0.0783319401876102,"#include <stdio.h>
#include <time.h>

#define LOOP_COUNT 1e8

void withRegister(void);
void withoutRegister(void);

int main()
{
	clock_t start, finish;
	start = clock();
	withRegister();
	finish = clock();
	printf(""withRegister duration: %f\n"", ((double)(finish - start)) / CLOCKS_PER_SEC);

	start = clock();
	withoutRegister();
	finish = clock();
	printf(""withoutRegister duration: %f\n"", ((double)(finish - start)) / CLOCKS_PER_SEC);
}

void withRegister(void)
{
	register int i;
	for (i = 0; i < LOOP_COUNT; i++)
		;

}

void withoutRegister(void)
{
	int i;
	for (i = 0; i < LOOP_COUNT; i++)
		;
}
"
150-19608,hexa00/binutils-gdb,gdb/testsuite/gdb.python/py-objfile-script.c,30,1,17,1993158.2501156998,169061.0,11.789578909387735,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0013287721667438,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2011-2016 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

struct ss
{
  int a;
  int b;
};

void
init_ss (struct ss *s, int a, int b)
{
  s->a = a;
  s->b = b;
}

int
main ()
{
  struct ss ss;

  init_ss (&ss, 1, 2);

  return 0;      /* break to inspect struct and union */
}
"
187-15537,EvtimPavlov/c-programming-2014-2015-homework,B/20_Nikolay_Karagyozov/homework_3/task_4.c,8,1,4,2006523.1947228,173190.0,11.58567469253421,1338.0,1319.0,39184.0,13309.0,1618.0,636.0,1340.0,593.0,1500000000,0.0013376821298152,1082014363648.0,0.0153415324210404,0.0797630160211837,"#include <stdio.h>

int main(){

	int answer = 1;
	int i;

	for(i=10;i>=1;i--)
		answer=answer*i;
	printf(""%d\n"", answer);
	return 0;
}"
319-31908,b3h3moth/L-LP,src/C/C_lang/structures_and_unions/unions/get_individual_bytes_with_array.c,19,1,11,1726998.24906885,177560.0,9.726278441090336,1340.0,1322.0,40078.0,13915.0,1621.0,631.0,1345.0,592.0,1500000000,0.0011513321660459,1082014363648.0,0.014992115341293,0.0775841312762765,"#include <stdio.h>
#include <stdlib.h>

/* Si intende stampare sullo stdout ciascun byte di un 'unsigned int', tale
rappresentazione sara' possibile grazie alla 'union' che consentira' di
visualizzare un byte per volta e di accertare peraltro anche l'ordinamento
dei byte stessi in memoria. 

La visualizzazione di ciascun byte e' affidata a un array di 'unsigned int'
elementi, ovvero 4.*/

union unsigned_inspect {
    unsigned int val;
    unsigned char bytes[sizeof(unsigned int)];
};

typedef union unsigned_inspect unsigned_inspect;

unsigned_inspect datatest = { .val = 0x12ABCDEF, };

int main(void) {
    printf(""Byte representation of unsigned int value: '%#x'\n"", datatest.val);

    // Each byte will be printed on the stdout separately
    for (size_t i = 0; i<sizeof(datatest.bytes); ++i)
        printf(""byte[%zu]: %#x\n"", i, datatest.bytes[i]);

    return(EXIT_SUCCESS);
}
"
374-34076,WooJaeWoo/Smith_Network,Part2/thread1.c,25,1,11,15019123327.801935,180427.0,83242.10526695006,1483.0,1449.0,41027.0,14441.0,1649.0,714.0,1361.0,671.0,1500000000,10.01274888520129,1082014363648.0,0.0162503394724736,0.0792348741616788,"#include <stdio.h>
#include <pthread.h>
void* thread_main(void* arg);

int main(int argc, char* argv[])
{
	pthread_t t_id;
	int thread_param = 5;

	if (pthread_create(&t_id, NULL, thread_main, (void*)&thread_param) != 0)
	{
		puts(""pthread_create error"");
		return -1;
	}
	sleep(10);
	puts(""END OF MAIN"");
	return 0;
}

void* thread_main(void *arg)
{
	int i;
	int cnt = *((int*)arg);
	for (i = 0; i < cnt; i++)
	{
		sleep(1);
		puts(""running thread"");
	}
	return NULL;
}

"
366-1264,todaygood/my_c,timer_coding/my_alarm.c,24,1,11,16503412000.718527,183931.0,88265.18338942321,1373.0,1350.0,41705.0,14869.0,1644.0,639.0,1358.0,596.0,1500000000,11.002274667145684,1082014363648.0,0.0148044647177474,0.0748930604164457,"#include <stdlib.h>  
#include <stdio.h>  
#include <unistd.h>  
#include <signal.h>  
  
#define SLEEP_TIME 6  
  
int time_out;  
  
void handler()  
{  
    printf(""Wake up!\n"");  
    time_out = 1;  
}  
  
int main()  
{  
    int i;  
    
    signal(SIGALRM, handler); 		//让内核做好准备，一旦接受到SIGALARM信号,就执行 handler  
    alarm(SLEEP_TIME);					//设置闹钟，准备睡觉  
    printf(""Set alarm!\n"");  
    
    for(i = 1;i < 2 * SLEEP_TIME && !time_out; i++)  
    {  
        printf(""sleep %d ...\n"",i);  
        sleep(1);  
        
        
		         if (i == SLEEP_TIME / 2) 
		        { 
		           printf(""Turn off the alarm!\n"");//我中途醒了，不需要闹钟，把闹钟关闭 
		           alarm(0); 
		        } 
    }  
      
    return 0;  
}








"
298-11779,Gurgel100/gcc,gcc/testsuite/gcc.dg/vect/pr81633.c,29,6,13,1568492.96763525,170970.0,9.174077323507047,1145.0,1137.0,38970.0,12910.0,1594.0,586.0,1337.0,546.0,1500000000,0.0010456619784235,1082014363648.0,0.0133473708837807,0.0783153430994603,"static double identity[4][4] = {{1, 0, 0, 0},
                                {0, 1, 0, 0},
                                {0, 0, 1, 0},
                                {0, 0, 0, 1}};
static double expected[4][4] = {{1, 0, 0, 0},
                                {0, 0, 0, 0},
                                {0, 0, 0, 0},
                                {0, 0, 0, 0}};

static void __attribute__((noinline,noclone))
kernel(double A[4][4])
{
  double tmp[4][4];
  for (int j = 0; j < 4; j++)
    for (int k = 0; k < 4; k++)
      tmp[j][k] = identity[j][0] * identity[j][k];
  for (int j = 0; j < 4; j++ )
    for (int k = 0; k < 4; k++)
      A[j][k] = tmp[j][k];
}

int main(void)
{
  double A[4][4] = {{0.0}};
  kernel(A);
  for ( int i = 0; i < 4; i++ )
    for ( int j = 0; j < 4; j++ )
      if (A[i][j] != expected[i][j])
	__builtin_abort ();
  return 0;
}
"
150-8892,tutufan/subterfugue,test/getpidloop.c,5,1,2,4960073.9730522,270025.0,18.368939912971022,1146.0,1138.0,58664.0,22780.0,1576.0,589.0,1323.0,547.0,1500000000,0.0033067159820348,1082014363648.0,0.0084584760670308,0.0495432444378959,"

int main() {
  int i;
  for (i=0; i<10000; i++)
    getpid();
}
"
280-16849,Frky/scat,test/proto/src/int__int.c,17,2,11,1651577.8843312499,293708.0,5.621276914486497,1151.0,1141.0,74660.0,26780.0,1579.0,586.0,1325.0,546.0,1500000000,0.0011010519228875,1082014363648.0,0.0078036689501137,0.0397870662460567,"
#include <stdlib.h>

// ORACLE INT foo(INT)

int foo(int a) {
    int b;
    int i;
    int res = 0; 

    b = rand() % 65536;

    for (i = 0; i < b; i++) 
        res += a;

    return res % 65536;
}

int main(void) {
    
    int a = 0, i;

    for (i=0; i < 1000; i++) {
        a += foo(rand() % 65536);
    }

    return 0; 
}
"
262-4847,zguangyu/euler,14.c,20,1,9,268665407.78428304,757170941.0,0.3548279423470373,1339.0,1320.0,39184.0,13307.0,1619.0,636.0,1342.0,593.0,1500000000,0.1791102718561887,1082014363648.0,3.5117565347769995e-06,0.0798232077880017,"#include <stdio.h>

int chain(int i, long num)
{
  if (num == 1)
    return i;
  if (num % 2 == 0)
    return chain(i+1, num/2);
  return chain(i+1, num*3+1);
}

int main()
{
  long num, max=0, maxchain=0;
  for (num=1; num < 1000000; num++) {
    int i = chain(1, num);
    if (i>maxchain) {
      maxchain = i;
      max = num;
    }
  }
  printf(""%ld\n"", max);
}
"
201-24429,tiggerlee/exercises,CSAPP/cp2/exercise2_7.c,26,1,9,1763089.3271415,176894.0,9.966923694415865,1341.0,1321.0,40071.0,13889.0,1627.0,637.0,1347.0,593.0,1500000000,0.001175392884761,1082014363648.0,0.0150485601546688,0.0779095626389918,"#include <string.h>
#include <stdio.h>

typedef unsigned char *byte_pointer;

void show_bytes(byte_pointer start, int len)
{
  int i;
  for (i = 0; i < len; i++) {
    printf("" %.2x"", start[i]);
  }
  printf(""\n"");
}

void show_int(int x)
{
  show_bytes((byte_pointer) &x, sizeof(int));
}

void show_float(float x)
{
  show_bytes((byte_pointer) &x, sizeof(float));
}

void show_pointer(void *x)
{
  show_bytes((byte_pointer) &x, sizeof(void *));
}

int main()
{
  const char *s = ""abcdef"";
  show_bytes((byte_pointer) s, strlen(s)); // 61 62 63 64 65 66
}
"
041-32163,wolfdale/Spaghetti-code,C_Prep/pattern_8.c,11,2,5,1577641.4657011502,181781.0,8.678800314664349,1340.0,1320.0,41242.0,14700.0,1625.0,635.0,1346.0,593.0,1500000000,0.0010517609771341,1082014363648.0,0.0146329924469554,0.0750598834507168,"#include<stdio.h>
int main(){
int i,j,k;
for(i=1;i<=5;i++){

        for(j=1;j<=i;j++)
        {
                printf(""%d"",j);
        }
        printf(""\n"");
}

return 0;

}
"
175-26983,cy1987/HUST_TENCENT_WEB,1_c_structure/程凤/insert_sort.c,30,4,10,4317232.2912141,180943.0,23.85962430157564,1410.0,1385.0,41020.0,14492.0,1637.0,646.0,1355.0,600.0,1500000000,0.0028781548608094,1082014363648.0,0.0154468534289803,0.0763438535812076,"#include<stdio.h>
#include<stdlib.h>
#define N 8
void insert_sort(int a[], int n);
void insert_sort(int a[], int n)
{
	for (int i = 1; i < n; i++)
	{
		int j = 0;
		while ((a[j] < a[i]) && (j < i))
		{
			j++;
		}
		if (i != j) 
		{
			int temp = a[i];
			for (int k = i; k > j; k--)
			{
				a[k] = a[k - 1];
			}
			a[j] = temp;
		}
	}
}
int  main()
{
	int num[N] = { 52, 38, 11, 78, 90, 44, 16, 27 };
	insert_sort(num, N);
	for (int i = 0; i < N; i++)
		printf(""%d \n "", num[i]);
	
	system(""pause"");
	return 0;
}"
250-11761,totalspectrum/binutils-propeller,gdb/testsuite/gdb.base/signest.c,38,1,14,1518332.8650891,171883.0,8.748241536393943,1157.0,1148.0,39127.0,12993.0,1595.0,586.0,1335.0,545.0,1500000000,0.0010122219100594,1082014363648.0,0.0134102849031026,0.0779163468917881,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2011-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

volatile char *p = NULL;

extern long
bowler (void)
{
  return *p;
}

extern void
keeper (int sig)
{
  static int recurse = 0;
  if (++recurse < 3)
    bowler ();

  _exit (0);
}

int
main (void)
{
  struct sigaction act;
  memset (&act, 0, sizeof act);
  act.sa_handler = keeper;
  act.sa_flags = SA_NODEFER;
  sigaction (SIGSEGV, &act, NULL);
  sigaction (SIGBUS, &act, NULL);

  bowler ();
  return 0;
}
"
359-306,AungWinnHtut/YCC,gotoxy.c,30,3,12,6370346.99320785,179487.0,45.8158919587491,1359.0,1337.0,41003.0,14297.0,1630.0,636.0,1352.0,593.0,1500000000,0.0042468979954719,1082014363648.0,0.0150205864491578,0.0761482820976491,"#include<stdio.h>
#include<stdlib.h>
int lasti=0,lastj=0;
void goback(int x,int y)
{ 
printf(""\033[%dA"",x);
printf(""\033[%dD"",y);
}
void gotoxy(int x,int y)
{ 
extern int lasti, lastj;
int i;
goback(lasti, lastj);

for(i=0;i<x;i++)
printf(""\n"");
for(i=0;i<y;i++)
printf(""\t"");
lasti=x;
lastj=y;

}

int main ()
{
int i=0;
do
{ i=i+1;
gotoxy(12,5);
printf(""hello i=%d\r"",i); 
gotoxy(10,5);
printf(""hello i-1=%d\r"",i-1); 
usleep(3*1000);
}while(0);
}"
112-17224,VictorRodriguez/operating-systems-lecture,labs/06/philosopher_simple.c,36,3,20,9013263280.503452,201474.0,44736.607601973454,1604.0,1548.0,46224.0,17736.0,1737.0,885.0,1386.0,825.0,1500000000,6.008842187002301,1082014363648.0,0.0156446985715278,0.0755628517823639,"#include<stdio.h>
#include<stdlib.h>
#include<pthread.h>
#include<semaphore.h>
#include<unistd.h>

sem_t room;
sem_t chopstick[5];

void * philosopher(void *);
void eat(int);
int main()
{
	int i,a[5];
	pthread_t tid[5];
	sem_init(&room,0,4);
	for(i=0;i<5;i++)
		sem_init(&chopstick[i],0,1);
	for(i=0;i<5;i++){
		a[i]=i;
		pthread_create(&tid[i],NULL,philosopher,(void *)&a[i]);
	}
	for(i=0;i<5;i++)
		pthread_join(tid[i],NULL);
}

void * philosopher(void * num)
{
	int phil=*(int *)num;

	sem_wait(&room);
	printf(""\nPhilosopher %d has entered room"",phil);
	sem_wait(&chopstick[phil]);
	sem_wait(&chopstick[(phil+1)%5]);

	eat(phil);
	sleep(2);
	printf(""\nPhilosopher %d has finished eating"",phil);

	sem_post(&chopstick[(phil+1)%5]);
	sem_post(&chopstick[phil]);
	sem_post(&room);
}

void eat(int phil)
{
	printf(""\nPhilosopher %d is eating"",phil);
}
"
221-4571,ensemblr/llvm-project-boilerplate,include/llvm/projects/test-suite/SingleSource/Regression/C/sumarray.c,17,3,11,3239181.2419518004,174748.0,18.536297983381782,1335.0,1316.0,39487.0,13516.0,1618.0,642.0,1340.0,600.0,1500000000,0.0021594541613012,1082014363648.0,0.0151704168288049,0.0792407976906967,"#include <stdlib.h>
#include <stdio.h>

int SumArray(int Array[], int Num) {
  unsigned i, Result = 0;
  Array[34] = 1234;

  for (i = 0; i < Num; ++i)
    Result += Array[i];

  return Result;
}

int main() {
  int *Array = (int*)malloc(sizeof(int)*100);
  int i;

  for (i = 0; i < 100; i += 2)
  	Array[i] = i*4;
  for (i = 1; i < 100; i += 2)
  	Array[i] = i*2;

  printf(""Produced: %d\n"", SumArray(Array, 100));
  return 0;
}
"
225-33873,cartman300/picoc,tests/csmith/rand100.c,86,3,14,2081253.1001864998,174109.0,11.953735878099351,1349.0,1330.0,39383.0,13446.0,1619.0,637.0,1342.0,594.0,1500000000,0.001387502066791,1082014363648.0,0.0153869127960071,0.0793503568115996,"#include <stdio.h>
int print_hash_value = 1;
static void platform_main_begin(void)
{
}
static unsigned crc32_tab[256];
static unsigned crc32_context = 0xFFFFFFFFUL;
static void
crc32_gentab (void)
{
 unsigned crc;
 unsigned poly = 0xEDB88320UL;
 int i, j;
 for (i = 0; i < 256; i++) {
  crc = i;
  for (j = 8; j > 0; j--) {
   if (crc & 1) {
    crc = (crc >> 1) ^ poly;
   } else {
    crc >>= 1;
   }
  }
  crc32_tab[i] = crc;
 }
}
static void
crc32_byte (unsigned char b) {
 crc32_context =
  ((crc32_context >> 8) & 0x00FFFFFF) ^
  crc32_tab[(crc32_context ^ b) & 0xFF];
}
extern int strcmp ( char *, char *);
static void
crc32_8bytes (unsigned val)
{
 crc32_byte ((val>>0) & 0xff);
 crc32_byte ((val>>8) & 0xff);
 crc32_byte ((val>>16) & 0xff);
 crc32_byte ((val>>24) & 0xff);
}
static void
transparent_crc (unsigned val, char* vname, int flag)
{
 crc32_8bytes(val);
 if (flag) {
    printf(""...checksum after hashing %s : %X\n"", vname, crc32_context ^ 0xFFFFFFFFU);
 }
}
static void
platform_main_end (int x, int flag)
{
  if (!flag) printf (""checksum = %x\n"", x);
}
static long __undefined;
void csmith_compute_hash(void);
void step_hash(int stmt_id);
static unsigned func_1(void);
static unsigned func_1(void)
{
    int l_2 = 0L;
    step_hash(1);
    return l_2;
}
void csmith_compute_hash(void)
{
}
void step_hash(int stmt_id)
{
    int i = 0;
    csmith_compute_hash();
    printf(""before stmt(%d): checksum = %X\n"", stmt_id, crc32_context ^ 0xFFFFFFFFUL);
    crc32_context = 0xFFFFFFFFUL;
    for (i = 0; i < 256; i++) {
        crc32_tab[i] = 0;
    }
    crc32_gentab();
}
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    csmith_compute_hash();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}
"
342-33622,TacOS-team/tacos,applications/loop.c,7,1,2,9596711.9559645,339987.0,28.22669984440581,1149.0,1139.0,68670.0,22781.0,1576.0,586.0,1323.0,546.0,1500000000,0.006397807970643,1082014363648.0,0.0067296690755823,0.0440782495544061,"#include <stdio.h>
#include <unistd.h>

int main() {
	int i;
	for (i = 0; i < 10000; i++) {
		write(1, ""hello\n"", 6);
	}
	return 0;
}
"
011-29480,cuviper/binutils-gdb,gdb/testsuite/gdb.python/py-pp-maint.c,61,1,25,1386362.94286695,169057.0,8.08663941747458,1140.0,1130.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0009242419619113,1082014363648.0,0.0134274238866181,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2010-2016 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <string.h>

enum flag_enum
  {
    FLAG_1 = 1,
    FLAG_2 = 2,
    FLAG_3 = 4,
    ALL = FLAG_1 | FLAG_2 | FLAG_3
  };

enum flag_enum fval;

struct function_lookup_test
{
  int x,y;
};

void
init_flt (struct function_lookup_test *p, int x, int y)
{
  p->x = x;
  p->y = y;
}

struct s
{
  int a;
  int *b;
};

struct ss
{
  struct s a;
  struct s b;
};

void
init_s (struct s *s, int a)
{
  s->a = a;
  s->b = &s->a;
}

void
init_ss (struct ss *s, int a, int b)
{
  init_s (&s->a, a);
  init_s (&s->b, b);
}

int
main ()
{
  struct function_lookup_test flt;
  struct ss ss;

  init_flt (&flt, 42, 43);
  init_ss (&ss, 1, 2);
  
  return 0;      /* break to inspect */
}
"
165-24212,gauthier-voron/bench-platform,control-payload/param/path/activecond/barrier.c,24,2,9,355717816.2736818,1073918342.0,0.3312335790238323,1342.0,1331.0,40189.0,268449207.0,1693.0,4194953.0,1418.0,4194911.0,1500000000,0.2371452108491212,1082014363648.0,2.489016059658659e-06,0.0312599868934861,"#include <stdio.h>
#include <stdlib.h>


static void barrier(void)
{
	size_t i, len = (1ul << 28);
	char *data = malloc(len);

	printf(""barrier : "");
	fflush(stdout);
	
#pragma omp parallel
	{
		for (i=0; i<len/2; i++) {
			data[i] = ((char) i % 256);
			asm ("""" : : : ""memory"");
		}
#  pragma omp barrier
		for (i=len/2; i<len; i++) {
			data[i] = ((char) i % 256);
			asm ("""" : : : ""memory"");
		}
	}

	printf(""done\n"");

	free(data);
}


int main(void)
{
	barrier();

	return EXIT_SUCCESS;
}
"
151-10629,IAmRasputin/euler,2/c/fibonacci.c,14,1,4,2195495.9956929,173396.0,12.66173960183626,1338.0,1319.0,39184.0,13309.0,1618.0,636.0,1340.0,593.0,1500000000,0.0014636639971286,1082014363648.0,0.0153233061893007,0.0797630160211837,"#include <stdio.h>

int main()
{
	int n_2 = 1;
	int n_1 = 2;
	int cur;

	int sum = 2;
		
	for (cur = 3; cur <= 4000000; cur = n_2 + n_1){
		if (cur % 2 == 0)
			sum += cur;
		n_2 = n_1;
		n_1 = cur;
	}
	printf(""%d\n"", sum);

}
"
369-7477,giannis20012001/CGeneralRepo,CStructuredProgrammingDev/HowFastIsYourComputer.c,14,1,13,972771398.8395407,7000182771.0,0.1389637142089986,1352.0,1332.0,41133.0,14638.0,1625.0,637.0,1345.0,594.0,1500000000,0.6485142658930272,1082014363648.0,3.834185603151875e-07,0.0753258862132649,"//
// Created by John Tsantilis (A.K.A lumi) on 21/1/2016.
//

#include <stdio.h>

int main (void) {
    int counter = 1;

    while (counter <= 1000000000) {
        counter++;
        if ((counter % 100000000) == 0) {
            printf(""%s%d\n"", ""The counter is: "", counter);

        }

    }
    puts(""Finished adding!!!"");

    return 0;

}"
071-1819,dijkstracula/Loopgrind,tests/function.c,17,2,11,1598252.9148459,241382.0,6.621255934576729,1339.0,1320.0,53837.0,23725.0,1618.0,641.0,1340.0,598.0,1500000000,0.0010655019432306,1082014363648.0,0.0110157343961024,0.0541115494701013,"/* sequential.c
 * Control test program with no jumps
 */

#include <stdio.h>

void function(int i) {
    int j = i;
    printf(""%d "", j);
}

int main(int argc, char *argv[]) {
    int i;

    for (i = 0; i < 10; ++i) {
        int j;
        function(i);
    }

    for (i = 0; i < 100; ++i) {
        function(i);
    }
}
"
102-28160,BharathTalloju/mrnd-submissions-tool,Arrays2-Worksheet/src/findSingleOccurenceNumber.c,37,3,16,1987352.7344316,176405.0,11.265848473682718,1343.0,1323.0,39613.0,13391.0,1625.0,633.0,1345.0,591.0,1500000000,0.0013249018229544,1082014363648.0,0.0151129503131997,0.0791261036902875,"/*
OVERVIEW: Given an array where every element occurs three times, except one element which occurs only
once. Find the element that occurs once.
E.g.: Input: arr = 12, 1, 12, 3, 12, 1, 1, 2, 3, 3
ouput: 2

INPUTS: Integer array and length of the array.

OUTPUT: Element that occurs only once.

ERROR CASES: Return -1 for invalid inputs.

NOTES:
*/
#include <stdio.h>


#define SIZE_OF_INT 32

int findSingleOccurenceNumber(int *A, int len) {
    int i ;
    int once= 0;
    
    if(!A){
        return -1;
    }
    
    for(i = 0; i < SIZE_OF_INT ; i++){
        int sum = 0;
        int j;
        for(j = 0 ; j < len ; j++){
            sum += k_th_bit(A[j], i);
        }
        sum = (sum % 3) > 0;
        once = once | (sum << i);
    }
    
	return once;
}

int k_th_bit(int n, int k){
    int x = (1 << k) & n;
    
    return (x>0);
}

//Test Driver
int main(){
    int A[] = { 2, 2, 2, 3,3,3,7, 6, 6, 6};
    int len = 7;
    printf(""%d\n"",findSingleOccurenceNumber(A,len));
}
"
344-21460,Krakn/learning,src/c/books/programming_in_c/chapters/ch07/src/ch07ex05.c,18,1,8,1471336.5817441498,177764.0,8.27690646025067,1347.0,1327.0,40099.0,13932.0,1620.0,637.0,1342.0,594.0,1500000000,0.0009808910544961,1082014363648.0,0.0150424157872235,0.077603597934519,"/* Function to find the greatest common divisor
        of wto nonnegative integer values       */

#include <stdio.h>

void gcd(int u, int v) {
    int temp;

    printf(""The gcd of %i and % i is "", u, v);

    while (v != 0) {
        temp = u % v;
        u = v;
        v = temp;
    }

    printf(""%i\n"", u);
}

int main(void) {
    gcd(150, 35);
    gcd(1026, 405);
    gcd(83, 240);

    return 0;
}
"
322-6437,lbovard/c_things,input_tests_c/generate_input.c,10,1,5,468577042.5712689,3471968612.0,0.1349600455431767,1336.0,1316.0,699407223.0,504210436.0,1620.0,701.0,1339.0,656.0,1500000000,0.3123846950475126,1082014363648.0,7.638317900784064e-07,3.5858563288161262e-06,"#include <stdlib.h>
#include <stdio.h>

int main() {
	int a,b,i;
	a=5000000;
	b=41832;
	printf(""%d %d\n"",a,b);
	for(i=1;i<=a;i++) {
		printf(""%d\n"",i);
	}
	return 0;
}
"
111-31187,totalspectrum/binutils-propeller,gdb/testsuite/gdb.multi/watchpoint-multi.c,37,1,12,1611902.8441606502,176584.0,9.128244914601549,1364.0,1338.0,40215.0,13799.0,1635.0,661.0,1354.0,615.0,1500000000,0.0010746018961071,1082014363648.0,0.0153014995696099,0.0789610101084904,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2012-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <pthread.h>
#include <assert.h>

static volatile int a, b, c;

static void
marker_exit (void)
{
  a = 1;
}

static void *
start (void *arg)
{
  b = 2;
  c = 3;

  return NULL;
}

int
main (void)
{
  pthread_t thread;
  int i;

  i = pthread_create (&thread, NULL, start, NULL);
  assert (i == 0);
  i = pthread_join (thread, NULL);
  assert (i == 0);

  marker_exit ();
  return 0;
}
"
032-16238,VincentLee0211/K-R,ch03_control_flow/reverse.c,17,1,12,2598862.5129684,170060.0,15.28202987180995,1151.0,1143.0,38678.0,12782.0,1575.0,586.0,1322.0,546.0,1500000000,0.0017325750086456,1082014363648.0,0.0134893566976361,0.0782938204430625,"/*
 * reverse.c
 *
 * 反转字符串
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void)
{

}

void reverse(char s[])
{
    int c, i, j;

    for (i = 0, j = strlen(s) - 1; i < j; i++, j--) {
        c = s[i];
        s[i] = s[j];
        s[j] = c;
    }
}
"
101-7460,hzq1001/or1k-src,gdb/testsuite/gdb.trace/trace-buffer-size.c,24,1,14,1538897.86452045,169061.0,9.10261384943896,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010259319096803,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2011-2013 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int var = 10;

int
test_function ()
{
  return 0;
}

int
main ()
{
  test_function ();
  return 0; /*breakpoint1*/
}
"
352-18031,Earth97/hello-world,exercises/ex14-1.c,18,2,8,2581611.1592575503,185098.0,13.9472657727258,1351.0,1331.0,41782.0,14952.0,1632.0,638.0,1351.0,595.0,1500000000,0.0017210741061717,1082014363648.0,0.0144896217139029,0.0743117002150386,"#include <stdio.h>
#include <ctype.h>

void print_arguments(int argc, char *argv[]) 
{
	int i = 0;
	for(; i < argc; i++) {
		for(int q = 0; argv[i][q] != '\0'; q++) {
			char ch = argv[i][q];
			if(isalpha(ch) || isblank(ch)) {
				printf(""%c == %d "", ch, ch);
			}
		}
		printf(""\n"");
	}
}


int main(int argc, char *argv[])
{
	print_arguments(argc, argv);
	return 0;
}
"
194-6588,Enether/algos,largest_sum_contiguous_subarray/largestSumContiguousSubarray.c,21,2,7,1815138.1518691499,175623.0,10.335423036845972,1344.0,1325.0,39780.0,13546.0,1630.0,629.0,1352.0,590.0,1500000000,0.0012100921012461,1082014363648.0,0.0151973260905462,0.0787795821925514,"#include <stdio.h>
#include <stdlib.h>

int largestSumContinousSubArray(int arr[], int size) {
	int max_till = 0;
	int max_int = 0;
	for (int i = 0; i < size; i++) {
		max_int = max_int + arr[i];
		if(max_till < max_int) {
			max_till = max_int;
		}
		if (max_int < 0) {
			max_int = 0;
		}
	}
	return max_till;
}

int main() {
	int array[10];
	for (int k = 0; k < 10; k++) {
		array[k] = rand() % 10;
	}
	printf(""%d"", largestSumContinousSubArray(array, 10));
}
"
016-22341,attente/eofsim,src/mkconv.c,235,3,22,2096118.0562152,5127053.0,0.4088348608840205,1363.0,1339.0,720759.0,269889.0,1654.0,698.0,1372.0,656.0,1500000000,0.0013974120374768,1082014363648.0,0.0005270084003422,0.004421348450711,"/*
 * Copyright © 2007 Ryan Lortie
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of version 3 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * See the included COPYING file for more information.
 */

#include <stdio.h>
#include <math.h>

double int_to_float_table[] = 
{
  [40] = 158.0,
  [41] = 158.0,
  [42] = 155.6,
  [43] = 153.3,
  [44] = 151.3,
  [45] = 149.0,
  [46] = 146.6,
  [47] = 144.3,
  [48] = 142.5,
  [49] = 140.3,
  [50] = 138.2,
  [51] = 136.4,
  [52] = 134.0,
  [53] = 133.5,
  [54] = 131.7,
  [55] = 130.4,
  [56] = 128.8,
  [57] = 127.3,
  [58] = 125.7,
  [59] = 124.5,
  [60] = 123.0,
  [61] = 121.4,
  [62] = 119.8,
  [63] = 118.5,
  [64] = 117.3,
  [65] = 116.2,
  [66] = 115.1,
  [67] = 114.1,
  [68] = 113.0,
  [69] = 111.9,
  [70] = 111.0,
  [71] = 110.1,
  [72] = 109.0,
  [73] = 108.1,
  [74] = 107.0,
  [75] = 105.9,
  [76] = 104.9,
  [77] = 104.0,
  [78] = 103.1,
  [79] = 102.0,
  [80] = 101.2,
  [81] = 100.2,
  [82] = 99.3,
  [83] = 98.2,
  [84] = 97.3,
  [85] = 96.4,
  [86] = 95.5,
  [87] = 94.6,
  [88] = 94.0,
  [89] = 93.2,
  [90] = 92.3,
  [91] = 91.7,
  [92] = 90.8,
  [93] = 90.1,
  [94] = 89.2,
  [95] = 88.5,
  [96] = 87.7,
  [97] = 87.0,
  [98] = 86.3,
  [99] = 85.6,
  [100] = 84.7,
  [101] = 84.2,
  [102] = 83.3,
  [103] = 82.7,
  [104] = 82.2,
  [105] = 81.6,
  [106] = 80.9,
  [107] = 80.2,
  [108] = 79.7,
  [109] = 79.0,
  [110] = 78.4,
  [111] = 77.7,
  [112] = 77.1,
  [113] = 76.6,
  [114] = 76.1,
  [115] = 75.4,
  [116] = 74.6,
  [117] = 74.1,
  [118] = 73.5,
  [119] = 73.0,
  [120] = 72.3,
  [121] = 71.6,
  [122] = 71.2,
  [123] = 70.6,
  [124] = 70.0,
  [125] = 69.2,
  [126] = 68.7,
  [127] = 68.2,
  [128] = 67.8,
  [129] = 67.1,
  [130] = 66.4,
  [131] = 66.0,
  [132] = 65.3,
  [133] = 64.7,
  [134] = 64.4,
  [135] = 63.6,
  [136] = 63.1,
  [137] = 62.5,
  [138] = 62.0,
  [139] = 61.3,
  [140] = 60.8,
  [141] = 60.2,
  [142] = 59.7,
  [143] = 59.1,
  [144] = 58.6,
  [145] = 58.1,
  [146] = 57.5,
  [147] = 57.0,
  [148] = 56.4,
  [149] = 55.7,
  [150] = 55.3,
  [151] = 54.7,
  [152] = 54.2,
  [153] = 53.6,
  [154] = 53.0,
  [155] = 52.5,
  [156] = 51.9,
  [157] = 51.4,
  [158] = 51.0,
  [159] = 50.5,
  [160] = 49.8,
  [161] = 49.2,
  [162] = 48.7,
  [163] = 48.2,
  [164] = 47.8,
  [165] = 47.1,
  [166] = 46.5,
  [167] = 46.0,
  [168] = 45.5,
  [169] = 45.1,
  [170] = 44.4,
  [171] = 43.8,
  [172] = 43.3,
  [173] = 42.8,
  [174] = 42.0,
  [175] = 41.7,
  [176] = 41.1,
  [177] = 40.6,
  [178] = 40.2,
  [179] = 39.7,
  [180] = 39.0,
  [181] = 38.4,
  [182] = 37.9,
  [183] = 37.5,
  [184] = 37.0,
  [185] = 36.3,
  [186] = 35.8,
  [187] = 35.4,
  [188] = 34.8,
  [189] = 34.3,
  [190] = 33.6,
  [191] = 33.2,
  [192] = 32.7,
  [193] = 32.0,
  [194] = 31.5,
  [195] = 30.8,
  [196] = 30.1,
  [197] = 29.5,
  [198] = 28.8,
  [199] = 28.1,
  [200] = 27.4,
  [201] = 26.6,
  [202] = 25.9,
  [203] = 25.2,
  [204] = 24.6,
  [205] = 24.0,
  [206] = 23.2,
  [207] = 22.7,
  [208] = 22.0,
  [209] = 21.2,
  [210] = 20.5,
  [211] = 19.9,
  [212] = 18.9,
  [213] = 18.2,
  [214] = 17.8,
  [215] = 16.7,
  [216] = 16.2,
  [217] = 15.5,
  [218] = 14.8,
  [219] = 14.2,
  [220] = 13.2,
  [221] = 12.6,
  [222] = 11.9,
  [223] = 11.2,
  [224] = 10.6,
  [225] = 9.0,
  [226] = 8.1,
  [227] = 7.0,
  [228] = 6.1,
  [229] = 5.2,
  [230] = 4.3,
  [231] = 3.3,
  [232] = 2.4,
  [233] = 1.3,
  [234] = 0.2,
  [235] = 0.0
};

int
main (void)
{
  int i;

  printf (""#include \""conversion.h\""\n\n"");
  printf (""const unsigned char analog_to_digital[] =\n{\n"");

  for (i = 0; i <= 1500; i++)
  {
    double value = i / 10.0;
    double minerr;
    int best, j;

    minerr = fabs (int_to_float_table[40] - value);
    best = 40;

    for (j = 41; j < 236; j++)
    {
      double err = fabs (int_to_float_table[j] - value);

      if (err < minerr)
      {
        minerr = err;
        best = j;
      }
    }

    printf (""  [%d] = %d%s\n"", i, best, i < 1500 ? "","" : """");
  }

  printf (""};\n"");

  return 0;
}
"
064-25659,cg2v/Autolab,examples/hello/test-autograder/hello.c,6,1,4,1701092.9295792002,172497.0,9.861574404192536,1292.0,1274.0,39029.0,13221.0,1606.0,634.0,1333.0,592.0,1500000000,0.0011340619530528,1082014363648.0,0.0148756210252931,0.079712918660287,"/* Solution for the Hello Lab */
#include <stdio.h>

int main()
{
    printf(""Hello, world\n"");
    return 0;
}

"
218-14701,cartman300/picoc,tests/csmith/rand93.c,90,3,15,1836814.4519626498,239099.0,7.682232046139884,1359.0,1338.0,40237.0,15064.0,1620.0,655.0,1342.0,612.0,1500000000,0.0012245429679751,1082014363648.0,0.011279846423448,0.0764723965208585,"#include <stdio.h>
int print_hash_value = 1;
static void platform_main_begin(void)
{
}
static unsigned crc32_tab[256];
static unsigned crc32_context = 0xFFFFFFFFUL;
static void
crc32_gentab (void)
{
 unsigned crc;
 unsigned poly = 0xEDB88320UL;
 int i, j;
 for (i = 0; i < 256; i++) {
  crc = i;
  for (j = 8; j > 0; j--) {
   if (crc & 1) {
    crc = (crc >> 1) ^ poly;
   } else {
    crc >>= 1;
   }
  }
  crc32_tab[i] = crc;
 }
}
static void
crc32_byte (unsigned char b) {
 crc32_context =
  ((crc32_context >> 8) & 0x00FFFFFF) ^
  crc32_tab[(crc32_context ^ b) & 0xFF];
}
extern int strcmp ( char *, char *);
static void
crc32_8bytes (unsigned val)
{
 crc32_byte ((val>>0) & 0xff);
 crc32_byte ((val>>8) & 0xff);
 crc32_byte ((val>>16) & 0xff);
 crc32_byte ((val>>24) & 0xff);
}
static void
transparent_crc (unsigned val, char* vname, int flag)
{
 crc32_8bytes(val);
 if (flag) {
    printf(""...checksum after hashing %s : %X\n"", vname, crc32_context ^ 0xFFFFFFFFU);
 }
}
static void
platform_main_end (int x, int flag)
{
  if (!flag) printf (""checksum = %x\n"", x);
}
static long __undefined;
void csmith_compute_hash(void);
void step_hash(int stmt_id);
static int g_3 = 0xD7D490C4L;
static unsigned char func_1(void);
static unsigned char func_1(void)
{
    int *l_2 = &g_3;
    step_hash(1);
    l_2 = l_2;
    step_hash(2);
    return g_3;
}
void csmith_compute_hash(void)
{
    transparent_crc(g_3, ""g_3"", print_hash_value);
}
void step_hash(int stmt_id)
{
    int i = 0;
    csmith_compute_hash();
    printf(""before stmt(%d): checksum = %X\n"", stmt_id, crc32_context ^ 0xFFFFFFFFUL);
    crc32_context = 0xFFFFFFFFUL;
    for (i = 0; i < 256; i++) {
        crc32_tab[i] = 0;
    }
    crc32_gentab();
}
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    csmith_compute_hash();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}
"
101-10836,danblade/C_code_4_class,Ch8p390pe4.c,29,2,18,2256347.9142262503,193504.0,11.66046696709112,1439.0,1413.0,43763.0,16229.0,1642.0,639.0,1356.0,596.0,1500000000,0.0015042319428175,1082014363648.0,0.014738713411609,0.0705594079210561,"/* 
ITS240-01 
Lab 07 
Ch8p390pe4 
03/06/2017 
Daniel Kuckuck
	Write a declaration to store the following values in an array named rates: 18.24, 25.63, 5.94, 33.92, 3.71, 32.84, 35.93, 18.24, 6.92. Your program should then locate and display both the maximum and the minimum values in the array. 
*/
#include <stdio.h>
#define MAX 9
int main()
{
	float lowRate, highRate, rates[] = {18.24, 25.63, 5.94, 33.92, 3.71, 32.84, 35.93, 18.24, 6.92};
	lowRate = rates[1];
	highRate = rates[1];
	for (int i = 0; i < MAX; i++)
	{	
		if (rates[i] <= lowRate)
			lowRate = rates[i];
		else if (rates[i] >= highRate)
			highRate = rates[i];
		//printf(""\nlowrate is now %.2f, highrate is now %.2f"", lowRate, highRate);
	}
	printf(""\nThe array is: "");
	for (int i = 0; i < MAX; i++)
	{
		printf(""%.2f "", rates[i] );
	}
	printf(""and \nthe array's highest number is %.2f, and the lowest %.2f.\n"", highRate, lowRate);
	return 0;
}
"
247-2620,autolab/Tango,clients/job7/bug.c,10,1,12,908194805.9611022,1048746065.0,0.8656710106464142,1150.0,1143.0,38675.0,1048588783.0,1623.0,16384595.0,1381.0,16384557.0,1500000000,0.6054632039740682,1082014363648.0,2.186420599346897e-06,0.0312524297833139,"/* Test program that exceeds the memory on the VM */

/* 1GB array */
#define SIZE 1000*1024*1024

char array[SIZE];

int main()
{
   int i;

   for (i=0; i<SIZE; i++)
       array[i] = 0;
   return 0;
}
"
378-2004,dterei/Scraps,euler/p14/p14.c,18,2,12,288022977.29998815,800780152.0,0.3596779668934651,1336.0,1317.0,39246.0,13349.0,1617.0,636.0,1340.0,593.0,1500000000,0.1920153181999921,1082014363648.0,3.3130191768289483e-06,0.0795893145736286,"#include <stdio.h> 

int main(int argc, char **argv) { 
	int longest = 0, terms = 0, this_terms = 1, i;
	unsigned long j; 

	for (i = 1; i <= 1000000; i++) { 
		j = i; 
		this_terms = 1;

		while (j != 1) { 
			this_terms++; 
			j = j % 2 == 0 ? j / 2 : 3 * j + 1;
		} 

		if (this_terms > terms) { 
			terms = this_terms; 
			longest = i; 
		} 
	} 

	printf(""longest: %d (%d)\n"", longest, terms); 
	return 0; 
}

"
147-23000,crazyleen/msp430-gdb-7.2a,gdb/testsuite/gdb.python/py-progspace.c,17,1,9,1728858.3330809998,169061.0,10.226237866805471,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.001152572222054,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
main ()
{
  return 0;
}
"
327-26416,ILyoan/gdb,gdb/testsuite/gdb.base/gdb1090.c,37,2,20,1791934.59916845,169083.0,10.597954850576343,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0011946230661123,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* Test program for multi-register variable.
   Copyright 2003, 2007-2012 Free Software Foundation, Inc.

   This file is part of the gdb testsuite.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
   This file was written by Michael Elizabeth Chastain (mec@shout.net).  */

struct s_2_by_4
{
  int field_0;
  int field_1;
};

void marker (struct s_2_by_4 s_whatever)
{
  s_whatever = s_whatever;
  return;
}

void foo ()
{
  /* I want this variable in a register but I can't really force it */
  register struct s_2_by_4 s24;
  s24.field_0 = 1170;
  s24.field_1 = 64701;
  marker (s24); /* break-here */
  return;
}

int main ()
{
  foo ();
}
"
358-5946,tudinfse/haft,src/benches/simple/fib/src/fib.c,12,1,7,504160201.7590776,5000173773.0,0.1008285359445646,1333.0,1315.0,39264.0,13364.0,1618.0,636.0,1341.0,593.0,1500000000,0.3361068011727184,1082014363648.0,5.295815946035122e-07,0.0795774112639659,"#include <stdio.h>

int main(int argc, char **argv) {

	long j;
	long f1 = 1, f2 = 1;

	for (j = 3 ; j <= 1000000000 ; ++ j) { 
		long t;

		t = f1;
		f1 = f2;
		f2 = t + f2;
	}
	printf(""%ld %ld\n"", j, f2);
	return 0;
}
"
214-7232,ericdahl/project-euler,c/p014.c,25,2,13,269005936.5704655,754170957.0,0.5888786446598738,1340.0,1320.0,39182.0,13307.0,1618.0,636.0,1340.0,593.0,1500000000,0.179337291046977,1082014363648.0,3.5270517583720742e-06,0.079769094476938,"#include <stdio.h>

static int calc_length(long n);

int main(int argc, char** argv) {

    int longest_length = 0;
    int longest_n = 0;
    for (long i = 1; i < 1000000; ++i) {
        const int len = calc_length(i);
        if (len > longest_length) {
            longest_length = len;
            longest_n = i;
        }
    }

    printf(""%d\n"", longest_n);
}

// using a cache does not seem to offer any time savings
static int calc_length(long n) {
    int len = 1;
    for (; n != 1; len++) {
        if (n % 2 == 0) {
            n /= 2;
        } else {
            n = 3 * n + 1;
        }
    } 
    return len;
}
"
066-9229,Prabudh/Miscellaneous,revision/euler/maxPrimeDivisor.c,10,1,5,3303396.04988685,227884.0,14.49595408190132,1331.0,1312.0,39164.0,13300.0,1617.0,638.0,1339.0,593.0,1500000000,0.0022022640332579,1082014363648.0,0.0115980060030541,0.0798071058249466,"#include<stdio.h>
int main()
{
long n = 600851475143L,i;
for(i=1;i<n;i++)
{
if(n%i==0)
  n = n/i;
}

printf(""%d"",n);
}
"
383-30547,FeiLi0211/432053414D504C4553,0X0053.c,13,1,9,1713768.1134045,179054.0,9.571235493203169,1340.0,1321.0,40468.0,14212.0,1617.0,639.0,1340.0,596.0,1500000000,0.001142512075603,1082014363648.0,0.0148614384487361,0.0766642282370153,"/* 调用次数 */
#include <stdio.h>

void put_count()
{
  static int times;

  printf(""put_count: 第%d次\n"", ++times);
}

int main(void)
{
  for (int i = 0; i < 10; i++) {
    put_count();
  }

  return 0;
}
"
050-24903,orangebook/FlyLab,example/demo-c_language/c-cache/main.c,10,2,9,2334514.39999035,169083.0,13.80691139854391,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0015563429333269,1082014363648.0,0.0134490161636592,0.0785049652044725,"#define DUMBCOPY for(i=0;i<65536; ++i) \
  destination[i] = source[i]

#define SMARTCOPY memcpy(destination, source, 65536)

int main(int argc, char * argv[]) {
  char source[65536], destination[65536];
  int i, j;
  for (j =0;j< 100; ++j) {
    // 选择以下两行之一进行测试
    SMARTCOPY;
    // DUMBCOPY
  }
}"
106-5356,depp/idiotest,selftest/subdir/nostdin.c,8,1,5,1501868986.291811,170517.0,8807.737562823648,1151.0,1140.0,38869.0,12875.0,1581.0,585.0,1328.0,546.0,1500000000,1.0012459908612072,1082014363648.0,0.0134356105256367,0.0780766852195423,"/* Copyright 2012 Dietrich Epp <depp@zdome.net>
   See LICENSE.txt for details.  */
#include <unistd.h>

int main(int argc, char *argv[])
{
    close(STDIN_FILENO);
    sleep(1);
    return 0;
}
"
085-1753,AndrewLaing/CHowToProgramExercises,Chapter4/ex04_33.c,49,3,20,2489509.4102248503,207624.0,11.990468346626594,1298.0,1281.0,52392.0,19472.0,1621.0,644.0,1342.0,602.0,1500000000,0.0016596729401499,1082014363648.0,0.0124214926983393,0.0585689635979071,"/*
 * Filename:    ex04_33.c
 * Author:      Andrew Laing
 * Email:       parisianconnections@gmail.com
 * Date:        24/04/2017
 */

#include <stdio.h>


int main()
{   
    int i, current;
    
    for(i=1; i<=100; i++)
    {
        current=i;
        
        if(current==100) {
            printf(""C"");
            current=0;
        }
        if(current>=50) {
            printf(""L"");
            current-=50;
        }
        while(current>=10) {
            printf(""X"");
            current-=10;
        }
        if(current>=5) {
            if(current%10==9) {
                printf(""IX"");
                current-=9;
            }
            else {
                printf(""V"");
                current-=5;
            }   
        }
        while(current>0) 
        {
            if(current%10==4) {
                printf(""IV"");
                current-=4;
            }
            else {
                printf(""I"");
                current-=1;
            }
            
        }
        printf(""\n"");
    }

    return 0;
}

"
078-16331,depp/idiotest,selftest/subdir/nostdout.c,8,1,5,1502015401.3764114,170491.0,8806.797320679683,1148.0,1137.0,38861.0,12875.0,1581.0,585.0,1328.0,546.0,1500000000,1.0013436009176075,1082014363648.0,0.0134024669923925,0.0780887583114272,"/* Copyright 2012 Dietrich Epp <depp@zdome.net>
   See LICENSE.txt for details.  */
#include <unistd.h>

int main(int argc, char *argv[])
{
    close(STDOUT_FILENO);
    sleep(1);
    return 0;
}
"
375-31289,benquike/cheatsheets,algo/leetcode/google/str_with_backspace.c,38,1,20,1882803.1606971002,173705.0,10.83908350364123,1298.0,1281.0,39374.0,13366.0,1618.0,633.0,1340.0,591.0,1500000000,0.0012552021071314,1082014363648.0,0.0148470107365936,0.0792946530147895,"#include <stdio.h>

int clean(char *str, int len) {
  int i = 0;
  int j = 0;

  while (j < len) {
    if (str[j] >= 'a' && str[j] <= 'z') {
      str[i++] = str[j];
    } else if (str[j] == 'B') {
      // TODO
      if (i > 0) {
        i--;
      } else {
        // unexpected
      }

    } else if (str[j] == 0) {
      // end of string
      break;
    } else {
      // unexpected input
    }

    j ++;
  }

  str[i] = 0;

  return i;
}

int same(char *str1, int len1, char *str2, int len2) {
  
}

int main() {

  char str1[10] = ""a"";
  int x = clean(str1, 10);
  printf(""%s\n"", str1);

  char str2[10] = ""aB"";
  int x2 = clean(str2, 10);
  printf(""%s\n"", str2);



  char str3[10] = ""aaaBaBaB"";
  int x3 = clean(str3, 10);
  printf(""%s\n"", str3);

  return 0;
}
"
097-16235,SanDisk-Open-Source/SSD_Dashboard,uefi/userspace/glibc/stdio-common/tst-fileno.c,28,1,16,1872664.20107325,179688.0,10.421753261208316,1365.0,1340.0,40574.0,14101.0,1632.0,639.0,1345.0,595.0,1500000000,0.0012484428007155,1082014363648.0,0.0150538711544454,0.0770187471422039,"/* Copyright (C) 1994-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

static int
check (const char *name, FILE *stream, int fd)
{
  int sfd = fileno (stream);
  printf (""(fileno (%s) = %d) %c= %d\n"", name, sfd,
	  sfd == fd ? '=' : '!', fd);
  return sfd != fd;
}

int
main (void)
{
  return (check (""stdin"", stdin, STDIN_FILENO) ||
	  check (""stdout"", stdout, STDOUT_FILENO) ||
	  check (""stderr"", stderr, STDERR_FILENO));
}
"
194-3902,freak97/binutils,gdb/testsuite/gdb.base/bg-execution-repeat.c,25,1,14,7502592626.726254,170067.0,44115.51109856703,1152.0,1142.0,38683.0,12795.0,1575.0,585.0,1323.0,544.0,1500000000,5.001728417817503,1082014363648.0,0.0134888014723608,0.0782275923695559,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2016 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
foo (void)
{
  return 0; /* set break here */
}

int
main (void)
{
  foo ();
  sleep (5);
  foo ();
  return 0;
}
"
323-10584,welkinli/nuts,server/frame/test/test_tlc.c,29,1,16,1530945349.484682,184804.0,8284.156993355122,1506.0,1472.0,42101.0,14950.0,1660.0,712.0,1371.0,668.0,1500000000,1.020630232989788,1082014363648.0,0.016114369818835,0.0773167867346759,"#include	<stdio.h>
#include	<pthread.h>

static int global_value = 0;

__thread int thread_value = 0;

void *
test_tls_func(void *arg)
{
	printf(""I am %d, tls: %p\n"", pthread_self(), &thread_value);
	global_value++;
	thread_value++;
	return NULL;
}

int
main(int arg, char **argv)
{
	int i, tnum = 0;;
	pthread_t tid;
	
	if (argv[1]) {
		tnum = atoi(argv[1]);
	}
	else {
		tnum = 2;
	}

	for (i = 0; i < tnum; i++) {
		pthread_create(&tid, NULL,  test_tls_func, NULL);
	}

	printf(""glabal value: %d, thread value: %d\n"", global_value, thread_value);
	sleep(1);
	printf(""glabal value: %d, thread value: %d\n"", global_value, thread_value);
	
	return 0;
}

"
321-18035,csulennon/unix-learn-note,20150215_pthread/mutex.c,29,1,15,153211237.5134601,289892.0,873.5603466118416,2309.0,1787.0,67842.0,27920.0,2181.0,896.0,1631.0,820.0,1500000000,0.1021408250089734,1082014363648.0,0.0141293999144509,0.0577264468160648,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
int count = 0;

void * func(void * arg)
{
	int th = *(int*) arg;
	printf(""线程%d正在运行...\n"", th);
	int i = 0;
	for (i = 0; i < 10; i++)
	{
		pthread_mutex_lock(&mutex);
		count++;
		pthread_mutex_unlock(&mutex);
		printf(""线程%d running...%d\n"", th, count);
		usleep(10 * 1000);
	}
	printf(""线程%d结束\n"", th);
	pthread_exit(NULL);
	//return NULL;
}

int main()
{
	pthread_t thrd1, thrd2;
	int arg[2] = { 1, 2 };
	pthread_create(&thrd1, NULL, func, &arg[0]);
	pthread_create(&thrd2, NULL, func, &arg[1]);

	pthread_join(thrd1, NULL);
	pthread_join(thrd2, NULL);

	return 0;
}

"
332-18760,arevaloarboled/Clases_2015,topics/process/LaboratorioProcesos/split2.c,29,2,15,1781762.8104238498,188257.0,9.464519247624258,1411.0,1388.0,42575.0,15287.0,1640.0,644.0,1356.0,601.0,1500000000,0.0011878418736159,1082014363648.0,0.0148679730368591,0.0732950814005737,"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

int strsplit (const char *str, char *parts[], const char *delimiter) 
{
  char *pch;
  int i = 0;
  char *tmp = strdup(str);
  pch = strtok(tmp, delimiter);

  parts[i++] = strdup(pch);

  while (pch) 
  {
    pch = strtok(NULL, delimiter);
    if (NULL == pch) break;
    parts[i++] = strdup(pch);
  }

  free(tmp);
  free(pch);
  return i;
}

int main (void) 
{
  char str[] = ""0 1 2 3 4 5 6 7 8 9"";
  char **parts = calloc(10, sizeof(char *));
  size_t size = strsplit(str, parts, "" "");
  int i = 0;

  for (; i < (int) size; ++i) 
  {
    printf(""%d\n"", atoi(parts[i]));
  }

  return 0;
}"
059-31814,TambourineReindeer/boomerang,tests/baseline/ppc/loop/loop.c,10,1,10,1832134.2067792502,172952.0,10.593309126231556,1345.0,1325.0,39114.0,13292.0,1612.0,634.0,1337.0,593.0,1500000000,0.0012214228045195,1082014363648.0,0.0154378093343817,0.0796855321909704,"// address: 0x10000418
int main(int argc, char *argv[], char *envp[]) {
    int local0; 		// m[g1 - 24]

    local0 = 0;
    while (local0 <= 9) {
        local0++;
    }
    printf(""%i\n"", local0);
    return 0;
}

"
244-5387,LLGZONE/HUST_TENCENT_WEB,1_c_structure/刘萱/冒泡排序.c,33,3,17,1955837.8262445,178553.0,10.953817633979826,1340.0,1320.0,40417.0,14085.0,1626.0,637.0,1344.0,594.0,1500000000,0.001303891884163,1082014363648.0,0.0148975374258623,0.0770797401930204,"#include <stdio.h>

void swap(int *a,int *b)
{
	int temp=*a;
	*a=*b;
	*b=temp;
}

void Bubble_Sort(int a[],int n )
{
	int i,j;
    for(i=n-1;i>=0;--i)
    {
    	int flag=0;
    	for (j=0;j<i;++j)
    	{
    		if(a[j]>a[j+1]) 
    		{
    			flag=1;
    			swap(&a[j],&a[j+1]);
    			
			}
		}
    	if (flag==0)
    	break;
	}
    
}


int main (void)
{
	int a[]={9,5,44,66,85,12,35,27};
	int n=sizeof(a)/sizeof(int),i;
	Bubble_Sort(a,n);
	for(i=0;i<n;i++)
	printf(""%d\n"",a[i]);
	
	return 0;
}
"
001-27084,isshe/2.Advanced_programming,chapter_10/p270_sleep2_setjmp.c,40,1,24,3004220857.5177937,1604764750.0,1.8720630902442243,1170.0,1159.0,39375.0,13079.0,1595.0,592.0,1336.0,547.0,1500000000,2.0028139050118625,1082014363648.0,1.4513030648261685e-06,0.0775917947153696,"/*==============================================================================\
* Copyright(C)2016 Chudai.
*
* File name    : p270_sleep2_setjmp.c
* Version      : v1.0.0
* Author       : 初代
* Date         : 2016/01/06
* Description  : 使用setjmp()和longjmp()的sleep实现, 同样是不完善的实现
* Function list: 1.
*                2.
*                3.
* History      :
\*==============================================================================*/

#include <setjmp.h>
#include <signal.h>
#include <unistd.h>
#include <stdio.h>      //main

static jmp_buf  env_alrm;

static void
sig_alrm(int signo)
{
    longjmp(env_alrm, 1);
}

unsigned int
sleep2(unsigned int seconds)
{
     if (signal(SIGALRM, sig_alrm) == SIG_ERR)
     {
         return(seconds);
     }

     if (setjmp(env_alrm) == 0)
     {
          alarm(seconds);
          while(1);             //这样也可以的样子哦???
 //         pause();
     }

     return (alarm(0));
}

int
main(void)
{
     sleep2(2);

     return 0;
}
"
145-25482,ccilab/binutils,gdb/testsuite/gdb.base/floatn.c,36,1,14,1569092.97220395,169112.0,9.278419035905198,1145.0,1135.0,38474.0,12711.0,1571.0,588.0,1320.0,549.0,1500000000,0.0010460619814693,1082014363648.0,0.0134821893183215,0.0786949301553189,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2016 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <stdio.h>
#include <stdlib.h>

_Float32 f32;
_Float64 f64;
_Float128 f128;
_Float32x f32x;
_Float64x f64x;

_Complex _Float32 c32;
_Complex _Float64 c64;
_Complex _Float128 c128;
_Complex _Float32x c32x;
_Complex _Float64x c64x;

int main()
{
  f32 = 1.5f32;
  f64 = 2.25f64;
  f128 = 3.375f128;
  f32x = 10.5f32x;
  f64x = 20.25f64x;

  c32 = 1.5f32 + 1.0if;
  c64 = 2.25f64 + 1.0if;
  c128 = 3.375f128 + 1.0if;
  c32x = 10.5f32x + 1.0if;
  c64x = 20.25f64x + 1.0if;

  return 0;
}
"
048-23420,urkopineda/system-programming-c,06mmtt/01variousThreads/01variousThreadsMain.c,37,3,21,15043523446.423933,207190.0,72607.381852406,1524.0,1489.0,47670.0,18972.0,1671.0,738.0,1376.0,695.0,1500000000,10.029015630949289,1082014363648.0,0.0145422076355036,0.0672248732030851,"#include <stdio.h>
#include <unistd.h>
#include <pthread.h>

void* threadMainFunction1(void*);
void* threadMainFunction2(void*);

int main()
{
  pthread_t idThread1, idThread2, idThread3;

  printf(""creating threads ......\n"");
  pthread_create(&idThread1, NULL, threadMainFunction1, (void*) 1);
  pthread_create(&idThread2, NULL, threadMainFunction1, (void*)2);
  pthread_create(&idThread3, NULL, threadMainFunction2, (void*)""kuku"");
  pthread_join (idThread1, NULL);
  pthread_join (idThread2, NULL);
  pthread_join (idThread3, NULL);
  printf(""Threads finished. Main going to finish \n"");
  return 0;
}

void *threadMainFunction1 (void *arg)
{
  int i, j,  n = (int) arg;
  
  for (i=0;i<10;i++)
  {
    sleep(1);
    for(j=0;j<n;j++) printf(""\t\t"");
    printf ("" ...... %d ...........\n"", n);
  }
  return NULL;
}

void *threadMainFunction2 (void *arg)
{
  int i;
  char* pStr= (char*)arg;
  
  for(i=0;i<5;i++)
  {
    sleep(2);
    printf(""%s\n"", pStr);
  }
  return NULL;
}
"
009-14187,swigger/gdb-ios,gdb/testsuite/gdb.base/nofield.c,29,1,12,1569962.9439040502,169083.0,9.153883004205037,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010466419626027,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2007-2016 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

struct empty {};
union empty_union {};

struct not_empty
{
  void *e;
  void *u;
};

int
main (void)
{
  struct empty e = {};
  union empty_union u;
  struct not_empty n = {0, 0};

  n.e = &e;
  n.u = &u;

  return 0;
}

"
183-7535,shivamdixit/euler,p5_imp.c,25,2,11,1485123829.334043,3795173203.0,0.3913191176165669,1338.0,1318.0,39187.0,13308.0,1620.0,636.0,1342.0,593.0,1500000000,0.990082552889362,1082014363648.0,6.998363073127969e-07,0.0798361748737975,"/*Problem 5: 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?*/

#include<stdio.h>

#define MAX 999999999
#define MIN 2520

int main(int argc, char const *argv[])
{
	unsigned long long int i,j;
	int flag=0;
	for(i=MIN;i<MAX;i++)
	{
		flag =0;
		for(j=2;j<=20;j++)
		{
			if(i%j!=0)
			{
				flag = 1;
				break;
			}
		}
		if(flag==0)
		{
			printf(""%llu\n"",i);
			break;
		}
	}
	return 0;
}"
315-31685,TZer0/INF3190-groupcode,2013/week3/bitshift.c,11,1,5,1667209.4352543,222476.0,7.493882486200759,1342.0,1323.0,49155.0,20402.0,1618.0,646.0,1340.0,603.0,1500000000,0.0011114729568362,1082014363648.0,0.011978820187346,0.0604827695271503,"#include<stdio.h>

int main() {
	int a = 1;
	int i = 0;
	int b = 12414146;
	while (i < 35) {
		printf(""a: %d\n"", a);
		printf(""b: %d\n"", b & (a-1));
		a<<=1;
		i++;
	}
}
"
345-32716,freak97/binutils,gdb/testsuite/gdb.base/continue-all-already-running.c,18,1,14,16261948182.131166,170055.0,95627.58038281732,1149.0,1140.0,38683.0,12795.0,1574.0,581.0,1323.0,544.0,1500000000,10.841298788087444,1082014363648.0,0.0134603510628914,0.0781304634989704,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2016 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
main (void)
{
  sleep (10);
  return 0; /* set break here */
}
"
261-20542,hzq1001/or1k-src,gdb/testsuite/gdb.base/memattr.c,21,1,10,1653452.9859199498,169083.0,9.77893697178309,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0011023019906133,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2011-2013 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#define MEMSIZE 64
static int mem1[MEMSIZE] = {111, 222, 333, 444, 555};
static int mem2[MEMSIZE];
static int mem3[MEMSIZE];
static int mem4[MEMSIZE];
static int mem5[MEMSIZE];

int main()
{
  return 0;
}
"
289-4934,rgv151/ptrace.nim,tests/target.c,7,1,0,1498471.59627825,173950.0,8.614377694739868,1282.0,1266.0,39478.0,13419.0,1617.0,633.0,1338.0,592.0,1500000000,0.0009989810641855,1082014363648.0,0.0146478873239436,0.0790214946027184,"#include <stdio.h>
int main(void)
{
    int c;
    while (EOF != (c = getc(stdin)))
        putc(c, stdout);
    return 0;
}
"
260-26387,EvtimPavlov/c-programming-2014-2015-homework,A/03_Antonio_Mindov/Homework_2/printf_examples.c,8,1,6,2249209.3266918,193776.0,11.607263025348855,1339.0,1320.0,43487.0,16333.0,1618.0,641.0,1339.0,596.0,1500000000,0.0014994728844612,1082014363648.0,0.0137220295599042,0.0701103309929789,"#include<stdio.h>

int main()
{
	int i;
	for(i=0;i<26;i++){
		char ch = 65+i;
		printf(""%d : %c \n"",i+1,ch);	
	}
}
"
118-7029,Gurgel100/gcc,gcc/testsuite/c-c++-common/torture/pr83553.c,26,1,16,1767348.0324447,169976.0,10.397632606956275,1147.0,1138.0,38668.0,12781.0,1577.0,586.0,1323.0,546.0,1500000000,0.0011782320216298,1082014363648.0,0.013443074316374,0.0783688701432486,"/* PR c++/83553 */
/* { dg-do run } */

int a[3];

int
foo (int n)
{
  switch (n)
    {
    case 0:
      for (n = 7, a[0]++; 0; a[2] = a[1] + 1)
	{
    case 2:
	  a[1] = a[0] + 1;
	}
    }
  return n;
}

int
main ()
{
  if (foo (0) != 7 || a[0] != 1 || a[1] || a[2])
    __builtin_abort ();
  if (foo (2) != 2 || a[0] != 1 || a[1] != 2 || a[2] != 3)
    __builtin_abort ();
  return 0;
}
"
104-3028,AungWinnHtut/POL,C/timetest.c,13,3,9,24849866.749718703,124159989.0,0.2001439127060489,1342.0,1322.0,24208590.0,15706967.0,1620.0,699.0,1340.0,656.0,1500000000,0.0165665778331458,1082014363648.0,2.145618746792898e-05,0.0001081032139924,"#include <stdio.h>

int main () {


   for(unsigned hour=0;hour<24;hour++)
   {
       for(unsigned minute=0;minute<=60;minute++)
       {
            for(unsigned second=0;second<=60;second++)
            {
                printf(""%d Hours %d minutes %d seconds\n"",hour,minute,second);
            }
       }
   }

   return 0;
}
"
239-30806,alpine9000/BitOS,tests/gcc.c-torture/pr65053-1.c,28,1,17,1553702.7502430999,169979.0,9.140552656504626,1146.0,1137.0,38667.0,12780.0,1577.0,586.0,1323.0,546.0,1500000000,0.0010358018334954,1082014363648.0,0.0134310708969931,0.0783719167298384,"/* { dg-do run } */
/* PR tree-optimization/65053 */

int i;

__attribute__ ((noinline, noclone))
unsigned int foo (void)
{
  return 0;
}

int
main ()
{
  unsigned int u = -1;
  if (u == -1)
    {
      unsigned int n = foo ();
      if (n > 0)
	u = n - 1;
    }

  while (u != -1)
    {
      asm ("""" : ""+g"" (u));
      u = -1;
      i = 1;
    }

  if (i)
    __builtin_abort ();
  return 0;
}
"
265-1278,yigezhe/algorithm-summary,math/integer_factors/integer_factors.c,12,1,6,1684817.71834185,175792.0,9.584150587057431,1338.0,1317.0,39772.0,13674.0,1625.0,637.0,1345.0,593.0,1500000000,0.0011232118122279,1082014363648.0,0.0151030763629744,0.07858399131834,"#include<stdio.h>
int main() {
	//这里我先找出给定整数的因数
	int i;
	int n=38;
	for(i=1;i<=n;i++) {
		if (n % i == 0) {
			printf("" %d"",i);
		}
	}
	printf(""\n"");
	return 0;
}
"
134-19140,Chilledheart/glibc,wctype/test_wctype.c,67,6,17,1972022.9320227,363175.0,5.429949748743718,1371.0,1351.0,90433.0,20309.0,1720.0,640.0,1427.0,595.0,1500000000,0.0013146819546818,1082014363648.0,0.0074950092930405,0.039569449711943,"/* Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <wctype.h>

int
main (int argc, char *argv[])
{
  int result = 0;
  wctype_t bit_alnum = wctype (""alnum"");
  wctype_t bit_alpha = wctype (""alpha"");
  wctype_t bit_cntrl = wctype (""cntrl"");
  wctype_t bit_digit = wctype (""digit"");
  wctype_t bit_graph = wctype (""graph"");
  wctype_t bit_lower = wctype (""lower"");
  wctype_t bit_print = wctype (""print"");
  wctype_t bit_punct = wctype (""punct"");
  wctype_t bit_space = wctype (""space"");
  wctype_t bit_upper = wctype (""upper"");
  wctype_t bit_xdigit = wctype (""xdigit"");
  int ch;

  if (wctype (""does not exist"") != 0)
    {
      puts (""wctype return value != 0 for non existing property"");
      result = 1;
    }

  for (ch = 0; ch < 256; ++ch)
    {
#define TEST(test) \
      do								      \
	{								      \
	  if ((is##test (ch) == 0) != (iswctype (ch, bit_##test) == 0))	      \
	    {								      \
	      printf (""`iswctype' class `%s' test ""			      \
		      ""for character \\%o failed\n"", #test, ch);	      \
	      result = 1;						      \
	    }								      \
	  if ((is##test (ch) == 0) != (isw##test (ch) == 0))		      \
	    {								      \
	      printf (""`isw%s' test for character \\%o failed\n"",	      \
		      #test, ch);					      \
	      result = 1;						      \
	    }								      \
	 }								      \
      while (0)

      TEST (alnum);
      TEST (alpha);
      TEST (cntrl);
      TEST (digit);
      TEST (graph);
      TEST (lower);
      TEST (print);
      TEST (punct);
      TEST (space);
      TEST (upper);
      TEST (xdigit);
    }

  if (result == 0)
    puts (""All test successful!"");
  return result;
}
"
110-28140,ISSAE/nsy103,BaseProgLinux/Environnement/exemple_getopt.c,32,2,13,1866497.9143067999,175559.0,10.631736339350304,1168.0,1157.0,40275.0,13430.0,1673.0,591.0,1344.0,548.0,1500000000,0.0012443319428712,1082014363648.0,0.0132434110469984,0.0773857182757657,"#include <stdio.h>
#include <unistd.h>

int
main(int argc, char * argv []) {

    char * liste_options = ""abc:XY"";
    int option;

    opterr = 0; /* Pas de message d'erreur automatique */

    while ((option = getopt(argc, argv, liste_options)) != -1) {

        switch (option) {

            case 'a':
                fprintf(stdout, ""Option a\n"");
                break;
            case 'b':
                fprintf(stdout, ""Option b\n"");
                break;
            case 'c':
                fprintf(stdout, ""Option c %s\n"", optarg);
                break;
            case 'X':
            case 'Y':
                fprintf(stdout, ""Option %c\n"", option);
                break;
            case '?':
                fprintf(stderr, ""Option %c fausse\n"", optopt);
                break;
        }
    }

    if (optind != argc) {
        fprintf(stdout, ""Arguments restants :\n"");
        while (optind != argc)
            fprintf(stdout, ""  %s\n"", argv [optind++]);
    }

    return (0);
}
"
079-8928,tejaswiyvs/LearnCTheHardWay,ex10.c,16,2,12,1995606.1150878002,178085.0,11.205918522054075,1356.0,1335.0,40252.0,13961.0,1627.0,637.0,1345.0,596.0,1500000000,0.0013304040767252,1082014363648.0,0.0151107617149114,0.0775644218176452,"#include <stdio.h>

int main(int argc, char *argv[])
{
  int i;
  for (i = 0; i < argc; i++) {
    printf(""arg %d: %s \n"", i, argv[i]);
  }

  // let's make our own array of strings
  char *states[] = {
    ""California"", ""Oregon"", ""Washington"", ""Texas""
  };

  int num_states = 4;

  for (i = 0; i < num_states; i++) {
    printf(""state %d: %s\n"", i, states[i]);
  }

  return 0;
}
"
364-16603,mattstock/binutils-bexkat1,gdb/testsuite/gdb.base/ldbl_e308.c,19,1,11,1358911.5114882,169086.0,8.036803756668204,1142.0,1132.0,38462.0,12697.0,1569.0,585.0,1318.0,546.0,1500000000,0.0009059410076588,1082014363648.0,0.0134487775451545,0.0785394554232881,"/* Copyright (C) 2012-2020 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

long double ldbl_308 = 2.0;

int
main (void)
{
  ldbl_308 = ldbl_308 / 2;

  return 0;
}
"
293-25545,chabbimilind/cctlib,tests/footprint_test/test6.c,27,3,13,73728932.99907435,127045590.0,0.5803344452963696,1152.0,1144.0,15663873.0,55637863.0,939140.0,1563095.0,313830.0,625546.0,1500000000,0.0491526219993829,1082014363648.0,1.807225264568412e-05,0.0482682637628907,"#include <stdio.h>
#define N (10000000)
int A[N];
int B[N/2];

void g()
{
  int i=0;
  for (i = 1; i<N; i++){
    A[i] = 2*B[i-1];
    B[i] = 0.5;
  }
}

void h1()
{
  int i;
  for (i = 1; i<N/2; i++) B[i] = B[i-1];
}

void f()
{
  int i;
  for (i = 1; i<N/2; i++) B[i-1] = B[i];
}

int main()
{
  f();
  g();
  h1();
  return 0;
}
"
375-25509,misizeji/StudyNote_201308,Linux_System/pthread/pthread_join.c,21,1,11,4502284173.038788,182398.0,24683.846166076382,1558.0,1523.0,41494.0,14635.0,1669.0,716.0,1374.0,671.0,1500000000,3.0015227820258588,1082014363648.0,0.0168916325836906,0.0789253327157084,"
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

void *func1(void *arg)
{
	static int num = 123;
	int i = 0;
	for (i = 0;i < 3;i++)
	{
		printf(""in func1\n"");
		sleep(1);
	}
	return &num;
}

int main(int argc, char *argv[])
{
	int *save = NULL;
	pthread_t pid1;
	
	pthread_create(&pid1,NULL,func1,NULL);

	pthread_join(pid1,(void **)&save);
	printf(""save content is %d\n"",*((int *)save));

	printf(""after join \n"");
	return 0;
}
"
047-31117,mattstock/binutils-bexkat1,gdb/testsuite/gdb.base/filesym.c,22,1,10,1579411.44425415,169083.0,9.3410396077666,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010529409628361,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2013-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
filesym (int arg)
{
  return arg;
}

int
main (void)
{
  return filesym (0);
}
"
055-26206,EvtimPavlov/c-programming-2014-2015-homework,B/02_Atanas_Chompolov/homework_3/task_3.c,36,4,18,1620693.01586595,182481.0,8.881434231509035,1338.0,1319.0,41048.0,14542.0,1618.0,637.0,1340.0,594.0,1500000000,0.0010804620105773,1082014363648.0,0.0145604199889303,0.0753552797265695,"#include <stdio.h>

int main()
{
	int x,f,count,a,b,t,tf;

	count=0;
	a=2;
	f=0;

	while(count<10)
 	{
		while(f==0)
		{
 			a++;
 			t=1;
 			for(x=1; x < a; x++)
 			{ 
				if(a%x<0 || a%x>0)
					t=0;
			}
 				if(t=1) 
					f=1;
 			}	
			b= a+2;
 			tf=1;
 			for(x=1; x < b; x++) 
			{
				if(b%x<0 || b%x>0) 
					tf=0;
			}
			if(tf=1)
 			{
 				printf(""%d - %d\n"",a,b);
 				count++;
 				a++;
 			}
	}
	return 0;
}
"
106-1204,ilee/projects,daily/pe/pe10.c,25,2,17,547158874.3384928,1898163923.0,0.2882569136258944,1347.0,1326.0,20813342.0,14974234.0,1622.0,699.0,1342.0,656.0,1500000000,0.3647725828923285,1082014363648.0,1.4082029310595003e-06,0.0001206843402861,"/* Project Euler
** 10
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <inttypes.h>

static long long euler = 0;
static long long primebelow = 2000000;

int isPrime (int number) {

	unsigned int j = 2;
	for (j=2; j*j<=number; j++) {
		if (number % j == 0) return 0;
	}
	return 1;
}

int main(int argc, char** argv) {

	unsigned long long primesum = 0;
	int i;

	for (i=2; i < primebelow; i++) {
		if (isPrime(i)) {
			printf(""%d\n"", i);
			primesum+=i;
		}
	}

	euler = primesum;

	printf(""%llu\n"", euler);

return 0;
}

"
127-23167,mattstock/binutils-bexkat1,gdb/testsuite/gdb.guile/scm-objfile.c,18,1,10,1558936.5502818,169057.0,9.22136320885855,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010392910335212,1082014363648.0,0.0134155935572026,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2011-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
main ()
{
  int some_var = 0;
  return 0;
}
"
034-10339,mattstock/binutils-bexkat1,gdb/testsuite/gdb.base/interrupt-noterm.c,18,1,10,4501755474.018864,170067.0,26470.48206883169,1151.0,1141.0,38683.0,12795.0,1574.0,589.0,1321.0,547.0,1500000000,3.001170316012576,1082014363648.0,0.01347704140133,0.0783052954660243,"/* This testcase is part of GDB, the GNU debugger.

   Copyright (C) 2013-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
main ()
{
  sleep (3);
  return 0;
}
"
113-769,totalspectrum/binutils-propeller,gdb/testsuite/gdb.base/interrupt-noterm.c,18,1,10,4501929460.32621,170067.0,26471.50511269088,1151.0,1141.0,38683.0,12795.0,1574.0,589.0,1321.0,547.0,1500000000,3.00128630688414,1082014363648.0,0.01347704140133,0.0783052954660243,"/* This testcase is part of GDB, the GNU debugger.

   Copyright (C) 2013-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
main ()
{
  sleep (3);
  return 0;
}
"
081-23790,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.base/interrupt-noterm.c,18,1,10,4503020137.664862,170067.0,26477.918332186728,1151.0,1141.0,38683.0,12795.0,1574.0,589.0,1321.0,547.0,1500000000,3.002013425109908,1082014363648.0,0.01347704140133,0.0783052954660243,"/* This testcase is part of GDB, the GNU debugger.

   Copyright (C) 2013-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
main ()
{
  sleep (3);
  return 0;
}
"
174-17494,ensc/dietlibc,test/getusershell.c,6,1,1,1804802.9160126,180973.0,9.97276941864256,1428.0,1405.0,41033.0,14313.0,1628.0,648.0,1349.0,605.0,1500000000,0.0012032019440084,1082014363648.0,0.0156542688688367,0.0764282875004517,"#define _BSD_SOURCE
#include <unistd.h>
#include <stdio.h>

int main() {
  char* c;
  while ((c=getusershell()))
    puts(c);
  return 0;
}
"
344-2180,zxombie/aarch64-freebsd-binutils,gdb/testsuite/gdb.base/interrupt-noterm.c,18,1,10,4534828010.830097,170067.0,26664.94975509652,1151.0,1141.0,38683.0,12795.0,1574.0,589.0,1321.0,547.0,1500000000,3.0232186738867317,1082014363648.0,0.01347704140133,0.0783052954660243,"/* This testcase is part of GDB, the GNU debugger.

   Copyright (C) 2013-2014 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
main ()
{
  sleep (3);
  return 0;
}
"
209-15220,jbush001/NyuziProcessor,tests/tools/profile/test_program.c,24,3,15,1524994.73188065,309081.0,4.93249989484957,1141.0,1131.0,73458.0,47700.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010166631545871,1082014363648.0,0.0073508238940601,0.0331633074167615,"
volatile void **foo;

void __attribute__((noinline)) loop5000() {
    for (int i = 0; i < 5000; i++) {
        foo = (void*) *foo;
    }
}

void __attribute__((noinline)) loop10000() {
    for (int i = 0; i < 10000; i++) {
        foo = (void*) *foo;
    }
}

void __attribute__((noinline)) loop20000() {
    for (int i = 0; i < 20000; i++) {
        foo = (void*) *foo;
    }
}


int main()
{
    foo = (void*) &foo;
    loop5000();
    loop10000();
    loop20000();
    return 0;
}
"
303-34518,luozhao/Classical-algorithm,insert_sort.c,37,3,19,2272324.52016315,187219.0,12.137251026872272,1343.0,1324.0,42281.0,15418.0,1626.0,638.0,1344.0,595.0,1500000000,0.0015148830134421,1082014363648.0,0.0142453490297459,0.0728435501481828,"/*
* @function insert sort algorithm 
* @author lz
* @date 2013.8.18
*/

#include <stdio.h>

void print(int a[], int n)
{
  int i = 0;
  
  if(a == NULL || n < 0)
    return;
  for(; i < n; i++)
    printf(""%d "", a[i]);
}

void insert_sort(int a[], int n)
{
  int i,j,temp;
  
  for(i = 0; i < n; i++)
  {
    temp = a[i+1];
    j = i;
    
    while(j > -1 && a[j] > temp)
    {
      a[j+1] = a[j];
      j--;
    }
    a[j+1] = temp;
  }
}

int main()
{
  int a[] = {1,9,0,2,8,3,7,3,5,6,4};
  int n = sizeof(a) / sizeof(int);
  
  print(a,n);
  insert_sort(a,n);
  print(a,n);
  return 0;
}
"
132-7951,smileboywtu/The-C-Programming-Language-2nd,Chapter-2/exercise-2-9/bitcount.c,20,2,13,1766757.10827105,173083.0,10.207570934176088,1332.0,1313.0,39177.0,13306.0,1618.0,636.0,1340.0,593.0,1500000000,0.0011778380721807,1082014363648.0,0.0152816856652588,0.0797782138978335,"#include ""stdio.h""

/**

	count the 1-bit in a unsigned.

*/

int bitcount(unsigned x){

	int counter;

	for(counter=0; x != 0; x &= (x-1)){
		counter++;
	}

	return counter;
}

int main(){


	int i;
	unsigned int a;

	a = ~0;
	
	for(i=0; i<10000L; i++){
		bitcount(a);
	}
	printf(""the 1-bit in the a is: %d.\n"", bitcount(a));

	return 0;

}	
"
126-30960,ruddfawcett/sandbox,C/Loops/for.c,7,1,3,2143024.58334705,178789.0,11.986330255217045,1336.0,1318.0,40430.0,14199.0,1617.0,636.0,1340.0,593.0,1500000000,0.0014286830555647,1082014363648.0,0.0148443136882022,0.0766259678925113,"#include <stdio.h>

int main () {
  for (int i = 0; i < 10; i++) {
    printf(""%d\n"", i);
  }

  printf(""Done."");

  return 0;
}
"
197-33216,fanbrightup/November-December,c程序设计经典236例/1_C语言基础知识/12_数组中元素的倒置.c,11,2,8,1592836.8084132,176340.0,9.032754905296589,1336.0,1318.0,39951.0,13766.0,1626.0,629.0,1346.0,591.0,1500000000,0.0010618912056088,1082014363648.0,0.0150504706816377,0.078038609751103,"#include <stdio.h>
int main(int argc, char const *argv[]) {
  int arr[5] = {1,2,3,4,5};
  int data[5];
  for(int i = 0,j =4;i<5;i++,j--){
    data[j] = arr[i];
  }
  for(int i = 0;i<5;i++){
    printf(""%d\t"",data[i]);
  }
  return 0;
}
"
269-21870,ShahriyarR/percona-qa,pty/test_args.c,7,1,5,1874434.5288723002,173413.0,10.80907429085478,1351.0,1330.0,39237.0,13343.0,1618.0,637.0,1340.0,594.0,1500000000,0.0012496230192482,1082014363648.0,0.0154602019456442,0.0796690756941803,"#include <stdio.h>

int main (int argc, char* argv[]) {
  int i;
  for (i = 0; i < argc; i++) {
    printf(""arg: %d is '%s'\n"", i, argv[i]);
  }
  return 0;
}
"
046-29343,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.python/py-progspace.c,17,1,10,1596799.70238345,169061.0,9.445105612766987,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010645331349223,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2010-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
main ()
{
  return 0;
}
"
359-14726,Great-Li-Xin/00864088,[书上的例题、练习与习题]/第03章/习题/习题3.5.c,9,1,6,1565837.9998057499,189673.0,8.251833418567745,1340.0,1320.0,42468.0,15657.0,1618.0,638.0,1340.0,595.0,1500000000,0.0010438919998705,1082014363648.0,0.0140241362766445,0.0721032258064516,"#include <stdio.h>
int main(void) {
    int year;
    for (year = 2000; year <=2100 ; year++) {
        if (((year%4==0)&&(year%100!=0))||(year%400==0)){
            printf(""%d\n"",year);
        }
    }
    return 0;
}
"
286-8707,Krakn/learning,src/c/books/programming_in_c/chapters/ch04/src/ch04pr09a.c,15,2,9,1755392.9938002,173146.0,10.134146904924169,1335.0,1316.0,39187.0,13308.0,1619.0,637.0,1341.0,594.0,1500000000,0.0011702619958668,1082014363648.0,0.0153107781871946,0.0798361748737975,"/*
 * Program to calculate the 200th triangular number
 * Introduction to the for statement
 */

#include <stdio.h>

int main(void) {
    int n, tri_num;
    tri_num = 0;

    n = 1;
    while (n <= 200) {
        tri_num = tri_num + n;
        n += 1;
    }
    printf(""The 200th triangular number is %i\n"", tri_num);

    return 0;
}
"
156-12686,PeterHuang2015/BITDM,c/mooc/XuetangXZuHeShuXueCheet/main.c,40,2,23,1110802859.8828242,172493.0,6439.698184853878,1292.0,1274.0,39028.0,13220.0,1606.0,634.0,1333.0,592.0,1500000000,0.7405352399218827,1082014363648.0,0.0148759659812282,0.0797159699892818,"#include <stdio.h>
#include <stdlib.h>

int validate(int number)
{
    int res = 1;
    int count[5] = {0};
    while (number != 0)
    {
        int digit = number%10;
        if (digit%2 != 1)
        {
            res = 0;
            break;
        }
        else
        {
            count[(digit-1)/2]++;
        }
        number = number/10;
    }
    if (count[0]%2 == 1 || count[1]%2 == 1)
    {
        res = 0;
    }
    return res;
}

int main()
{
    int ctr;
    int have = 0;
    for (ctr = 11111111; ctr < 100000000; ctr++)
    {
        /*
        if (!((ctr%3 == 0)||(ctr%5 == 0)||(ctr%7 == 0)))
            have++;
        */
        if (validate(ctr))
            have++;
    }
    printf(""Hello world! %d\n"",have);
    return 0;
}
"
121-13459,UCL-RITS/pi_examples,c_pi_dir/pi.c,24,2,17,2183675302.541815,12000180777.0,0.1819702004977554,1456.0,1432.0,41002.0,14370.0,1650.0,637.0,1366.0,594.0,1500000000,1.4557835350278765,1082014363648.0,2.406630411381177e-07,0.0766994148667196,"#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main( int argc, char **argv ) {
   long i, num_steps = 1000000000;
   double step, x, sum, pi, taken;
   clock_t start, stop;  
 
   if (argc > 1) {
      num_steps = atol(argv[1]);
   }
   
   printf(""Calculating PI using:\n""
          ""  %ld slices\n""
          ""  1 process\n"", num_steps);
   
   start = clock();
   
   sum = 0.0;
   step = 1.0 / num_steps;

   for (i=0;i<num_steps;i++) {
      x    = (i + 0.5) * step;
      sum += 4.0 / (1.0 + x*x);
   }

   pi = sum * step;

   stop = clock();
   taken = ((double)(stop - start))/CLOCKS_PER_SEC;

   printf(""Obtained value for PI: %.16g\n""
          ""Time taken:            %.16g seconds\n"", pi, taken);

   return 0;
}

"
103-14956,ILyoan/gdb,gdb/testsuite/gdb.base/arrayidx.c,19,1,10,2342496.0672855,169058.0,13.856167705757787,1139.0,1129.0,38452.0,12697.0,1568.0,585.0,1317.0,546.0,1500000000,0.001561664044857,1082014363648.0,0.0134155142022264,0.0785157090070187,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2005, 2007-2012 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int array[] = {1, 2, 3, 4};

int
main (void)
{
  array[0] = 5;

  return 0;
}
"
085-30147,txemagon/c-programs,2016/13_bajo/disass/do_while.c,7,1,2,1813187.9623978501,169057.0,10.725299750971566,1139.0,1129.0,38452.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0012087919749319,1082014363648.0,0.0134155935572026,0.0785172440760147,"int main(){

    int a = 3;

    do{
        a--;
    } while(a);


    return 0;
}
"
089-26705,chbrown/sandbox,c/k_and_r/fahr.c,49,1,25,2095622.82543615,303511.0,6.904599833284461,1459.0,1432.0,68802.0,31036.0,1635.0,650.0,1353.0,607.0,1500000000,0.0013970818836241,1082014363648.0,0.0095251901908003,0.0425188805865502,"#include <stdio.h>

int main()
{
    float fahrenheit, celsius;
    int start = -50, end = 300, by = 10;

    fahrenheit = start;
    while (fahrenheit <= end) {
        celsius = (5.0/9.0) * (fahrenheit - 32);
        printf(""%3.0f°F = %5.1f°C\n"", fahrenheit, celsius);
        fahrenheit = fahrenheit + by;
    }
}

/*
-50°F = -45.6°C
-40°F = -40.0°C
-30°F = -34.4°C
-20°F = -28.9°C
-10°F = -23.3°C
  0°F = -17.8°C
 10°F = -12.2°C
 20°F =  -6.7°C
 30°F =  -1.1°C
 40°F =   4.4°C
 50°F =  10.0°C
 60°F =  15.6°C
 70°F =  21.1°C
 80°F =  26.7°C
 90°F =  32.2°C
100°F =  37.8°C
110°F =  43.3°C
120°F =  48.9°C
130°F =  54.4°C
140°F =  60.0°C
150°F =  65.6°C
160°F =  71.1°C
170°F =  76.7°C
180°F =  82.2°C
190°F =  87.8°C
200°F =  93.3°C
210°F =  98.9°C
220°F = 104.4°C
230°F = 110.0°C
240°F = 115.6°C
250°F = 121.1°C
260°F = 126.7°C
270°F = 132.2°C
280°F = 137.8°C
290°F = 143.3°C
300°F = 148.9°C
*/
"
277-10814,mattstock/binutils-bexkat1,gdb/testsuite/gdb.multi/tids-gid-reset.c,17,1,10,1446691.3416980999,169061.0,8.557213076936726,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0009644608944654,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2019-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
main (void)
{
  return 0;
}
"
315-2034,invisiblek/kernel_808l,drivers/net/eip93_drivers/quickSec/src/lib/sshenroll/tests/t-dummy.c,6,1,6,1529912.8135664999,169083.0,9.04828989312941,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.001019941875711,1082014363648.0,0.0134490161636592,0.0785049652044725,"int main(int ac, char **av)
{
  /* This is just a dummy test program acting as a placeholder for
     Enrollment regression test. */
  return 0;
}
"
263-7863,PaulaGVF/Pair-numbers,pair-numbers-using-for.c,8,1,2,5008749.081753151,190138.0,26.34270372045567,1401.0,1379.0,42919.0,16001.0,1621.0,641.0,1343.0,597.0,1500000000,0.0033391660545021,1082014363648.0,0.0146209595136164,0.0713170400543109,"#include <stdlib.h>
#include <stdio.h>


int main()
{int a;

for(a=0;a<=50;a=a+2)
            {printf(""%d\n"",a);
            
             }

system(""PAUSE"");
    return 0;
}
"
279-8672,logicchains/ArrayAccessBench,C2.c,48,3,21,1597735738.4981587,2775187884.0,0.5757216465276266,1362.0,1355.0,333041973.0,777014992.0,83251816.0,83250718.0,83251568.0,83250680.0,1500000000,1.0651571589987725,1082014363648.0,9.790328127563992e-07,0.2999889127311588,"#define _POSIX_C_SOURCE 200809L
 
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>
 
#define NUM_RECORDS (50 * 1000 * 444)
 
struct CMemoryTrade {
	long TradeId; long ClientId; int VenueCode; int InstrumentCode; long Price; long Quantity; char Side;
};
 
struct CMemoryTrade trades[NUM_RECORDS];
 
void initTrades() {
	for (long i = 0; i < NUM_RECORDS; i++) {
 
		trades[i].TradeId = i;
		trades[i].ClientId = 1;
		trades[i].VenueCode = 123;
		trades[i].InstrumentCode = 321;
 
		trades[i].Price = i;
		trades[i].Quantity = i;
 
		if ((i&1) == 0) {
			trades[i].Side = 'B';
		} else {
			trades[i].Side = 'S';
		}
	}
}
 
double getTime(){
	struct timespec spec;
	clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &spec);	
	double s  = spec.tv_sec;
	double ms = spec.tv_nsec;
	return (s*1000 + ms / 1000000);
}
 
void perfRun(int runNum) {	
	double startT = getTime();
	initTrades();

	long buyCost = 0;
	long sellCost = 0;
 
	for (long i = 0; i < NUM_RECORDS; i++) {
		if (trades[i].Side == 'B') {
			buyCost += trades[i].Price * trades[i].Quantity;
		} else {
			sellCost += trades[i].Price * trades[i].Quantity;
		}
	}
	double endT = getTime();
	double duration =  endT - startT;
	printf(""%d - duration %d ms\n"", runNum, (int)duration);
	printf(""buyCost = %ld sellCost = %ld\n"", buyCost, sellCost);
}
 
int main() {
	for (int i = 0; i < 5; i++) {
		perfRun(i);
	}
}
"
308-1569,geminy/aidear,snippets/algo/ds/enum.c,26,2,10,1795413.0889846499,182721.0,9.825980593363653,1342.0,1323.0,41094.0,14570.0,1619.0,639.0,1341.0,596.0,1500000000,0.0011969420593231,1082014363648.0,0.0145850777962029,0.0753628916355274,"#include <stdio.h>

enum DefalutEnum
{
	DE_0,
	DE_1,
	DE_2,
	DE_3,
	DE_4
};

enum AssginedEnum
{
	AE_0 = 0,
	AE_1 = 3,
	AE_2 = 2,
	AE_3 = 1,
	AE_4 = 4
};

int main()
{
	for (int i = DE_0; i <= DE_4; ++i) {
		printf(""default enum:[%d] = %d\n"", i, DE_0 + i);
	}

	for (int i = AE_0; i <= AE_4; ++i) {
		printf(""assigned enum:[%d] = %d\n"", i, AE_0 + i);
	}

	return 0;
}
"
181-27080,totalspectrum/binutils-propeller,gdb/testsuite/gdb.base/cond-eval-mode.c,40,2,14,1915399.3343934,169062.0,11.329565484851711,1140.0,1130.0,38453.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0012769328895956,1082014363648.0,0.0134270267712436,0.0785548104557273,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int global;

int cond_global;


int
foo (int i)
{
  global++;
  return i;
}

int
bar (int i)
{
  return i;
}

void
test ()
{
  foo (1);
  foo (2);
  bar (3);
}

int
main ()
{
  int i;

  for (i = 0; i < 1000; i++)
    test ();

  return 0;
}
"
051-27174,ZhangIIIr/one,Practice/0c/03-gdb.c,11,1,5,1943432.9587965,182366.0,10.656767160545275,1341.0,1322.0,41025.0,14525.0,1618.0,637.0,1340.0,594.0,1500000000,0.001295621972531,1082014363648.0,0.0146025026594869,0.0754095409540954,"#include <stdio.h>

int main(void)
{
	int i = 0;
	int j = 1;

	for( ; i<10 ; i++)
	{
		j = 2 * i;
		printf(""%d	%d\n"", i, j);
	}

	return 0;
}
"
193-25546,MicroTrustRepos/microkernel,src/l4/pkg/valgrind/src/valgrind-3.6.0-svn/perf/heap.c,27,3,17,108084289.35706605,629632303.0,0.1716625536603067,1326.0,1307.0,155051996.0,101022227.0,2153976.0,676513.0,1343.0,675698.0,1500000000,0.0720561929047107,1082014363648.0,4.181805773710438e-06,0.01369731774994,"#include <stdio.h>
#include <stdlib.h>

#define NLIVE 1000000

#define NITERS (3*1000*1000)

char* arr[NLIVE];

int main ( void )
{
   int i, j, nbytes = 0;
   printf(""initialising\n"");
   for (i = 0; i < NLIVE; i++)
      arr[i] = NULL;

   printf(""running\n"");
   j = -1;
   for (i = 0; i < NITERS; i++) {
      j++;
      if (j == NLIVE) j = 0;
      if (arr[j]) 
         free(arr[j]);
      arr[j] = malloc(nbytes);

      // Cycle through the sizes 0,8,16,24,32.  Zero will get rounded up to
      // 8, so the 8B bucket will get twice as much traffic.
      nbytes += 8;
      if (nbytes > 32)
         nbytes = 0;
   }

   for (i = 0; i < NLIVE; i++)
      if (arr[i])
         free(arr[i]);

   printf(""done\n"");
   return 0;
}
"
257-11609,LeetCodePracticeGroup/Mark,easy/4-Roman_To_Integer.c,31,1,14,1916823.2101947002,173743.0,11.03251929574141,1340.0,1321.0,39363.0,13383.0,1621.0,633.0,1343.0,590.0,1500000000,0.0012778821401298,1082014363648.0,0.0153157249500699,0.0793804269518067,"#include <stdio.h>
#include <stdlib.h>


int romanToInt(char* s) {
	int i, r = 0,pre = 0, now = 0, sum = 0, temp = 0;
	int len = strlen(s);
	for(i = 0; i < len; i++){
		if(s[i] == 'I') r = 1;
		if(s[i] == 'V') r = 5;
		if(s[i] == 'X') r = 10;
		if(s[i] == 'L') r = 50;
		if(s[i] == 'C') r = 100;
		if(s[i] == 'D') r = 500;
		if(s[i] == 'M') r = 1000;
		now = r;
		if(i == 0){
			pre = now; temp = r; continue;
		}
		if(now == pre)	temp += now;
		if(now > pre)	temp = now - temp;
		if(now < pre){
			sum += temp;
			temp = now;
		}
		pre = now;
	}
	sum += temp;
    return sum;
}


int main(){
	char *input = ""DCXXI""; //621
	//printf(""%d"", strlen(input));
	printf(""%d"", romanToInt(input));
}

"
195-30463,swigger/gdb-ios,gdb/testsuite/gdb.reverse/rerun-prec.c,16,1,12,1609428.0872493,169057.0,9.520031705282834,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010729520581662,1082014363648.0,0.0134155935572026,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2016 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int main (int argc, char **argv)
{
  return 0;
}
"
292-11288,Amit-Tomar/GATE-2015,CFiles/CProgram4.c,28,3,15,2099704.46303475,182281.0,11.519050257569358,1340.0,1320.0,41148.0,14682.0,1619.0,641.0,1341.0,598.0,1500000000,0.0013998029753565,1082014363648.0,0.0145928538904219,0.0752104603259896,"#include <stdio.h>

int staticFn() {
  static int x = 0;
  x++;
  return x;
}

int autoFn() {
  auto int x = 0;
  x++;
  return x;
}

int registerFn() {
  register int x = 0;
  x++;
  return x;
}

int main(void) {
  int j;
  for (j = 0; j < 5; j++) {
    printf(""Value of autoFn(): %d\n"", autoFn());
  }
  for (j = 0; j < 5; j++) {
    printf(""Value of registerFn(): %d\n"", registerFn());
  }
  for (j = 0; j < 5; j++) {
    printf(""Value of staticFn(): %d\n"", staticFn());
  }
  return 0;
}"
214-5384,swigger/gdb-ios,gdb/testsuite/gdb.base/cond-eval-mode.c,40,2,14,1552818.11021265,169062.0,9.184902580118536,1140.0,1130.0,38453.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010352120734751,1082014363648.0,0.0134270267712436,0.0785548104557273,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2016 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int global;

int cond_global;


int
foo (int i)
{
  global++;
  return i;
}

int
bar (int i)
{
  return i;
}

void
test ()
{
  foo (1);
  foo (2);
  bar (3);
}

int
main ()
{
  int i;

  for (i = 0; i < 1000; i++)
    test ();

  return 0;
}
"
173-24459,cartman300/picoc,tests/csmith/rand10.c,91,3,18,2439529.5185967,239106.0,10.202709258655156,1360.0,1339.0,40240.0,15065.0,1620.0,655.0,1342.0,612.0,1500000000,0.0016263530123978,1082014363648.0,0.0112878806888994,0.0764668655636922,"#include <stdio.h>
int print_hash_value = 1;
static void platform_main_begin(void)
{
}
static unsigned crc32_tab[256];
static unsigned crc32_context = 0xFFFFFFFFUL;
static void
crc32_gentab (void)
{
 unsigned crc;
 unsigned poly = 0xEDB88320UL;
 int i, j;
 for (i = 0; i < 256; i++) {
  crc = i;
  for (j = 8; j > 0; j--) {
   if (crc & 1) {
    crc = (crc >> 1) ^ poly;
   } else {
    crc >>= 1;
   }
  }
  crc32_tab[i] = crc;
 }
}
static void
crc32_byte (unsigned char b) {
 crc32_context =
  ((crc32_context >> 8) & 0x00FFFFFF) ^
  crc32_tab[(crc32_context ^ b) & 0xFF];
}
extern int strcmp ( char *, char *);
static void
crc32_8bytes (unsigned val)
{
 crc32_byte ((val>>0) & 0xff);
 crc32_byte ((val>>8) & 0xff);
 crc32_byte ((val>>16) & 0xff);
 crc32_byte ((val>>24) & 0xff);
}
static void
transparent_crc (unsigned val, char* vname, int flag)
{
 crc32_8bytes(val);
 if (flag) {
    printf(""...checksum after hashing %s : %X\n"", vname, crc32_context ^ 0xFFFFFFFFU);
 }
}
static void
platform_main_end (int x, int flag)
{
  if (!flag) printf (""checksum = %x\n"", x);
}
static long __undefined;
void csmith_compute_hash(void);
void step_hash(int stmt_id);
static int g_6 = (-9L);
static int func_1(void);
static int func_1(void)
{
    int l_4 = 0L;
    int *l_5 = &g_6;
    step_hash(1);
    (*l_5) = ((unsigned short)0x0BCDL + (unsigned short)(0L < l_4));
    step_hash(2);
    return g_6;
}
void csmith_compute_hash(void)
{
    transparent_crc(g_6, ""g_6"", print_hash_value);
}
void step_hash(int stmt_id)
{
    int i = 0;
    csmith_compute_hash();
    printf(""before stmt(%d): checksum = %X\n"", stmt_id, crc32_context ^ 0xFFFFFFFFUL);
    crc32_context = 0xFFFFFFFFUL;
    for (i = 0; i < 256; i++) {
        crc32_tab[i] = 0;
    }
    crc32_gentab();
}
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    csmith_compute_hash();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}
"
200-28447,qlkzy/project-euler-c,problem-023.c,27,4,15,1177103834.808804,4100955891.0,0.2870315763657161,1342.0,1320.0,23521257.0,41433.0,518420.0,2422.0,1339.0,2351.0,1500000000,0.7847358898725361,1082014363648.0,6.491169548646091e-07,0.0222611255336296,"#include <stdio.h>

#define LIMIT 28124
#define NELEM(x) (sizeof(x) / sizeof(x[0]))

static int abundant[LIMIT];

int check_abundant(int n)
{
    int i, sum = 0;
    for (i = 1; i < n; i++)
        if (n % i == 0)
           sum += i;
    return sum > n;
}

int not_sum_of_two(int n)
{
    int cand;
    for (cand = n-1; cand > 0; --cand)
        if (abundant[cand] && abundant[n-cand])
            return 0;
    return n;
}

int main()
{
    int i, sum = 0;

    for (i = 0; i < NELEM(abundant); i++)
        abundant[i] = check_abundant(i);

    for (i = 0; i < NELEM(abundant); i++)
        sum += not_sum_of_two(i);

    printf(""%d\n"", sum);
    return 0;
}

"
294-16285,AndrewLaing/CHowToProgramExercises,Chapter5/ex05_31.c,27,1,17,2312584.5473259003,215824.0,10.7151382608051,1362.0,1338.0,50660.0,20098.0,1638.0,648.0,1356.0,605.0,1500000000,0.0015417230315506,1082014363648.0,0.0125101934909926,0.0600214816699171,"/*
 * Filename:    ex05_31.c
 * Author:      Andrew Laing
 * Email:       parisianconnections@gmail.com
 * Date:        03/05/2017
 */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int flip( void );


int main()
{
    srand( (time(NULL)) );
    int total = 0;
    int i;
    
    for(i=0; i<100; i++)
        total += flip();
    
    printf(""\n\nThe total number of heads was = %d\n"", total);
    printf(""The total number of tails was = %d\n"", 100-total);  

    return 0;
}



int flip( )
{
    int res = rand()%2;

    if(res)
        printf(""Heads "");
    else
        printf(""Tails "");
    
    return res;
}

"
242-29518,SanDisk-Open-Source/SSD_Dashboard,uefi/gcc/gcc-4.6.3/gcc/testsuite/gcc.dg/bitfld-4.c,29,2,18,1564715.8725185997,169057.0,9.255546945704705,1139.0,1129.0,38452.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010431439150124,1082014363648.0,0.0134155935572026,0.0785172440760147,"/* { dg-do run { target { pcc_bitfield_type_matters || default_packed } } } */
/* { dg-options """" } */

/* Check bitfields and non-bitfields are aligned & sized similarly.

   Copyright (C) 2002 Free Software Foundation Inc
   Contributed by Nathan Sidwell <nathan@codesourcery.com>
*/

#include <limits.h>
#include <stdio.h>

static int fail;

#define CHECK1(N, T) do { \
  typedef struct Field_##N { char c; T f; } Field_##N; \
  typedef struct BitField_##N { char c; T f : sizeof (T) * CHAR_BIT; } BitField_##N; \
  if (sizeof (Field_##N) != sizeof (BitField_##N)) { \
    fail = 1; printf (""sizeof %s failed\n"", #T); \
  } \
  if (__alignof__ (Field_##N) != __alignof__ (BitField_##N)) { \
    fail = 1; printf (""__alignof__ %s failed\n"", #T); \
  } \
} while (0)

#define CHECK(N, T) do { \
  CHECK1(N, T); \
  CHECK1 (s##N, signed T); \
  CHECK1 (u##N, unsigned T); \
} while (0)
 
int main ()
{
  
  CHECK (c, char);
  CHECK (s, short);
  CHECK (i, int);
  CHECK (l, long);
  CHECK (ll, long long);
  
  return fail;
}
"
007-14480,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.base/vla-stub.c,29,1,11,1494737.80766115,169057.0,8.841615549784983,1139.0,1129.0,38452.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0009964918717741,1082014363648.0,0.0134155935572026,0.0785172440760147,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

struct dynamic_struct;
typedef struct dynamic_struct dynamic_struct_t;

struct static_struct
{
  int field;
};
typedef struct static_struct static_struct_t;

struct local_struct
{
  static_struct_t here;
  dynamic_struct_t *ptr;
} local_struct;

int
main (void)
{
  return 0;
}
"
325-3983,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.python/py-linetable.c,36,2,13,1419620.93766765,169061.0,8.397087441810944,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0009464139584451,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2013-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see  <http://www.gnu.org/licenses/>.  */

int
foo (int a, int b)
{
  if (a == b)
    return 1;

  return 0;
}

bar (int a, int b)
{
  if (a + b == a)
    return 1;

  return 0;
}

int
main (void)
{
  int i;
  if (foo (5,5) && bar (5,0))
    return 0;

  for (i = 0;
       i<500;
       i++);
  return 0;
}
"
021-20657,ISSAE/nsy103,MPS/prog_linux/13/exemple_malloc_1.c,14,1,9,3957625.59492135,252215.0,15.656420117756676,1323.0,1302.0,55959.0,25278.0,1624.0,904.0,1339.0,861.0,1500000000,0.0026384170632809,1082014363648.0,0.0104077870071169,0.0582000812437682,"
	#include <stdio.h>
	#include <stdlib.h>

	#define	NB_BLOCS	257
	#define TAILLE		(1024*1024)

	int
main (void)
{

	int	i;
	char *	bloc [NB_BLOCS];

	for (i = 0; i < NB_BLOCS; i ++) {
		if ((bloc [i] = (char *) malloc (TAILLE)) == NULL) {
			fprintf (stderr, ""Echec pour i = %d\n"", i);
			break;
		}
	}
	fprintf (stderr, ""Alloués : %d blocs de %d Ko\n"", i, TAILLE / 1024);
	
	return (0);
}	

"
151-17972,epicsdeb/rtems-gdb,gdb/testsuite/gdb.server/server.c,17,1,11,1620947.9654206499,169083.0,9.586694108810466,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010806319769471,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2005, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
main (int argc, char **argv)
{
  return 0;
}
"
291-31893,Bootz/multicore-opimization,delay-thread/CpuMemoryExample/test.c,24,2,15,1857873.28518915,174849.0,10.62558550520735,1340.0,1321.0,39610.0,13476.0,1632.0,636.0,1351.0,593.0,1500000000,0.0012385821901261,1082014363648.0,0.0152188459756704,0.0793429529442791,"#include<stdlib.h>
#include<stdio.h>

#define NPAD 15 

struct element {
  struct element *next;
  int pad[NPAD];
};


int main(int argc, char **argv) {
  long i,size;
  struct element *temp;
  struct element *list; 
  char *stopstring;

  size = (argc == 2? strtol(argv[1],&stopstring,16):0x400000);
  printf(""%ld\n"", size);
  list = (struct element *)calloc(size, sizeof(struct element));

  for(i=0; i<size; i++) {
    if(i == size - 1 )
      list[i].next = &list[0];
    else
      list[i].next = &list[i+1];
  }

  temp = &list[0];
  for(i=0; i<size; i++) {
    temp = temp->next;
  } 

  return 0;
} 

"
062-22253,rhuitl/uClinux,user/gdb/gdb/testsuite/gdb.hp/gdb.base-hp/pxdb.c,27,5,9,1540801.6042783498,178716.0,8.618064415049576,1338.0,1320.0,40470.0,14165.0,1625.0,636.0,1345.0,594.0,1500000000,0.0010272010695189,1082014363648.0,0.014872759014302,0.076873798846893,"#include <stdio.h>

#ifdef PROTOTYPES
int callee (int x)
#else
int callee( x )
int x;
#endif
{
    int y = x * x;
    return (y - 2);
}

int main()
{
    int i;
    for (i = 1; i < 10; i++)
        {
            printf( ""%d "", callee( i ));
            
        }
    printf( "" Goodbye!\n"" );
    return 0;
}
/* This routine exists only for aCC.  The way we compile this test is
   that we use aCC for the actual compile into the object file but then
   use ld directly for the link.  When we do this, we get an undefined
   symbol _main().  Therefore, for aCC, we have this routine in here and
   ld is happy.  */

#ifdef __cplusplus
extern ""C"" {
void _main()
{
}
}
#endif
"
275-31478,mattstock/binutils-bexkat1,gdb/testsuite/gdb.base/duplicate-bp.c,30,1,18,1208221.6562703,169061.0,7.146657123760063,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0008054811041802,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2012-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

void
spacer ()
{
  /* Nothing.  */
}

void
breakpt ()
{
  /* Nothing.  */
}

int
main ()
{
  spacer ();

  breakpt ();

  spacer ();

  return 0;
}
"
000-35499,ontouchstart/emcc,home/demo/argv/main.c,7,1,4,3186126.2395976996,172991.0,18.417871449959826,1325.0,1305.0,39163.0,13297.0,1617.0,636.0,1339.0,593.0,1500000000,0.0021240841597318,1082014363648.0,0.0152031030516038,0.079775066717499,"#include <stdio.h>

int main(int argc, char *argv[])
{
    for(int i = 0; i < argc; i++) {
        printf(""%s "",argv[i]);
    }
    return 0;
}
"
385-28034,andrew0snake/5,5.10/echo_1.c,8,1,6,2112213.0565343997,173005.0,12.208970838993093,1269.0,1255.0,39243.0,13293.0,1617.0,634.0,1341.0,592.0,1500000000,0.0014081420376896,1082014363648.0,0.0145891737233027,0.0796406273793208,"#include <stdio.h>

int main ( int argc, char * argv [] ) {

    int i = 0;

    for ( i = 1; i < argc; i++ ) { 
        printf ( ""%s%s"", argv [ i ], ( i < argc - 1 ) ? "" "" : """" );
    };
    printf ( ""\n"" );

    return 0;
}
"
226-31115,Prabudh/Miscellaneous,revision/binary_search.c,56,2,25,1541642.9378091001,203138.0,7.58661107227599,1340.0,1321.0,45616.0,17848.0,1619.0,642.0,1340.0,598.0,1500000000,0.0010277619585394,1082014363648.0,0.0130994693262708,0.0661634942644649,"#include<stdio.h>
int array[10] = {1,2,3,4,5,6,7,8,9,10};
void bSearch(int val)
{
//To search val in array
int arrayLen = 10;
int count =0;
int oldi=0;
int i,temp;
for(i=arrayLen/2;i<arrayLen && i >=0;)
{
printf(""%d,"",i);
if(oldi==i)
{
    break;
}
temp = i;
count++;
if(array[i]>val)
{
if(i>oldi)
{
if((i-oldi)/2 !=0)
i=i-(i-oldi)/2;
else
i = i-1;
}
else
{
if(oldi-i/2 !=0)
i= i-(oldi-i)/2;
else
i = i-1;
}
}
else if(array[i]<val)
{
i=i+(oldi+i)/2;
}
else{
printf(""Found in %d attempts\n"",count);
return;
}
oldi = temp;
}

printf(""Not Found in %d attempts\n"",count);
return;
}
int main()
{
for(int i = 0;i<10;i++)
{
bSearch(i);
}
bSearch(11);
bSearch(0);
}
"
251-33037,tiehuis/euler,c/src/030.c,24,2,12,5808704.998344149,27295298.0,0.2127414765722653,1339.0,1319.0,2054082.0,1784863.0,1626.0,635.0,1345.0,594.0,1500000000,0.0038724699988961,1082014363648.0,9.737940944993528e-05,0.0010940505790002,"#include <stdio.h>

int square_digits(int n)
{
    const int pow5[10] = { 
        0, 1, 32, 243, 1024, 3125, 7776, 16807, 32768, 59049 
    };

    int sum = 0;
    while (n) {
        sum += pow5[n % 10];
        n /= 10;
    }
    return sum;
}

/* 6 * 9^5 */
#define ulim 354295

int main(void)
{
    int sum = 0;
    int i;
    for (i = 2; i < ulim; ++i) {
        if (i == square_digits(i))
            sum += i;
    }

    printf(""%d\n"", sum);
    return 0;
}
"
004-26230,fgr/whz-cprog,zuul/player/player1.c,36,1,22,2318674.349226,176570.0,13.131755111287308,1362.0,1341.0,40048.0,13737.0,1636.0,639.0,1353.0,595.0,1500000000,0.001545782899484,1082014363648.0,0.0153083762813615,0.0785163149577019,"// Player (Ausbaustufe 1)

#include <stdio.h>

void read_line(char *buf, int buf_sz) {
  int c, i = 0;
  while ((i < buf_sz - 1) && ((c = getc(stdin)) != EOF)) { // buf_sz -1 wegen \0
    if (c == '\n') {
      break;
    }
    buf[i] = c;
    ++i;
  }
  buf[i] = 0; // Null-Terminierung
}

struct player_t {
  char *name; // FALSCH
  int energy;
};

struct player_t player_new(char *name) {
  struct player_t p;
  p.name = name; // FALSCH
  p.energy = 100;
  return p;
}

struct player_t player_new_ask_user_for_name() {
  const int buf_sz = 10;
  char buf[buf_sz];
  read_line(buf, buf_sz);

  struct player_t p = player_new(buf);
  printf(""Created player '%s'\n"", p.name);
  return p;
}

int main(void) {
  struct player_t p = player_new_ask_user_for_name();
  // printf(""Test\n"");
  printf(""New player: '%s'\n"", p.name);

  return 0;
}
"
048-51,luisbg/hhgtg,bit_manipulation/count_ones.c,34,2,14,1755047.9387863502,174563.0,10.053946139789073,1334.0,1315.0,39453.0,13482.0,1619.0,639.0,1340.0,594.0,1500000000,0.0011700319591909,1082014363648.0,0.0151750370926255,0.0791914612260319,"/* Write a function that determines the number of 1 bits in the computer’s
 * internal representation of a given integer.
 */

#include <stdio.h>


int
count_ones (int n)
{
  int ones = 0;

  while (n != 0) {
    if ((n & 1) == 1)
      ones++;
    n = n >> 1;
  }

  return ones;
}

int
count_ones_fast (int n)
{
  int ones = 0;

  while (n != 0) {
    n = n & (n - 1);
    ones++;
  }

  return ones;
}

int
main ()
{
  int i = 55;

  printf (""number of 1's in bit representation of %d: %d\n"", i, count_ones (i));

  i = 57;
  printf (""number of 1's in bit representation of %d: %d\n"", i,
      count_ones_fast (i));

  return 0;
}
"
271-29927,harryjackson/doc,c/permutations_of_string.c,32,2,20,395886207.23225176,2351030553.0,0.1683883718545617,1347.0,1327.0,530933808.0,403743789.0,569505.0,567720.0,1349.0,567653.0,1500000000,0.2639241381548345,1082014363648.0,1.1373735643664346e-06,0.0018254711629725,"#include <assert.h>
#include <stdio.h>
#include <string.h>
       
#define TEN_FACTORIAL 3628800
static size_t pos = 0;
static char AllCombos[TEN_FACTORIAL][10];
void swap(char *x, char *y) {
  char temp;
  temp = *x;
  *x = *y;
  *y = temp;
}

void permute(char *a, int l, int r) {
  int i;
  if (l == r) {
    assert(pos <= TEN_FACTORIAL);
    memcpy(AllCombos[pos++], a, 10);

  }
  else {
    for (i = l; i <= r; i++) {
      swap((a+l), (a+i));
      permute(a, l+1, r);
      swap((a+l), (a+i));
    }
  }
}

int main(void) {
  size_t i = 0;
  char str[] = ""ABCDEFGHIJ"";
  int n = strlen(str);
  permute(str, 0, n-1);

  for(i = 0; i < TEN_FACTORIAL; i++) {
    printf(""%.10s\n"", AllCombos[i]);
  }
  return 0;
}
"
362-33227,Abner-Sun/vx_mysql5.1_git,client/echo.c,34,4,16,2667364.6643757,173406.0,15.382189774286934,1272.0,1257.0,39322.0,13352.0,1620.0,632.0,1337.0,592.0,1500000000,0.0017782431095838,1082014363648.0,0.0145842704404691,0.0793750237308729,"/* Copyright (c) 2000, 2007 MySQL AB

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; version 2 of the License.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA */

/*
  echo is a replacement for the ""echo"" command builtin to cmd.exe
  on Windows, to get a Unix eqvivalent behaviour when running commands
  like:
    $> echo ""hello"" | mysql

  The windows ""echo"" would have sent ""hello"" to mysql while
  Unix echo will send hello without the enclosing hyphens

  This is a very advanced high tech program so take care when
  you change it and remember to valgrind it before production
  use.

*/

#include <stdio.h>

int main(int argc, char **argv)
{
  int i;
  for (i= 1; i < argc; i++)
  {
    fprintf(stdout, ""%s"", argv[i]);
    if (i < argc - 1)
      fprintf(stdout, "" "");
  }
  fprintf(stdout, ""\n"");
  return 0;
}
"
013-7468,Gurgel100/gcc,gcc/testsuite/gcc.c-torture/execute/pr86714.c,19,1,11,1791033.19533165,169989.0,10.536169987469778,1146.0,1137.0,38671.0,12782.0,1577.0,586.0,1323.0,546.0,1500000000,0.0011940221302211,1082014363648.0,0.0134302807828741,0.0783627776806017,"/* PR tree-optimization/86714 - tree-ssa-forwprop.c confused by too
   long initializer

   The excessively long initializer for a[0] is undefined but this
   test verifies that the excess elements are not considered a part
   of the value of the array as a matter of QoI.  */

const char a[2][3] = { ""1234"", ""xyz"" };
char b[6];

void *pb = b;

int main ()
{
   __builtin_memcpy (b, a, 4);
   __builtin_memset (b + 4, 'a', 2);

   if (b[0] != '1' || b[1] != '2' || b[2] != '3'
       || b[3] != 'x' || b[4] != 'a' || b[5] != 'a')
     __builtin_abort ();

   if (__builtin_memcmp (pb, ""123xaa"", 6))
     __builtin_abort ();

   return 0;
}
"
029-15157,RWTH-OS/HermitCore,usr/tests/test-malloc.c,12,1,11,3229192092.0833945,36692047.0,88.00795692864996,1394.0,1370.0,8241117.0,5218604.0,1622.0,660.0,1344.0,615.0,1500000000,2.1527947280555964,1082014363648.0,7.532967566513801e-05,0.0003150882548011,"#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <malloc.h>

#ifndef NUM_ITER
#define NUM_ITER    100000
#endif

#ifndef SIZE
#define SIZE    16*1024
#endif 

void* buf;

int main(int argc, char** argv)
{
    /* optionally: insert more useful stuff here */

    for(int i=0; i<NUM_ITER; i++)
    {
        buf = malloc(SIZE*i);
        free(buf);
    }
    malloc_stats();

    return 0;
}


"
320-32425,JohnHwee/show-me-the-code,Algorithm/0006/bubbleSort.c,34,3,18,1563842.7576049499,180031.0,8.686515100177191,1341.0,1320.0,40748.0,14279.0,1626.0,637.0,1344.0,594.0,1500000000,0.0010425618384033,1082014363648.0,0.0147807877532202,0.0763443400512475,"#include <stdio.h>
typedef int T;


void swap(T* a, T* b)
{
    *a = *a ^ *b;
    *b = *a ^ *b;
    *a = *a ^ *b;
}

int bubble(T _elem[], int lo, int hi)
{
    int last = lo;
    while (++lo < hi)
    {
        if (_elem[lo-1] > _elem[lo])
        {
            last = lo;
            swap(&_elem[lo-1], &_elem[lo]);
        }
    }
    return last;
}

void bubbleSort(T _elem[], int lo, int hi)
{
    while (lo < bubble(_elem, lo, hi));
}


int main()
{
    T elem[10] = {6, 7, 3, 2, 7, 1, 5, 8, 7, 4};
    bubbleSort(elem, 0, 10);
    for (int i = 0; i < 10; i++)
    {
        printf(""%d\t"", elem[i]);
    }
    return 0;
}
"
020-24579,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.base/del.c,17,1,10,1542529.3240695002,169037.0,9.125392665511102,1138.0,1128.0,38451.0,12696.0,1567.0,585.0,1317.0,546.0,1500000000,0.001028352882713,1082014363648.0,0.0134053491247478,0.0784992277161905,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2006-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
main(void)
{
  return 0;
}
"
247-35239,hironics/clib_examples,limits/limits.c,24,1,17,1960623.19446345,181744.0,10.78782793379699,1347.0,1326.0,40863.0,14487.0,1621.0,640.0,1343.0,597.0,1500000000,0.0013070821296423,1082014363648.0,0.0147075006602693,0.0758988256549232,"#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
/*
limits contains the complier's limits for each type of data
char
int
short
long
unsigned values

*/

#define printme(x, y) printf(#y x, y)
int main(int argc, char * argv[])
{
    printme(""	is %ld\n"", CHAR_BIT);
    printme(""	is %ld\n"", SCHAR_MIN);
    printme(""	is %ld\n"", SCHAR_MAX);
    printme(""	is %ld\n"", SHRT_MIN);
    printme(""	is %ld\n"", SHRT_MAX);
    printme(""	is %ld\n"", USHRT_MAX);
    printme(""	is %ld\n"", INT_MIN);
    printme(""	is %ld\n"", INT_MAX);
    printme(""	is %ld\n"", UINT_MAX);
    printme(""	is %ld\n"", LONG_MIN);
    printme(""	is %ld\n"", LONG_MAX);
    printme(""	is %ld\n"", ULONG_MAX);
    return EXIT_SUCCESS;
}
"
017-11584,nishanttotla/predator,cpachecker/test/programs/policyiteration/pointers/pointers_loop_true_assert.c,8,1,6,2073783.0782308502,169080.0,12.265099361249112,1142.0,1132.0,38460.0,12696.0,1566.0,584.0,1317.0,544.0,1500000000,0.0013825220521539,1082014363648.0,0.0134492547906316,0.0784072249589491,"#include<assert.h>

int main() {
  int sum = 0;
  int* p = &sum;
  for (int i=0; i<1000; i++) {
    (*p)++;
  }
  assert(sum == 1000);
}
"
229-15904,rgehring/c_problems,c9/p3.c,52,2,23,1686873.0308487,182260.0,9.25188192691759,1349.0,1332.0,41079.0,14471.0,1627.0,639.0,1347.0,597.0,1500000000,0.0011245820205658,1082014363648.0,0.014709755294634,0.0757875787578757,"
#include <stdlib.h>
#include <stdio.h>


int binarySearch( int target, int *arr, int leftBound, int rightBound) {
  int left = arr[leftBound] ;
  int right = arr[rightBound] ; 
  int midptIdx = (rightBound + leftBound) / 2 ;
  int midpt = arr[midptIdx] ;
  printf(""\nleft: %d, right: %d, midpt: %d"", leftBound, rightBound, midptIdx);
  if (left == target) {
    return leftBound ;
  }
  if (right == target) {
    return rightBound ;
  }
  if (midpt == target) {
    return midptIdx ;
  }
  if (midpt < target)  {
    return binarySearch(target, arr,  midptIdx, rightBound ) ;
  }
  return binarySearch(target, arr,  leftBound, midptIdx ) ;
  

}


int binarySearchMin(int *arr, int leftBound, int rightBound ) {
  int left = arr[leftBound] ;
  int right = arr[rightBound] ; 
  int midptIdx = (rightBound + leftBound) / 2 ;
  int midpt = arr[midptIdx] ;
  printf(""\nleft: %d, right: %d, midpt: %d"", leftBound, rightBound, midptIdx);
  if (((rightBound - leftBound) == 1) || (rightBound == leftBound)) {
    if (right >= left) {
      return leftBound;
    }
    return rightBound ;
  }

  if (midpt < left)  {
      return binarySearchMin(arr, leftBound, midptIdx ) ;
  }
  
  return binarySearchMin(arr, midptIdx, rightBound ) ;

}

int searchRotatedArray( int target, int *arr, int arrLen) {
  // binary search for min, then binary search for target
  int minIdx = binarySearchMin( arr, 0, arrLen -1) ;
  if ((target >= arr[0] ) && (arr[0] > arr[minIdx] ) ) {
    return binarySearch(target, arr, 0, minIdx-1);
  }
  else {
    return binarySearch(target, arr,  minIdx, arrLen-1);
  } 
}


int main() {
  int ar[10] = {5,6,7,8,9,0,1,2,3,4};
  //printf(""\n %d \n"", searchRotatedArray(7, ar, 10 )  );
  printf(""\n %d \n"", searchRotatedArray(8, ar, 10));
}
"
367-30759,Gurgel100/gcc,gcc/testsuite/gcc.c-torture/execute/pr80153.c,39,1,15,1584108.1039979998,170668.0,9.281810298357044,1150.0,1142.0,38901.0,12886.0,1581.0,585.0,1328.0,546.0,1500000000,0.001056072069332,1082014363648.0,0.013429582581386,0.0780118562573618,"/* PR tree-optimization/80153 */

void check (int, int, int) __attribute__((noinline));
void check (int c, int c2, int val)
{
  if (!val) {
    __builtin_abort();
  }
}

static const char *buf;
static int l, i;

void _fputs(const char *str)  __attribute__((noinline));
void _fputs(const char *str)
{
  buf = str;
  i = 0;
  l = __builtin_strlen(buf);
}

char _fgetc() __attribute__((noinline));
char _fgetc()
{
  char val = buf[i];
  i++;
  if (i > l)
    return -1;
  else
    return val;
}

static const char *string = ""oops!\n"";

int main(void)
{
  int i;
  int c;

  _fputs(string);

  for (i = 0; i < __builtin_strlen(string); i++) {
    c = _fgetc();
    check(c, string[i], c == string[i]);
  }

  return 0;
}
"
301-22486,lijiaying/InvariantGenerationPaperZILU,testcases/blast/fig1b.c,12,1,6,1718644.6348204499,169083.0,10.164499092161838,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0011457630898803,1082014363648.0,0.0134490161636592,0.0785049652044725,"#include <assert.h>

int main() {
	int x;
	int y;

	if(!( y>0 || x>0)) 
		return 0;
	while(x+y<=-2) {
		if (x>0) x++;
		else y++;
	}
	assert(x>0 || y>0);
	return 0;
}
"
142-16037,dxs/EPFL,ba-2/tp/serie20_0/valgrind/memory_leak.c,21,2,16,15122137321.50849,256985.0,58844.43574916824,1154.0,1146.0,55662.0,24780.0,1576.0,589.0,1322.0,547.0,1500000000,10.08142488100566,1082014363648.0,0.0089499387123762,0.0501479326719872,"#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

// An example function with memory allocation
void function_with_memory_allocation()
{
	int i = 10000;
	int* p = (int*) malloc(sizeof(int) * i);
	for(; i >= 0; --i)
		*p = i;
}


int main(void)
{
	int i;
	// Call the function 10000 times
	for(i = 0; i < 1000; ++i)
	{
		// call the function
		function_with_memory_allocation();
		
		// wait 10000 microseconds 
		usleep(10000);
	}
	return EXIT_SUCCESS;
}
"
081-20168,alexfru/retrobsd,share/examples/c/primelist.c,26,2,12,1713978.0102297,190140.0,9.0142947301988,1342.0,1322.0,42611.0,15686.0,1625.0,636.0,1346.0,594.0,1500000000,0.0011426520068198,1082014363648.0,0.014010728936573,0.0720620272055165,"/*
 * Print the list of prime numbers up to 100.
 */
#include <stdio.h>

int isprime(int);

int main(void)
{
    int n;

    for (n=2; n<100; ++n) {
        if (isprime(n)) {
            printf(""%d "", n);
        }
    }
    printf(""\n"");
}

int isprime(int n)
{
    int j;

    if (n == 2)
        return 1;

    if (n % 2 == 0)
        return 0;

    for (j=3; j*j<=n; j+=2)
        if (n % j == 0)
            return 0;
    return 1;
}

"
208-4633,dyladan/euler,c/4.2.c,39,3,19,60307198.2041001,367234044.0,0.1642200634318097,1369.0,1346.0,66251257.0,56088524.0,1643.0,638.0,1362.0,594.0,1500000000,0.0402047988027334,1082014363648.0,7.393105416991242e-06,3.4633052024181734e-05,"#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>



void reverse_string(char *str){
  char temp;
  size_t len = strlen(str) - 1;
  size_t i;
  size_t k = len;
  for(i = 0; i < (len +1)/2; i++){
    temp = str[k];
    str[k] = str[i];
    str[i] = temp;
    k--;
  }
}

int isPalindrome(int n){
  char str[10];
  char rev[10];
  sprintf(str, ""%d"", n);
  strcpy(rev, str);
  reverse_string(rev);
  if(strcmp(str,rev) == 0){
    return 1;
  } else {
    return 0;
  }
}

int main(int argc, char *argv[]){
  int a, b, product, large;
  for(a = 100; a < 1000; a++){
    for(b = a; b < 1000; b++){
      product = a*b;
      if(isPalindrome(product)){
        //printf(""%d\n"", product);
        if(product > large){
          large = product;
        }
      }
    }
  }
  printf(""Largest is %d\n"", large);
}

"
349-13892,gdos/SmallerC,v0100/tests/picoc/36.c,12,2,12,1714067.7664428,193540.0,8.85639661051979,1344.0,1325.0,43334.0,15997.0,1627.0,637.0,1346.0,596.0,1500000000,0.0011427118442952,1082014363648.0,0.0137904309186731,0.0708904282752692,"#include <stdio.h>

int main()
{
   int Count;

   int Array[10] = { 12, 34, 56, 78, 90, 123, 456, 789, 8642, 9753 };

   for (Count = 0; Count < 10; Count++)
      printf(""%d: %d\n"", Count, Array[Count]);

   int Array2[10] = { 12, 34, 56, 78, 90, 123, 456, 789, 8642, 9753, };

   for (Count = 0; Count < 10; Count++)
      printf(""%d: %d\n"", Count, Array2[Count]);


   return 0;
}

/* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
"
041-11888,misizeji/StudyNote_201308,c/test/array_typedef.c,15,2,7,1881763.45545795,175048.0,10.749982861843607,1335.0,1316.0,39598.0,13602.0,1618.0,639.0,1339.0,594.0,1500000000,0.0012545089703053,1082014363648.0,0.0151444175311914,0.0787593984962406,"
#include <stdio.h>

int main(int argc, char *argv[])
{
	int src[2][2] ={{1,2},{3,4}};
	
	typedef int (*dest)[2];
	dest num =  (dest)src;

	int i,j;
	for(i = 0; i < 2; i++)
	{
		for(j = 0; j < 2; j++)
		{
			
			printf(""____%d____\n"",num[i][j]);
		}
	}
	return 0;
}


"
176-19143,ISSAE/nsy103,CodeCamp/collections/tab.c,14,3,10,2409785.98594665,290357.0,8.299386617164387,1339.0,1320.0,62362.0,28710.0,1625.0,655.0,1345.0,612.0,1500000000,0.0016065239906311,1082014363648.0,0.0091576920825053,0.046523629655657,"#include <stdio.h>

int main () {

   int t[10];
   int tab2[100];
   int i;

   for (i=0; i<100; i++) {
       t[i]=i;
   }

   for (i=0;i<10;i++) {
       printf(""t[%d]=%d\n"",i,t[i]);
   }

   for (i=0;i<100;i++) {
       printf(""t[%d]=%d\n"",i,tab2[i]);
   }

}
"
061-21032,kkmonlee/Project-Euler-Solutions,CCPP/p12.c,24,2,16,392444642.8427472,919042090.0,0.4270148737148698,1343.0,1321.0,39252.0,13352.0,1618.0,636.0,1341.0,593.0,1500000000,0.2616297618951648,1082014363648.0,2.8986702883216155e-06,0.0796137175880161,"#include <stdio.h>
#include <limits.h>

#define LIMIT 500

typedef unsigned long ul;

int factor(ul n) {
    ul k;
    int count = 2;

    for (k = 2; k < n; k++) {
        if (n % k == 0) count++;
    }

    return count;
}

int main() {
    ul trinum = 0, i;
    int count;

    for (i = 1; i < ULONG_MAX; i++) {
        trinum += i;

        if (i & 1) count = factor(i) * factor((i + 1) / 2);
        else count = factor(i / 2) * factor(i + 1);

        if (count > LIMIT) {
            printf(""%ld: %ld\n"", i, trinum);
            return 0;
        }

        count = 0;
    }

    return 0;
}"
074-33748,b3h3moth/L-LP,src/C/bitwise_hacks/tips_and_tricks/get_rightmost_one.c,14,1,12,1833198.0099901499,186549.0,9.82263641188106,1363.0,1341.0,41937.0,15016.0,1631.0,643.0,1349.0,599.0,1500000000,0.0012221320066601,1082014363648.0,0.0144948512187146,0.0741313012483978,"#include <stdio.h>
#include <stdlib.h>

int get_rightmost_one_bit(unsigned value);

int main(void) {
    int values[] = { 0xFF, 0xA, 0x14, 0x0100, 0xABC, 0x6600, 0x0200};
    int i;

    for (i=0; i<sizeof(values)/sizeof(*values); i++)
        printf(""%#6x (hex) %6d (dec) righmost 1 is: %3d\n"",\
                values[i], values[i], get_rightmost_one_bit(values[i]));

    return(EXIT_SUCCESS);
}

/* Thi get_rightmost_one_bit() function returns the rightmost 1 bit within
an integer 'int' value */
int get_rightmost_one_bit(unsigned value) {
    return (value & -value);
}
"
164-24039,totalspectrum/binutils-propeller,gdb/testsuite/gdb.arch/spu-ls.c,22,2,13,1807684.5444737999,169083.0,14.753913758331707,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0012051230296492,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* Copyright 2010-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

   This file is part of the gdb testsuite.

   Contributed by Ulrich Weigand <uweigand@de.ibm.com>.
   Tests for SPU local-store access.  */

char *ptr = (char *)0x12345678;

char array[256];

int
main (unsigned long long speid, unsigned long long argp, 
      unsigned long long envp)
{
  return 0;
}

"
287-15057,ZhangIIIr/one,Practice/0c/09-wan.c,15,2,7,2351254.8068538,173593.0,13.544636016429234,1338.0,1318.0,39356.0,13381.0,1625.0,635.0,1346.0,593.0,1500000000,0.0015675032045692,1082014363648.0,0.0153001561122856,0.0796215180992472,"#include <stdio.h>

int main(int argc, char* argv[])
{
	int i = 0;
	int j = 0;

	printf(""%d\n"", argv[1]);

	for(i=0; i<(int)argv[1]; i++)
	{
		for(j=0; j<i; j++)
		{
			printf(""* "");
		}
		printf(""\n"");
	}
	return 0;
}
"
387-14056,jbaldwin/project_euler,p018/p18.c,71,1,28,1619826.18737955,173748.0,9.322846881690724,1333.0,1315.0,39264.0,13306.0,1624.0,636.0,1348.0,593.0,1500000000,0.0010798841249197,1082014363648.0,0.0152404631995763,0.079912497622218,"#include <stdio.h>

int triangle[] = {
75,
95, 64,
17, 47, 82,
18, 35, 87, 10,
20,  4, 82, 47, 65,
19,  1, 23, 75,  3, 34,
88,  2, 77, 73,  7, 63, 67,
99, 65,  4, 28,  6, 16, 70, 92,
41, 41, 26, 56, 83, 40, 80, 70, 33,
41, 48, 72, 33, 47, 32, 37, 16, 94, 29,
53, 71, 44, 65, 25, 43, 91, 52, 97, 51, 14,
70, 11, 33, 28, 77, 73, 17, 78, 39, 68, 17, 57,
91, 71, 52, 38, 17, 14, 91, 43, 58, 50, 27, 29, 48,
63, 66,  4, 68, 89, 53, 67, 30, 73, 16, 69, 87, 40, 31,
 4, 62, 98, 27, 23,  9, 70, 98, 73, 93, 38, 53, 60,  4, 23,
};

int left_child(int n, int i) {
	return i + n;
}

int right_child(int n, int i) {
	return i + n + 1;
}

int greedy_two_step(int triangle[], int rows, int len) {
	int max = triangle[0];
	int i = 0;
	int n = 1;
	int row = 0;

	while(row < rows - 1) {
		int left  = left_child(n, i);
		int right = right_child(n, i);

		int leftleft  = left_child(n + 1, left);
		int leftright = right_child(n + 1, left);

		int rightleft  = left_child(n + 1, right);
		int rightright = right_child(n + 1, right);

		int n_ll = 0;
		int n_lr = 0;
		int n_rl = 0;
		int n_rr = 0;

		if(left < len) {
			n_ll += triangle[left];
			n_lr += triangle[left];
		}
		if(right < len) {
			n_rl += triangle[right];
			n_rr += triangle[right];
		}

		if(leftleft   < len) n_ll += triangle[leftleft];
		if(leftright  < len) n_lr += triangle[leftright];
		if(rightleft  < len) n_rl += triangle[rightleft];
		if(rightright < len) n_rr += triangle[rightright];

		// Determine moving left or right is better,
		// either path works...
		if( (n_ll >= n_lr && n_ll >= n_rl && n_ll >= n_rr) ||
			(n_lr >= n_ll && n_lr >= n_rl && n_lr >= n_rr)) {
			i = left;
			max += triangle[left];
		} else {
			i = right;
			max += triangle[right];
		}

		n++;
		row++;
	}
	
	return max;
}

int main(int argc, char* argv[]) {
	int max = greedy_two_step(triangle, 15, 120);
	printf(""%i"", max);
	return 0;
}

"
386-2238,Tarek-Adra/nsy103,MPS/prog_linux/13/exemple_calloc_3.c,14,1,9,257255109.02702805,270584965.0,0.9507368933081703,1343.0,1336.0,43246017.0,44181477.0,22620.0,4469445.0,1409.0,4461107.0,1500000000,0.1715034060180187,1082014363648.0,9.900771833350017e-06,0.1024229403166925,"
	#include <stdio.h>
	#include <stdlib.h>

	#define	NB_BLOCS	(1024*1024)
	#define TAILLE		257

	int
main (void)
{

	int	i;
	char *	bloc [NB_BLOCS];

	for (i = 0; i < NB_BLOCS; i ++) {
		if ((bloc [i] = (char *) calloc (1, TAILLE)) == NULL) {
			fprintf (stderr, ""Echec pour i = %d\n"", i);
			break;
		}
	}
	fprintf (stderr, ""Alloués : %d blocs de %d Ko\n"", i, TAILLE / 1024);
	
	return (0);
}	

"
214-5615,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.trace/actions-changed.c,51,1,14,1502627.9725133998,169061.0,8.888075901597649,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010017519816756,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2013-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
end (int i)
{
}

int
subr2 (int parm)
{
  int keeping, busy;

  keeping = parm + parm;
  busy = keeping * keeping;

  return busy;
}

int
subr (int parm)
{
  int keeping, busy;

  keeping = parm + parm;
  busy = keeping * keeping;

  return busy;
}

int
main()
{
  subr (1);
  end (1);

  subr (2);
  end (2);

  subr (3);
  end (3);

  subr (4);
  end (4);

  subr (5);
  subr2 (5);
  end (5);

  subr (6);
  subr2 (6);
  end (6);

  return 0;
}
"
155-8394,EvtimPavlov/c-programming-2014-2015-homework,A/06_Velin_Yavorski/homework_3/task_4.c,9,1,4,2097423.1883883,173200.0,12.109832563510391,1338.0,1319.0,39184.0,13309.0,1618.0,636.0,1340.0,593.0,1500000000,0.0013982821255922,1082014363648.0,0.0153406466512702,0.0797630160211837,"#include<stdio.h>

int main()
{
	int i,f;
	f=1;
	for(i=1;i<=10;i++)
	f=f*i;
	printf(""%d\n"",f);
return 0;
}

"
204-16513,Gurgel100/gcc,gcc/testsuite/gcc.dg/torture/pr81571.c,10,1,7,1758932.95090635,169086.0,10.402588032125664,1143.0,1133.0,38461.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0011726219672709,1082014363648.0,0.013460605845546,0.078503430615556,"/* { dg-do compile } */

int a, b, c, d;
short fn1(int p1, int p2) { return p1; }

int fn2(int p1) {}

int main()
{
  for (; c; c++)
    a |= fn1(1, a) | fn2(b |= d);
  return 0;
}
"
384-17633,dllm/practice,array_adhoc/reverse_string.c,24,1,16,1742433.17451315,175438.0,9.931901868466351,1323.0,1303.0,39821.0,13575.0,1639.0,639.0,1354.0,594.0,1500000000,0.0011616221163421,1082014363648.0,0.014968250892053,0.0791445052063825,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>


char* reverseString(char* s) {

        char *right, *left;
        char temp;

        if (s){
                right = s + strlen(s) - 1;
                left = s;
        }
        else{
                printf (""str = NULL\n"");
        }

        while (s != right){

                temp = *right;
                *right = *left;
                *left = temp;
                left++;
                right--;

        }

        return s;
}

int main (void){


        char str[] = ""Hello ABCDEF"";

        char *newstr = reverseString(str);


        printf(""%s "", newstr);


}
"
043-11175,buptlxb/HuaWei,oj/4741/4741_factorial.c,47,4,21,2800144.4879919,275352.0,10.16932508207676,1313.0,1292.0,47000.0,23487.0,1625.0,679.0,1343.0,608.0,1500000000,0.0018667629919946,1082014363648.0,0.0094606176820941,0.060365741200505,"#include <stdio.h>

#define LIMIT 1000
unsigned int CalcMM(unsigned int n)
{
    if (n < 2)
        return 1;
    return n * CalcMM(n-1);
}

void CalcNN(int n, char *pOut)
{
    if (n < 2) {
        sprintf(pOut, ""%u"", CalcMM(n));
        return;
    }
    unsigned int res[LIMIT] = {6};
    int i, j, len, carry;
    for (i = 4, len = 1; i <= n; ++i) {
        for (j = 0, carry = 0; j < len; ++j) {
            res[j] = res[j]*i + carry;
            carry = res[j] / 10;
            res[j] %= 10;
        }
        for (; carry; carry /= 10)
            res[len++] = carry % 10;
        if (len >= LIMIT) {
            printf(""overflow!\n"");
            return;
        }
    }
    i = 0;
    pOut[len] = '\0';
    while (len-- > 0)
        pOut[i++] = res[len] + '0';
}

int main(void)
{
    char buf[LIMIT];
    CalcNN(5, buf);
    puts(buf);
    CalcNN(12, buf);
    puts(buf);
    CalcNN(13, buf);
    puts(buf);
    CalcNN(20, buf);
    puts(buf);
    CalcNN(100, buf);
    puts(buf);
    return 0;
}
"
359-10424,epicsdeb/rtems-gdb,gdb/testsuite/gdb.python/py-symbol.c,45,1,23,1698258.10007745,169083.0,10.043931087099237,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0011321720667183,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2010, 2011 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see  <http://www.gnu.org/licenses/>.
*/

#ifdef __cplusplus
class SimpleClass
{
 private:
  int i;

 public:
  void seti (int arg)
  {
    i = arg;
  }

  int valueofi (void)
  {
    return i; /* Break in class. */
  }
};
#endif

int func (int arg)
{
  int i = 2;
  i = i * arg;
  return arg; /* Block break here.  */
}

int main (int argc, char *argv[])
{
#ifdef __cplusplus
  SimpleClass sclass;
#endif
  int a = 0;
  int result;
  enum tag {one, two, three};
  enum tag t = one;

  result = func (42);

#ifdef __cplusplus
  sclass.seti (42);
  sclass.valueofi ();
#endif
  return 0; /* Break at end.  */
}
"
243-8539,LinuxIoT/training,src/c/misc/linkedLists/list1.c,31,1,19,2264674.63653525,177495.0,12.75908617144145,1342.0,1324.0,40132.0,13852.0,1627.0,635.0,1345.0,594.0,1500000000,0.0015097830910235,1082014363648.0,0.0150201414124341,0.0778193538826318,"#include <stdio.h>

struct point{
    int x;
    int y;
    struct point * next;
};

void printPoints(struct point *);
void appendNode(struct point *, struct point *);

int main(void) {
    
	struct point pt1 = {1, 2, NULL};
    struct point pt2 = {-2, 3, NULL};
    struct point pt3 = {5, -4, NULL};
    struct point pt4 = {9, -9, NULL};
    struct point * head, * tail;
    
    head = &pt1;
    pt1.next = &pt2;
    pt2.next = &pt3;
    
    appendNode(&pt3, &pt4);

    printPoints(head);
    
	return 0;
}

void appendNode(struct point *src, struct point *dst) {
    (*src).next = dst;
}

void printPoints(struct point *head) {
    struct point *tail;

    tail = head;

    while (tail != NULL) {
		printf(""(%d, %d)\n"", (*tail).x, (*tail).y);
        tail = (*tail).next;
    }
}
"
028-34626,danielmapar/TheCProgrammingLanguage,src/Chapter-2/Exercices/Exercise-2-6.c,36,2,21,2325289.4170581,173882.0,13.372798794584831,1276.0,1261.0,39410.0,13402.0,1620.0,635.0,1336.0,593.0,1500000000,0.0015501929447054,1082014363648.0,0.0145903543782565,0.0792244186927213,"/*
 ============================================================================
 Name        : Exercise-2-6.c
 Author      : Daniel Marchena Parreira
 Email       : danielmapar@gmail.com
 Date        : 12/04/2014
 Version     : 0.1
 Copyright   : GNU General Public License Version 2
 Description : Write a function setbits(x,p,n,y) that returns x with the
               n bits that begin at position p set to the rightmost n bits
               of y, leaving the other bits unchanged.
 ============================================================================
 */

#include <stdio.h>

unsigned setbits(unsigned char x, unsigned char p, unsigned char n, unsigned char y);
void printbits(unsigned char v);

int main(void)
{
	printbits(setbits(8,2,1,2));
	return 0;
}

unsigned setbits(unsigned char x, unsigned char p, unsigned char n, unsigned char y)
{
	unsigned char left,right, substitute;

	left = x >> (9-p);
	left = left << (9-p);

	right = x << (p+n-1);
	right = right >> (p+n-1);

	substitute = y << (8-n);
	substitute = substitute >> (p-1);

	return(left | right | substitute);
}

void printbits(unsigned char v) {
  int i; // for C89 compatability
  for(i = 7; i >= 0; i--) putchar('0' + ((v >> i) & 1));
  printf(""\n"");
}

"
300-4679,SanDisk-Open-Source/SSD_Dashboard,uefi/gcc/gcc-4.6.3/gcc/testsuite/gcc.c-torture/compile/20000329-1.c,34,1,18,1419741.0782799,169058.0,8.397952182091354,1139.0,1129.0,38452.0,12697.0,1567.0,588.0,1316.0,547.0,1500000000,0.0009464940521866,1082014363648.0,0.0134155142022264,0.0785548104557273,"int giop_tx_big_endian;

inline
void
giop_encode_ulong (unsigned long i, char *buf)
{
  if (giop_tx_big_endian)
    {
      *(unsigned long *) buf = i;
    }
  else
    {
      *buf++ = i & 0xff;
      *buf++ = (i >> 8) & 0xff;
      *buf++ = (i >> 16) & 0xff;
      *buf = (i >> 24) & 0xff;
    }
}



static
double
time_giop_encode (unsigned long l)
{
  int c;
  char buf[4];

  for (c = 0; c < (512 * 1024 * 1024); ++c)
    {
      giop_encode_ulong (l, buf);
    }
}

int
main (int ac, char *av[])
{
  giop_tx_big_endian = 1;
  time_giop_encode (0);
}
"
105-30329,levelfour/min-caml,shootout/mandelbrot.c,36,3,19,304579533.05449337,1053974632.0,0.2889818442992658,1275.0,1257.0,2121517.0,1134084.0,1613.0,699.0,1331.0,656.0,1500000000,0.2030530220363289,1082014363648.0,2.4023348599912032e-06,0.0013204935125649,"#include<stdio.h>
#include<stdlib.h>

double dbl(double f) {
  return f + f;
}

int main ()
{
  int w, h, x, y;
  int i, iter = 1000;
  double limit = 2.0;
  double zr, zi, zr2, zi2, cr, ci, tr, ti;

  w = 400;
  h = w;

  for(y=0;y<h;y++)
    {
      for(x=0;x<w;x++)
        {
	  zr = 0.0; zi = 0.0; zr2 = 0.0; zi2 = 0.0;
	  cr = (dbl((double)x)/w - 1.5); ci=(dbl((double)y)/h - 1.0);

	  for (i=0;i<iter;i++)
            {
	      tr = zr2 - zi2 + cr;
	      ti = dbl(zr)*zi + ci;
	      zr = tr; zi = ti;
	      zr2 = zr*zr;
	      zi2 = zi*zi;
	      if (zr2+zi2 > limit*limit) {
		putchar('0');
		goto cont;
	      }
            }

	  putchar('1');

	cont:
	  ;
        }
    }

  return(0);
}
"
098-20627,mattstock/binutils-bexkat1,gdb/testsuite/gdb.base/info_minsym.c,22,1,12,1473947.8938280498,169058.0,8.71858770362834,1139.0,1129.0,38453.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0009826319292187,1082014363648.0,0.0134155142022264,0.0785548104557273,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2018-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

static int minsym_var;

static int minsym_fun (void)
{
   minsym_var++;
}

int
main (void)
{
  return minsym_fun ();
}
"
197-22244,EvtimPavlov/c-programming-2014-2015-homework,A/02_Andrea_Georgieva/homework_3/task_2.c,19,1,8,1932513.08519385,245791.0,7.862423766533356,1351.0,1331.0,53247.0,23155.0,1623.0,657.0,1345.0,614.0,1500000000,0.0012883420567959,1082014363648.0,0.0109117095418465,0.0554828407633308,"#include <stdio.h>
int main()
{	
long long unsigned int L1,L2,L3;
int a;
L1=2;
L2=1;
printf(""%lli, "",L1);
printf(""%lli, "",L2);
for(a=2;a<=93;a++)
{
L3=L2+L1;
printf(""%lli, "",L3);
L1=L2;
L2=L3;	
}
printf(""27280388024614569596, 44140595050111976643, 71420983074726546239, 115561578124838522882, 186982561199565069121, 302544139324403592003, 489526700523968661124, 792070839848372253127 "");
// The numbers after the 90s lucas number were too big so I printed them manually
return 0;
}
"
140-23332,klenovic/nucleos-utils,simple/printenv.c,8,1,6,1341092.9823294,188206.0,7.123301063728043,1304.0,1286.0,43568.0,15432.0,1699.0,696.0,1361.0,654.0,1500000000,0.0008940619882196,1082014363648.0,0.0137615166360264,0.0747457627118644,"
#include <stdio.h>

int main(int argc, char *argv[], char *envp[])
{
	int p;
	for(p = 0; envp[p] && *envp[p]; p++) {
		printf(""%s\n"", envp[p]);
	}
	return 0;
}

"
298-23874,JasonVann/ComputerArchitecture,CS61C/L3/Argc.c,4,1,5,2018432.8313916002,173406.0,11.63992018730609,1351.0,1330.0,39235.0,13341.0,1618.0,636.0,1340.0,593.0,1500000000,0.0013456218875944,1082014363648.0,0.0154608260383147,0.0796370967741935,"#include <stdio.h>

int main(int argc, char *argv[]) {
    for (int i=0;  i<argc;  i++) 
        printf(""arg[%d] = %s\n"", i, argv[i]);
}

"
010-27366,chrismoulds/Misc.-Projects,projecteuler/C/problem2.c,29,1,19,2680039.49895495,173409.0,15.45501675230236,1335.0,1316.0,39181.0,13311.0,1618.0,636.0,1340.0,593.0,1500000000,0.0017866929993033,1082014363648.0,0.0152875571625463,0.079764535548274,"/*
* Project Euler Problem #2:
* Each new term in the Fibonacci sequence is generated by adding the 
* previous two terms. By starting with 1 and 2, the first 10 terms will be:
*
* 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
*
* By considering the terms in the Fibonacci sequence whose values do not exceed 
* four million, find the sum of the even-valued terms.
* 
* Author: Chris Moulds
*/


#include <stdio.h>

int main()
{

	int sum, first, second, third;

	sum = 2;
	first = 1;
	second = 2;
	third = 0;

	while (third <= 4000000){

	third = first+second;

	if (third%2 == 0)
		sum+=third;

	first = second;
	second = third;

	}
	

	printf(""SUM: %d\n"", sum);

	return 0;
}
"
150-22188,totalspectrum/binutils-propeller,gdb/testsuite/gdb.base/bg-execution-repeat.c,25,1,14,7501956523.396074,170067.0,44111.77079033558,1152.0,1142.0,38683.0,12795.0,1575.0,585.0,1323.0,544.0,1500000000,5.0013043489307165,1082014363648.0,0.0134888014723608,0.0782275923695559,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
foo (void)
{
  return 0; /* set break here */
}

int
main (void)
{
  foo ();
  sleep (5);
  foo ();
  return 0;
}
"
397-25499,fred-dbg/fred,test/many-threads2.c,37,3,21,8099968048.743904,2158089.0,3753.3058404912863,1462.0,1419.0,598640.0,367215.0,25240.0,26537.0,1383.0,1133.0,1500000000,5.399978699162602,1082014363648.0,0.0013349773804509,0.0562123714222114,"#include <stdio.h>
#include <pthread.h>

/*
 * Creates CONCURRENT_THREADS number of threads which are alive at
 * once. Does this a total of TOTAL_NUM_THREADS / CONCURRENT_THREADS
 * times.
 */

#define TOTAL_NUM_THREADS 1000
#define CONCURRENT_THREADS 20
#define THREAD_LIFETIME_US 100000
//#define PRINTING

void *worker(void *arg)
{
  long i = (long)arg;
#ifdef PRINTING
  printf(""Thread %ld alive\n"", i);
#endif
  usleep(THREAD_LIFETIME_US);
#ifdef PRINTING
  printf(""aaaaand thread %ld exiting.\n"", i);
#endif
}

int main()
{
  pthread_t threads[CONCURRENT_THREADS];
  long i = 0;
  int rc = 0;
  for (i = 0; i < TOTAL_NUM_THREADS; i += CONCURRENT_THREADS) {
    long j;
    for (j = 0; j < CONCURRENT_THREADS; j++) {
      rc = pthread_create(&threads[j], NULL, worker, (void *)(i+j));
      if (rc) {
        perror(""pthread_create"");
        return 1;
      }
    }
    for (j = 0; j < CONCURRENT_THREADS; j++) {
      rc = pthread_join(threads[j], NULL);
      if (rc) {
        perror(""pthread_join"");
        return 1;
      }
    }
  }

  return 0;
}
"
035-25137,Gurgel100/gcc,gcc/testsuite/gcc.c-torture/compile/pr91190.c,29,3,11,1624967.7864834,170025.0,9.557223937656229,1150.0,1142.0,38675.0,12784.0,1577.0,586.0,1324.0,546.0,1500000000,0.0010833118576556,1082014363648.0,0.013480370533745,0.0783730737091665,"/* PR middle-end/91190 */

unsigned a[1], c;
long d, h;
int e[2], f, g;
char i;

int
main ()
{
  char k = 0;
  int l;
  while (i || d)
    {
      if (g)
	while (1)
	  ;
      e[1] = 0;
      long m[2], n = ~(3 & (5 | (h | 9) * 2237420170));
      g = 90 * n;
      char b = m[300000000], j = 0;
      c = 5 ^ a[c ^ (b & 5)];
      int o = d;
      k = o ? : j;
      if (k)
	for (l = 0; l < 3; l++)
	  if (m[200000000000000000]) 
	    __builtin_printf (""%d"", f);
    }
  return 0; 
}
"
180-27626,zhangrxiang/learn-c,linux/pthread/pthread_create.c,52,1,30,15003383998.526262,197379.0,76013.07128924556,1549.0,1507.0,45005.0,16801.0,1695.0,746.0,1395.0,700.0,1500000000,10.002255999017509,1082014363648.0,0.0154829034497084,0.073390932919134,"//
// Created by zing on 5/23/2020.
//


#include <pthread.h>
#include <stdio.h>
#include <errno.h>
#include <unistd.h>

static void *thread_start(void *arg) {
    printf(""thread_start pid %d thread_id %lx\n"",getpid(),pthread_self());
    return NULL;
}

int pthread_create1() {
    pthread_t pthread;
    pthread_attr_t pthreadAttr;
    if (pthread_attr_init(&pthreadAttr) != 0) {
        perror(""pthread_attr_init"");
        return errno;
    }
    int s = pthread_create(&pthread, &pthreadAttr, &thread_start, NULL);
    if (s != 0) {
        perror(""pthread_create"");
        return errno;
    }
    s = pthread_create(&pthread, &pthreadAttr, &thread_start, NULL);
    if (s != 0) {
        perror(""pthread_create"");
        return errno;
    }
    return 0;
}

//void *(*__start_routine) (void *),
void *print1(void *argv) {
    printf(""print1 pid %d thread_id %lx\n"",getpid(),pthread_self());
    printf(""get param { %s }\n"",(char *)argv);
    for (int i = 0; i < 10; i++) {
        sleep(1);
        printf(""print1 %d\n"", i);
    }
    return 0;
}

pthread_t pthread_create2() {
    pthread_t pthread;
    if (0 != pthread_create(&pthread, NULL, &print1, ""i am from pthread_create2"")) {
        perror(""pthread_create"");
        return errno;
    }
    return pthread;
}

int main(int argc, char *argv[]) {
    printf(""main pid %d thread_id %lx\n"",getpid(),pthread_self());
    pthread_create1();
    pthread_t p2 = pthread_create2();
    void *rev2;
    pthread_join(p2,&rev2);
    return 0;
}
"
297-26394,kurt-vd/rund,ktstamp.c,9,1,10,2147794.2354976498,175890.0,12.207709363806924,1359.0,1339.0,39815.0,13538.0,1637.0,634.0,1355.0,593.0,1500000000,0.0014318628236651,1082014363648.0,0.0153391324123031,0.0790770903229434,"/* See LICENSE file for copyright and license details. */
#include <stdio.h>
#include <time.h>
#include <string.h>

int main(int argc, char *argv[])
{
	struct timespec ts;
	int secwidth = !strcmp(argv[1]?: """", ""-k"") ? 5 : 0;

	clock_gettime(CLOCK_MONOTONIC, &ts);
	printf(""%*lu.%06lu\n"", secwidth, ts.tv_sec, ts.tv_nsec/1000);
	return 0;
}
"
205-33289,tadamczyk/LabPO_III,lab5/Dane.c,8,1,5,3723879.1119306,884957.0,4.207977336751955,1440.0,1411.0,193611.0,116659.0,1646.0,700.0,1363.0,657.0,1500000000,0.0024825860746204,1082014363648.0,0.0032216254575081,0.0140716150449608,"#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(){
  srand(time(0));
  FILE *out;
  out = fopen(""Dane.txt"", ""w"");
  int i;
  for (i=0; i<1000; i++) fprintf(out, ""%d\n"", rand()%256);
  fclose(out);
}
"
189-6703,xitkov/projecteuler,other-lang/c/prob0012.c,37,4,14,100995749.8172298,885661404.0,0.1140342669826899,1346.0,1326.0,26403964.0,491365134.0,1720561.0,6447918.0,1361.0,1109.0,1500000000,0.0673304998781532,1082014363648.0,3.016954321292745e-06,0.0157810673359266,"#include <stdio.h>
#include <math.h>
#include <ctype.h>

#define PRIMES 10000

unsigned long int divisors(unsigned long long int);

int main()
{
	unsigned long long int i, flag = 0, n = 0, div;
	
		for(i = 1; !flag ; i++)
		{
			if(i == 1)
				n = 1;
			else
			{
				n += i;
				div = divisors(n);
				if(div > 500)
					flag = 1;
			}
		}
	
	printf(""\nLargest is %llu"", n);
	return 0;
}

unsigned long int divisors(unsigned long long int n)
{
	unsigned int primes[PRIMES];
	unsigned long int i;
	
	for( i = 0; i < PRIMES && i <= n ; i++) primes[i]=0;
	
	unsigned short int div=1;
	
	for(i = 2 ; i < PRIMES && i <= n ; i++)		
	{
		while(!(n % i))
		{
			n /= i;
			primes[i]++;
		}
		if(primes[i])
			div *= (primes[i] + 1);
	}
	
	return div;
}"
077-9888,zguangyu/euler,7.c,22,2,11,908749092.137441,1993220404.0,0.4559200227813842,1336.0,1317.0,39176.0,13307.0,1622.0,630.0,1343.0,590.0,1500000000,0.6058327280916274,1082014363648.0,1.3310118613455657e-06,0.0797401063201417,"#include <stdio.h>

int is_prime(int n)
{
  long i;
  if (n==2) return 1;
  if (n<2) return 0;
  for (i=2; i<=n/2; i++) {
    if (n%i == 0)
      return 0;
  }
  return 1;
}

int main()
{
  long i=2, num=0;
  while(num < 10001) {
    if (is_prime(i))
      num++;
    i++;
  }
  i--;
  printf(""%ld\n"", i);
}
"
017-32890,Legend/Elune,drd/tests/pth_detached.c,74,4,29,1512361774.686724,480246.0,3149.1397617054595,1402.0,1366.0,123976.0,68471.0,3953.0,5921.0,1590.0,4800.0,1500000000,1.0082411831244826,1082014363648.0,0.0057637127638751,0.0845115798115844,"/* Test whether detached threads are handled properly. */


#include <assert.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>


static int s_finished_count;
static pthread_mutex_t s_mutex;


static void increment_finished_count()
{
  pthread_mutex_lock(&s_mutex);
  s_finished_count++;
  pthread_mutex_unlock(&s_mutex);
}

static int get_finished_count()
{
  int result;
  pthread_mutex_lock(&s_mutex);
  result = s_finished_count;
  pthread_mutex_unlock(&s_mutex);
  return result;
}

static void* thread_func1(void* arg)
{
  write(STDOUT_FILENO, ""."", 1);
  increment_finished_count();
  return 0;
}

static void* thread_func2(void* arg)
{
  pthread_detach(pthread_self());
  write(STDOUT_FILENO, ""."", 1);
  increment_finished_count();
  return 0;
}

int main(int argc, char** argv)
{
  const int count1 = argc > 1 ? atoi(argv[1]) : 100;
  const int count2 = argc > 2 ? atoi(argv[2]) : 100;
  int thread_arg[count1 > count2 ? count1 : count2];
  int i;
  int detachstate;
  pthread_attr_t attr;

  for (i = 0; i < count1 || i < count2; i++)
    thread_arg[i] = i;

  pthread_mutex_init(&s_mutex, 0);

  pthread_attr_init(&attr);
  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
  assert(pthread_attr_getdetachstate(&attr, &detachstate) == 0);
  assert(detachstate == PTHREAD_CREATE_DETACHED);
  pthread_attr_setstacksize(&attr, 16384);
  // Create count1 detached threads by setting the ""detached"" property via
  // thread attributes.
  for (i = 0; i < count1; i++)
  {
    pthread_t thread;
    pthread_create(&thread, &attr, thread_func1, &thread_arg[i]);
  }
  // Create count2 detached threads by letting the threads detach themselves.
  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
  assert(pthread_attr_getdetachstate(&attr, &detachstate) == 0);
  assert(detachstate == PTHREAD_CREATE_JOINABLE);
  for (i = 0; i < count2; i++)
  {
    pthread_t thread;
    pthread_create(&thread, &attr, thread_func2, &thread_arg[i]);
  }
  pthread_attr_destroy(&attr);

  // Wait until all detached threads have written their output to stdout.
  while (get_finished_count() < count1 + count2)
  {
    struct timespec delay = { 0, 1 * 1000 * 1000 };
    nanosleep(&delay, 0);
  }

  write(STDOUT_FILENO, ""\n"", 1);

  pthread_mutex_destroy(&s_mutex);

  sleep(1);

  return 0;
}
"
345-22298,talkspoon/cobj,bench/prime.c,22,2,11,10960737.1268793,33949107.0,0.3228578884269327,1341.0,1320.0,1361926.0,961768.0,1620.0,699.0,1340.0,656.0,1500000000,0.0073071580845862,1082014363648.0,7.838203225787353e-05,0.0018569570692182,"#include <stdio.h>

static int
is_prime(unsigned int i)
{
    unsigned int j;
    for (j = 2; j * j < i + 1; j++) {
        if (!(i % j)) {
            return -1;
        }
    }
    return 0;
}

int
main(int argc, const char **argv)
{
    int maxnum = 100000;
    unsigned int i = 2;
    for (i = 2; i < maxnum; i++) {
        if (!is_prime(i)) {
            printf(""%d\n"", i);
        }
    }
}
"
258-16270,CodethinkLabs/endian-tests,test-src/misaligned-words.c,11,1,11,1900787.9309355,183107.0,10.380744591959893,1364.0,1343.0,41105.0,14483.0,1631.0,639.0,1349.0,596.0,1500000000,0.001267191953957,1082014363648.0,0.0147837057021304,0.075825717780816,"#include <stdio.h>

int main()
{
  unsigned int alignedInts[4] = { 0x01020304, 0x05060708, 0x090A0B0C, 0x0D0E0F10 };
  int offset;

  for(offset = 0; offset < 4; offset++) {
    unsigned char* misalignedPtr = ((unsigned char*) alignedInts) + offset;
    unsigned int* misalignedInts = (unsigned int*) misalignedPtr;
    printf(""Offset %d: %8.8X %8.8X %8.8X\n"", offset, misalignedInts[0], misalignedInts[1], misalignedInts[2]);
  }
  return 0;
}
"
345-1518,rfmvh/perftool-testsuite,base_probe/examples/load.c,16,2,9,870958974.0028605,104162621.0,8.361530898881663,1486.0,1460.0,229714.0,137338.0,1647.0,698.0,1362.0,655.0,1500000000,0.580639316001907,1082014363648.0,2.8282698454755663e-05,0.0118838747643385,"#include <stdio.h>
#include <stdlib.h>


int main (int argc, char *argv[])
{
	long from, i, j = 20L;

	if (argc > 1)
		from = atol (argv[1]);
	else
		from = 20L;

	for (i = 1L; j; ++i)
	{
		for (j = from; j > 0L; --j)
			if (i % j)
				break;
	}

	printf (""%ld\n"", --i);

	return 0;
}
"
022-879,qeedquan/misc_utilities,snippets/posix/sleep.c,21,1,12,37536529095.02852,179343.0,209300.2185476991,1370.0,1346.0,40688.0,14152.0,1640.0,638.0,1357.0,595.0,1500000000,25.024352730019015,1082014363648.0,0.0151441650914727,0.0771334792122538,"// ./sleep | ts  '%.s' -s
#define _GNU_SOURCE
#include <stdio.h>
#include <time.h>
#include <unistd.h>

int
main(void)
{
	struct timespec tp;
	int i;

	setvbuf(stdout, NULL, _IONBF, 0);
	for (i = 0; i < 10; i++) {
		clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &tp);
		printf(""clock_gettime(CLOCK_PROCESS_CPUTIME_ID) %lld %lld\n"", (long long)tp.tv_sec, (long long)tp.tv_nsec);

		printf(""clock_nanosleep(CLOCK_REALTIME)\n"");
		clock_nanosleep(CLOCK_REALTIME, 0, &(struct timespec){0, 500ull * 1000000ull}, NULL);

		printf(""clock_nanosleep(CLOCK_MONOTONIC)\n"");
		clock_nanosleep(CLOCK_MONOTONIC, 0, &(struct timespec){0, 500ull * 1000000ull}, NULL);

		printf(""nanosleep()\n"");
		nanosleep(&(struct timespec){0, 500ull * 1000000ull}, NULL);

		printf(""sleep()\n"");
		sleep(1);
	}

	return 0;
}
"
297-30183,Jadoch/LinuxProject,MPS/prog_linux/12/exemple_semaphores.c,37,2,14,25503508540.685287,301494.0,84590.43476818776,2328.0,1789.0,71624.0,30831.0,2507.0,1322.0,1644.0,1068.0,1500000000,17.002339027123526,1082014363648.0,0.0136553297909742,0.0638426626323751,"	#include <stdio.h>
	#include <stdlib.h>
	#include <pthread.h>
	#include <semaphore.h>
	#include <unistd.h>


	sem_t	semaphore;

	static void *	routine_thread (void * numero_thread);
	static int      aleatoire      (int maximum);
	int
main (void)
{
	int        i;
	pthread_t  thread;

	sem_init (& semaphore, 0, 3);
	for (i = 0; i < 10; i ++)
		pthread_create (& thread, NULL, routine_thread, (void *) i);
	pthread_exit (NULL);
}

	void *
routine_thread (void * numero_thread)
{
	int    i;
	for (i = 0; i < 2; i ++) {
		sem_wait (& semaphore);
		fprintf (stdout, ""Thread %d dans portion critique\n"",
				 (int) numero_thread);
		sleep (aleatoire (4));
		
		fprintf (stdout, ""Thread %d sort de la portion critique\n"",
				 (int) numero_thread);
		sem_post (& semaphore);
		sleep (aleatoire (4));
	}
	return (NULL);
}		


	static int
aleatoire (int maximum)
{
	double d;
	d = (double) maximum * rand ();
	d = d / (RAND_MAX + 1.0);
	return ((int) d);
}
"
156-7398,javimv36/SO,ejercicios/e2-hilos/hilos_join.c,42,2,26,1502604858.018458,320806.0,4683.8427523176,1525.0,1494.0,70852.0,35014.0,1674.0,775.0,1374.0,729.0,1500000000,1.0017365720123053,1082014363648.0,0.0094106718702268,0.0429977518750118,"#include<stdio.h>
#include<string.h>
#include<pthread.h>
#include<stdlib.h>
#include<unistd.h>

void *trabajo(void *arg);
int variable_global = 0;

pthread_t tid[2]; //tid es el identificador de hilo (threadID)

int main(void)
{
    int i = 0;
    int err;

    while(i < 2)  //Queremos crear 2 hilos
    {
        err = pthread_create(&(tid[i]), NULL, trabajo, NULL);
        if (err != 0)
            printf(""\nError al crear el hilo :[%d]"", strerror(err));
        else
            printf(""\n Hilo creado!\n"");

        i++;
    }

    //sleep(5);
    (void) pthread_join(tid[0], NULL);
    (void) pthread_join(tid[1], NULL);
    printf(""El valor FINAL es: %d\n"", variable_global);
    return 0;
}

void *trabajo(void *arg)
{
    int i = 0;
    /* i es un avariable local*/

    pthread_t id = pthread_self();

    for(i=0; i<100; i++)
    {
    	variable_global++;
    
     	if(pthread_equal(id,tid[0]))
     	{
        	printf(""\n El valor de variable global para el primer hilo es: %d\n"",variable_global);
     	}
    	else
    	{
        	printf(""\n El valor de variable global para el segundo hilo es: %d\n"",variable_global);
    	}
    }
    sleep(1);

    //return NULL;
}
"
060-2887,seansaville/ProjectEuler,Problem5/problem5.c,20,2,10,780134104.541503,2047205635.0,0.3810726634698814,1335.0,1316.0,39173.0,13306.0,1618.0,636.0,1340.0,593.0,1500000000,0.5200894030276686,1082014363648.0,1.2949358651017978e-06,0.079784294670249,"#include ""stdio.h""

int main() {
	int done = 0;
	int i;
	int num = 0;

	while (!done) {
		num++;
		// We need only test divisibility by 11...20 because the numbers 0...10 are
		// factors of these numbers
		for (i = 11; i <= 20; i++) {
			if (num % i == 0) {
				done = 1;
			} else {
				done = 0;
				break;
			}
		}
	}

	printf(""%d\n"", num);

	return 0;
}"
108-24251,flaviomahooney/Treino-c,mapa.c,13,2,13,2119594.3700149497,292516.0,7.246078846969055,1270.0,1255.0,72445.0,35366.0,1617.0,691.0,1335.0,650.0,1500000000,0.0014130629133433,1082014363648.0,0.0086320064543477,0.0398196844477836,"#include <stdio.h>
int main(void) 
{
        int a,b,c;
        for (b=c=10;(a=""- FIGURE?, UMKC,XYZHello Folks,\
TFy!QJu ROo TNn(ROo)SLq SLq ULo+UHs UJq TNn*RPn/QPbEWS_JSWQAIJO^\
NBELPeHBFHT}TnALVlBLOFAkHFOuFETpHCStHAUFAgcEAelclcn^r^r\\tZvYxXy\
T|S~Pn SPm SOn TNn ULo0ULo#ULo-WHq!WFs XDt!""[b++ + 21]);) {
                for(; a-- > 64 ;) {
                        putchar (++c == 'Z' ? c = c/9 : 33^b&1);
                }
        }
        return 0;
}"
012-25564,alpine9000/BitOS,tests/gcc.dg/tree-ssa/sra-14.c,56,1,15,1829267.9451405,170009.0,10.759824479880477,1148.0,1139.0,38670.0,12784.0,1577.0,586.0,1323.0,546.0,1500000000,0.001219511963427,1082014363648.0,0.0134522289996411,0.0783612547129474,"/* { dg-do run } */
/* { dg-options ""-O1"" } */

struct S
{
  int i, j;
};

struct Z
{
  struct S d, s;
};

struct S __attribute__ ((noinline, noclone))
get_s (void)
{
  struct S s;
  s.i = 5;
  s.j = 6;

  return s;
}

struct S __attribute__ ((noinline, noclone))
get_d (void)
{
  struct S d;
  d.i = 0;
  d.j = 0;

  return d;
}

int __attribute__ ((noinline, noclone))
get_c (void)
{
  return 1;
}

int __attribute__ ((noinline, noclone))
my_nop (int i)
{
  return i;
}

int __attribute__ ((noinline, noclone))
foo (void)
{
  struct Z z;
  int i, c = get_c ();

  z.d = get_d ();
  z.s = get_s ();

  for (i = 0; i < c; i++)
    {
      z.s.i = my_nop (z.s.i);
      z.s.j = my_nop (z.s.j);
    }

  return z.s.i + z.s.j;
}

int main (int argc, char *argv[])
{
  if (foo () != 11)
    __builtin_abort ();
  return 0;
}

"
341-18690,cyumeng/CPrimerPlus,plist.5.10.c,12,1,10,1719843.24697395,177558.0,9.686091305376271,1335.0,1316.0,40067.0,13889.0,1618.0,640.0,1339.0,595.0,1500000000,0.0011465621646493,1082014363648.0,0.014930332623706,0.077692934984061,"/* incrementing: prefix and postfix */
#include <stdio.h>
int main(void)
{
	int ultra = 0, super = 0;

	while (super < 5)
	{
		super++;
		++ultra;
		printf(""super = %d, ultra = %d \n"", super, ultra);
	}

	return 0;
}
"
234-3021,freudshow/learnc,trimzero.c,17,1,13,2047218.0331125,177473.0,11.535377212308353,1344.0,1325.0,40180.0,13974.0,1631.0,642.0,1349.0,599.0,1500000000,0.001364812022075,1082014363648.0,0.0150389073267482,0.0779443808398271,"#include<stdio.h>
#include<string.h>

int main(void)
{
    char buf[]=""00001234"";
	int i = 0, bufSize = sizeof(buf);
	char* lu8pBuf = buf;
	char tmpBuf[512] = { 0 };
	while (i < bufSize && (*lu8pBuf == '0')) {
		i++;
		lu8pBuf++;
		printf(""lu8char: %c\n"", *lu8pBuf);
	}
	memcpy(tmpBuf, buf+i, bufSize - i);
	printf(""tmpbuf: %s\n"", tmpBuf);
	memset(buf, 0, bufSize);
	memcpy(buf, tmpBuf, bufSize - i);
	printf(""buf: %s\n"", buf);
}
"
212-16827,TommesDee/cpachecker,test/programs/simple/loop-tests/for2+init.c,10,3,6,1887932.8854381,169083.0,11.165711514463313,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0012586219236254,1082014363648.0,0.0134490161636592,0.0785049652044725,"#include <stdlib.h>

int main(void) {

  for (int counter = 0; counter < 5; counter++) {

    for (int a = 0; a < 5; a++) {
      
      int b;
      for(b=0; b<5; b++) {
      }
      
    }

  }

  return (0);
}
"
335-22216,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.base/structs3.c,31,1,14,1545213.27931425,169087.0,9.097908177447112,1139.0,1129.0,38461.0,12699.0,1569.0,585.0,1318.0,546.0,1500000000,0.0010301421862095,1082014363648.0,0.0134132133162218,0.0785379202501954,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2008-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

struct One
{
  int x;
};

struct Two
{
  struct One one;
  int x, y;
};

struct Two two = { { 1 }, 2, 3 };

typedef struct One tOne;
typedef struct Two tTwo;

tOne *onep = &two.one;
tTwo *twop = &two;

int main()
{
  onep->x = twop->y;
  return 0;
}
"
109-25865,filipegoncalves/codinghighway,CII/ch1/double.c,50,4,23,2178229.27515945,182112.0,11.960930636092074,1305.0,1283.0,41775.0,14339.0,1691.0,638.0,1392.0,595.0,1500000000,0.0014521528501063,1082014363648.0,0.0142110349674925,0.0769148519086146,"#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <ctype.h>

int linenum;

int getword(FILE *, char *, int);
void doubleword(char *name, FILE *fp);

int main(int argc, char *argv[]) {
  int i;

  for (i = 1; i < argc; i++) {
    FILE *fp = fopen(argv[i], ""r"");
    if (fp == NULL) {
      fprintf(stderr, ""%s: can't open '%s' (%s)\n"",
	      argv[0], argv[i], strerror(errno));
      return EXIT_FAILURE;
    } else {
      doubleword(argv[i], fp);
      fclose(fp);
    }
  }
  if (argc == 1) doubleword(NULL, stdin);
  return EXIT_SUCCESS;
}

int getword(FILE *fp, char *buf, int size) {
  int c;

  c = getc(fp);
  for ( ; c != EOF && isspace(c); c = getc(fp))
    if (c == '\n')
      linenum++;
  {
    int i = 0;
    for ( ; c != EOF && !isspace(c); c = getc(fp))
      if (i < size - 1)
	buf[i++] = tolower(c);
    if (i < size)
      buf[i] = '\0';
  }
  if (c != EOF)
    ungetc(c, fp);
  return buf[0] != '\0';
}

void doubleword(char *name, FILE *fp) {
  char prev[128], word[128];

  linenum = 1;
  prev[0] = '\0';
  while (getword(fp, word, sizeof word)) {
    if (isalpha(word[0]) && strcmp(prev, word) == 0) {
      if (name)
	printf(""%s:"", name);
      printf(""%d: %s\n"", linenum, word);
    }
    strcpy(prev, word);
  }
}
"
059-30500,christiankaiser/spatial-tools,src/r.pixels.stats/main.c,31,4,11,2571649.26733815,172501.0,14.908023721601614,1292.0,1274.0,39030.0,13222.0,1606.0,634.0,1333.0,592.0,1500000000,0.0017144328448921,1082014363648.0,0.014875276085356,0.0797098675648779,"/*
 
 r.pixels.stats
 Computes pixel-by-pixel statistics for several raster files.
 The statistics can be: sum, average, minimum, maximum, variance.
 Computes statistics for different clusters. The clusters are defined in a
 raster file where the value corresponds to the cluster ID. The statistics
 are computed for the statistic raster file according to the spatial clusters
 defined in the cluster raster file. The statistics include the sum, number of
 cells, average, minimum and maximum.
 
 Version:	1.0
 Date:		24.11.2009
 Author:	Christian Kaiser, christian.kaiser@unil.ch
 
 Copyright (C) 2009 Christian Kaiser.
 
 r.clusters.stats is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
 r.clusters.stats is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with r.clusters.stats; see the file COPYING.  If not, write to the Free
 Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 02110-1301, USA.
 
 */



#include <stdio.h>

int main (int argc, const char * argv[]) {
    // insert code here...
    printf(""Hello, World!\n"");
    return 0;
}
"
225-18582,acgtyrant/UULP,6/sigdemo1.c,14,1,10,7503292740.206234,174871.0,42907.58753595508,1314.0,1297.0,39712.0,13584.0,1622.0,634.0,1342.0,592.0,1500000000,5.002195160137489,1082014363648.0,0.0149310062846326,0.0786175322725908,"//  sigdemo1.c - show how a signal handler works.
//  - run this and press Ctrl-C a few times

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

extern void f(int);

int main(int argc, char *argv[]) {
  signal(SIGINT, f);
  for (int i = 0; i < 5; ++i) {
    printf(""blah blah blah\n"");
    sleep(1);
  }
  return EXIT_SUCCESS;
}

extern void f(int signum) {
  printf(""Shut up.\n"");
}
"
378-3907,IAmRasputin/euler,4/c/palindrome.c,32,3,13,40842803.7771954,329181857.0,0.1240736757858438,1369.0,1348.0,57954173.0,49742535.0,1636.0,641.0,1353.0,594.0,1500000000,0.0272285358514636,1082014363648.0,8.253796320251027e-06,3.922125456239572e-05,"#include <stdio.h>
#include <string.h>

int isPalindrome(int num)
{
	int len = 0;
	int isPalindrome = 1;
	int i;

	char out[512];
	sprintf( out, ""%d"", num ); // Write the integer to a characrer array
	
	len = strlen( out );

	for( i = 0; i < len; i++ ){
		if( out[i] != out[len - (i + 1)] ){
			isPalindrome = 0;
			break;
		}
	}

	return isPalindrome;
}

int main()
{
	int num1 = 999, num2, largest = 0, current;

	for( ; num1 >= 100; num1-- ){
		for( num2 = num1; num2 >= 100; num2-- ){
			current = num1 * num2;
			if( isPalindrome( current ) ){
				if( current > largest ){
					largest = current;
				}
			}
		}
	}

	printf( ""%d\n"", largest );
	
	return 0;
}
					
"
116-33238,chaws/personal,weird_c/slash_r.c,7,1,3,862799743.4232384,6959101584.0,0.1239814841880888,1342.0,1322.0,1399852200.0,1009479705.0,1620.0,699.0,1340.0,656.0,1500000000,0.5751998289488256,1082014363648.0,3.828080346067844e-07,1.7909529156382462e-06,"#include <stdio.h>
#include <stdlib.h>

int	main()
{
	int i;
	for(i = 0; i < 10000000; i++)
		printf(""\r%i"", i);
	return 0;
}"
141-16989,qjcg/CO2Aldrin,app/src/fizzbuzz.c,16,1,10,2479022.95086525,214691.0,11.54693023927412,1344.0,1324.0,48471.0,19446.0,1625.0,641.0,1345.0,599.0,1500000000,0.0016526819672435,1082014363648.0,0.0124271627595008,0.0619874258285848,"/* FizzBuzz in C. */
#include <stdio.h>

int main() {
	int i;
	for (i=1; i<=100; i++) {
		if (i % 15 == 0) {
			printf(""fizzbuzz\n"");
		} else if (i % 3 == 0) {
			printf(""fizz\n"");
		} else if (i % 5 == 0) {
			printf(""buzz\n"");
		} else {
			printf(""%d\n"", i);
		}
	}
	return 0;
}
"
266-10383,Calebe94/Programacao_em_C,Testes/argv.c,4,1,5,1854482.80535625,173406.0,10.694451172393112,1351.0,1330.0,39235.0,13341.0,1618.0,637.0,1340.0,594.0,1500000000,0.0012363218702375,1082014363648.0,0.0154608260383147,0.0796751369446135,"#include<stdio.h>
int main(int argc, char *argv[]){
	for(register unsigned int cont = 0 ; cont < argc ; cont ++)
		printf(""Parâmetro %d: %s\n"",cont,argv[cont]);
}
"
311-2182,ThiagoSSantos/LP1-Jogo-da-Forca,vetor2.c,12,1,10,2128176.04187865,181422.0,11.7305288223038,1354.0,1333.0,41065.0,14521.0,1631.0,635.0,1351.0,593.0,1500000000,0.0014187840279191,1082014363648.0,0.0148107726736558,0.075738495304573,"#include<stdio.h>
int main()
{
	int i;
	int v[10]={1,2,3};	

	printf(""%d\n"",i); //i=?
	
	v[5]=42;
	
	for(i=0;i<10;i++)
		printf(""%d-"", v[i]);

	printf(""\n"");
		printf(""%d\n"", i); //i=10

	return 0;
}
"
277-7374,kmongo/practice,qsort.c,44,4,23,1847629.5517756501,243274.0,7.5948477848023215,1382.0,1353.0,55096.0,23172.0,1645.0,644.0,1364.0,601.0,1500000000,0.0012317530345171,1082014363648.0,0.0112424673413517,0.0543517146215567,"#include <stdio.h> 
#include <stdlib.h> 
#include <time.h> 
#define MAX 10
#define SWAP(x,y) {int t; t = x; x = y; y = t;} 

int partition(int[], int, int); 
void quickSort(int[], int, int); 

int main(void) { 
	srand(time(NULL));

	int number[MAX] = {0};
	printf(""排序前：""); 
	int i;
	for(i = 0; i < MAX; i++) { 
		number[i] = rand() % 100; 
		printf(""%d "", number[i]); 
	} 

	printf(""\n"");
	quickSort(number, 0, MAX-1); 

	printf(""\n排序後：""); 
	for(i = 0; i < MAX; i++) 
		printf(""%d "", number[i]); 
					    
	printf(""\n""); 

	return 0; 
} 

int partition(int number[], int left, int right) { 
	int i = left - 1; 
	int j;
	for(j = left; j < right; j++) { 
		if(number[j] <= number[right]) { 
			i++; 
			SWAP(number[i], number[j]); 
		} 
	} 
	printf(""i = %d\n"",i);
	SWAP(number[i+1], number[right]); 
	printf(""i = %d\n"",i);
	return i+1; 
} 

void quickSort(int *number, int left, int right) { 
	int i;
	if(left < right) { 
		int q = partition(number, left, right); 
	for(i = 0; i < MAX; i++) 
		printf(""%d "", number[i]); 
	printf(""\n"");
		quickSort(number, left, q-1); 
		quickSort(number, q+1, right); 
	} 
} 
"
102-30827,benquike/cheatsheets,algo/leetcode/singleNumber/singleNum137.c,18,2,9,2121079.36386015,175367.0,12.095086304720956,1339.0,1321.0,39577.0,13411.0,1626.0,638.0,1344.0,594.0,1500000000,0.0014140529092401,1082014363648.0,0.0151681901383954,0.0793009738053899,"#include <stdio.h>

int singleNumber(int* nums, int numsSize) {
    int c[32] = {0};
    int n = 0;
    for (int i = 0; i < 32; i++) {
        for (int j = 0; j < numsSize; j++) {
            if ((nums[j] >> i) & 0x1)
                c[i] ++;
        }
        if (c[i] % 3 != 0)
            n |= 0x1 << i;
    }
    
    return n;
}

int main() {
  int x[4] = {1,1,1,2};
  printf(""%d\n"", singleNumber(x, 4));
  return 0;
}
"
319-7723,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.base/term.c,16,1,10,1656587.81770605,169083.0,9.797478161612936,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0011043918784707,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2012-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int main ()
{
  return 0;
}
"
256-32455,AndrewLaing/CHowToProgramExercises,Chapter5/ex05_20.c,23,2,15,2602982.9168690997,174009.0,14.958892930825415,1271.0,1256.0,39687.0,13505.0,1605.0,634.0,1332.0,592.0,1500000000,0.0017353219445794,1082014363648.0,0.014522237355539,0.0782636486689727,"/*
 * Filename:    ex05_20.c
 * Author:      Andrew Laing
 * Email:       parisianconnections@gmail.com
 * Date:        27/04/2017
 */

#include <stdio.h>


void fillCharacter( int, char );


int main()
{
    fillCharacter(5, '#'); 
    return 0;
}


void fillCharacter(int n, char c)
{
    int i, j;
    
    for(i=0; i<n; i++) {
        for(j=0; j<n; j++) {
            printf(""%c"", c);
        }
        printf(""\n"");
    }
    
    printf(""\n"");
}

"
079-25175,totalspectrum/binutils-propeller,gdb/testsuite/gdb.python/py-mi-objfile.c,17,1,10,1396728.21387645,169061.0,8.261680695133709,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0009311521425843,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2015-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see  <http://www.gnu.org/licenses/>.  */

int
main (void)
{
  return 0;
}
"
132-11851,yubo/program,c/gdb/gdbinit/gdb-sample2.c,52,3,17,22539799159.392715,201234.0,182946.2481141358,1456.0,1425.0,45632.0,17646.0,1656.0,720.0,1361.0,675.0,1500000000,15.026532772928476,1082014363648.0,0.0143166661697327,0.0697240747179114,"#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

void* Thread_function1(void * arg)
{
 unsigned int i=1;
    while(i < 11)
    {
          printf(""Child Thread Iteration %d\n"",i);
         i++;
   if(i%2)
         sleep(2);
   else
         sleep(1);
   }
   return arg;
}
void* Thread_function2(void * arg)
{
 unsigned int i=1;
 while(i < 11)
 {
   printf(""Child Thread 2 Iteration %d\n"",i);
   i++;
   if(i%2)
          sleep(2);
   else
          sleep(1);
 }
 return arg;
}
int main (int argc, char *argv[])
{
   pthread_t thread;
   pthread_t thread2;
   if(pthread_create(&thread,NULL,Thread_function1,NULL))
   {
   return(1);
   }
   if(pthread_create(&thread2,NULL,Thread_function2,NULL))
   {
   return(1);
   }
   unsigned int i = 1;
   while(i < 11)
   {
     printf(""Main Loop Iteration %d\n"",i);
     i++;
     if(i%2)
         sleep(1);
     else
         sleep(2);
   }
   return 0;
}
"
321-33336,acarno/slicer,valgrind/none/tests/bug129866.c,29,2,17,3492245.91627705,3777115.0,0.924580003521206,1331.0,1310.0,39832.0,3615221.0,1708.0,56931.0,1344.0,53744.0,1500000000,0.0023281639441847,1082014363648.0,0.000699210905678,0.0311150070874485,"
#include <stdlib.h>
#include <stdio.h>

char * touch_malloc (int size) 
{
  char * result;
  int i;
  result = malloc (size);
  for (i = 0; i < size; i++)
    *(result + i) = 'a';

  return result;
}
char * touch_realloc (char * ptr, int size) 
{
  char * result;
  int i;
  result = realloc (ptr, size);
  for (i = 0; i < size; i++)
    *(result + i) = 'a';

  return result;
}

int main ( void )
{
  char *a1, *b1, *a2 __attribute__((unused)), *b2 __attribute__((unused));
  printf(""started\n"");
  a1 = touch_malloc(1600000) ;
  b1 = touch_malloc(200000) ;
  a2 = touch_realloc(a1, 1601600) ;
  b2 = touch_realloc(b1, 200000) ;
  printf(""success\n"");
  return 0;
};
"
136-32312,artnavsegda/crossnavsegda,src/getopt.c,19,1,10,1477187.84864985,175202.0,8.429207429138938,1355.0,1334.0,39797.0,13526.0,1686.0,638.0,1347.0,594.0,1500000000,0.0009847918990999,1082014363648.0,0.0153479983105215,0.0799842469478461,"#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>

int main(int argc, char *argv[])
{
  int opt;
  char * config = NULL;
  char * type = NULL;
  while ((opt = getopt(argc, argv, ""c:t:"")) != -1)
  {
    switch (opt)
    {
      case 'c': // config
        config = optarg;
        break;
      case 't': // type
        type = optarg;
        break;
    }
  }

  printf(""config %s, type %s\n"", config, type);

}
"
042-31353,damballa/Threat-research,dga_ramdo.c,44,2,22,3036214.50439095,656567.0,4.624378014734216,1367.0,1343.0,140938.0,101506.0,1641.0,647.0,1355.0,604.0,1500000000,0.0020241430029273,1082014363648.0,0.004127530015977,0.0175174473280427,"#include<stdio.h>
#include<stdlib.h>

int main(int argc, char *argv[])
{
unsigned int i, numdoms, domain_iterator, domain_length, initial_seed;

initial_seed = 0x2b44c;
//initial_seed = 0x7ac7;
domain_length = 0;
domain_iterator = 0x00;
numdoms = 0;

char dom[16];
int dom_byte;

while( numdoms < 30)
	{
	unsigned int xor1 = 0; 
	unsigned int shl = initial_seed << 1;
	domain_iterator += 1;
	unsigned int step1 = domain_iterator * shl;
	unsigned int step1b = domain_iterator * initial_seed;
	domain_iterator -= 1;
	unsigned int iter_seed = domain_iterator * initial_seed;

	unsigned int imul_edx = iter_seed * 0x1a;
	xor1 = step1 ^ imul_edx;
	domain_length = 0;
	
	while(domain_length < 0x10)
		{

		unsigned int xor1_divide = xor1 / 0x1a;
		unsigned int xor1_remainder = xor1 % 0x1a;
		unsigned int xo1_rem_20 = xor1_remainder + 0x20;
		unsigned int xo1_step2 = xo1_rem_20 ^ 0xa1;
				
		dom_byte = 0x41 + (0xa1 ^ xo1_step2);
		
		sprintf(dom, ""%c"", dom_byte);
		printf(""%s"", dom);			
		
		unsigned int imul_iter = domain_length * step1;
		unsigned int imul_result = domain_length * imul_iter;
		unsigned int imul_1a = 0x1a * imul_result;
		unsigned int xor2 = xor1 ^ imul_1a;
		xor1 = xor1 + xor2;
		
		domain_length += 1;

		}
	printf("".org\n"");	
	domain_iterator +=1;
	numdoms +=1;
		
	}

return 0;	
}
"
265-20242,Alex1990/ccell,swap_str_arr.c,51,3,22,2020294.66163355,177874.0,11.358006229128485,1335.0,1314.0,40386.0,13953.0,1640.0,640.0,1355.0,595.0,1500000000,0.0013468631077557,1082014363648.0,0.0148925643995187,0.0778446419698559,"/**
 * Swap two char arrays
 */

#include <stdio.h>
#include <string.h>

void
swap_str_arr(char *str_a, char *str_b);

int
main()
{
  char s1[] = ""foo"";
  char s2[] = ""bar bar bar"";

  printf(""Before swap:\n"");
  printf(""============\n"");
  printf(""s1: %s\n"", s1);
  printf(""s2: %s\n"", s2);

  // swap
  swap_str_arr(s1, s2);

  printf(""\nAfter swap:\n"");
  printf(""============\n"");
  printf(""s1: %s\n"", s1);
  printf(""s2: %s\n"", s2);

  return 0;
}

void
swap_str_arr(char *str_a, char *str_b)
{
  int i;
  char temp;
  int len1 = strlen(str_a);
  int len2 = strlen(str_b);
  int min_len = len1 < len2 ? len1 : len2;
  int max_len = len1 > len2 ? len1 : len2;

  for (i = 0; i < min_len; i++) {
    temp = str_a[i];
    str_a[i] = str_b[i];
    str_b[i] = temp;
  }

  if (min_len == len1) {
    for (i = min_len; i < max_len; i++) {
      str_a[i] = str_b[i];
    }
    str_b[min_len] = '\0';
    str_a[max_len] = '\0';
  }
  else {
    for (i = min_len; i < max_len; i++) {
      str_b[i] = str_a[i];
    }
    str_a[min_len] = '\0';
    str_b[max_len] = '\0';
  }
}
"
387-32795,rbheromax/src_glibc,pwd/tst-getpw.c,29,2,16,6824338837.643154,331567708.0,20.58203700886336,3533337.0,3054.0,65751207.0,52888027.0,292292.0,182385.0,4239.0,1466.0,1500000000,4.549559225095436,1082014363648.0,0.0106656677193666,0.0040490989683901,"/* Copyright (C) 1999-2014 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#include <pwd.h>

static void
check (uid_t uid)
{
  char buf[1024];

  (void) getpw (uid, buf);
}

int
main (void)
{
  uid_t uid;

  /* Just call it a different number of times the range should be
     large enough to find some existing and some non existing uids.  */

  for (uid = 0; uid < 2000; ++uid)
    check (uid);

  return 0;
}
"
329-14322,AndrewLaing/CHowToProgramExercises,Chapter5/ex05_41.c,40,1,23,2337439.33495125,291528.0,8.017888504706237,1362.0,1342.0,63193.0,29019.0,1629.0,687.0,1350.0,645.0,1500000000,0.0015582928899675,1082014363648.0,0.0092752668697346,0.0467509651672233,"/*
 * Filename:    ex05_41.c
 * Author:      Andrew Laing
 * Email:       parisianconnections@gmail.com
 * Date:        06/05/2017
 * Description: Recursive factorial function
 */

#include <stdio.h>
int DEBUG = 1;
int start = 1;

long factorial( long );

int main()
{
    int i;

    for(i=1; i<=10; i++)
    {
        start=1;
        printf(""%2d! = %1d\n\n"", i, factorial( i ));
    }

    return 0;
}

long factorial( long number)
{
    int rcParam;
    static int calls=0;
    
    if(start)
    {
        calls=0;
        printf(""=== First call to function ===\n"");
        start=0;
    }
    
    
    calls++;
    
    if(DEBUG) printf(""Call #%d: Number = %d\n"", calls, number);
        
    if( number <= 1)
        return 1;
    else {
        rcParam = number * factorial(number - 1);
        
        if(DEBUG) printf(""Call #%d: Recursive call parameter = %d\n"", calls, rcParam);
        
        return rcParam;     
    }    
}

"
271-497,peterstace/project-euler,OLD_PY_CODE/project_euler_old_old/73/73.c,21,3,14,536051670.089364,668393749.0,0.8019998254053091,1339.0,1320.0,39183.0,13309.0,1618.0,636.0,1341.0,593.0,1500000000,0.357367780059576,1082014363648.0,3.978193997143441e-06,0.0797835860702583,"#include <stdio.h>

int gcd(int a, int b)
{
	while (b != 0) {
		int tmp = a;
		a = b;
		b = tmp % b;
	}
	return a;
}

int main()
{
	int count = 0;
	for (int d = 2; d <= 12000; d++) {
		for (int n = d / 3 + 1; n < (d % 2 == 0 ? d / 2 : d / 2 + 1); n++) {
			if (gcd(d, n) == 1) {
				count++;
			}
		}
	}
	printf(""%d\n"", count);
}
"
358-21915,krixi/intro-to-c,InClassExamples/Strings/program2.c,49,1,23,2507344.7031900003,184360.0,13.600260360164894,1400.0,1376.0,41826.0,14879.0,1656.0,640.0,1371.0,597.0,1500000000,0.00167156313546,1082014363648.0,0.0150574962030809,0.0751961908120977,"
#include <stdio.h>
#include <string.h>


#define SIZE 10


void demo_strtok(void)
{
    char str[] = ""This is a string"";
    char copy[50]; 
    strcpy(copy, str);
    printf(""str = %s\n"", str);
    
    char * word1 = strtok(copy, "" "");
    char * word2 = strtok(NULL, "" "");
    char * word3 = strtok(NULL, "" "");
    char * word4 = strtok(NULL, "" "");
    char * word5 = strtok(NULL, "" "");


    
    printf(""word1 = %s\n"", word1);
    printf(""word2 = %s\n"", word2);
    printf(""word3 = %s\n"", word3);
    printf(""word4 = %s\n"", word4);   
    printf(""word5 = %s\n"", (word5 != NULL ? word5 : ""NULL"") );
}


void demo_substr(void)
{
    char date[] = ""March 23, 2016"";
    char copy[SIZE];
    
    strncpy(copy, date+6, 2);
    copy[2] = '\0'; // null terminator;

    printf(""date = %s\n"", date);
    printf(""copy = %s\n"", copy);
}


int main(void)
{
    char str2[SIZE];
    char str1[SIZE];
    
    int i;
    for( i = 0; i < SIZE; ++i )
    {
        str1[i] = 'a';
        str2[i] = 'z';
    }
    str2[SIZE-1] = '\0';

    printf(""str1 = %s \n"", str1);
    printf(""str2 = %s \n"", str2);

    int len1 = strlen(str1);
    int len2 = strlen(str2);
    printf(""len1 = %d \n"", len1);
    printf(""len2 = %d \n"", len2);

    printf(""\n\n\n"");
    demo_substr();

    printf(""\n\n\n"");
    demo_strtok();
    return 0;
}


"
281-10971,GunioRobot/macgdb,gdb/testsuite/gdb.base/del.c,17,1,9,1424371.3812901499,169037.0,8.42638593917308,1138.0,1128.0,38451.0,12696.0,1567.0,585.0,1317.0,546.0,1500000000,0.0009495809208601,1082014363648.0,0.0134053491247478,0.0784992277161905,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
main(void)
{
  return 0;
}
"
382-28395,EvtimPavlov/c-programming-2014-2015-homework,A/02_Andrea_Georgieva/homework_4/christmas_tree.c,32,4,13,1856912.8587841499,188433.0,9.85449470103432,1269.0,1254.0,45649.0,16108.0,1604.0,642.0,1331.0,598.0,1500000000,0.0012379419058561,1082014363648.0,0.0133893744726242,0.0676036724581828,"#include <stdio.h>
void christmas_tree(int h)
 {
  int a, b, c;
  int d = 1;
  int ch = 1;
  for(a = 2; a <= h; a++)
   {
    d = d + 2;
   }
  int e = d / 2;
  for(a = 1; a <= h; a++)
   {
      for(b = 1; b <= e; b++)
        {
           printf("" "");
        }
      for(c = 1; c <= ch; c++)
        {
          printf(""*"");
        }
      ch = ch + 2;
      e = e -1;
      printf(""\n"");
   }
 }
int main()
   {
     christmas_tree(4);
     christmas_tree(7);
     christmas_tree(11);
     return 0;
   }
"
174-30304,pietrodn/middleware-exe,pthread/thread_base.c,17,1,11,3059179.5220970996,340063.0,8.995918403354672,2306.0,1770.0,79569.0,35426.0,2393.0,1303.0,1668.0,1144.0,1500000000,0.0020394530147314,1082014363648.0,0.0119860143561634,0.056593764946302,"#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#define NUM_THREADS 5

void * PrintHello(void *threadid) {
    printf(""\n%d: Hello World!\n"", *((int *)threadid));
    free(threadid);
    pthread_exit(NULL);
}

int main(int argc, char* argv[]) {
    pthread_t threads[NUM_THREADS];
    int *ids[NUM_THREADS];
    int i;

    for(i=0; i<NUM_THREADS; i++) {
        ids[i] = malloc(sizeof(int));
        *ids[i] = i;
        printf(""\n%d: Creating thread!"", i);
        pthread_create(&threads[i], NULL, PrintHello, ids[i]);
    }

    pthread_exit(NULL);
}
"
276-27621,joemathai/snippets,C/System_Lab/thread.c,17,1,12,15044661216.088573,297910.0,50500.692209056426,2178.0,1752.0,69568.0,29074.0,2222.0,1039.0,1630.0,948.0,1500000000,10.029774144059049,1082014363648.0,0.0131919035950454,0.0591938525171833,"#include<stdio.h>
#include<unistd.h>
#include<pthread.h>
#define NUM_THREADS 5
void *printhello(void *threadid){ //using a void pointer
	long tid;
	tid = (long) threadid;
	printf(""\nhello wolrd ! from:%ld"",tid);
	sleep(10);
	pthread_exit(NULL);
}
int main(){
int i;
long t;
pthread_t thread[NUM_THREADS];
for(i=0;i<5;i++)
	if( pthread_create(thread+i,NULL,printhello,(void *) (t=i+1)) )
		printf(""error creating thread ; %d"",i+1);
pthread_exit(NULL);
return 0;
}
"
278-28600,totalspectrum/binutils-propeller,gdb/testsuite/gdb.dwarf2/dw2-icycle.c,18,1,14,1410122.84439045,169057.0,8.341103888037763,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0009400818962603,1082014363648.0,0.0134155935572026,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2004-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* Dummy main function.  */

int
main()
{
  return 0;
}
"
112-16275,feilongzheng/infer,infer/tests/codetoanalyze/c/frontend/conditional_operator/if_short_circuit.c,44,1,22,2021402.819082,171791.0,11.766635039088197,1147.0,1138.0,39261.0,12803.0,1635.0,589.0,1323.0,547.0,1500000000,0.001347601879388,1082014363648.0,0.0133010460385002,0.0786339889366933,"/*
* Copyright (c) 2013 - present Facebook, Inc.
* All rights reserved.
*
* This source code is licensed under the BSD style license found in the
* LICENSE file in the root directory of this source tree. An additional grant
* of patent rights can be found in the PATENTS file in the same directory.
*/

#include<stdlib.h>

void shortcircuit_or(int *x) {
    //x = 0;
    if (x == 0 || *x == 2){ x=17;} else {x=32; };
}

void shortcircuit_and(int *x) {
    if (!x && !(x =getenv (""BLOCK""))) {
        x=17;
    }
    else {
        *x=32;
    };
}



void test_loop () {
    
    char* spec;
    char* block_size;
    
    spec= getenv (""BLOCK"");

while((! spec
       && ! (spec = getenv (""BLOCK_SIZE""))
       && ! (spec = getenv (""BLOCKSIZE"")))) {
 block_size =0;

 }
 

}


int main() {
 
    char* spec;
    char* block_size;
    
    spec= getenv (""BLOCK"");
    
    

    if (! spec
       && ! (spec = getenv (""BLOCK_SIZE""))
       && ! (spec = getenv (""BLOCKSIZE"")))
        block_size = 0;
    else
    {
        if (*spec == '\'')
            block_size=0; }
    
    
    return 0;
}
"
144-12936,wuzhouhui/leetcode,92_reverse_linked_list.c,33,2,19,1444591.6749535499,169080.0,8.543831322450911,1142.0,1132.0,38460.0,12696.0,1566.0,584.0,1317.0,544.0,1500000000,0.0009630611166357,1082014363648.0,0.0134492547906316,0.0784072249589491,"struct ListNode {
	int	val;
	struct ListNode *next;
};

#ifndef NULL 
#define NULL ((struct ListNode *)0)
#endif

struct ListNode *reverseBetween(struct ListNode *head, int m, int n)
{
	if (!head || !head->next)
		return(head);

	struct ListNode *ptr, *prev, *revptr, *next, *revtail;
	int	i;

	ptr = head;
	prev = NULL;
	for (i = 1; i < m; i++) {
		prev = ptr;
		ptr = ptr->next;
	}

	revptr = NULL;
	revtail = next = ptr;
	for (i = m; i <= n; i++) {
		ptr = next;
		next = next->next;
		ptr->next = revptr;
		revptr = ptr;
	}

	if (!prev)
		head = revptr;
	else 
		prev->next = revptr;
	revtail->next = next;
	return(head);
}

int main(void)
{}
"
039-17506,totalspectrum/binutils-propeller,gdb/testsuite/gdb.base/argv0-symlink.c,17,1,12,1635888.0093321,169061.0,13.353481879321665,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010905920062214,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2013-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
main (int argc, char **argv)
{
  return 0;
}
"
097-8528,chibby0ne/K_R_Exercises,Chapter07/Exercise7-09.c,21,1,11,1472673.1460540998,169061.0,8.710897250104992,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0009817820973694,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* Functions like isupper can be implemented to save space and to save 
 * time. Explore both possibilities */

#include <stdio.h>

#define COUNT 1000000

int isupperr(char c);

int main(int argc, char *argv[])
{

    int i;
    char c = 'C';
    for (i = 0; i != COUNT; ++i) {
        //printf(""C is %s\n"", (isupperr(c)) ? ""UPPER"" : ""lower"");
        isupperr(c);
    }
    return 0;
}

int isupperr(char c)
{
    if (c >= 'A' && c <= 'Z') {
        return 1;
    } else {
        return 0;
    }
    
}
"
259-16244,swigger/gdb-ios,gdb/testsuite/gdb.base/sepsymtab.c,16,1,14,1842859.55037915,169083.0,10.899138293027685,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0012285730335861,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* Copyright 2006-2016 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
main (int argc, char **argv, char **envp)
{
  return 0;
}
"
311-26435,Gurgel100/gcc,gcc/testsuite/c-c++-common/pr88984.c,17,1,12,1559913.04200135,169083.0,9.225723461258672,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010399420280009,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* PR c++/88984 */
/* { dg-do run } */

void
foo (int x, int y)
{
  while (x > 0)
    switch (({ if (y) break; y; }))
      {
      case 2: x = 0;
      }
}

int
main ()
{
  foo (1, 1);
  return 0;
}
"
338-21843,djsilenceboy/LearnTest,Cpp_Test/RecursiveTest/src/RecursiveTest.c,53,2,17,1529281.37686095,197329.0,7.747426886063376,1365.0,1344.0,44792.0,17062.0,1633.0,643.0,1353.0,598.0,1500000000,0.0010195209179073,1082014363648.0,0.0137283420075103,0.0683383451353186,"/*
 ============================================================================
 Name        : RecursiveTest.c
 Author      : djs
 Version     :
 Copyright   : Your copyright notice
 Description : Hello World in C, Ansi-style
 ============================================================================
 */

#include <stdio.h>
#include <stdlib.h>

void printArray(int data[])
{
	int i;

	for (i = 0; i < 3; i++)
	{
		printf(""%4d"", data[i]);
	}

	printf(""\n"");
}

void comb(int n, int r, int lvl, int data[])
{
	int i;

	for (i = n; i >= r; i--)
	{
		data[lvl] = i;

		if (r == 1)
		{
			printArray(data);
		}
		else
		{
			comb(i - 1, r - 1, lvl + 1, data);
		}
	}
}

int main(void)
{
	int data[3] =
	{ 0 };

	comb(5, 3, 0, data);

	/*
	 5   4   3
	 5   4   2
	 5   4   1
	 5   3   2
	 5   3   1
	 5   2   1
	 4   3   2
	 4   3   1
	 4   2   1
	 3   2   1
	 */

	return EXIT_SUCCESS;
}
"
115-4001,totalspectrum/binutils-propeller,gdb/testsuite/gdb.btrace/enable.c,18,1,10,1525444.21143825,169083.0,8.920642524677229,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010169628076255,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2013-2017 Free Software Foundation, Inc.

   Contributed by Intel Corp. <christian.himpel@intel.com>

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
main (void)
{
  return 0;
}
"
208-10167,jdh8/metallic,test/wasm/crt/argv.c,6,1,6,1678954.57707345,174104.0,9.643397050039058,1338.0,1318.0,39433.0,13429.0,1620.0,636.0,1342.0,594.0,1500000000,0.0011193030513823,1082014363648.0,0.0152552497357901,0.0793008210056373,"#include <assert.h>
#include <stdio.h>

int main(int argc, char** argv)
{
    for (int i = 0; i < argc; ++i)
        printf(""%p: %s\n"", argv[i], argv[i]);

    assert(!argv[argc]);
}
"
251-25291,ayaovi/yoda,xor.c,40,1,20,1934629.5157446,176934.0,10.93418449817446,1298.0,1279.0,40372.0,13784.0,1644.0,635.0,1369.0,592.0,1500000000,0.0012897530104964,1082014363648.0,0.0145647529587303,0.0782923406455425,"#include <time.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

long size(FILE* fp){
	fseek(fp, 0L, SEEK_END);
	long sz = ftell(fp);
	fseek(fp, 0L, SEEK_SET);
	return sz;
}

long min(long a,long b){
	return a<b?a:b;
}

void apply(char* cyphername,char* filename){
	FILE* cypher=fopen(cyphername,""rb"");
	if(!cypher)printf(""CANT OPEN %s\n"",cyphername);
	FILE* file=fopen(filename,""rb"");
	if(!file)printf(""CANT OPEN %s\n"",filename);
	long i=0;
	size_t num_bytes=min(size(file),size(cypher));
	for (; i < num_bytes; i++)
	{
		int f= fgetc(file);
		int c= fgetc(cypher);
		printf(""%c"",f^c);
	}
}

void usage(){
	printf(""USAGE:\n xor file0 file1\n"");
}

int eq(char* a,char* b){
	return	strstr(a,b)!=0;
}

//srand ((unsigned int) time (NULL));
int main(int cc,char** cv){
	cc--;
	if(cc==2){
		char* c=cv[1];
		char* f=cv[2];
		apply(c,f);
	}else{
		usage();
	}
}
"
189-22730,Tarek-Adra/nsy103,MPS/prog_linux/12/exemple_mutex.c,35,2,13,9003886816.673912,296109.0,30407.339243319184,2314.0,1768.0,70514.0,29873.0,2418.0,1232.0,1634.0,1059.0,1500000000,6.002591211115941,1082014363648.0,0.0137854641365172,0.0631854722224989,"	#include <stdio.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <pthread.h>



	static void *	routine_threads (void * argument);
	static	int	aleatoire	(int maximum);

	pthread_mutex_t	mutex_stdout = PTHREAD_MUTEX_INITIALIZER;

	int
main (void)
{
	int		i;
	pthread_t	thread;
	
	for (i = 0; i < 10; i ++)
		pthread_create (& thread, NULL, routine_threads, (void *) i);
	pthread_exit (NULL);
}

	static void *
routine_threads (void * argument)
{
	int numero = (int) argument;
	int nombre_iterations;
	int i;
	nombre_iterations = aleatoire (6);
	for (i = 0; i < nombre_iterations; i ++) {
		sleep (aleatoire (3));
		pthread_mutex_lock (& mutex_stdout);
		fprintf (stdout, ""Le thread numéro %d tient le mutex\n"", numero);
		pthread_mutex_unlock (& mutex_stdout);
	}
	return (NULL);
}

	static int
aleatoire (int maximum)
{
	double d;
	d = (double) maximum * rand ();
	d = d / (RAND_MAX + 1.0);
	return ((int) d);
}	
"
044-19321,arante/cloc,abw-things/sum.c,23,1,17,1878858.07827105,182575.0,10.290883198685473,1334.0,1316.0,39174.0,13308.0,1617.0,636.0,1340.0,593.0,1500000000,0.0012525720521807,1082014363648.0,0.0145145830480624,0.0797606798521397,"/* sum.c
 * A function that returns the sum of numbers between 0 to 1000 that is
 * divisible by 3 or 5.
 *
 * Created by Billy Wilson Arante <arantebillywilson@gmail.com>
 * Last updated on 2017/06/08 PHT
 */
#include <stdio.h>

int sum_zero_to_onethousand();

int main(void)
{
	printf(""%d\n"", sum_zero_to_onethousand());

	return 0;
}

int sum_zero_to_onethousand()
{
	int total = 0;
	for (int count = 0; count <= 1000; count++) {
		if ((count % 3 == 0) || (count % 5 == 0)) {
			total += count;
		}
	}

	return total;
}
"
012-7113,cartman300/picoc,tests/csmith/rand18.c,86,3,14,2007723.2038601998,174109.0,11.531414229017454,1349.0,1330.0,39383.0,13446.0,1619.0,637.0,1342.0,594.0,1500000000,0.0013384821359068,1082014363648.0,0.0153869127960071,0.0793503568115996,"#include <stdio.h>
int print_hash_value = 1;
static void platform_main_begin(void)
{
}
static unsigned crc32_tab[256];
static unsigned crc32_context = 0xFFFFFFFFUL;
static void
crc32_gentab (void)
{
 unsigned crc;
 unsigned poly = 0xEDB88320UL;
 int i, j;
 for (i = 0; i < 256; i++) {
  crc = i;
  for (j = 8; j > 0; j--) {
   if (crc & 1) {
    crc = (crc >> 1) ^ poly;
   } else {
    crc >>= 1;
   }
  }
  crc32_tab[i] = crc;
 }
}
static void
crc32_byte (unsigned char b) {
 crc32_context =
  ((crc32_context >> 8) & 0x00FFFFFF) ^
  crc32_tab[(crc32_context ^ b) & 0xFF];
}
extern int strcmp ( char *, char *);
static void
crc32_8bytes (unsigned val)
{
 crc32_byte ((val>>0) & 0xff);
 crc32_byte ((val>>8) & 0xff);
 crc32_byte ((val>>16) & 0xff);
 crc32_byte ((val>>24) & 0xff);
}
static void
transparent_crc (unsigned val, char* vname, int flag)
{
 crc32_8bytes(val);
 if (flag) {
    printf(""...checksum after hashing %s : %X\n"", vname, crc32_context ^ 0xFFFFFFFFU);
 }
}
static void
platform_main_end (int x, int flag)
{
  if (!flag) printf (""checksum = %x\n"", x);
}
static long __undefined;
void csmith_compute_hash(void);
void step_hash(int stmt_id);
static short func_1(void);
static short func_1(void)
{
    short l_2 = 0xFD41L;
    step_hash(1);
    return l_2;
}
void csmith_compute_hash(void)
{
}
void step_hash(int stmt_id)
{
    int i = 0;
    csmith_compute_hash();
    printf(""before stmt(%d): checksum = %X\n"", stmt_id, crc32_context ^ 0xFFFFFFFFUL);
    crc32_context = 0xFFFFFFFFUL;
    for (i = 0; i < 256; i++) {
        crc32_tab[i] = 0;
    }
    crc32_gentab();
}
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    csmith_compute_hash();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}
"
059-8609,totalspectrum/binutils-propeller,gdb/testsuite/gdb.dwarf2/data-loc.c,36,1,16,1482617.9249211,169113.0,8.76701968506265,1139.0,1129.0,38466.0,12702.0,1571.0,586.0,1319.0,547.0,1500000000,0.0009884119499474,1082014363648.0,0.0134111511238047,0.0786233583489681,"/* Copyright 2014-2017 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* This C file provides some global variables laid out in a way
   that mimicks what the GNAT Ada compiler calls ""fat pointers"".
   These fat pointers are the memory representation used by
   the compiler to handle dynamic arrays.

   Debugging information on how to decode that data into an array
   will be generated separately by the testcase using that file.  */

struct fat_pointer
{
  int *data;
  int *bounds;
};

int table_1_data[] = {1, 2, 3};
int table_1_bounds[] = {1, 3};
struct fat_pointer table_1 = {table_1_data, table_1_bounds};

int table_2_data[] = {5, 8, 13, 21, 34};
int table_2_bounds[] = {2, 6};
struct fat_pointer table_2 = {table_2_data, table_2_bounds};

int
main (void)
{
  table_1.bounds[1] = 2;
  table_2.bounds[1] = 3;
  return 0;
}
"
380-33023,totalspectrum/binutils-propeller,gdb/testsuite/gdb.python/py-progspace.c,17,1,10,1515603.1586229,169061.0,8.964829262810465,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010104021057486,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2010-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
main ()
{
  return 0;
}
"
238-1117,begeekmyfriend/leetcode,0114_flatten_binary_tree_to_linked_list/flatten.c,67,1,20,1773259.71890235,180518.0,9.823169988588395,1355.0,1336.0,40892.0,14403.0,1631.0,640.0,1351.0,596.0,1500000000,0.0011821731459349,1082014363648.0,0.0149071006769408,0.0762817614612532,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
};

static struct TreeNode *partition(struct TreeNode *node)
{
    if (node == NULL) {
        return NULL;
    }

    if (node->right == NULL && node->left == NULL) {
        return node;
    }

    struct TreeNode *right_last = partition(node->right);
    struct TreeNode *left_last = partition(node->left);

    if (left_last != NULL) {
        left_last->right = node->right;
        node->right = node->left;
        node->left = NULL;
    }

    return right_last != NULL ? right_last : left_last;
}

static void flatten(struct TreeNode *root)
{
    partition(root);
}

int main(void)
{
    struct TreeNode root, n1[2], n2[4], n3[8];
    root.val = 5;
    n1[0].val = 4;
    n1[1].val = 8;
    n2[0].val = 11;
    n2[2].val = 13;
    n2[3].val = 4;
    n3[0].val = 7;
    n3[1].val = 2;
    n3[6].val = 5;
    n3[7].val = 1;

    root.left = &n1[0];
    root.right = &n1[1];
    n1[0].left = &n2[0];
    n1[0].right = NULL;
    n1[1].left = &n2[2];
    n1[1].right = &n2[3];
    n2[0].left = &n3[0];
    n2[0].right = &n3[1];
    n2[2].left = NULL;
    n2[2].right = NULL;
    n2[3].left = &n3[6];
    n2[3].right = &n3[7];
    n3[0].left = NULL;
    n3[0].right = NULL;
    n3[1].left = NULL;
    n3[1].right = NULL;
    n3[6].left = NULL;
    n3[6].right = NULL;
    n3[7].left = NULL;
    n3[7].right = NULL;

    flatten(&root);

    struct TreeNode *p;
    for (p = &root; p != NULL; p = p->right) {
        printf(""%d "", p->val);
    }
    printf(""\n"");
    return 0;
}
"
066-2531,Akagi201/akcode,c/ctest/test_rand/student2.c,33,3,18,2006942.9883732,187306.0,10.714776889154646,1378.0,1354.0,42777.0,14580.0,1640.0,640.0,1359.0,597.0,1500000000,0.0013379619922488,1082014363648.0,0.0145857580643439,0.0738532350018306,"#include <stdio.h>
#include <stdlib.h>
#include <time.h>

struct student
{
    char name[10];
    int num;
}
stu[5] = {""A"", 0, ""B"", 0, ""C"", 0, ""D"", 0, ""E"", 0};

int main()
{
    int a[5];
    int i;
    int index;
    int x = 0;
    for (i = 0; i < 5; ++i)
    {
        a[i] = i + 1;  /* 存放座位号 */
    }
    srand(time(0));
    for (i = 0; i < 5;)
    {
        index = rand()%5; /* 随机抽取座位号 */
        if (a[index] != 0)
        {
            stu[i].num = a[index];
            a[index] = 0;
            ++i;
        }
    }
    for (i = 0; i < 5; ++i)
    {
        printf(""\n%s:%d\n"", stu[i].name, stu[i].num);
    }
    return 0;
}
"
001-9607,aarestad/advent-of-code-2015,2015/25.c,19,1,10,132524856.24980175,339318754.0,0.3905615426137042,1343.0,1324.0,39325.0,13391.0,1620.0,636.0,1343.0,593.0,1500000000,0.0883499041665345,1082014363648.0,7.859866183523708e-06,0.079520449199484,"#include <stdio.h>
#include <inttypes.h>

static uint64_t next_code(uint64_t prev_code) {
	return (prev_code * 252533LL) % 33554393LL;
}

int main() {
	uint64_t first_code = 20151125LL;
	int row = 1;
	int col = 1;

	while (row != 2947 || col != 3029) {
		first_code = next_code(first_code);

		if (row == 1) {
			row = col + 1;
			col = 1;
		}	else {
			row--;
			col++;
		}
	}

	printf(""%d %d %llu\n"", row, col, first_code);
}
"
154-32987,ktereyp/Algorithms,Bubble_Sort/bubble_sort_v3.c,26,4,17,556510888.5057269,7622134450.0,0.0730124732974239,1367.0,1342.0,1094909425.0,1088979727.0,61313629.0,4816.0,1415.0,4610.0,1500000000,0.371007259003818,1082014363648.0,3.55412255946233e-07,0.0280803949888387,"#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv)
{
    int big_array[65535];

    int i;
    for(i = 0; i < 65535; i++)
        big_array[i] = 2 * rand();

    i = 0;
    while(++i < 65535)
    {
        int j = i - 1;
        int at_i = big_array[i];
        while(j > -1 && big_array[j] > at_i)
        {
            big_array[j + 1] = big_array[j];
            j--;
        }
        big_array[j + 1] = at_i;


    }

    i = 0;
    for(i = 0; i < 65535; i++)
    {
        printf(""%d : "", i);
        printf(""%d\n"", big_array[i]);
    } 

    return 0;
}
"
276-5409,ICS-53-Labs/Lab-2,test1.c,15,1,10,1518154147.5467384,174498.0,8700.12347992527,1354.0,1331.0,39572.0,13481.0,1625.0,635.0,1346.0,592.0,1500000000,1.012102765031159,1082014363648.0,0.0153869958394938,0.0791284187510602,"/* Test 1 executable object */
//Print statements from 1 to arg
#include <stdio.h>

int main (int argc, char* argv[]) {
	int num = 0;
	if (argc >= 2) {
		num = atoi (argv[1]);
	}
	int i = 0;
	while(i <= num) {
		printf (""Printing at %d\n"",i);
		sleep (1);
		++i;
	}
	return 0;
}"
146-18307,mattstock/binutils-bexkat1,gdb/testsuite/gdb.dwarf2/fission-base.c,22,1,12,1485946.58821815,169061.0,8.789407373669858,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0009906310588121,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2012-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
func (int arg)
{
  return arg + 1;
}

int
main ()
{
  return func (-1);
}
"
368-748,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.python/py-arch.c,17,1,10,1435430.95327905,169083.0,8.321457509034024,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0009569539688527,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2013-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see  <http://www.gnu.org/licenses/>.  */

int
main (void)
{
  return 0;
}
"
098-6862,davidlt/glibc-slc6,stdlib/tst-xpg-basename.c,54,2,24,2112768.0083736,173994.0,12.142763543570467,1166.0,1157.0,39760.0,13202.0,1613.0,593.0,1355.0,550.0,1500000000,0.0014085120055824,1082014363648.0,0.0133510350931641,0.0776216910237528,"/* Copyright (C) 1999, 2000, 2002 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Andreas Jaeger <aj@suse.de>, 1999.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#include <libgen.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static struct
{
  const char *path;
  const char *file;
} tests [] =
{
  { ""/dir/file"", ""file"" },
  { ""file"", ""file""},
  { ""/dir/file///"", ""file"" },
  { ""../file"", ""file"" },
  { ""/"", ""/"" },
  { NULL, "".""},
  { """", "".""}
};


int
main (void)
{
  size_t i = 0;
  int errors = 0;
  char path[1024];
  char *file;

  for (i = 0; i < sizeof (tests) / sizeof (tests [0]); ++i)
    {
      if (tests [i].path == NULL)
	file = __xpg_basename (NULL);
      else
	{
	  strcpy (path, tests [i].path);
	  file = __xpg_basename (path);
	}
      if (strcmp (file, tests [i].file))
	{
	  printf (""Test with `%s' failed: Result is: `%s'.\n"",
		  (tests [i].path == NULL ? ""NULL"" : tests [i].path), file);
	  errors = 1;
	}
    }

  return errors;
}
"
246-8407,rswinkle/C_Interpreter,tests/break_continue.c,39,4,13,1963247.7778941,216655.0,9.06162793381182,1342.0,1321.0,48427.0,19872.0,1618.0,641.0,1339.0,596.0,1500000000,0.0013088318519294,1082014363648.0,0.0122914310770579,0.0614064627593376,"#include <stdio.h>


int main()
{
	int i = 0;
	while (i < 20) {
		i += 1;
		if (i % 2)
			continue;
		if (i == 16)
			break;
		printf(""%d\n"", i);
	}

	i = 0;
	while (i < 20) {
		i += 1;
		if (i % 2)
			continue;
		if (i == 16)
			break;
		printf(""%d\n"", i);
		
		int j = 20;
		while (j) {
			j -= 1;
			if (j % 2)
				continue;
			if (j == 4)
				break;
			printf(""%d\n"", j);
		}
	}

	for (int i=0, j=10; ; i+=1) {
		if (i % 2)
			continue;
		printf(""%d\n"", i);
		if (i == j)
			break;
	}
	
	printf(""%d\n"", i);


	return 0;
}
"
095-32532,OpenInkpot-archive/iplinux-gdb,gdb/testsuite/gdb.base/structs3.c,31,1,13,1577013.17220915,169087.0,9.32663658353392,1139.0,1129.0,38461.0,12699.0,1569.0,585.0,1318.0,546.0,1500000000,0.0010513421148061,1082014363648.0,0.0134132133162218,0.0785379202501954,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2008, 2009 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

struct One
{
  int x;
};

struct Two
{
  struct One one;
  int x, y;
};

struct Two two = { { 1 }, 2, 3 };

typedef struct One tOne;
typedef struct Two tTwo;

tOne *onep = &two.one;
tTwo *twop = &two;

int main()
{
  onep->x = twop->y;
  return 0;
}
"
145-3992,antoyo/c--,tests/test9.c,21,8,8,2585749.7239485,176016.0,14.69042018907372,1300.0,1282.0,40022.0,13730.0,1607.0,637.0,1333.0,595.0,1500000000,0.001723833149299,1082014363648.0,0.014669120989001,0.0776157166244976,"#include <stdio.h>

int main() {
    int i = 0;
    while(i < 5) {
        puts(""while"");
        i++;
    }
    i = 0;
    do {
        puts(""do while"");
        i++;
    } while(i < 10);
    i = 0;
    while(i < 5) {
        puts(""while"");
        i++;
    }
    for(int j = 0 ; j < 3 ; j++) {
        puts(""for"");
    }
    return 0;
}
"
121-16100,LiuZhenPei/demos,others/process-and-thread/pthread_return_values.c,19,1,12,2587174.6474876497,179278.0,14.431073528263369,1492.0,1460.0,40805.0,14175.0,1660.0,659.0,1364.0,616.0,1500000000,0.0017247830983251,1082014363648.0,0.016466047144658,0.0781920698435794,"#include <stdio.h>
#include <pthread.h>

void *compute_factorial(void *arg) {
    int n = *((int*)arg);
    int i = 1;
    int factorial = 1;

    for (i = 1; i <= n; i++) {
        factorial *= i;
    }

    return (void*)factorial;
}

int main () {
    pthread_t thread;
    int number = 10;
    int factorial = 0;

    pthread_create(&thread, NULL, &compute_factorial, &number);
    printf(""Computing factorial of %d.\n"", number);

    pthread_join(thread, (void*)&factorial);
    printf(""The factorial of %d is %d.\n"", number, factorial);

    return  0;
}
"
093-30858,MeteoSwiss-APN/omni-compiler,tests/openacc/loop/loop_longlong_var.c,22,2,15,9482911.555096501,9609563.0,0.986820212323911,1235.0,1219.0,1087655.0,1061792.0,132715.0,131717.0,1327.0,131665.0,1500000000,0.006321941036731,1082014363648.0,0.0002553706136272,0.184895929045936,"#include<stdio.h>
#include<stdlib.h>

int main()
{
  const long long start = (long long)1024*1024*1024*6;
  const long long length = (long long)1024*1024;
  long long i;
  long long *a;
  long long *alloc;

  alloc = (long long *)malloc(sizeof(long long)*length);
  a = alloc - start;

#pragma acc data create(a[start:length])
  {
#pragma acc parallel loop
	for(i=start;i<start+length; i++){
	  a[i] = i;
	}
  
#pragma acc update host(a[start:length])
  }

  for(i=start; i<start+length; i++){
    if(a[i] != i){
      return 1;
    }
  }

  free(alloc);

  return 0;
}
"
218-24759,ataniazov/KOU,poligon/prime.c,29,2,13,1562643.0977134502,462166.0,3.3811292912070554,1341.0,1322.0,49457.0,20657.0,1618.0,651.0,1340.0,608.0,1500000000,0.0010417620651423,1082014363648.0,0.0057619989354474,0.0601449068659611,"#include <stdio.h>
#include <math.h>

int is_prime(int number);

int main()
{
	int start = 499;
	int needed = 75;

	int counter = 0;

	int result = 1;

	int i;

	for(i = start; counter <= needed; i++){
		result = is_prime(i);

		if(result == 0){
			printf(""%d is prime\n"", i);
			counter++;
		} else {
			//printf(""%d: %d\n"", i, result);
		}
	}

	return 0;
}

int is_prime(int number) {

	int middle = number/2;	
	int i;

	for(i = 2; i <= middle; i++){
		if((number % i) == 0) {
			return i;
		}
	}

	return 0;
}
"
363-26435,javimv36/SO,ejercicios/e2-hilos/hilos_exit.c,40,2,26,1503400025.7728622,266517.0,5639.487027093956,2269.0,1736.0,63020.0,25088.0,2176.0,816.0,1630.0,737.0,1500000000,1.0022666838485748,1082014363648.0,0.0150271840070239,0.0608230807645162,"#include<stdio.h>
#include<string.h>
#include<pthread.h>
#include<stdlib.h>
#include<unistd.h>

void *trabajo(void *arg);
int variable_global = 0;

pthread_t tid[2]; //tid es el identificador de hilo (threadID)

int main(void)
{
    int i = 0;
    int err;

    while(i < 2)  //Queremos crear 2 hilos
    {
        err = pthread_create(&(tid[i]), NULL, trabajo, NULL);
        if (err != 0)
            printf(""\nError al crear el hilo :[%d]"", strerror(err));
        else
            printf(""\n Hilo creado!\n"");

        i++;
    }

    //sleep(5);
    printf(""El valor FINAL es: %d\n"", variable_global);

    pthread_exit(NULL);
    
}

void *trabajo(void *arg)
{
    int i = 0;
    /* i es un avariable local*/

    pthread_t id = pthread_self();

    for(i=0; i<10; i++)
    {
    	variable_global++;
    
     	if(pthread_equal(id,tid[0]))
     	{
        	printf(""\n El valor de variable global para el primer hilo es: %d\n"",variable_global);
     	}
    	else
    	{
        	printf(""\n El valor de variable global para el segundo hilo es: %d\n"",variable_global);
    	}
    }
    sleep(1);

    //return NULL;
}
"
122-19861,mattstock/binutils-bexkat1,gdb/testsuite/gdb.perf/skip-prologue.c,36,1,17,1655627.7405469501,169061.0,9.793074689017574,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0011037518270313,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright (C) 2013-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* GDB will analyze the prologue of functions f1 and f2.  */

struct foo
{
  int a[32];
};

static int
f1 (void)
{
  return 0;
}

static double
f2 (int a, long long b, double c, struct foo f)
{
  f.a[0] = a + (int) b + c;

  return c + 0.2;
}

int
main (void)
{
  struct foo f;

  f1 ();
  f2 (0, 0, 0.1, f);

  return 0;
}
"
132-19319,CajetanP/coding-exercises,CodeWars/Fundamentals/HowMuch/HowMuch.c,37,1,21,1862642.93733975,209013.0,8.91160836885744,1396.0,1375.0,44904.0,16919.0,1653.0,647.0,1371.0,604.0,1500000000,0.0012417619582265,1082014363648.0,0.0132575485735337,0.0691490222085631,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <assert.h>

void swap (int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

char* howMuch (int m, int n) {
    if (m > n)    swap (&m, &n);
    char* results = malloc (sizeof(char)*1000);
    strcat (results, ""["");

    double c = 0.0, b = 0.0;

    int i;
    for (i = m ; i <= n ; ++i) {
        c = (i-1)/9.0;
        b = (i-2)/7.0;
        if (c < 0 || b < 0)    continue;
        double intpart;
        if (modf (c, &intpart) == 0 && modf (b, &intpart) == 0) {
            char* temp = malloc (sizeof(char)*35);
            sprintf (temp, ""[M: %d B: %d C: %d]"", i, (int)b, (int)c);
            strcat (results, temp);
            strcpy (temp, """");
        }
    }
    strcat (results, ""]"");

    return results;
}

void tests () {
    printf (""%s\n"", howMuch (1,100));
    assert(strcmp(howMuch (1,100),""[[M: 37 B: 5 C: 4][M: 100 B: 14 C: 11]]"") == 0);
    assert (strcmp (howMuch (2950, 2950), ""[]"") == 0);
    assert (strcmp(howMuch (20000, 20100),
                   ""[[M: 20008 B: 2858 C: 2223][M: 20071 B: 2867 C: 2230]]"") == 0);
}

int main () {
    tests ();

    return 0;
}
"
215-23935,rajmani1995/CN-CS352,mid/code/echo.c,16,1,16,7502871095.901355,170975.0,43882.85477408978,1155.0,1143.0,38975.0,12950.0,1580.0,585.0,1327.0,546.0,1500000000,5.001914063934237,1082014363648.0,0.0134405614855973,0.0777660086663456,"/*
 * Helper Echo Service
 * 
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BUFSIZE 1024

/**
 * Author: Rajmani Arya
 * Date: 8th March 2016
 */

int main(int argc, char * argv[]) {
	int i;
	for(i=0; i<5; i++){
		write(0, ""echo_hello"", 10);
		sleep(1);
	}
	return 0;
}
"
305-16651,ice1000/OI-codes,other/gdfzoj/data.c,12,1,9,6318220.28662995,8103984.0,0.7796436913004764,1423.0,1394.0,1647719.0,1119498.0,1661.0,766.0,1362.0,722.0,1500000000,0.0042121468577533,1082014363648.0,0.0003476068067261,0.0016301576638189,"#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>
#define n 10001

int main(int argc, const char *argv[]) {
  int i, j;
  freopen(""in"", ""w"", stdout);
  srand(time(0));
  printf(""%i\n"", n);
  for (i = 0; i < n; ++i) printf(""%i "", abs(rand()));
  return 0;
}
/*
4
3 2 3 2
*/
"
139-22467,garbageman/C101,problem_2/min_element_sol.c,24,1,12,1423201.40730585,173077.0,8.222935456473131,1335.0,1316.0,39172.0,13302.0,1618.0,638.0,1339.0,593.0,1500000000,0.0009488009382039,1082014363648.0,0.0153168820813857,0.0798109539962648,"/**
Problem 2
Write a function min_element, that given an array, returns the value of the
smallest element in the array.
@author garbagman
**/
#include <stdio.h>
#define TEST_ARRAY {1,2,3,4}
#define TEST_SIZE 4

int min_element(int * array, int array_size) {
  // CODE GOES HERE
  int min = array[0];
  int i = 1;

  for (; i < array_size; i++) {
    if (array[i] < min) {
      min = array[i];
    }
  }

  return min;
}

int main() {
  int array[4] = TEST_ARRAY;
  int min;

  min = min_element(array, TEST_SIZE);

  printf(""The min value is: %d\n"",min);

  return 0;
}
"
378-8778,zxombie/aarch64-freebsd-binutils,gdb/testsuite/gdb.base/step-symless.c,30,1,14,1509901.3689904502,169067.0,8.930784836780685,1139.0,1129.0,38454.0,12698.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010066009126603,1082014363648.0,0.0134148000496844,0.0785502033156083,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2012-2014 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

static volatile int v;

static void
symful (void)
{
  v++;
}

static void
symless (void)
{
  v++;
}

int
main (void)
{
  symless ();
  symful ();
  return 0;
}
"
179-2071,ccilab/binutils,gdb/testsuite/gdb.dwarf2/implref-struct.c,34,2,15,1775388.02381595,169061.0,10.501463968626709,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0011835920158773,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* Copyright (C) 2016 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* Test program for synthetic C++ references to structs.  */

struct S {
  int a;
  int b;
  int c;
};

struct S s1 = {
  0,
  1,
  2
};

struct S s2 = {
  10,
  11,
  12
};

int
main (void)
{
  asm (""main_label: .globl main_label"");
  return 0;
}
"
022-9263,tpltnt/uncrustify,tests/output/c/00621-nl_endif.c,8,1,8,1418869.36035,169061.0,13.87164987785474,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0009459129069,1082014363648.0,0.0134152761429306,0.0785563462891999,"int main
(
)
{
   #ifdef useJPLvelocity
      for(i = 0; i < x; i++)
         y++;
   #endif

   return (0);
} /* main */

"
149-19202,ferquies/2dam,PSER/punteros2.c,13,2,12,2155458.0889641,185576.0,11.61496098633444,1356.0,1337.0,41765.0,14976.0,1631.0,638.0,1351.0,596.0,1500000000,0.0014369720593094,1082014363648.0,0.0145115747725999,0.0743025325602298,"#include <stdio.h>

int main(int argc, char **argv) {
	int arr[5];
	int i;
	
	printf(""sizeof(int): %d\n"", sizeof(int));
	for(i = 0; i < 5; i++) {
		printf(""%d. %p\n"", i, &arr[i]);
	}
	printf(""\n"");
	for(i = 0; i < 5; i++) {
		printf(""%d. %p\n"", i, arr+i);
	}
	
	return 0;
}
"
390-4672,totalspectrum/binutils-propeller,gdb/testsuite/gdb.base/bp-cmds-execution-x-script.c,26,2,13,1474113.0871698,169054.0,8.71977592958463,1139.0,1129.0,38452.0,12696.0,1568.0,580.0,1319.0,544.0,1500000000,0.0009827420581132,1082014363648.0,0.0134158316277639,0.0784194885430515,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2015-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
increment (int i)
{
  return i + 1;
}

#define N_INCR 20

int
main (void)
{
  int val = 1;
  int j;

  for (j = 0; j < N_INCR; j++)
    val = increment (val);
  return val == N_INCR;
}
"
233-21478,hzq1001/or1k-src,gdb/testsuite/gdb.trace/trace-break.c,45,1,22,1505103.07867065,169063.0,8.88325062254899,1139.0,1129.0,38454.0,12698.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010034020524471,1082014363648.0,0.0134151174414271,0.0785502033156083,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2011-2013 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#ifdef SYMBOL_PREFIX
#define SYMBOL(str)     SYMBOL_PREFIX #str
#else
#define SYMBOL(str)     #str
#endif

/* Called from asm.  */
static void __attribute__((used))
func (void)
{}

static void
marker (void)
{
  /* Some code to make sure `b marker' and `b set_point' set
     breakpoints at different addresses.  */
  int a = 0;
  int b = a;

  /* `set_point' is the label where we'll set multiple tracepoints and
     breakpoints at.  The insn at the label must the large enough to
     fit a fast tracepoint jump.  */
  asm (""    .global "" SYMBOL(set_point) ""\n""
       SYMBOL(set_point) "":\n""
#if (defined __x86_64__ || defined __i386__)
       ""    call "" SYMBOL(func) ""\n""
#endif
       );

  asm (""    .global "" SYMBOL(after_set_point) ""\n""
       SYMBOL(after_set_point) "":\n""
#if (defined __x86_64__ || defined __i386__)
       ""    call "" SYMBOL(func) ""\n""
#endif
       );
}

static void
end (void)
{}

int
main ()
{
  marker ();
  end ();
  return 0;
}
"
385-23452,higgsd/euler,c/14.c,27,2,15,305304184.5560073,756170961.0,0.4037502096037247,1339.0,1320.0,39187.0,13307.0,1620.0,636.0,1343.0,593.0,1500000000,0.2035361230373382,1082014363648.0,3.516400572277464e-06,0.0798567455328227,"/* 837799 */
#include <stdio.h>

int main(int argc, char **argv)
{
    int t;
    int m = 0;
    long long n, nx, mn = 0;

    for (n = 1; n < 1000000; n++)
    {
        nx = n;
        t = 1;
        while (nx != 1)
        {
            if (nx % 2 == 0)
                nx /= 2;
            else
                nx = 3 * nx + 1;
            t++;
        }
        if (t > m)
        {
            m = t;
            mn = n;
        }
    }
    printf(""%lld\n"", mn);
    return 0;
}
"
232-23868,feliposz/learning-stuff,harvard-cs50/ascii.c,11,2,11,2441179.35653775,304035.0,8.029269656454026,1368.0,1345.0,65353.0,30426.0,1628.0,648.0,1349.0,607.0,1500000000,0.0016274529043585,1082014363648.0,0.0089233147499465,0.0441850510028294,"#include <stdio.h>

int main(void)
{
	for (int j = 32; j < 32+16; j++) {
		for (int i = 0; i < 160; i+=16)
		{
			if (i+j < 127)
				printf(""%3d %2x %c "", i+j, i+j, i+j);
		}
		printf(""\n"");
	}
}
"
103-25177,froglogic/tracetool,config-tests/execinfo.c,27,1,15,2284127.98605855,427435.0,5.343799642050838,2052.0,1660.0,95936.0,24316.0,4971.0,761.0,2779.0,658.0,1500000000,0.0015227519907057,1082014363648.0,0.0086843613648858,0.0762482120879486,"#include <execinfo.h>
#include <stdio.h>
#include <stdlib.h>

/* Obtain a backtrace and print it to stdout. */
void
print_trace (void)
{
  void *array[10];
  size_t size;
  char **strings;
  size_t i;

  size = backtrace (array, 10);
  strings = backtrace_symbols (array, size);

  printf (""Obtained %zd stack frames.\n"", size);

  for (i = 0; i < size; i++)
     printf (""%s\n"", strings[i]);

  free (strings);
}

/* A dummy function to make the backtrace more interesting. */
void
dummy_function (void)
{
  print_trace ();
}

int
main (void)
{
  dummy_function ();
  return 0;
}

"
240-16214,sebastianscatularo/glibc,libio/test-fmemopen.c,27,3,12,3424849.47759645,181273.0,18.89332112338848,1430.0,1405.0,41443.0,14591.0,1650.0,648.0,1358.0,602.0,1500000000,0.0022832329850643,1082014363648.0,0.0156393947250831,0.0759895777563622,"/* Test for fmemopen implementation.
   Copyright (C) 2000-2014 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Hanno Mueller, kontakt@hanno.de, 2000.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

static char buffer[] = ""foobar"";

#include <stdio.h>
#include <string.h>

int
main (void)
{
  int ch;
  FILE *stream;

  stream = fmemopen (buffer, strlen (buffer), ""r"");

  while ((ch = fgetc (stream)) != EOF)
    printf (""Got %c\n"", ch);

  fclose (stream);

  return 0;
}
"
262-21297,sisnkemp/compiler,tests.c/matmul0000.c,25,5,14,344730843.09138346,943893616.0,0.3652221364319514,1141.0,1131.0,268473911.0,799131.0,134513231.0,295508.0,1316.0,49699.0,1500000000,0.2298205620609223,1082014363648.0,2.4070509234167764e-06,0.5008290209756683,"#define TYPE int
#define DIM 512

TYPE A[DIM][DIM];
TYPE B[DIM][DIM];
TYPE C[DIM][DIM];
	
int
main(void)
{
	int i = 0;

	for (i = 0; i < DIM; i++) {
		int j;

		for (j = 0; j < DIM; j++) {
			A[i][j] = i + j;
			B[i][j] = i - j;
		}
	}

	for (i = 0; i < DIM; i++) {
		int j;

		for (j = 0; j < DIM; j++) {
			int k, sum = 0;

			for (k = 0; k < DIM; k++) {
				sum += A[i][k] * B[k][j];
			}
			C[i][j] = sum;
		}
	}
}
"
024-21138,chbrown/sandbox,c/k_and_r/fahr_define.c,7,1,9,2105824.64933385,273720.0,7.69335086950168,1457.0,1430.0,62134.0,27090.0,1635.0,651.0,1352.0,606.0,1500000000,0.0014038830995559,1082014363648.0,0.0105472745871693,0.0475656773962162,"#include <stdio.h>

// defines do not have to be uppercase!
#define LIMIT 300
#define step 15

int main() {
  for (float fahrenheit = -100; fahrenheit <= LIMIT; fahrenheit += step) {
    float celsius = (5.0/9.0) * (fahrenheit - 32);
    printf(""%3.0f°F = %6.2f°C\n"", fahrenheit, celsius);
  }
}
"
066-10455,phil-opp/binutils-gdb,gdb/testsuite/gdb.dwarf2/dw2-reg-undefined.c,29,2,14,1594906.44000465,169061.0,9.433908470906951,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010632709600031,1082014363648.0,0.0134152761429306,0.0785563462891999,"/*
   Copyright 2013-2016 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

void
stop_frame ()
{
  /* The debug information for this frame is modified in the accompanying
     .S file, to mark a set of registers as being undefined.  */
}

void
first_frame ()
{
  stop_frame ();
}

int
main ()
{
  first_frame ();

  return 0;
}
"
135-7363,wolfdale/Spaghetti-code,Code08/Basics/segoddandeven.c,27,4,13,1472103.17663835,177942.0,10.21730114306909,1341.0,1322.0,40317.0,14030.0,1626.0,637.0,1344.0,594.0,1500000000,0.0009814021177589,1082014363648.0,0.0149655505726585,0.0772995749535393,"#include <stdio.h>
void seg(int a[],int n){
	int i=0;
	int j=n;
	int k;
	while(i<j){
		while(a[i]%2==0 && i<j){
			i++;
		}
		while(a[j]%2==1 && i<j){
			j--;
		}
		if(i<j){
			int temp = a[i];
			a[i] = a[j];
			a[j] = temp;
			i++;j--;
		}
	}
	for(i=0;i<n;i++){
		printf(""%d"",a[i]);
	}
}
int main(void) {
	int a[10]={2,2,2,5,8,1,1,4,1};
	seg(a,8);
	
	return 0;
}
"
180-32191,rodmachen/exercises,lcthw/ex13/rod/ex13.c,19,2,11,1935438.02015475,178607.0,10.83629421019333,1358.0,1336.0,40372.0,14054.0,1628.0,636.0,1346.0,595.0,1500000000,0.0012902920134365,1082014363648.0,0.0150833953876387,0.0772608679675155,"#include <stdio.h>

int main(int argc, char *argv[])
{
    int i = 0;
    argv[2] = ""two"";    
    char string[] = ""strang\n"";

    printf(""%s"", string);

    for (i = 1; i < argc; i++) {
        printf(""arg %d: %s\n"", i, argv[i]);
    }

    char *states[] = {
        ""California"", ""Oregon"",
        ""Washington"", ""Texas"", argv[2] 
    };

    int num_states = 5;

    for (i = 0; i < num_states; i++) {
        printf(""state %d: %s\n"", i, states[i]);
    }

    return 0;
}

"
337-28842,xfce-mirror/xfconf,tests/tests-end/t-tests-end.c,7,1,6,2138599.6369644003,169057.0,15.101492396055768,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0014257330913096,1082014363648.0,0.0134155935572026,0.0785563462891999,"/* It is just a dummy test in order to shutdown
 * xfconfd, see tests-driver.sh for more details */

int
main(void)
{
    return 0;
}
"
039-9827,choueric/tools,C/utils/temporary/progress/main.c,12,1,11,7518446147.907525,172502.0,43584.68972533652,1292.0,1274.0,39030.0,13221.0,1605.0,634.0,1332.0,592.0,1500000000,5.01229743193835,1082014363648.0,0.0148751898528712,0.0796731163039941,"#include <stdio.h>
#include <unistd.h>

int main(int argc, char **argv)
{
    int i = 0;

    for (i = 0; i < 100; i++) {
        printf(""%d%%\r"", i);
        fflush(stdout);
        usleep(50 * 1000);
    }
    printf(""%d%%\r"", i);
    printf(""\n"");

	return 0;
}
"
071-33578,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.dwarf2/dw2-reg-undefined.c,29,2,14,1637192.79225915,169061.0,9.684031207670603,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010914618615061,1082014363648.0,0.0134152761429306,0.0785563462891999,"/*
   Copyright 2013-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

void
stop_frame ()
{
  /* The debug information for this frame is modified in the accompanying
     .S file, to mark a set of registers as being undefined.  */
}

void
first_frame ()
{
  stop_frame ();
}

int
main ()
{
  first_frame ();

  return 0;
}
"
117-26679,csziacobus/euler,src/1-10/euler4.c,32,2,17,1424087.79356625,275559.0,5.167993061377056,1344.0,1322.0,39185.0,13307.0,1618.0,636.0,1340.0,593.0,1500000000,0.0009493918623775,1082014363648.0,0.0096748790640117,0.079764535548274,"#include <stdio.h>

int palindrome (int);

int
main ()
{
  int i;
  int j;
  for (i = 999; i > 100; i--)
    {
      for (j = 999; j > 100; j--)
	{
	  if (palindrome(i * j))
	    {
	    printf (""answer: %d\n"", i * j);
	    return 0;
	    }
	}
    }
  return 1;
}	  

int
palindrome (int number)
{
  if (number % 10 == number / 100000)
    {
      if ((number % 100) / 10 == (number / 10000) % 10)
	{
	  if ((number % 1000) / 100 == (number / 1000) % 100)
	    return 1;
	}
    }
  return 0;
}
"
270-20129,mattstock/binutils-bexkat1,gdb/testsuite/gdb.base/startup-with-shell.c,20,2,15,1656122.9713259998,173418.0,9.549885248359455,1352.0,1331.0,39236.0,13340.0,1618.0,635.0,1340.0,591.0,1500000000,0.001104081980884,1082014363648.0,0.0154712890242074,0.0795800365185636,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2017-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <stdio.h>

int
main (int argc, char *argv[])
{
  int i;

  for (i = 0; argv[i] != NULL; ++i)
    printf (""ARG %d = %s\n"", i, argv[i]);

  return 0;
}
"
278-370,mattstock/binutils-bexkat1,gdb/testsuite/gdb.multi/multi-re-run-2.c,38,2,14,1600277.8429537502,177397.0,9.020879721754032,1339.0,1313.0,40393.0,13861.0,1644.0,669.0,1359.0,624.0,1500000000,0.0010668518953025,1082014363648.0,0.0149495200031567,0.0791831017067866,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <limits.h>
#include <string.h>
#include <pthread.h>

int re_run_var_2 = 2;

#define NUM_THREADS 1

__thread int tls_var = 1;

static pthread_barrier_t barrier;

static void *
thread_start (void *arg)
{
  pthread_barrier_wait (&barrier);

  while (1)
    sleep (1);
  return NULL;
}

static void
all_started (void)
{
}

int
main (int argc, char ** argv)
{
  pthread_t thread;
  int len;

  pthread_barrier_init (&barrier, NULL, NUM_THREADS + 1);
  pthread_create (&thread, NULL, thread_start, NULL);

  pthread_barrier_wait (&barrier);
  all_started ();

  return 0;
}
"
305-11308,alpine9000/BitOS,tests/gcc.c-torture/pr57344-1.c,27,1,16,1591338.19397535,169990.0,9.3613624330843,1147.0,1138.0,38670.0,12783.0,1577.0,586.0,1323.0,546.0,1500000000,0.0010608921293169,1082014363648.0,0.0134419671745396,0.0783627776806017,"/* { dg-do run } */
/* PR middle-end/57344 */

struct __attribute__((packed)) S
{
  int a : 11;
#if __SIZEOF_INT__ * __CHAR_BIT__ >= 32
  int b : 22;
#else
  int b : 13;
#endif
  char c;
  int : 0;
} s[2];
int i;

__attribute__((noinline, noclone)) void
foo (int x)
{
  if (x != -3161)
    __builtin_abort ();
  asm volatile ("""" : : : ""memory"");
}

int
main ()
{
  struct S t = { 0, -3161L };
  s[1] = t;
  for (; i < 1; i++)
    foo (s[1].b);
  return 0;
}
"
077-24730,hironics/clib_examples,time/clock.c,19,1,17,1502448309.212923,44487472.0,33.77239122510715,1342.0,1322.0,10847574.0,3255913.0,1624.0,636.0,1346.0,594.0,1500000000,1.0016322061419487,1082014363648.0,5.988202701200913e-05,0.0002977986933302,"#include <stdio.h>
#include <stdlib.h>
#include <time.h>
//#include <unistd.h>

int main(int argc, char * argv[])
{
    clock_t ticks1, ticks2;
    /*
    shows the number of cloks per second
    */
    printf(""CLOCKS PER SEC IS: %ld\n"", CLOCKS_PER_SEC);
    ticks1 = clock();
    ticks2 = ticks1;
    // this is also good way to sleep, but the difference with sleep is
    // it will not give up cpu
    while((ticks2-ticks1)<1000000)
        ticks2 = clock();
    //sleep(1);
    ticks2 = clock();
    printf(""clocks spent on sleeping : %ld\n"", ticks2- ticks1);
    return EXIT_SUCCESS;
}
"
253-735,SaberMod/binutils-saber,gdb/testsuite/gdb.python/py-strfns.c,39,1,20,1798896.1189984502,169083.0,10.639129894785402,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0011992640793323,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2012-2014 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

const char str1[] = ""Hello."";
const char str2[] = ""Hello."";
const char str3[] = ""Goodbye."";

const char buf1[] = { 0, 1, 2, 3 };
const char buf2[] = { 0, 1, 2, 3 };
const char buf3[] = { 0, 1, 2, 4 };

static void
func (const char *arg)
{
  return; /* Break func here.  */
}

static void
bfunc (const char *arg)
{
  return; /* Break bfunc here.  */
}

int
main ()
{
  func (str1);
  func (str2);
  func (str3);

  bfunc (buf1);
  bfunc (buf2);
  bfunc (buf3);

  return 0;
}
"
129-31934,tendoasan/ProgrammingInC,chapter10/exce14.c,27,2,17,2627180.7728334,173894.0,15.10793931935547,1325.0,1306.0,39411.0,13393.0,1625.0,635.0,1344.0,594.0,1500000000,0.0017514538485556,1082014363648.0,0.0151299067247863,0.0795015529126581,"// 编写intToStr的函数
#include <stdio.h>

void intToStr(int value, char result[]){
	char intString[81];
	int i, j = 0;
	
	if(value < 0){
		result[0] = '-';
		value = - value;
		j = 1;
	}
	
	do{
		intString[i] = value % 10;
		++i;
		value = value / 10;
	}while(value != 0);
	
	for(--i; i >= 0; --i){
		result[j] = intString[i] + '0';
		++j;
	}
	
	result[j] = '\0';
}

int main(void){
	void intToStr(int value, char result[]);
	char result[81];
	
	intToStr(-867, result);
	
	printf(""%s"", result);
	
	return 0;
}
"
360-13858,Gurgel100/gcc,gcc/testsuite/gcc.dg/torture/pr95045.c,28,4,15,1581423.10101525,169869.0,9.309662151422566,1144.0,1134.0,38461.0,12896.0,1569.0,586.0,1318.0,547.0,1500000000,0.0010542820673435,1082014363648.0,0.0134103338454927,0.0782756002102926,"/* { dg-do run } */

int a, c, f;
long b;
char d;
int e[3];
int g[9][3][2];
int main()
{
    {
h:
      for (f = 0; f <= 5; f++) {
	  b = 3;
	  for (; b >= 0; b--) {
	      e[2] = d = 0;
	      for (; d <= 3; d++) {
		  g[8][2][0] = e[1] = c = 0;
		  for (; c <= 1; c++)
		    e[c + 1] = g[d + 5][2][c] = 4;
	      }
	      if (a)
		goto h;
	  }
      }
    }
  if (e[2] != 4)
    __builtin_abort ();
  return 0;
}
"
283-12475,Xilinx/binutils-gdb,gdb/testsuite/gdb.base/paginate-inferior-exit.c,24,1,13,4503581028.082408,170086.0,26478.258222311066,1153.0,1144.0,38691.0,12795.0,1573.0,585.0,1322.0,544.0,1500000000,3.0023873520549387,1082014363648.0,0.0135049327987018,0.078157168939129,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

static void
after_sleep (void)
{
  return; /* after sleep */
}

int
main (void)
{
  sleep (3);
  after_sleep ();
  return 0;
}
"
031-30954,rkdarst/scicomp,tut/profiling/c-profiling.c,11,2,11,1573217.91630225,169057.0,9.30583767605009,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010488119442015,1082014363648.0,0.0134155935572026,0.0785563462891999,"int f(x) { y(x);  x+=1;  y(x); }  // f is fast, but calls y twice
int y(z) {                        // y is slow
  for ( ; z>=0 ; z-- ) {
    0;
} }

int main() {                      // main has a loop, calls f and y
  int i;
  for (i=0; i<10000; i++) {
    f(i);
    y(i);
} }
"
356-3531,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.base/bg-execution-repeat.c,25,1,14,7502013853.518292,170067.0,44112.10789277167,1152.0,1142.0,38683.0,12795.0,1575.0,585.0,1323.0,544.0,1500000000,5.001342569012195,1082014363648.0,0.0134888014723608,0.0782275923695559,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
foo (void)
{
  return 0; /* set break here */
}

int
main (void)
{
  foo ();
  sleep (5);
  foo ();
  return 0;
}
"
361-5668,mattstock/binutils-bexkat1,gdb/testsuite/gdb.base/bg-execution-repeat.c,25,1,14,7502167104.0449295,170067.0,44113.009014094445,1152.0,1142.0,38683.0,12795.0,1575.0,585.0,1323.0,544.0,1500000000,5.001444736029953,1082014363648.0,0.0134888014723608,0.0782275923695559,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
foo (void)
{
  return 0; /* set break here */
}

int
main (void)
{
  foo ();
  sleep (5);
  foo ();
  return 0;
}
"
055-2142,bhagatyj/algorithms,problems/strings/pallindrome/isPall.c,22,1,13,1765008.0844759499,170811.0,10.333105010801413,1150.0,1141.0,38899.0,12876.0,1580.0,585.0,1326.0,546.0,1500000000,0.0011766720563173,1082014363648.0,0.0134124851443993,0.0779719942056977,"#include <stdio.h>
#include <assert.h>
#include <string.h>

int isPall ( char *s) {
    int len = strlen(s);
    char *end = s+len - 1;

    if ( len <= 1 ) {
        return 1;
    }

    while ( end > (s+2) ) {
        if ( *end != *s ) {
            return 0;
        }
        end--;
        s++;
    }
    return 1;
}

int main(int argc, char **argv) {
    assert( isPall(""Hello"") == 0 );
    assert( isPall(""H"") == 1 );
    assert( isPall(""roor"") == 1 );
    assert( isPall(""rotor"") == 1 );
    assert( isPall("""") == 1 );
}
"
164-24613,oldhill/halloween,c/euler.c,16,1,8,104859260.95861936,900174083.0,0.1164877571797409,1342.0,1322.0,39351.0,13426.0,1620.0,637.0,1342.0,594.0,1500000000,0.0699061739724129,1082014363648.0,2.9594275710779378e-06,0.0794474865945392,"#include <stdio.h>

int main()
{
  int n = 100000000;
  printf(""\nFinding sum of multiples of 3 and 5 below %d\n"", n);

  long total = 0;
  for (int i = 0; i < n; ++i) {
    if (i % 3 == 0) {
      total = total + i;
    }
    else if (i % 5 == 0) {
      total = total + i;
    }
  }
  printf(""Result: %ld\n"", total);

  return 0;
}
"
368-6463,dyladan/euler,c/10.1.c,19,3,14,19989559.42690365,44165401.0,0.4526067588517989,1437.0,1412.0,2042281.0,13822717.0,129215.0,3824236.0,3316.0,123568.0,1500000000,0.0133263729512691,1082014363648.0,6.45075089434827e-05,0.257191018870598,"#include <stdio.h>
int main(int argc, char *argv[]){
  int mark[2000000];
  //int list[2000000];
  int i,j;
  double sum = 0;
  for(i = 1; i < 1999999; i++){
    //list[i-1] = i;
    mark[i-1] = 0;
  }

  for(i = 2; i < 2000000; i++){
    if(mark[i] == 0){
      sum += i;
      for(j = i; j < 2000000; j+=i){
        mark[j] = 1;
      }
    }
  }
  printf(""%.0f\n"", sum);


}
"
115-16653,ataniazov/KOU,Trash/ders/useful/dik_uchgen_2.c,13,3,7,1661762.9444226,173898.0,9.555958090374816,1267.0,1252.0,39654.0,13493.0,1604.0,637.0,1331.0,593.0,1500000000,0.0011078419629484,1082014363648.0,0.0144855029960091,0.0783675466159896,"int main() {
	int i, j;
	for (i = 1 ; i <= 5 ; i++) {
		for (j = 1 ; j <= 5-i ; j++) {
			printf(""."");
		}
		for (j = 1 ; j <= i ; j++) {
			printf(""x"");
		}
		printf(""\n"");
	}
	return 0;
}

"
140-31663,NicoleRobin/glibc,ctype/test_ctype.c,71,3,30,2323742.95592295,1336188.0,1.739083123033585,1395.0,1374.0,299064.0,187471.0,1709.0,701.0,1411.0,657.0,1500000000,0.0015491619706153,1082014363648.0,0.002072313177487,0.0092038599484107,"/* Copyright (C) 1991-2017 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#include <limits.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>

#define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
#define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
#define XOR(e,f) (((e) && !(f)) || (!(e) && (f)))

#ifdef	__GNUC__
__inline
#endif
static void
print_char (unsigned char c)
{
  printf(""%d/"", (int) c);
  if (isgraph(c))
    printf(""'%c'"", c);
  else
    printf(""'\\%.3o'"", c);
}

int
main (int argc, char **argv)
{
  unsigned short int c;
  int lose = 0;

#define TRYEM do {							      \
      TRY (isascii);							      \
      TRY (isalnum);							      \
      TRY (isalpha);							      \
      TRY (iscntrl);							      \
      TRY (isdigit);							      \
      TRY (isgraph);							      \
      TRY (islower);							      \
      TRY (isprint);							      \
      TRY (ispunct);							      \
      TRY (isspace);							      \
      TRY (isupper);							      \
      TRY (isxdigit);							      \
      TRY (isblank);							      \
    } while (0)

  for (c = 0; c <= UCHAR_MAX; ++c)
    {
      print_char (c);

      if (XOR (islower (c), ISLOWER (c)) || toupper (c) != TOUPPER (c))
	{
	  fputs ("" BOGUS"", stdout);
	  ++lose;
	}

#define TRY(isfoo) if (isfoo (c)) fputs ("" "" #isfoo, stdout)
      TRYEM;
#undef TRY

      fputs(""; lower = "", stdout);
      print_char(tolower(c));
      fputs(""; upper = "", stdout);
      print_char(toupper(c));
      putchar('\n');
    }

  fputs (""EOF"", stdout);
  if (tolower (EOF) != EOF)
    {
      ++lose;
      printf ("" tolower BOGUS %d;"", tolower (EOF));
    }
  if (toupper (EOF) != EOF)
    {
      ++lose;
      printf ("" toupper BOGUS %d;"", toupper (EOF));
    }

#define TRY(isfoo) if (isfoo (EOF)) fputs ("" "" #isfoo, stdout), ++lose
  TRYEM;
#undef TRY

  return lose ? EXIT_FAILURE : EXIT_SUCCESS;
}
"
155-23310,gusrc/mpgedit,gui/xmpgedit.app/Contents/MacOS/xmpgedit.c,23,2,12,4119961.4061042005,175800.0,48.42046643913538,1299.0,1273.0,39965.0,13700.0,1625.0,641.0,1349.0,598.0,1500000000,0.0027466409374028,1082014363648.0,0.0146302616609783,0.0785055436504239,"#include <stdlib.h>

int main(int argc, char *argv[])
{
    char *cmd;
    int len = 0;
    int i = 1;

    while (i < argc) {
        len += strlen(argv[i]) + 2;
        i++;
    }

    cmd = (char *) malloc(strlen(argv[0]) + 2 + len + sizeof("".sh""));
    if (cmd) {
        strcpy(cmd, argv[0]);
        strcat(cmd, "".sh"");
        strcat(cmd, "" "");
        i = 1;
        while (i < argc) {
            strcat(cmd, argv[i]);
            strcat(cmd, "" "");
            i++;
        }
    }
    return system(cmd);
}
"
377-2651,mickael-guene/binutils,gdb/testsuite/gdb.python/py-pp-maint.c,67,1,29,1644406.4676760498,169057.0,9.726932336430908,1140.0,1130.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010962709784507,1082014363648.0,0.0134274238866181,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2010-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <string.h>


enum flag_enum
  {
    /* Define the enumeration values in an unsorted manner to verify that we
       effectively sort them by value.  */
    FOO_MASK = 0x07,
    FOO_1    = 0x01,
    FOO_2    = 0x02,
    FOO_3    = 0x04,

    BAR_MASK = 0x70,
    BAR_1    = 0x10,
    BAR_2    = 0x20,
    BAR_3    = 0x40,
  };

enum flag_enum fval;

struct function_lookup_test
{
  int x,y;
};

void
init_flt (struct function_lookup_test *p, int x, int y)
{
  p->x = x;
  p->y = y;
}

struct s
{
  int a;
  int *b;
};

struct ss
{
  struct s a;
  struct s b;
};

void
init_s (struct s *s, int a)
{
  s->a = a;
  s->b = &s->a;
}

void
init_ss (struct ss *s, int a, int b)
{
  init_s (&s->a, a);
  init_s (&s->b, b);
}

int
main ()
{
  struct function_lookup_test flt;
  struct ss ss;

  init_flt (&flt, 42, 43);
  init_ss (&ss, 1, 2);
  
  return 0;      /* break to inspect */
}
"
236-5750,kujenga/euler,Euler_92/SquareDigitChain.c,27,2,20,606434596.5860411,3288444876.0,0.1843503558245444,1338.0,1318.0,39181.0,13311.0,1618.0,638.0,1339.0,593.0,1500000000,0.4042897310573607,1082014363648.0,8.076766070747418e-07,0.0797835860702583,"// (c) 2013 Aaron M. Taylor
// This program solves problem 92 of Project Euler
// It adds together the square of the digits in a number recursively until it reaches 89 or 1

#import <stdio.h>

int digitSquareSum ( int n ) {
  int new = 0;
  while ( n ) {
    new += (n%10) * (n%10); // adds square of current digit
    n /= 10;
  }
  return new;
}

int chainDest ( int n ) {
  if ( n == 1 )
    return 1;
  else if ( n == 89 )
    return 89;
  else {
    return chainDest ( digitSquareSum(n) );
  }
}

int main ( int argc, char** argv ) {
  int n89 = 0;
  for ( int i = 1; i < 10000000; i ++ )
    if ( chainDest(i) == 89 )
      n89++;
  printf(""n89: %d\n"",n89);
}
"
085-13559,Eddyding/C,niukewang/time_diff7.c,19,2,11,6321874140.179716,1092347.0,5787.422989214965,1520.0,1489.0,246150.0,244833.0,1645.0,646.0,1363.0,599.0,1500000000,4.214582760119811,1082014363648.0,0.002754619182366,0.008662214374021,"#include<stdio.h>
#include<time.h>
#include<unistd.h>
#include<stdlib.h>

int
main()
{
	clock_t start,finish;
	double duration;
	
	long i,j;

	start = clock();

	sleep(3);// do not affect clock()

	for(i=0;i<100;++i)
	{
		for(j=0;j<10;++j)
		 system(""cd"");
	}

	finish=clock();

	duration = (double)(finish-start)/CLOCKS_PER_SEC;
	
	printf(""Time to do %ld empty loops is "",i*j);
	printf(""%lf seconds\n"",duration);
	return 0;
}
"
107-17637,hzq1001/or1k-src,gdb/testsuite/gdb.threads/staticthreads.c,51,3,20,1550388.0567847497,185319.0,8.366049892347789,1506.0,1475.0,42321.0,14891.0,1697.0,717.0,1394.0,670.0,1500000000,0.0010335920378565,1082014363648.0,0.0160857764179603,0.0782702929455359,"/* This test program is part of GDB, The GNU debugger.

   Copyright 2004-2013 Free Software Foundation, Inc.

   Originally written by Jeff Johnston <jjohnstn@redhat.com>,
   contributed by Red Hat

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <pthread.h>
#include <semaphore.h>
#include <stdio.h>
#include <limits.h>
#include <errno.h>

sem_t semaphore;

void *
thread_function (void *arg)
{
  printf (""Thread executing\n"");
  while (sem_wait (&semaphore) != 0)
    {
      if (errno != EINTR)
	{
	  perror (""thread_function"");
	  return;
	}
    }
  return NULL;
}

int 
main (int argc, char **argv)
{
  pthread_attr_t attr;

  pthread_attr_init (&attr);
  pthread_attr_setstacksize (&attr, PTHREAD_STACK_MIN);

  if (sem_init (&semaphore, 0, 0) == -1)
    {
      perror (""semaphore"");
      return -1;
    }


  /* Create a thread, wait for it to complete.  */
  {
    pthread_t thread;
    pthread_create (&thread, &attr, thread_function, NULL);
    sem_post (&semaphore);
    pthread_join (thread, NULL);
  }

  pthread_attr_destroy (&attr);
  return 0;
}
"
152-26431,ArmstrongJ/insight-debugger,gdb/testsuite/gdb.python/py-symbol.c,46,1,28,1798519.2826017,169083.0,10.636900220601715,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0011990128550678,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2010-2012 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see  <http://www.gnu.org/licenses/>.
*/

#ifdef __cplusplus
class SimpleClass
{
 private:
  int i;

 public:
  void seti (int arg)
  {
    i = arg;
  }

  int valueofi (void)
  {
    return i; /* Break in class. */
  }
};
#endif

int qq = 72;			/* line of qq */

int func (int arg)
{
  int i = 2;
  i = i * arg;
  return arg; /* Block break here.  */
}

int main (int argc, char *argv[])
{
#ifdef __cplusplus
  SimpleClass sclass;
#endif
  int a = 0;
  int result;
  enum tag {one, two, three};
  enum tag t = one;

  result = func (42);

#ifdef __cplusplus
  sclass.seti (42);
  sclass.valueofi ();
#endif
  return 0; /* Break at end.  */
}
"
105-12745,mattstock/binutils-bexkat1,gdb/testsuite/gdb.mi/mi-reg-undefined.c,28,2,14,1557617.7975161998,169061.0,9.213343112840928,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010384118650108,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* Copyright 2013-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

void
stop_frame ()
{
  /* The debug information for this frame is modified in the accompanying
     .S file, to mark a set of registers as being undefined.  */
}

void
first_frame ()
{
  stop_frame ();
}

int
main ()
{
  first_frame ();

  return 0;
}
"
075-16609,totalspectrum/binutils-propeller,gdb/testsuite/gdb.base/paginate-inferior-exit.c,24,1,14,4501802800.688892,170086.0,26467.803346542336,1153.0,1144.0,38691.0,12795.0,1573.0,585.0,1322.0,544.0,1500000000,3.0012018671259284,1082014363648.0,0.0135049327987018,0.078157168939129,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

static void
after_sleep (void)
{
  return; /* after sleep */
}

int
main (void)
{
  sleep (3);
  after_sleep ();
  return 0;
}
"
210-6564,hzq1001/or1k-src,gdb/testsuite/gdb.base/gcore-buffer-overflow.c,19,2,15,1400252.80416,169100.0,8.278367829686577,1142.0,1132.0,38461.0,12696.0,1567.0,584.0,1317.0,544.0,1500000000,0.00093350186944,1082014363648.0,0.0134476641040804,0.0784252399476122,"/* Copyright 2007-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/*
 * Test GDB's internal buffers safety for the GCORE command.
 */

int main (void)
{
  return 0;
}
"
345-26470,unix1986/universe,tool/cmake-3.0.2/Tests/CTestTestFdSetSize/sleep.c,7,1,7,167369029.4846892,170094.0,983.9796171528684,1156.0,1148.0,38686.0,12791.0,1577.0,586.0,1323.0,546.0,1500000000,0.1115793529897928,1082014363648.0,0.0135454513386715,0.0783262427880412,"#if defined(_WIN32)
# include <windows.h>
#else
# include <unistd.h>
#endif

/* sleeps for 0.1 second */
int main(int argc, char** argv)
{
#if defined(_WIN32)
  Sleep(100);
#else
  usleep(100 * 1000);
#endif
  return 0;
}
"
294-31313,mattstock/binutils-bexkat1,gdb/testsuite/gdb.base/memattr.c,21,1,10,1453126.5478581,169083.0,8.594157898783438,1142.0,1132.0,38460.0,12696.0,1569.0,585.0,1318.0,546.0,1500000000,0.0009687510319054,1082014363648.0,0.0134490161636592,0.0785440613026819,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2011-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#define MEMSIZE 64
int mem1[MEMSIZE] = {111, 222, 333, 444, 555};
int mem2[MEMSIZE];
int mem3[MEMSIZE];
int mem4[MEMSIZE];
int mem5[MEMSIZE];

int main()
{
  return 0;
}
"
394-12965,ShooShoSha/Course-Work,COP3014/Chapters/8/Samples/pgm8-15.c,14,1,10,1966293.202713,177586.0,11.072342414379513,1340.0,1321.0,40077.0,13891.0,1617.0,638.0,1340.0,595.0,1500000000,0.001310862135142,1082014363648.0,0.0149842893020846,0.0776386006522383,"// Program to illustrate static and automatic variables

#include <stdio.h>

void auto_static(void)
{
	auto int autoVar = 1;
	static int staticVar = 1;
	
	printf(""autoVar = %i, staticVar = %i\n"", autoVar++, staticVar++);
}

int main(void)
{
	int i;
	for(i = 0; i < 5; ++i)
		auto_static();
	
	return 0;
}
"
183-7536,goblint/analyzer,tests/regression/00-sanity/24-update_suite.c,7,1,6,1828067.9360031,169061.0,10.81306155766262,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0012187119573354,1082014363648.0,0.0134152761429306,0.0785563462891999,"// SKIP (just for manually testing that update_suite works)
#include <assert.h>

int main() {
  int x = 42;
  // Should fail with: Expected unknown, but registered success
  assert(x == 42); // UNKNOWN

  return 0;
}
"
077-30413,quchunguang/test,bookasm/chap04/demo.c,22,4,9,2361094.4626852497,169083.0,13.964112299876392,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0015740629751235,1082014363648.0,0.0134490161636592,0.0785049652044725,"
#include <stdio.h>

void function1()
{
	int i, j;
	for(i = 0; i < 20000; i++)
		j += i;
}

void function2()
{
	int i, j;
	function1();
	for(i = 0; i < 20000; i++)
		j = i;
}

int main()
{
	int i, j;
	for(i = 0; i < 100; i++)
		function1();
	for(i = 0; i < 50000; i++)
		function2();
	return 0;
}
"
262-14918,krystism/leetcode,algorithms/ContainerWithMostWater/solve.c,31,3,18,1798114.5065276998,174659.0,10.29499768119593,1343.0,1324.0,39571.0,13488.0,1626.0,636.0,1345.0,594.0,1500000000,0.0011987430043518,1082014363648.0,0.0152697542067686,0.0791760116097174,"#include <stdio.h>
#include <stdlib.h>
int maxArea(int a[], int n)
{
	int max = -1;
	int left = 0, right = n - 1;
	for (int i = 1; i < n; ++i) {
		int area = (a[left] <= a[right] ? a[left] : a[right]) * (right - left);
		max = max < area ? area : max;
		if (a[left] <= a[right]) {
			int l = a[left];
			left++;
			while (left < right && a[left] <= l) {
				left++;
			}
		} else {
			int r = a[right];
			right--;
			while (left < right && a[right] <= r) {
				right--;
			}
		}
	}
	return max;
}
int main(int argc, char **argv)
{
	int a[] = {2, 3, 4, 1};
	int b[] = {1,2,1};
	printf(""%d\n"", maxArea(a, 4));
	printf(""%d\n"", maxArea(b, 3));
	return 0;
}
"
254-4346,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.perf/skip-prologue.c,36,1,17,1482111.1690252498,169061.0,8.698239097130621,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0009880741126835,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright (C) 2013-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* GDB will analyze the prologue of functions f1 and f2.  */

struct foo
{
  int a[32];
};

static int
f1 (void)
{
  return 0;
}

static double
f2 (int a, long long b, double c, struct foo f)
{
  f.a[0] = a + (int) b + c;

  return c + 0.2;
}

int
main (void)
{
  struct foo f;

  f1 ();
  f2 (0, 0, 0.1, f);

  return 0;
}
"
079-12528,EricLagergren/decimal,benchmarks/testdata/c_double.c,35,3,15,1758614616.0028875,2556978893.0,0.6877704860272384,1430.0,1404.0,40725.0,13888.0,1635.0,635.0,1354.0,593.0,1500000000,1.172409744001925,1082014363648.0,1.1083392231974907e-06,0.0772160474612271,"#include <stdio.h>
#include <stdlib.h>
#include <time.h>

double calcPifloat();
double gd;

#define NITER 40
#define ROUNDS 10000

int main(void) {
	double ld;
	double sum = 0;
	for (int i = 0; i < NITER; ++i) {
		clock_t start_clock = clock();
		for (int j = 0; j < ROUNDS; ++j) {
			ld = calcPifloat();
		}
		sum += (double)(clock() - start_clock) / (double)(CLOCKS_PER_SEC);
	}
	gd = ld;
	printf(""average: %f\n"", sum / NITER);
	return 0;
}

double calcPifloat() {
	double lasts = 0.0;
	double t     = 3.0;
	double s     = 3.0;
	double n     = 1.0;
	double na    = 0.0;
	double d     = 0.0;
	double da    = 24.0;
	while (s != lasts) {
		lasts = s;
		n += na;
		na += 8;
		d += da;
		da += 32;
		t = (t * n) / d;
		s = t;
	}
	return s;
}
"
232-23481,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.server/wrapper.c,23,1,11,1603386.1320465,170699.0,9.393060299123018,1151.0,1142.0,38885.0,12790.0,1637.0,586.0,1324.0,546.0,1500000000,0.001068924088031,1082014363648.0,0.0134330019508022,0.079206579583938,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2013-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <stdlib.h>

static char *d = NULL;

static void
marker (void)
{}

int
main (void)
{
  d = getenv (""TEST"");

  marker ();

  return 0;
}
"
292-34570,zhaoqin/Umbra,test/test-scan-pthread.c,27,2,18,1969939.3305927,324735.0,6.066297134586663,1531.0,1488.0,68491.0,32599.0,1663.0,758.0,1371.0,712.0,1500000000,0.0013132928870618,1082014363648.0,0.0092968112460929,0.0445543575032149,"#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>

int *p;
int size = 1 * 4096;

void *mem_scan(void *ptr)
{
  int i, j;
  
  for (j = 0; j < 10; j++) 
  for (i = 0; i < size; i += 1024) {
      p[i] = i;
      if (i % 1024 == 0)
	printf(""%s p[%d] at %p is %d\n"", (char *)ptr, i, &p[i], p[i]);
  }
}


int main()
{
  pthread_t thread1, thread2;
  char *msg1 = ""thread 1"";
  char *msg2 = ""thread 2"";
  p = malloc(size * sizeof(int));
  printf(""Allocate %d ints at %p\n"", size, p);
  printf(""create thread 1\n"");
  pthread_create(&thread1, NULL, mem_scan, msg1);
  printf(""create thread 2\n"");
  pthread_create(&thread2, NULL, mem_scan, msg2);
  pthread_join(thread1, NULL);
  pthread_join(thread2, NULL);
  return 0;
}
"
194-25122,wch16534421/-,逆序交换.c,19,2,14,1970986.36999725,176430.0,11.171490109391828,1337.0,1318.0,39961.0,13776.0,1626.0,637.0,1344.0,594.0,1500000000,0.0013139909133315,1082014363648.0,0.0150484611460635,0.0781770474719467,"#include<stdio.h>

int main()
{
	int array[5] = {15,20,25,30,35};
	int temp;
	int i;
	int * ptr_array_start = array;
	int * ptr_array_end = array + 4;
	while(ptr_array_start != ptr_array_end)
	{
		temp = *ptr_array_start;
		*ptr_array_start = *ptr_array_end;
		*ptr_array_end = temp;
		
		ptr_array_start++;
		ptr_array_end--;
	}
	for(i = 0; i < 5; i++)
		printf(""%d\t"",array[i]);
	return 0;
}
"
210-13267,medik/lang-hack,C/TheCProgrammingLang/Chapter1/1.3-farcel-float-for.c,11,2,13,1590016.2979959,213601.0,7.440920220410953,1496.0,1465.0,48009.0,18788.0,1636.0,636.0,1354.0,593.0,1500000000,0.0010600108653306,1082014363648.0,0.0138622946521785,0.0631615192299055,"#include <stdio.h>

// Example 1.3 page 13
// Build: cc farcel-float-for.c

int main(int argc, char const *argv[]) {
    float celsius;
    int fahr;

    for (fahr = 0; fahr <= 300; fahr = fahr + 20) {
        celsius = 5.0/9.0 * (fahr - 32.0);
        printf(""%3d %6.1f\n"", fahr, celsius);
    }

    return 0;
}
"
253-9316,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.base/paginate-inferior-exit.c,24,1,14,4501925194.286741,170086.0,26468.522947214937,1153.0,1144.0,38691.0,12795.0,1573.0,585.0,1322.0,544.0,1500000000,3.0012834628578275,1082014363648.0,0.0135049327987018,0.078157168939129,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

static void
after_sleep (void)
{
  return; /* after sleep */
}

int
main (void)
{
  sleep (3);
  after_sleep ();
  return 0;
}
"
064-3032,mattstock/binutils-bexkat1,gdb/testsuite/gdb.base/paginate-inferior-exit.c,24,1,14,4502510650.316254,170086.0,26471.96506473196,1153.0,1144.0,38691.0,12795.0,1573.0,585.0,1322.0,544.0,1500000000,3.001673766877502,1082014363648.0,0.0135049327987018,0.078157168939129,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

static void
after_sleep (void)
{
  return; /* after sleep */
}

int
main (void)
{
  sleep (3);
  after_sleep ();
  return 0;
}
"
080-16143,csitd/c-utils,examples/slowcat.c,22,2,14,1691973.06968265,174984.0,9.669301193251954,1299.0,1278.0,39686.0,13504.0,1622.0,633.0,1342.0,591.0,1500000000,0.0011279820464551,1082014363648.0,0.0147270607598409,0.0787366046249295,"#include <stdio.h>

/* C 2014, MIT license, ""slowcat.c"" C. Graff */
/* Usage:     slowcat [STDIN|FILE(S)] */

void slow_cat(FILE *);
int main ( int argc, char *argv[] )
{
	FILE *fip;
	int c, cntr = 1;

	if ( argc > cntr )  
		while ( cntr < argc )
		{
			fip = fopen( argv[cntr++] , ""r"");
			slow_cat(fip); 
		}
	else	slow_cat(stdin); 

	return 0;
}
void slow_cat(FILE *source)
{
	int c; 
	while ( (c=fgetc(source)) != EOF) 
		putchar(c); 
}

"
140-24320,cyjseagull/SHMA,zsim-nvmain/pin_kit/source/tools/Debugger/watchpoint-app.c,29,1,16,1743379.6310796,173801.0,10.030891651946767,1342.0,1323.0,39408.0,13410.0,1626.0,637.0,1345.0,593.0,1500000000,0.0011622530873864,1082014363648.0,0.0153336286902837,0.079537278957931,"/*NO LEGAL*/

#include <stdio.h>


int A[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int Sum = 0;

int main(int argc, char **argv)
{
    int i;

    /*
     * If there's an argument, print the debugger commands.
     */
    if (argc > 1)
    {
        printf(""monitor watch 0x%lx\n"", (long)&Sum);
        printf(""c\n"");
        printf(""p Sum\n"");
        printf(""c\n"");
        printf(""p Sum\n"");
        printf(""c\n"");
        printf(""p Sum\n"");
        printf(""c\n"");
        printf(""p Sum\n"");
        printf(""q\n"");
        return 0;
    }

    printf(""Hello world\n"");
    for (i = 0;  i < 10;  i++)
        Sum += A[i];

    printf(""Sum is %d\n"", Sum);
    return 0;
}
"
191-33601,totalspectrum/binutils-propeller,gdb/testsuite/gdb.arch/amd64-entry-value-inline.c,41,1,23,1629694.4813802,169079.0,9.635188284766294,1140.0,1130.0,38457.0,12701.0,1566.0,584.0,1317.0,544.0,1500000000,0.0010864629875868,1082014363648.0,0.0134256767546531,0.0784041596622229,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2012-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

static volatile int v;

static __attribute__((noinline, noclone)) void
fn1 (int x)
{
  v++;
}

static int
fn2 (int x, int y)
{
  if (y)
    {
      fn1 (x);
      y = -2 + x;	/* break-here */
      y = y * y * y + y;
      fn1 (x + y);
    }
  return x;
}

__attribute__((noinline, noclone)) int
fn3 (int x, int y)
{
  return fn2 (x, y);
}

int
main ()
{
  fn3 (6, 25);
  return 0;
}
"
254-27187,ForceBru/PyVM,C/src/args.c,8,1,11,2034949.72083705,176068.0,11.557744734988754,1376.0,1354.0,39902.0,13674.0,1667.0,636.0,1348.0,594.0,1500000000,0.0013566331472247,1082014363648.0,0.0155053729240975,0.0792332387636255,"#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char **argv) {
    printf(""Got %d arguments\n"", argc);

    for (int i = 0; i < argc; ++i) {
        printf(""Argument %d: '%s' (addr=0x%08x)\n"", i, argv[i], *(argv + i));
    }

    printf(""USER='%s'\n"", getenv(""USER""));

    return 0;
}
"
030-7985,gauthier-voron/bench-platform,control-payload/param/path/chronometer/t/gomp.c,38,4,13,1785861487.3839543,5368886632.0,0.332631625401771,1346.0,1335.0,40446.0,1342191192.0,1728.0,20972184.0,1453.0,20972141.0,1500000000,1.1905743249226362,1082014363648.0,4.993586536211293e-07,0.0312520617249822,"#include <stdio.h>
#include <stdlib.h>


static void simd(void)
{
	size_t i, len = (1ul << 30);
	char *data = malloc(len);

	printf(""simd : "");
	fflush(stdout);

#pragma omp parallel for
	for (i=0; i<len; i++) {
		data[i] = ((char) i % 256);
		asm ("""" : : : ""memory"");
	}

	printf(""done\n"");

	free(data);
}


static void barrier(void)
{
	size_t i, len = (1ul << 28);
	char *data = malloc(len);

	printf(""barrier : "");
	fflush(stdout);
	
#pragma omp parallel
	{
		for (i=0; i<len/2; i++) {
			data[i] = ((char) i % 256);
			asm ("""" : : : ""memory"");
		}
#  pragma omp barrier
		for (i=len/2; i<len; i++) {
			data[i] = ((char) i % 256);
			asm ("""" : : : ""memory"");
		}
	}

	printf(""done\n"");

	free(data);
}


int main(void)
{
	simd();
	barrier();

	return EXIT_SUCCESS;
}
"
278-33353,1GHL/2014y,use-c-language/p_type.c,27,2,18,1990277.6693925,192629.0,10.332177398003417,1418.0,1393.0,43427.0,15579.0,1700.0,657.0,1358.0,612.0,1500000000,0.001326851779595,1082014363648.0,0.0145928183191523,0.0733315256075653,"#include <stdio.h>
#include <stdlib.h>
#include <mcheck.h>

typedef struct tag{
  char *p;
}tag_t;
typedef tag_t * ptag;
typedef tag_t tag8[8];

int main()
{

  tag_t pa[8];
  tag8 *pp;

  int i=0;

  setenv(""MALLOC_TRACE"",""output.out"",1);
  mtrace();

  for(i=0;i<8;i++)
    {
      printf(""#%d,%p\n"",sizeof(pa[i].p),pa[i].p);
      pa[i].p=(char *)malloc((i+1)*2);

    }
  pp = &pa ;
  

  printf(""@%d,%p\n"",sizeof(pp),pp[1]);
  //  printf(""@%d,%d\n"",sizeof(p),sizeof(p[2]));
  for(i=0;i<8;i++)
    {

      free(pa[i].p);
      pa[i].p=NULL;

    }


  return 0;
}
"
191-29724,EnriqueIzel2/trab_pca,trab_pca/2_lista/q06.c,15,2,9,1904942.9101868998,311586.0,6.113695737292433,1337.0,1317.0,66139.0,30581.0,1624.0,652.0,1346.0,610.0,1500000000,0.0012699619401246,1082014363648.0,0.0085177126058295,0.0437551695616211,"#include <stdio.h>

int mult(int x, int y){
  if(x == 1)
    return y;
  else
    return y + mult(x - 1, y);
}

int main(void){

  for(int i = 1; i <= 10; i++){
    for(int j = 1; j <= 10; j++){
      printf(""%d x %d = %d\n"", j, i, mult(i, j));
    }
    printf(""\n"");
  }
  return 0;
}
"
110-885,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.base/start.c,27,1,14,1582413.21332745,169083.0,9.35879420166427,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010549421422183,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2005-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <stdio.h>

int x;

void bar()
{
  x--;
}

void foo()
{
  x++;
}

int main()
{
  foo();
  bar();
  return 0;
}
"
055-33745,pirix/glibc-pirix,stdlib/testrand.c,44,1,17,2798254.36882665,181562.0,15.412112666747449,1303.0,1283.0,41579.0,13846.0,1632.0,636.0,1353.0,593.0,1500000000,0.0018655029125511,1082014363648.0,0.0142430684834932,0.0760306720793865,"/* Copyright (C) 1992, 1997 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#include <stdlib.h>
#include <stdio.h>

int
main (void)
{
  int i1, i2;
  int j1, j2;

  /* The C standard says that ""If rand is called before any calls to
     srand have been made, the same sequence shall be generated as
     when srand is first called with a seed value of 1."" */
  i1 = rand();
  i2 = rand();
  srand (1);
  j1 = rand();
  j2 = rand();
  if (i1 < 0 || i2 < 0 || j1 < 0 || j2 < 0) {
      puts (""Test FAILED!"");
  }
  if (j1 == i1 && j2 == i2)
    {
      puts (""Test succeeded."");
      return 0;
    }
  else
    {
      if (j1 != i1)
	printf (""%d != %d\n"", j1, i1);
      if (j2 != i2)
	printf (""%d != %d\n"", j2, i2);
      puts (""Test FAILED!"");
      return 1;
    }
}
"
003-25851,hzq1001/or1k-src,sid/component/testsuite/sidcomp.bsp/test-insn.c,11,1,14,3435697.4065303504,15173117.0,0.2263504591706503,1346.0,1326.0,39133.0,13308.0,1612.0,634.0,1337.0,593.0,1500000000,0.0022904649376869,1082014363648.0,0.0001761009290312,0.0796323487347686,"/*
# mach(): all 
# output(): Done*
*/

#ifndef WORKFACTOR
#define WORKFACTOR 25
#endif


int main()
{ 
  /* Use register variables to use memory system very little. */
  register unsigned i, j = 0;
  for (i=0; i<(150000*WORKFACTOR); i++)
    j += i;
  printf (""Done (%d)\n"", j);
  return 0;
}
"
110-31026,ecolitan/learnC,learnCthehardway/ex10.c,19,2,16,2024104.23662505,177126.0,11.427481002224406,1358.0,1337.0,40061.0,13829.0,1628.0,636.0,1346.0,595.0,1500000000,0.0013494028244167,1082014363648.0,0.0152151575714463,0.0780293189831137,"#include <stdio.h>

int main(int argc, char *argv[])
{
    int i = 0;

    // go through each string in argv
    // why am I skipping argv[0]?
    for (i = 1; i < argc; i++) {
        printf(""arg %d: %s\n"", i, argv[i]);
    }

    // let's make our own array of strings
    char *states[] = {
        ""California"", NULL,
        argv[0], ""Texas""
    };
    int num_states = 4;

    for (i = 0; i < num_states; i++) {
        printf(""state %d: %s\n"", i, states[i]);
    }

    return 0;
}
"
283-5136,jessek/colorize,src/test.c,10,2,7,2168512.5539079,546949.0,3.9647425994014074,1273.0,1257.0,197989.0,82334.0,1605.0,697.0,1332.0,655.0,1500000000,0.0014456750359386,1082014363648.0,0.0046256597964344,0.0153002072609097,"#include <stdio.h>

int main(int argc, char **argv)
{
  int count, i;
  for (count = 0 ; count <= 0xff ; ++count)
    {
      for (i = 0 ; i < 27 ; ++i)
	printf (""%c"", count);
    }
  return 0;
}
"
005-9841,splash2077/study,1/task3.c,15,1,12,1912813.517265,243390.0,12.990053001355848,1467.0,1438.0,55288.0,23231.0,1643.0,644.0,1359.0,601.0,1500000000,0.00127520901151,1082014363648.0,0.0119355766465343,0.0540888192666743,"#include <stdio.h>

/*Печать таблицы температур*/

int main(int argc, char ** argv) {
	float fahr, celsius;
	int lower, upper, step;
	
	lower = 0;
	upper = 300;
	step  = 20;
	
	fahr = lower;
	
	printf(""Таблица перевода из fahr в cels\n"");
	
	while (fahr <= upper) {
		celsius = (5.0/9.0) * (fahr - 32);
		printf(""fahr: %7.3f\tcels: %7.3f\n"", fahr, celsius);
		fahr += step;
	}
}	
"
098-15981,danielcabralsilveira/C_code,Factorial_async/fact_async.c,40,1,28,3003403798.327781,253416.0,11851.67391956309,2203.0,1763.0,60022.0,23081.0,2146.0,828.0,1629.0,762.0,1500000000,2.0022691988851875,1082014363648.0,0.0156501562647978,0.0645584395268522,"/*
 * Author: Daniel Cabral Silveira
 *
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

typedef struct _factorialData {
    int number;
    int result;
    void (*callback)(struct _factorialData*);
} FactorialData;

void factorial(void *args) {
    FactorialData *factorialData = (FactorialData*) args;
    void (*callback)(FactorialData*);

    int number = factorialData->number;
    callback = factorialData->callback;

    int num = 1;
    for(int i = 1; i<=number; i++ ) {
        num *= i;
    }

    factorialData->result = num;
    callback(factorialData);

    pthread_exit(NULL);
}

void startThread(FactorialData *data) {
    pthread_t thread_id;
    int thread = pthread_create(&thread_id, NULL,(void *) factorial, (void *) data);
}

void callbackFunction(FactorialData *factorialData) {
    printf(""Factorial is %d\n"", factorialData->result);
}

int main(void) {
    FactorialData *data = malloc(sizeof(FactorialData));

    if(!data) {
        printf(""Failed to allocate memory\n"");
    }

    data->number = 5;
    data->callback = callbackFunction;

    startThread(data);

    sleep(2);

    return 0;
}
"
282-34128,acarno/slicer,valgrind/helgrind/tests/locked_vs_unlocked3.c,44,2,18,1502664499.4504747,184210.0,8155.0227457792735,1388.0,1363.0,42194.0,14734.0,1666.0,687.0,1383.0,645.0,1500000000,1.001776332966983,1082014363648.0,0.0149340426686933,0.0769568577852726,"
/* Needed for older glibcs (2.3 and older, at least) who don't
   otherwise ""know"" about pthread_rwlock_anything or about
   PTHREAD_MUTEX_RECURSIVE (amongst things). */
#define _GNU_SOURCE 1

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <unistd.h>

/* Test of the mechanism for showing all locks held by a thread.  This
   is like locked_vs_unlocked.c, except that it uses a recursively
   lockable lock, and one thread holds the lock more than once.  Point
   is to check that the lock showing mechanism shows the
   lock-number-of-times-held count. */

pthread_mutex_t mx;

int x = 0;

void* child_fn1 ( void* arg )
{
   int r;
   r= pthread_mutex_lock(&mx);  assert(!r);
   r= pthread_mutex_lock(&mx);  assert(!r);
   x = 1;
   r= pthread_mutex_unlock(&mx);  assert(!r);
   r= pthread_mutex_unlock(&mx);  assert(!r);
   sleep(1);
   return NULL;
}

void* child_fn2 ( void* arg )
{
   sleep(1);
   x = 1;
   return NULL;
}

int main ( int argc, char** argv )
{
   int r;
   pthread_t child1, child2;
   pthread_mutexattr_t attr;
   r = pthread_mutexattr_init( &attr );
   assert(!r);
   r = pthread_mutexattr_settype( &attr, PTHREAD_MUTEX_RECURSIVE );
   assert(!r);
   r= pthread_mutex_init(&mx, &attr);  assert(!r);

   r= pthread_create(&child2, NULL, child_fn2, NULL);  assert(!r);
   r= pthread_create(&child1, NULL, child_fn1, NULL);  assert(!r);

   r= pthread_join(child1, NULL);  assert(!r);
   r= pthread_join(child2, NULL);  assert(!r);

   r= pthread_mutex_destroy(&mx);  assert(!r);

   return 0;
}
"
240-19435,rciampa/CST337,hw5/hw54.c,27,1,19,2161894.34286195,172000.0,12.569151162790698,1141.0,1132.0,39287.0,13027.0,1600.0,587.0,1343.0,546.0,1500000000,0.0014412628952413,1082014363648.0,0.0132151162790697,0.0779141338838551,"/*
 * Author: Richard Ciampa
 * Course: CST337
 * Date: 2/20/2016
 */

#include <stdio.h>
#include <string.h>

char nand_gate(char x, char y);

int main(int argc, char *argv[]){

 if(argc == 3 && (strlen(argv[1]) == strlen(argv[2]))){
  
  //We only need the size of one because they are equal   
  size_t argSize = strlen(argv[1]);
  //Print the result
  printf(""Result of NAND: "");
  //Loop through the command line args 
  for(int i = 0; i < argSize; i++){
      printf(""%c"", nand_gate(argv[1][i], argv[2][i]));
  }
  puts(""\n""); 
 }
  return 0;
}

char nand_gate(char x, char y){
  if(x == '1' && y == '1'){
    return '0';
  }else{
    return '1';
  }
}
"
369-17542,yupswing/ansic_examples,examples/system2.c,16,2,10,16615732821.053825,395464.0,42015.79112384439,1427.0,1401.0,94313.0,57340.0,1649.0,641.0,1358.0,598.0,1500000000,11.077155214035884,1082014363648.0,0.0071510933991463,0.027998127303779,"#include <stdio.h>
#define DEL 4

int main() {

	int ii,jj;
	
	system(""clear"");

	printf(""\n"");

	printf(""\n\ncompletato   0%%"");
	fflush(stdout);

	for (ii=1;ii<=100;ii++) {
		for (jj=0;jj<DEL;jj++)
			printf(""%c"",8);
		printf(""%3d%%"",ii);
		system(""sleep 0.1"");
		fflush(stdout);
	}
	printf(""\n"");
	return 0;

}
"
113-24277,hydai/CProgramming,2nd/101062124-pro-2.c,75,6,33,22674797249.841503,1613736.0,14051.11942040086,1697.0,1635.0,406559.0,124157.0,1741.0,697.0,1398.0,650.0,1500000000,15.116531499894336,1082014363648.0,0.0020647739159317,0.0084527317812163,"#include <stdio.h>
#include <unistd.h>
#include <time.h>

#define MAX 15

int get_hour()
{
    int hour;
    time_t timer;
	
   	struct tm *time_ptr;
    
    timer = time(NULL);
	time_ptr = localtime(&timer);
	hour = time_ptr->tm_hour;
    
    return hour;
}

int get_sec()
{
    int sec;
    time_t timer;
	
   	struct tm *time_ptr;
    
	timer = time(NULL);
	time_ptr = localtime(&timer);
	sec = time_ptr->tm_sec;
    
    return sec;
}

int gcd(int max, int min)
{
	int temp;
    
	if(min > max)
	{
		temp = min;
		min = max;
		max = temp;
	}
    
	for( ; (min != 1 ) ; )
	{
		max %= min;
		//swap
		temp = min;
		min = max;
		max = temp;
        
		if( min == 0)
			break;
	}
    
	if( min == 0)
		return max;
	else
		return min;
}

int main()
{
	int nowcounter,counter = MAX;
	int i, space, star;
    
    //build the fib index
	unsigned long long int fib[50];
	fib[0] = 0;
	fib[1] = 1;
	
	for( i = 2 ; i < 50 ; i++)
		fib[i] = fib[i-1] + fib[i-2];


	int fib_counter;
	//print
	for( nowcounter = 0 ; nowcounter < counter ; nowcounter++ )
	{
        system(""clear"");
        
		fib_counter =  get_sec() % 4;

		//fib_counter = ( get_sec() % 4 ) * ( rand() % 3 );
        for( i = 0 ; i <= fib[ fib_counter + 2 ] ; i++)
        {
            for( space = 0 ; space < nowcounter ; space++ )
                printf("" "");
		
			for( star = 0 ; star <= gcd( get_hour(), (get_sec() + 1 ) ); star++ )
                printf(""*"");
            
            printf(""\n"");
        }
        
        usleep(1000000);
	
	}

	system(""clear"");
    printf(""The End of the animation.\n"");

	return 0;
}
"
128-14100,darchons/android-gdb,gdb/testsuite/gdb.trace/ftrace.c,52,2,29,2269249.7586831003,169165.0,13.414411964649895,1142.0,1132.0,38480.0,12717.0,1568.0,585.0,1317.0,546.0,1500000000,0.0015128331724554,1082014363648.0,0.0134424969704135,0.0784420962165751,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2011-2012 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#ifdef SYMBOL_PREFIX
#define SYMBOL(str)     SYMBOL_PREFIX #str
#else
#define SYMBOL(str)     #str
#endif

int globvar;

static void
begin (void)
{}

/* Called from asm.  */
static void __attribute__((used))
func (void)
{}

static void
marker (int anarg)
{
  /* `set_point' is the label at which to set a fast tracepoint.  The
     insn at the label must be large enough to fit a fast tracepoint
     jump.  */
  asm (""    .global "" SYMBOL(set_point) ""\n""
       SYMBOL(set_point) "":\n""
#if (defined __x86_64__ || defined __i386__)
       ""    call "" SYMBOL(func) ""\n""
#endif
       );

  ++anarg;

  /* Set up a known 4-byte instruction so we can try to set a shorter
     fast tracepoint at it.  */
  asm (""    .global "" SYMBOL(four_byter) ""\n""
       SYMBOL(four_byter) "":\n""
#if (defined __i386__)
       ""    cmpl $0x1,0x8(%ebp) \n""
#endif
       );
}

static void
end (void)
{}

int
main ()
{
  begin ();

  for (globvar = 1; globvar < 11; ++globvar)
    {
      marker (globvar * 100);
    }

  end ();
  return 0;
}
"
187-4745,weirdNox/emacs-gdb,testbed.c,60,2,35,6015992023.749277,192730.0,31214.611233331605,1639.0,1544.0,43822.0,16280.0,1671.0,724.0,1370.0,682.0,1500000000,4.010661349166185,1082014363648.0,0.0165153323302028,0.0739908821669828,"#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

typedef struct test {
    int Number;
    union {
        char Letter;
        long AnotherNumber;
    };
} test;

void *threadFunction(void *Vargp) {
    int Id = *(int*)Vargp;
    printf(""Thread %d\n"", Id);
    test TestVariable = {2, 3};
    TestVariable.Number = 10;
    sleep(2);
    return 0;
}

void functionToCall(char *Arg1, int Arg2) {
    if(Arg1) {
        printf(""String: %s\nInteger: %d\n"", Arg1, Arg2);
    }
}

int factorial(int N) {
    if(N > 1) {
        return N*factorial(N-1);
    } else {
        return 1;
    }
}

int main(int ArgCount, char *ArgVal[]) {
    // NOTE(nox): Arguments test
    if(ArgCount > 1) {
        printf(""%d arguments were passed to this program.\n"", ArgCount-1);
        for(int I = 1; I < ArgCount; ++I) {
            printf(""Argument %d: %s\n"", I, ArgVal[I]);
        }
    }

    // NOTE(nox): Threads test
    pthread_t ThreadId;

    pthread_create(&ThreadId, 0, threadFunction, &(int){0});
    pthread_join(ThreadId, 0);

    pthread_create(&ThreadId, 0, threadFunction, &(int){1});
    pthread_join(ThreadId, 0);

    // NOTE(nox): Variable tests
    char SingleLetter = 'a';
    SingleLetter = 'z';

    test TestVariable = {12, .Letter = 'a'};
    TestVariable.Number = 3;
    TestVariable.AnotherNumber = 1891898;

    test *Pointer = 0;
    Pointer = &TestVariable;

    // NOTE(nox): Loop tests
    for(int TestIndex = 0; TestIndex < 10; ++TestIndex) {
        printf(""Index: %d\n"", TestIndex);
    }

    // NOTE(nox): Function call test
    functionToCall(""Hello world"", 4);

    // NOTE(nox): Recursive function tests
    printf(""4! = %d\n"", factorial(4));
    printf(""5! = %d\n"", factorial(5));

    return 0;
}
"
162-3663,baotiao/Asenal,apue/point6.c,23,1,15,2100722.8642701,175947.0,11.939515876940217,1349.0,1329.0,39960.0,13632.0,1641.0,637.0,1356.0,594.0,1500000000,0.0014004819095134,1082014363648.0,0.0152204925346837,0.0788923719958202,"#include<stdio.h>
#include<string.h>
void strcpy1(char *to, char *from)
{
    int len = strlen(to);
    printf(""%d\n"", len);
    char *q = from;
    while (*to != '\0') {
        *q = *to;
        to++;
        q++;
    }
    *q='\0';
    printf(""%s\n"", to);
    return ;
}
int main()
{
    char str1[] = ""hello world"";
    char str2[100];
    strcpy1(str1, str2);
    printf(""%s\n"",str2);
    printf(""%s\n"",str1);
    return 0;
}
"
053-18642,lijunxyz/codedrop,queue/queue_practice.c,52,1,19,2175049.3906437,181068.0,12.012332383413966,1355.0,1334.0,41058.0,14498.0,1633.0,640.0,1353.0,595.0,1500000000,0.0014500329270958,1082014363648.0,0.01485077429474,0.0759773921808625,"#include <stdio.h>
#include <stdlib.h>
#define MAX_QUEUE_SIZE (5)

// Implement queue with array in C

int q[MAX_QUEUE_SIZE];
int head, tail;

void init_queue() {
    head = -1;  // head ""index"" of queue, head+1 is the element to be dequeued
    tail = -1;
}

int is_empty() {
    if (head==tail) return 1;
    else return 0;
}

int is_full() {
    if (tail>=head+MAX_QUEUE_SIZE) return 1;
    else return 0;
}

void enqueue(int val) {
    if (is_full()) printf(""[Error] Cannot enqueue %d: queue is full!\n"", val);
    else {
        tail ++;
        q[tail%MAX_QUEUE_SIZE] = val;
    }
}

void dequeue() {
    if (is_empty()) printf(""[Error] Cannot dequeue: queue is empty!\n"");
    else {
        head++;
    }
}

void print_queue() {
    if (is_empty()) printf(""[Error] Cannot print queue: queue is empty!\n"");
    else {
        int i;
        for (i=head+1; i<=tail; i++)
            printf(""%d, "", q[i%MAX_QUEUE_SIZE]);
        printf(""\n"");
    }
}
int main() {
    init_queue();
    print_queue();
    enqueue(1);
    enqueue(2);
    print_queue();
    enqueue(3);
    enqueue(4);
    enqueue(5);
    enqueue(6);
    print_queue();
    dequeue();
    dequeue();
    print_queue();
}
"
332-21624,mattstock/binutils-bexkat1,gdb/testsuite/gdb.base/randomize.c,19,1,15,1366022.85783735,169083.0,8.079002620015022,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0009106819052249,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2008-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <stdlib.h>
#include <stdio.h>

int main()
{
  void *p;

  p = malloc (1);

  free (p); /* print p */
  return 0;
}
"
262-27002,ataniazov/KOU,Trash/ders/string/ortalama.c,20,2,11,1682223.1700642998,177676.0,9.467924761926202,1428.0,1405.0,40257.0,13935.0,1639.0,637.0,1354.0,595.0,1500000000,0.0011214821133762,1082014363648.0,0.015944753371305,0.0779635370534396,"#include <stdio.h>
// fonksiyonu boyutu belli olan (6 elemanli) bir dizi gonderilmek istenilirse
float dizi_toplam(float d[6]) {
	int i;
	float toplam = 0;
	for (i = 0 ; i < 6 ; i++) {
		toplam += d[i];
	}
	return toplam;
}
int main() {
	int i;
	float kareler[6];
	for (i = 0 ; i < 6 ; i++)
		kareler[i] = i*i;
	float toplam = dizi_toplam(kareler);
	float ortalama = toplam / 6.0;
	printf(""toplam: %f\n"", toplam);
	printf(""ortalama: %f\n"", ortalama);
	return 0;
}
"
057-8220,LastLeaf/srexec,test/extreme/correct.c,10,2,12,61204693.2801603,237094871.0,0.2581443147287652,1432.0,1406.0,58776251.0,36922958.0,173637.0,161899.0,1555.0,25401.0,1500000000,0.0408031288534402,1082014363648.0,1.196989200158615e-05,0.0037878265012618,"#include <stdio.h>
#include <stdlib.h>
#define COUNT 200000
int cmpfunc(const void* p, const void* q){
	return *(int*)p - *(int*)q;
}
int main(){
	int i, a[COUNT];
	for(i=0; i<COUNT; i++) a[i] = rand();
	qsort(a, COUNT, sizeof(int), cmpfunc);
	for(i=0; i<COUNT; i++) printf(""%d\n"", a[i]);
	return 0;
}
"
098-23390,facebook/infer,infer/tests/codetoanalyze/c/frontend/conditional_operator/if_short_circuit.c,42,1,19,1590078.1145319,171791.0,9.252609275223964,1147.0,1138.0,39261.0,12803.0,1635.0,589.0,1323.0,547.0,1500000000,0.0010600520763546,1082014363648.0,0.0133010460385002,0.0786339889366933,"/*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include <stdlib.h>

void shortcircuit_or(int* x) {
  // x = 0;
  if (x == 0 || *x == 2) {
    x = 17;
  } else {
    x = 32;
  };
}

void shortcircuit_and(int* x) {
  if (!x && !(x = getenv(""BLOCK""))) {
    x = 17;
  } else {
    *x = 32;
  };
}

void test_loop() {

  char* spec;
  char* block_size;

  spec = getenv(""BLOCK"");

  while ((!spec && !(spec = getenv(""BLOCK_SIZE"")) &&
          !(spec = getenv(""BLOCKSIZE"")))) {
    block_size = 0;
  }
}

int main() {

  char* spec;
  char* block_size;

  spec = getenv(""BLOCK"");

  if (!spec && !(spec = getenv(""BLOCK_SIZE"")) && !(spec = getenv(""BLOCKSIZE"")))
    block_size = 0;
  else {
    if (*spec == '\'')
      block_size = 0;
  }

  return 0;
}
"
281-30836,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.base/randomize.c,19,1,15,1444081.4265981,169083.0,8.540663461140387,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0009627209510654,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2008-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <stdlib.h>
#include <stdio.h>

int main()
{
  void *p;

  p = malloc (1);

  free (p); /* print p */
  return 0;
}
"
218-13101,mkosola/sp-rtrace,tests/sp-rtrace.modules/memtransfer_test.c,71,2,37,1506481735.5014384,186748.0,8066.922992481847,1316.0,1293.0,42591.0,15361.0,1689.0,715.0,1395.0,618.0,1500000000,1.004321157000959,1082014363648.0,0.0139706984813759,0.0762182495858641,"/*
 * This file is part of sp-rtrace package.
 *
 * Copyright (C) 2010 by Nokia Corporation
 *
 * Contact: Eero Tamminen <eero.tamminen@nokia.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */
/**
 * @file memtransfer_test.c
 *
 * Test application for memory transfer tracking module (memtransfer) coverage.
 */
#define _GNU_SOURCE
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <wchar.h>

void test_multi()
{
	char src[1024] = ""source string"", dst[1024], *ptr;
	int len = strlen(src);

	strcpy(dst, src);
	memcpy(dst, src, len);
	memmove(dst, src, len);
	mempcpy(dst, src, len);
	memset(dst, 0, 100);
	strncpy(dst, src, 5);
	stpcpy(dst, src);
	strcat(dst, src);
	strncat(dst, src, 5);
	bcopy(src, dst, len);
	bzero(dst, 100);
	ptr = strdup(src);
	free(ptr);
	ptr = strndup(src, 5);
	free(ptr);
}

void test_wide()
{
	wchar_t src[1024] = L""source string"", dst[1024], *ptr;
	int len = wcslen(src);
	wmemcpy(dst, src, len);
	wmempcpy(dst, src, len);
	wmemmove(dst, src, len);
	wmemset(dst, 0, 100);
	wcscpy(dst, src);
	wcsncpy(dst, src, 5);
	wcpcpy(dst, src);
	wcpncpy(dst, src, 5);
	wcscat(dst, src);
	wcsncat(dst, src, 5);
	ptr = wcsdup(src);
	free(ptr);
}

int main()
{
	test_multi();
	test_wide();
	
	sleep(1);
	return 0;
}
"
237-20546,jainaman224/Algo_Ds_Notes,Matrix_Operations/C/Matrix_Multiplication.c,39,5,21,1665680.7856633503,181007.0,9.20229604379941,1357.0,1335.0,41063.0,14423.0,1643.0,636.0,1358.0,593.0,1500000000,0.0011104538571089,1082014363648.0,0.0148723530029225,0.0762354467793677,"#include<stdio.h>
 
#define N 3    
  
// multiplies, matrix1[][] and matrix2[][], and  
// stores the result in result[][]
void multiply(int matrix1[][N], int matrix2[][N], int result[][N]) 
{ 
    int i, j, k; 
    for (i = 0; i < N; i++) 
    { 
        for (j = 0; j < N; j++) 
        { 
            result[i][j] = 0; 
            for (k = 0; k < N; k++) 
                result[i][j] += matrix1[i][k] * matrix2[k][j]; 
        } 
    } 
}   

int main() 
{ 
    int i, j; 
    int result[N][N]; 
    int matrix1[N][N] = {{1, 2, 3}, 
                         {4, 5, 6}, 
                         {7, 8, 9}}; 
  
    int matrix2[N][N] = {{1, 2, 3}, 
                         {4, 5, 6}, 
                         {7, 8, 9}};                        
  
    multiply(matrix1, matrix2, result); 
  
    printf(""Result matrix is \n""); 
    for (i = 0; i < N; i++) 
    { 
        for (j = 0; j < N; j++) 
            printf(""%d "", result[i][j]); 
        printf(""\n""); 
    } 
    return 0; 
}

/*Result matrix is
30 36 42
66 81 96
102 126 150*/
"
336-23208,OpenGenus/cosmos,code/data_structures/src/list/Queue_using_Linked_list/Queue_using_Linked_List.c,81,1,21,1655598.0546399,177887.0,9.22741403250378,1342.0,1325.0,40330.0,14098.0,1617.0,636.0,1341.0,593.0,1500000000,0.0011037320364266,1082014363648.0,0.0149926638821274,0.0769273168222238,"#include<stdio.h>
#include <stdlib.h>

struct node
{
    int data;
    struct node *next;
};

struct node * rear=0;
struct node * front=0;

//insertion
void enqueue(int x)
{
    struct node * temp=0;
    temp=(struct node *)malloc(sizeof(struct node));

    if(temp==0)
    {
        printf(""\nQueue Overflow"");
        return;
    }

    temp->data=x;
    temp->next=0;

    if(front==0 && rear==0)
    {
        front=temp;
        rear=temp;
    }

    else
    {
        rear->next=temp;
        rear=temp;
    }
}

//deletion
void dequeue()
{
    if(front==0 && rear==0)
    {
        printf(""\nQueue underflow"");
        return;
    }

    struct node * temp=front;
    temp=(struct node *)malloc(sizeof(struct node));

    if(front==rear)
    {
        front=0;
        rear=0;
    }

    else
    {
        front=front->next;
        free(temp);
    }
}

//printing the elements
void print()
{
    if(front==0 && rear==0)
    {
        printf(""\nQueue underflow"");
        return;
    }

    printf(""\nQueue: "");
    struct node *temp = front;
    while(temp!=0)
    {
        printf(""%d "",temp->data);
        temp=temp->next;
    }
}


int main()
{
    print();
    enqueue(10);
    print();
    enqueue(20);
    enqueue(30);
    print();
    dequeue();
    dequeue();
    print();
    dequeue();

    return 0;
}
"
090-8594,iamwrm/coding,16projects/16115_c_Algorithm/search/test2.c,32,1,22,1499043.3119236499,215759.0,6.945666229450452,1349.0,1328.0,47648.0,18642.0,1627.0,645.0,1345.0,604.0,1500000000,0.0009993622079491,1082014363648.0,0.0124073619176952,0.0636747624076029,"// GNU gcc compiler -std=c11
// Binary search
#include ""stdio.h""
#include ""stdlib.h""
#include ""math.h""

#ifndef MAX
#define  MAX 20
#endif

int search(int *array,int a,int be,int en){

    if (be==en-1)   return be;
    if (array[be]==a)   return be;
    int result;
    int mid;
    mid=(be+en)/2;
    if (array[mid]<a){
        be=mid;
    } else{
        en=mid;
    }
    result=search(array,a,be,en);
    return result;
}

int main(void) {
  int array[MAX]={1,4,6,8,10,13,17,18,24,26,30};

  int index=-1;
 // index=search(array,8,1,18);
 // printf(""%d\n"", index);

  for(int i=0;i<MAX*2;i++){
    index=search(array,i,1,18);
    if (index!=-1){
      printf(""%d's index is %d\n"",array[index],index );
  }
    else{
      printf(""%d can't be found\n"",i );
    }

  }

  return 0;
}
"
254-5743,gaodacheng/bitcode,c/cpp5/sizeof.c,11,1,10,1420443.06267045,180673.0,12.845776624066684,1374.0,1352.0,40800.0,14319.0,1630.0,638.0,1348.0,596.0,1500000000,0.0009469620417803,1082014363648.0,0.015088031969359,0.0764164807053829,"#include <stdio.h>
int main(void)
{
    char * data_type[] = {""int"", ""char"", ""float"", ""double"", ""long""};
    int index;
    printf(""%10s %5s\n"", ""data-type"", ""length"");
    for (index = 0; index < sizeof(data_type)/sizeof(char *); index++)
    {
        printf(""%10s %5d\n"", data_type[index], sizeof(data_type[index]));
    }
    return 0;
}
"
045-18778,JasonVann/ComputerArchitecture,CS61C/L2/Undefined.c,13,1,10,1923469.36091775,176335.0,10.90803867638302,1345.0,1325.0,39936.0,13790.0,1625.0,635.0,1345.0,593.0,1500000000,0.0012823129072785,1082014363648.0,0.0151416338219865,0.0781372147563563,"#include <stdio.h>
#include <stdlib.h>

void undefined_local() {
    int x;  /* undefined */
    printf(""x = %d\n"", x);
}

void some_calc(int a) { 
    a = a%2 ? rand() : -a; 
}
	
int main(void) {
    for (int i=0;  i<5;  i++) {
        some_calc(i*i);
        undefined_local();
    }
}

"
009-20916,livinsunny/alpha,bubble_sort.c,23,3,11,2322395.9142342,179901.0,12.909294556450492,1341.0,1320.0,40719.0,14301.0,1626.0,638.0,1344.0,595.0,1500000000,0.0015482639428228,1082014363648.0,0.0147914686410859,0.0763904034896401,"

#include<stdio.h>

int main()
{
    int a[]={23,45,11,24,67,89,6,3,55,77};
    int size = 9;
    int pass=0,temp=0,comp=0;
    for (pass=1;pass<size;pass++)
    {
        for(comp=0;comp<size-pass;comp++)
        {
            if(a[comp] > a[comp+1])
            {
                temp=a[comp];
                a[comp]=a[comp+1];
                a[comp+1] = temp;
            }
        }
    }
    for (pass =0; pass <10;pass++)
    {
        printf(""%d \n"",a[pass]);
    }
    return 0;
}

"
040-13264,jnuyens/linux-c-programming,1_4_basics/while2.c,10,1,11,30028956749.942158,187144.0,160459.0943284316,1349.0,1329.0,42315.0,15504.0,1622.0,636.0,1343.0,594.0,1500000000,20.01930449996144,1082014363648.0,0.014309836275809,0.0725540047389266,"#include <stdio.h>
#include <unistd.h>

int main(void)
{ 
	int i = 0;    
	while ( i < 20 ) { /* While i is less than 20 */
		printf( ""%d\n"", i );
		i++;             /* Update i with one*/
		sleep(1);
	}
	return 0;
}

"
142-24177,Dimitur-Matev/elsys-c-programming-2013-2014,10G/Radoslav_Kostadinov_23/Homework_1/ascii1.c,7,1,5,2558974.4327589003,385622.0,6.635964753048322,1336.0,1318.0,82945.0,44056.0,1618.0,666.0,1340.0,623.0,1500000000,0.0017059829551726,1082014363648.0,0.0068823874156557,0.0334406815694364,"#include <stdio.h>
int main()
{
  int c;
  for (c=0; c<=255; c++)
    {printf(""%c - %d\n"", c, c);}
  return 0;
}
"
179-29385,alpine9000/BitOS,tests/gcc.c-torture/pr61375.c,24,1,13,1756938.0579515998,169984.0,10.33590220256024,1146.0,1137.0,38666.0,12780.0,1577.0,586.0,1323.0,546.0,1500000000,0.0011712920386344,1082014363648.0,0.0134306758283132,0.078373440111962,"/* { dg-do run } */
#ifdef __UINT64_TYPE__
typedef __UINT64_TYPE__ uint64_t;
#else
typedef unsigned long long uint64_t;
#endif

#ifndef __SIZEOF_INT128__
#define __int128 long long
#endif

/* Some version of bswap optimization would ICE when analyzing a mask constant
   too big for an uint64_t variable (PR210931).  */

__attribute__ ((noinline, noclone)) uint64_t
uint128_central_bitsi_ior (unsigned __int128 in1, uint64_t in2)
{
  __int128 mask = (__int128)0xffff << 56;
  return ((in1 & mask) >> 56) | in2;
}

int
main(int argc, char **argv)
{
  __int128 in = 1;
#ifdef __SIZEOF_INT128__
  in <<= 64;
#endif
  if (sizeof (uint64_t) * __CHAR_BIT__ != 64)
    return 0;
  if (sizeof (unsigned __int128) * __CHAR_BIT__ != 128)
    return 0;
  if (uint128_central_bitsi_ior (in, 2) != 0x102)
    __builtin_abort ();
  return 0;
}
"
123-8196,SanDisk-Open-Source/SSD_Dashboard,uefi/gcc/gcc-4.6.3/gcc/testsuite/gcc.c-torture/execute/pr47337.c,75,4,20,1354279.4622479999,171830.0,7.881504975848222,1144.0,1136.0,38934.0,13135.0,1589.0,603.0,1333.0,563.0,1500000000,0.000902852974832,1082014363648.0,0.0132689285922132,0.0785112062839693,"/* PR rtl-optimization/47337 */

static unsigned int a[256], b = 0;
static char c = 0;
static int d = 0, *f = &d;
static long long e = 0;

static short
foo (long long x, long long y)
{
  return x / y;
}

static char
bar (char x, char y)
{
  return x - y;
}

static int
baz (int x, int y)
{
  *f = (y != (short) (y * 3));
  for (c = 0; c < 2; c++)
    {
    lab:
      if (d)
	{
	  if (e)
	    e = 1;
	  else
	    return x;
	}
      else
	{
	  d = 1;
	  goto lab;
	}
      f = &d;
    }
  return x;
}

static void
fnx (unsigned long long x, int y)
{
  if (!y)
    {
      b = a[b & 1];
      b = a[b & 1];
      b = a[(b ^ (x & 1)) & 1];
      b = a[(b ^ (x & 1)) & 1];
    }
}

char *volatile w = ""2"";

int
main ()
{
  int h = 0;
  unsigned int k = 0;
  int l[8];
  int i, j;

  if (__builtin_strcmp (w, ""1"") == 0)
    h = 1;

  for (i = 0; i < 256; i++)
    {
      for (j = 8; j > 0; j--)
	k = 1;
      a[i] = k;
    }
  for (i = 0; i < 8; i++)
    l[i] = 0;

  d = bar (c, c);
  d = baz (c, 1 | foo (l[0], 10));
  fnx (d, h);
  fnx (e, h);

  if (d != 0)
    __builtin_abort ();
  return 0;
}
"
248-1906,SanDisk-Open-Source/SSD_Dashboard,uefi/gcc/gcc-4.6.3/gcc/testsuite/gcc.c-torture/execute/loop-ivopts-1.c,27,2,16,1712270.8959503998,170411.0,10.047884232825346,1143.0,1135.0,38719.0,12794.0,1582.0,591.0,1326.0,547.0,1500000000,0.0011415139306336,1082014363648.0,0.0133676816637423,0.0785432803370023,"/* From PR 18977.  */
void foo(float * x);

int main()
{
  float x[4];
  foo (x);
  return 0;
}

void foo (float *x)
{
    int i,j,k;
    float temp;
    static float t16[16]={1.,2.,3.,4.,5.,6.,7.,8.,9.,
			  10.,11.,12.,13.,14.,15.,16.};
    static float tmp[4]={0.,0.,0.,0.};

    for (i=0; i<4; i++) {
	k = 3 - i;
	temp = t16[5*k];
	for(j=k+1; j<4; j++) {
	    tmp[k] = t16[k+  j*4] * temp;
	}
    }
    x[0] = tmp[0];
    x[1] = tmp[1];
    x[2] = tmp[2];
    x[3] = tmp[3];
}
"
312-24043,cartman300/picoc,tests/csmith/rand68.c,95,4,17,1890977.9610110999,239106.0,7.908530107985579,1360.0,1339.0,40240.0,15065.0,1620.0,655.0,1342.0,612.0,1500000000,0.0012606519740074,1082014363648.0,0.0112878806888994,0.0764668655636922,"#include <stdio.h>
int print_hash_value = 1;
static void platform_main_begin(void)
{
}
static unsigned crc32_tab[256];
static unsigned crc32_context = 0xFFFFFFFFUL;
static void
crc32_gentab (void)
{
 unsigned crc;
 unsigned poly = 0xEDB88320UL;
 int i, j;
 for (i = 0; i < 256; i++) {
  crc = i;
  for (j = 8; j > 0; j--) {
   if (crc & 1) {
    crc = (crc >> 1) ^ poly;
   } else {
    crc >>= 1;
   }
  }
  crc32_tab[i] = crc;
 }
}
static void
crc32_byte (unsigned char b) {
 crc32_context =
  ((crc32_context >> 8) & 0x00FFFFFF) ^
  crc32_tab[(crc32_context ^ b) & 0xFF];
}
extern int strcmp ( char *, char *);
static void
crc32_8bytes (unsigned val)
{
 crc32_byte ((val>>0) & 0xff);
 crc32_byte ((val>>8) & 0xff);
 crc32_byte ((val>>16) & 0xff);
 crc32_byte ((val>>24) & 0xff);
}
static void
transparent_crc (unsigned val, char* vname, int flag)
{
 crc32_8bytes(val);
 if (flag) {
    printf(""...checksum after hashing %s : %X\n"", vname, crc32_context ^ 0xFFFFFFFFU);
 }
}
static void
platform_main_end (int x, int flag)
{
  if (!flag) printf (""checksum = %x\n"", x);
}
static long __undefined;
void csmith_compute_hash(void);
void step_hash(int stmt_id);
static int g_2 = (-5L);
static short func_1(void);
static short func_1(void)
{
    step_hash(5);
    for (g_2 = 0; (g_2 != (-21)); g_2 -= 7)
    {
        step_hash(4);
        return g_2;
    }
    step_hash(6);
    g_2 = (4294967295UL != g_2);
    step_hash(7);
    return g_2;
}
void csmith_compute_hash(void)
{
    transparent_crc(g_2, ""g_2"", print_hash_value);
}
void step_hash(int stmt_id)
{
    int i = 0;
    csmith_compute_hash();
    printf(""before stmt(%d): checksum = %X\n"", stmt_id, crc32_context ^ 0xFFFFFFFFUL);
    crc32_context = 0xFFFFFFFFUL;
    for (i = 0; i < 256; i++) {
        crc32_tab[i] = 0;
    }
    crc32_gentab();
}
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    csmith_compute_hash();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}
"
238-7551,tendoasan/ProgrammingInC,chapter10/exce5a.c,17,2,9,2352681.1273768498,173133.0,13.588865207672717,1332.0,1314.0,39183.0,13295.0,1618.0,636.0,1340.0,593.0,1500000000,0.0015684540849179,1082014363648.0,0.0152830482923532,0.0797858150081939,"// 编写findString函数，检查一个字符串是否包含另外一个字符串
#include <stdio.h>

int findString(const char source[],const char destination[]){
	int i,j;
	
	for(i = 0; source[i] != '\0'; ++i){
		j = 0;
		while(source[i+j] == destination[j] && destination[j] != '\0')
			++j;
		if(destination[j] == '\0')
			return i;
	}

	return -1;
}

int main(void){
	int findString(const char source[], const char search[]);
	
	printf(""%i"", findString(""a chatterbox"", ""hoat""));
	
	return 0;
}
"
371-31358,matthewelse/british-informatics-olympiad,2015/final/cipher/masked.c,30,3,19,7183137.00053835,3895474.0,1.8439699507685072,1349.0,1325.0,1220577.0,721932.0,2992.0,1720.0,1722.0,1650.0,1500000000,0.0047887580003589,1082014363648.0,0.0006864376453289,0.0041616280799728,"#include <stdio.h>
#include <stdlib.h>
FILE *fin, *fout;

int main(int argc, char** argv) {
	char str[1000000];
	fin = fopen(""input.txt"", ""rb"");
	fout = fopen(""output.txt"", ""wb"");
	
	int i = 0;
	int c; 
	while ((c = fgetc(fin)) != EOF) { 
		str[i] = c;
		i++;
	}
		
	for (int j = 0; j < i; j++) {
		if (str[j] == 'M' || str[j] == 'm') {
			// start of the string...
			int n = 0;
			for (int k = 1; k <= 5; k++) {
				if (str[j+k] < 91) {
					// caps
					n += 1 << (5-k);
				}
			}
			fputc(n+(str[j] == 'M' ? 64 : 96), fout);
			
			j += 5;
		}
		else {
			fputc(str[j], fout);
		}
	}
	
	return 0;
}"
126-13497,seansaville/ProjectEuler,Problem14/problem14.c,22,1,13,267618307.6109736,887105236.0,0.3016759411845022,1342.0,1322.0,39185.0,13307.0,1619.0,636.0,1341.0,593.0,1500000000,0.1784122050739824,1082014363648.0,3.0030259003002887e-06,0.0798026365922426,"#include ""stdio.h""

int collatz(long int n, int length) {
	if (n == 1) {
		return ++length;
	} else if (n % 2 == 0) {
		return collatz(n / 2, ++length);
	} else {
		return collatz(3 * n + 1, ++length);
	}
}

int main() {
	long int i, resultnum = 0;
	int current, longest = 0;

	for (i = 1; i < 1000000; i++) {
		current = collatz(i, 0);
		if (current > longest) {
			longest = current;
			resultnum = i;
		}
	}

	printf(""%ld\n"", resultnum);

	return 0;
}"
374-22426,ccilab/binutils,gdb/testsuite/gdb.base/infcall-input.c,26,1,15,1501933409.9488332,170067.0,8831.421786707591,1152.0,1142.0,38683.0,12795.0,1574.0,589.0,1321.0,547.0,1500000000,1.0012889399658889,1082014363648.0,0.0134888014723608,0.0783052954660243,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2016 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
some_function (void)
{
  /* Sleep a bit to make sure the next command is queued before this
     function returns.  */
  sleep (1);
  return 1;
}

int
main (int argc, char **argv)
{
  some_function ();
  return 0;
}
"
391-465,lilianglaoding/codeprimer,CLab/C_Prog/mystrcpy.c,17,1,12,2188399.6669203,173982.0,12.578306951293811,1294.0,1279.0,39485.0,13405.0,1626.0,634.0,1348.0,591.0,1500000000,0.0014589331112802,1082014363648.0,0.014788886206619,0.0793911892607298,"#include <stdio.h>

char *my_str_cpy(char *dst, char *src)
{
    if (dst == NULL || src == NULL)
        return NULL;

    char *addr = dst;

    while ((*dst++ = *src++))
        ;

    return addr;
}

int main()
{
    char a[8] = {};
    char *b = ""abcde"";

    printf(""%s\n"", my_str_cpy(a, b));
    printf(""\n"");
    return 0;
}
"
083-25260,hzq1001/or1k-src,gdb/testsuite/gdb.base/gdb1821.c,15,1,11,1586193.1024119002,169083.0,9.377767132118546,1142.0,1132.0,38461.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010574620682746,1082014363648.0,0.0134490161636592,0.078503430615556,"/* Test printing of structure member names in gdb. PR exp/1821

   Copyright 2005-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

struct foo { double x__0, y__0, z__1; } bar;


int main(void) { return (int) bar.x__0; }
"
067-12159,Lind-Project/native_client,tests/clock/clock_get_test.c,48,2,28,2007409.5809832,186933.0,10.738655026132358,1385.0,1363.0,42189.0,14997.0,1657.0,643.0,1370.0,600.0,1500000000,0.0013382730539888,1082014363648.0,0.0147004541734204,0.074668625187983,"/*
 * Copyright (c) 2012 The Native Client Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

#include <inttypes.h>
#include <stdio.h>
#include <time.h>

#define DEFERRED_STRINGIFY(symbol) #symbol
#define SHOW(symbol)                                  \
  do {                                                \
    printf(""Current definition for %s is \""%s\"".\n"",  \
           #symbol, DEFERRED_STRINGIFY(symbol));      \
  } while (0)

void ShowCurrentDefinitions(void) {
  SHOW(CLOCK_REALTIME);
  SHOW(CLOCK_MONOTONIC);
  SHOW(CLOCK_PROCESS_CPUTIME_ID);
  SHOW(CLOCK_THREAD_CPUTIME_ID);
}

struct timespec;

/*
 * Basic functionality test: the syscalls are present.
 */
int TimeTest(int (*func)(clockid_t clk_id, struct timespec *ts),
             clockid_t clk_id,
             char const *error_string,
             char const *success_name) {
  struct timespec       ts;

  if (0 != (*func)(clk_id, &ts)) {
    fprintf(stderr, ""%s\n"", error_string);
    return 1;
  }
  printf(""%30s: %lld.%09lu\n"", success_name,
         (int64_t) ts.tv_sec, (unsigned long) ts.tv_nsec);
  return 0;
}

int main(void) {
  int errs = 0;

  ShowCurrentDefinitions();

  errs += TimeTest(clock_getres, CLOCK_REALTIME,
                   ""clock_getres on realtime clock failed"",
                   ""Realtime clock resolution"");
  errs += TimeTest(clock_getres, CLOCK_MONOTONIC,
                   ""clock_getres on monotonic clock failed"",
                   ""Monotonic clock resolution"");
  errs += TimeTest(clock_gettime, CLOCK_REALTIME,
                   ""clock_gettime on realtime clock failed"",
                   ""Realtime clock value"");
  errs += TimeTest(clock_gettime, CLOCK_MONOTONIC,
                   ""clock_gettime on monotonic clock failed"",
                   ""Monotonic clock value"");
  return errs;
}
"
131-8422,danielpontello/sorting-performance,heap.c,65,5,24,6465490.6746,24151437.0,0.2677062238574044,1326.0,1306.0,5477093.0,2633870.0,33032.0,658.0,13756.0,606.0,1500000000,0.0043103271164,1082014363648.0,0.000108979022656,0.0059243273579228,"#include<stdio.h>
#include<stdlib.h>
#include<time.h>

#define QUANTIDADE 200000

void heapsort(int array[], int n)
{
 int i,t;
 
 heapify(array,n);
 
 for(i=n-1 ; i>0 ; i--)
 {
  t = array[0];
  array[0] = array[i];
  array[i] = t;
  adjust(array,i);
 }
}
 
 
void heapify(int array[], int n)
{
 int item,i,j,k;
 
 for(k=1 ; k<n ; k++)
 {
  item = array[k];
  i = k;
  j = (i-1)/2;
 
  while( (i>0) && (item>array[j]) )
  {
   array[i] = array[j];
   i = j;
   j = (i-1)/2;
  }
  array[i] = item;
 }
}
 
void adjust(int array[], int n)
{
 int item,i,j;
 
 j = 0;
 item = array[j];
 i = 2*j+1;
 
  while(i<=n-1)
 {
  if(i+1 <= n-1)
   if(array[i] < array[i+1])
    i++;
  if(item < array[i])
  {
   array[j] = array[i];
   j = i;
   i = 2*j+1;
  }
  else
   break;
 }
 array[j] = item;
}


int main()
{
    int vetor[QUANTIDADE];
    int i, alea, qtd=0;
    
    srand(time(NULL));
    
    for(i=0; i<QUANTIDADE; i++)
    {
        alea = rand()%1000000;
	// vetor[i] = alea;
    }    

    printf(""Executando HeapSort...\n"");
    heapsort(vetor, QUANTIDADE);
    return 0;
}
"
122-14235,totalspectrum/binutils-propeller,gdb/testsuite/gdb.stabs/gdb11479.c,60,2,29,1444653.1422434999,169057.0,8.545360440561467,1139.0,1129.0,38452.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.000963102094829,1082014363648.0,0.0134155935572026,0.0785172440760147,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2010-2017 Free Software Foundation, Inc.

   Contributed by Pierre Muller.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

   Qualifiers of forward types are not resolved correctly with stabs.  */

struct dummy;

enum dummy_enum;

/* This function prevents the compiler from dropping local variables
   we need for the test.  */
void *hack (const struct dummy *t, const enum dummy_enum *e);

const void *
test (const struct dummy *t)
{
  const struct dummy *tt;
  enum dummy_enum *e;
  tt = t;
  return hack (t, e);
}

void *
test2 (struct dummy *t)
{
  struct dummy *tt;
  const enum dummy_enum *e;
  tt = t;
  return hack (t, e);
}


struct dummy {
 int x;
 int y;
 double b;
} tag_dummy;

enum dummy_enum {
  enum1,
  enum2
} tag_dummy_enum;

void *
hack (const struct dummy *t, const enum dummy_enum *e)
{
  return (void *) t;
}

int
main ()
{
  struct dummy tt;
  tt.x = 5;
  tt.y = 25;
  tt.b = 2.5;
  test2 (&tt);
  test (&tt);
  return 0;
}
"
026-32605,AndrewLaing/CHowToProgramExercises,Chapter3/ex03_40.c,23,1,17,2083504.6889259,190912.0,10.913426081126383,1304.0,1288.0,44042.0,16861.0,1620.0,637.0,1342.0,595.0,1500000000,0.0013890031259506,1082014363648.0,0.0135769359704994,0.0688636027781882,"/*
 * Filename:    ex03_40.c
 * Author:      Andrew Laing
 * Email:       parisianconnections@gmail.com
 * Date:        16/04/2017
 */

#include <stdio.h>


int main()
{
    int i = 1;
    int addSpace = 1;
    
    while(i<=64)
    {
        printf(""* "");
    
        if(i%8==0) {
            printf(""\n"");
            addSpace++;
    
            if(addSpace%2==0)
                printf("" "");
        }
        i++;   
    }
    
    return 0;
}
"
206-28020,danadorneanu/portofolio,kr/knr_3_5.c,40,2,23,2593712.88120735,175245.0,14.800490741533284,1356.0,1335.0,39682.0,13523.0,1629.0,637.0,1350.0,594.0,1500000000,0.0017291419208049,1082014363648.0,0.0153556449542069,0.0791279015130157,"#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>

#define LEN 12
#define MININT -2147483648;

void itob(int n, char s[],int base);
void reverse( char s[]);

int main(void)
{
   int ret = 0;
   int n =  -31;
   char s[LEN + 1];
   int base = 16;

   itob (n, s, base);
   reverse (s);
   printf(""\n The value of the 10 base number %d in hex is %s"", n, s);

   return ret;
}

void itob(int n, char s[], int base)
{
   int i = 0, sign = 0;

   sign = n;

   do
   {
      int digit = abs(n - (n/base)*base) + '0';
      if (digit > '9') 
         digit += 7;
      s[i++] = digit;
   }
   while ((n /= base));

   if (sign < 0)
      s[i++] = '-'; 
   s[i] = '\0';
}

void reverse(char s[])
{
   int c = 0;
   int i = 0;
   
   for (i = 0; i < strlen(s) / 2; i++)
   {
      c = s[i];
      s[i] = s[strlen(s) - i - 1];
      s[strlen(s) - i - 1] = c; 
   }
}


"
268-30454,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.python/py-objfile-script.c,30,1,17,1690039.6440177,169061.0,9.99662252086525,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0011266930960118,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2011-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

struct ss
{
  int a;
  int b;
};

void
init_ss (struct ss *s, int a, int b)
{
  s->a = a;
  s->b = b;
}

int
main ()
{
  struct ss ss;

  init_ss (&ss, 1, 2);

  return 0;      /* break to inspect struct and union */
}
"
278-16145,milekb/Laboratorium-2016-2017,LAB3/zad4.c,31,3,21,1772173.56394965,899180.0,1.9708767988611848,1484.0,1457.0,180033.0,106684.0,1644.0,699.0,1359.0,656.0,1500000000,0.0011814490426331,1082014363648.0,0.0032707578015525,0.0151996568044448,"#include <stdio.h>
int main()
{
  float x = 1.0;
  double x1 = 1.0;
  long double x2 = 1.0;
  int l=1;

  printf(""Float:\n"");
  while(1.0+x>1.0)
  {
    x=x/2.0;
    printf(""%i. %f >> %e\n"", l, x, x);
    l++;
  }

  l=1;
  printf(""Double:\n"");
  while(1.0+x1>1.0)
  {
    x1=x1/2.0;
    printf(""%i. %f >> %e\n"", l, x1, x1);
    l++;
  }

  l=1;
  printf(""Long double:\n"");
  while(1.0+x2>1.0)
  {
    x2=x2/2.0;
    printf(""%i. %Lf >> %Le\n"", l, x2, x2);
    l++;
  }
  return 0;
}"
075-12551,paramsingh/codechef-solutions,src/practice/numbers/euler/12.c,32,4,14,1481647014.1522586,1574614909.0,0.9409583292596654,1355.0,1348.0,80119205.0,251042307.0,5039803.0,168280829.0,657316.0,37785581.0,1500000000,0.9877646761015058,1082014363648.0,1.7166101911969132e-06,0.639456945709319,"#include <stdio.h>
#include <stdlib.h>
#define MAX 80000000

int main(void) {
    int* seive = (int *) calloc(MAX, sizeof(int));
    int i, j;
    for (i = 2; i < MAX; i++) {
        if (seive[i] == 0) {
            for (j = i; j < MAX; j+=i)
                seive[j] = i;
        }
    }
    long long int sum = 1;
    long long int factors = 1;
    for (i = 2; i < MAX; i++) {
        sum += i;
        long long int x = sum;
        int prev = seive[x], count = 1;
        int val = 1;
        while (x != 1) {
            x /= seive[x];
            if (seive[x] == prev)
                count++;
            else {
                val *= count + 1;
                count = 1;
            }
            prev = seive[x];
        }
        if (val > 500) {
            printf(""%lld\n"", sum);
            break;
        }
    }
}
"
234-10744,totalspectrum/binutils-propeller,gdb/testsuite/gdb.python/py-bad-printers.c,44,1,29,1644318.10844685,169062.0,9.726124143805231,1140.0,1130.0,38452.0,12697.0,1567.0,589.0,1316.0,548.0,1500000000,0.0010962120722979,1082014363648.0,0.0134270267712436,0.078593911904436,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2008-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* This lets us avoid malloc.  */
int array[100];

struct container
{
  const char *name;
  int len;
  int *elements;
};

struct container
make_container (const char *name)
{
  struct container result;

  result.name = name;
  result.len = 0;
  result.elements = 0;

  return result;
}

void
add_item (struct container *c, int val)
{
  if (c->len == 0)
    c->elements = array;
  c->elements[c->len] = val;
  ++c->len;
}

int
main ()
{
  struct container c = make_container (""foo"");

  add_item (&c, 23);

  return 0; /* break here */
}
"
130-12273,tykowale/learningC,ProgrammingInC/chapter11/ex11.c,17,1,15,2126838.08058495,174031.0,12.221029586682832,1342.0,1322.0,39440.0,13398.0,1626.0,636.0,1345.0,594.0,1500000000,0.0014178920537233,1082014363648.0,0.0153076176083571,0.0795071728680116,"/*Function to sum the elements of an integer array*/

#include <stdio.h>

int array_sum (int array[], const int n)
{
    int sum = 0, *ptr;
    int * const array_end = array + n;

    for ( ptr = array; ptr < array_end; ++ptr ) {
        sum += *ptr;
    }

    return sum;
}

int main (void)
{
    int array_sum (int array[], const int n);
    int values[] = { 3, 7, -9, 3, 6, -1, 7, 9, 1, -5 };

    printf (""The sum is %i\n"", array_sum(values, 10));

    return 0;
}

"
062-916,Nuist-319/trashwork,rabitdash/c-pj/archive/consoleArgs.c,7,1,5,1558651.565574,170090.0,9.163683932035982,1142.0,1132.0,38720.0,12787.0,1582.0,590.0,1326.0,547.0,1500000000,0.001039101043716,1082014363648.0,0.0133693926744664,0.0785330149300095,"#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
	int counter;
	for(counter = 1;counter < argc;counter++){
		printf(""Argument%d:  %s\n"",counter,argv[counter]);
	}
	return 0;
}
"
269-28028,totalspectrum/binutils-propeller,gdb/testsuite/gdb.dwarf2/dw2-undefined-ret-addr.c,29,2,14,1525277.97035865,169080.0,9.02103737875562,1142.0,1132.0,38460.0,12696.0,1566.0,584.0,1317.0,544.0,1500000000,0.0010168519802391,1082014363648.0,0.0134492547906316,0.0784072249589491,"/*
   Copyright 2013-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

void
stop_frame ()
{
  /* The debug information for this frame is modified in the accompanying
     .S file, to mark the return address as undefined.  */
}

void
first_frame ()
{
  stop_frame ();
}

int
main ()
{
  first_frame ();

  return 0;
}
"
246-23443,cojocar/bin2llvm,tests/tests/switch-table/switch-statement.armle.c,26,1,17,1591578.1259536499,169252.0,15.359209935480822,1146.0,1136.0,38516.0,12696.0,1568.0,584.0,1318.0,544.0,1500000000,0.0010610520839691,1082014363648.0,0.0134828539692293,0.0783800671717566,"int call_me(int, char **);

int
main(int argc, char *argv[])
{
	call_me(argc-1, argv);
	switch (argc) {
	case 0: call_me(argc-1, argv); break;
	case 1: call_me(argc+1, argv); break;
	case 2: call_me(argc-2, argv); break;
	case 3: call_me(argc-5, argv); break;
	case 4: call_me(argc+3, argv); break;
	case 5: call_me(argc+2, argv); break;
	default:
			break;
	}
	return 0;
}

int
call_me(int x, char *p[])
{
	char *a = p[x];
	char *orig_a = a;
	while (*a)
		++a;
	return (int)a-(int)orig_a;
}
"
035-31508,LorhanSohaky/UFSCar,2019/SO1/03-threads/01.c,35,1,24,1561025741.7429237,236475.0,6601.229478803256,1616.0,1555.0,54054.0,23984.0,2008.0,1816.0,1459.0,1684.0,1500000000,1.040683827828616,1082014363648.0,0.0134094513162067,0.0892770188882339,"/*
 Ideia: Criar processos e ver a ordem de criação e depois criar processos de modo a forçar a criação de forma ordenada.
 
*/

#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

#define MAX 10

void *desordenado(void *valor){
	printf(""Thread desordenada %d\n"", *((int *)valor));
	return NULL;
}

void criar_threads_de_qualquer_forma(){
	pthread_t thrs[MAX];
	for(int i = 0; i < MAX; i++){
		pthread_create(&thrs[i], NULL, desordenado, &i);
	}

}

void *criar_threads_de_forma_ordenada(void *quantidade){
	int valor = *((int *)quantidade);
	printf(""Thread %d\n"",valor);

	pthread_t thr;
	if(valor == MAX){
		return NULL;
	}

	valor++;

	pthread_create(&thr, NULL, criar_threads_de_forma_ordenada, &valor);
	pthread_join(thr, NULL);

	return NULL;
}

int main(){
	int min = 1;
	criar_threads_de_qualquer_forma();
	sleep(1); // Somente para aguardar que a função acima termine de criar todas as threads
	criar_threads_de_forma_ordenada(&min);
	return 0;
}

/*
 Conclusão: Para garantir que uma thread execute numa sequência determinada, é necessário encadear a criação das threads.
*/
"
151-1596,tudinfse/fex,src/micro/funccalls/funccalls.c,19,1,18,3513000955.4559364,8590108517.0,0.4089588563459588,1343.0,1336.0,1073781242.0,2147497077.0,1676.0,16777874.0,1418.0,16777834.0,1500000000,2.3420006369706243,1082014363648.0,3.1187033256893137e-07,0.0104178523793056,"/* stress metadata propagation on func calls */
#include <stdio.h>
#include <stdlib.h>

// 1GB size
#define SIZE 1024*1024*1024

__attribute__((noinline)) 
void dummywrite(char* arr, int i) {
  arr[i] = (char) i;  
}

__attribute__((noinline)) 
void arraywrite(char* arr) {
  int i = SIZE-1, r=0;
  for (; i >= 0; i--) {
    dummywrite(arr, i);
  }
}

int main(int argc, char **argv) {
  char* arr = (char*) malloc(SIZE);
  arraywrite(arr);
  printf(""r = %d\n"", arr[0]);
  return 0;
}
"
301-15654,ccilab/binutils,gdb/testsuite/gdb.base/new-ui-pending-input.c,19,1,13,3002212377.14868,170106.0,17649.06809283623,1153.0,1144.0,38692.0,12795.0,1574.0,585.0,1322.0,544.0,1500000000,2.0014749180991203,1082014363648.0,0.0135033449731343,0.0781750733194787,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2016 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <unistd.h>

int
main (void)
{
  sleep (2);
  return 0; /* set breakpoint here */
}
"
215-2077,Leo-Souto/physics-simulations,chapter-7/box5.c,20,1,18,29791924.520395648,154996344.0,0.1922104949778686,1404.0,1376.0,29473272.0,18692465.0,1647.0,772.0,1357.0,729.0,1500000000,0.0198612830135971,1082014363648.0,1.793590692694016e-05,9.353121701428548e-05,"#include <stdio.h>
#include <math.h>
#include <time.h>
#include <stdlib.h>
#define pi M_PI
#define inf INFINIT
#define N 800

int main(void)
{
	int nleft = N, t = 0;
	double r, error_bar, error = 0, sigma;
	FILE *graf;
	graf = fopen(""graf5.dat"", ""w"");

	srand(time(NULL));
	while (t < 100000){
		r = rand()*1.0/RAND_MAX;
		if (r <= 0.5 & nleft > 0){
			nleft--;
		}
		else if (r >= .5 & (N - nleft) > 0){
			nleft++;
		}
		t++;
		fprintf(graf, ""%d\t %d\t %d\n"", t, nleft, N - nleft); /*to plot in gnuplot use this command: plot 'graf5.dat' u 1:2 w l, '' u 1:3 w l*/
		
	}
	return 0;
}
"
354-12170,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.python/py-frame-args.c,45,1,20,1592929.3585941,169061.0,9.422214466967544,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010619529057294,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2013-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <string.h>

struct s
{
  int m;
};

struct ss
{
  struct s a;
  struct s b;
};

void
init_s (struct s *s, int m)
{
  s->m = m;
}

void
init_ss (struct ss *s, int a, int b)
{
  init_s (&s->a, a);
  init_s (&s->b, b);
}

void
foo (int x, struct ss ss)
{
  return; /* break-here */
}

int
main ()
{
  struct ss ss;

  init_ss (&ss, 1, 2);

  foo (42, ss);

  return 0;
}
"
013-1096,mattstock/binutils-bexkat1,gdb/testsuite/gdb.base/hook-stop.c,29,1,16,1567893.3123126002,169083.0,9.18705606122437,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010452622082084,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2009-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

void
func (void)
{
  int a;

  a = 1; /* set breakpoint here */
  a = 2;
}

int
main (int argc, char **argv)
{
  int i;

  i = 1;
  i = 2;
  i = 3;
  func ();

  return 0;
}
"
292-18502,Eddyding/C,niukewang/time_diff2.c,15,1,16,6001168365.008198,208458576.0,28.788301638403208,1349.0,1329.0,46324920.0,13899112.0,1633.0,638.0,1352.0,593.0,1500000000,4.000778910005465,1082014363648.0,1.2846677029972612e-05,7.000527629900302e-05,"#include<stdio.h>
#include<time.h>

int
main()
{
    long	int b;

	b = clock()/CLOCKS_PER_SEC; // 0
	printf(""b is %ld,CLOCKS_PER_SEC is %ld\n"",b,CLOCKS_PER_SEC);
	for(int i = 0; i < 5;++i )//延时5s
	{
//		i = i - b;
		i = clock()/CLOCKS_PER_SEC;
//		printf(""i is %d\n"",i);
	}
	printf(""over\n"");
	return 0;
}
"
176-18338,ferreiro/C,Scheduling/Examples/PartialSum/partial_sum.c,23,1,18,2910904.3534845,301940.0,9.640670331854013,2238.0,1772.0,61938.0,24281.0,2182.0,881.0,1640.0,799.0,1500000000,0.001940602902323,1082014363648.0,0.0132807842617738,0.0638142404806365,"#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

int total_sum = 0;
void * partial_sum(void * arg) {
  int j = 0;
  int ni=((int*)arg)[0];
  int nf=((int*)arg)[1];

  for (j = ni; j <= nf; j++)
    total_sum = total_sum + j;

  pthread_exit(0);
}

int main(void) {
  pthread_t th1, th2;
  int num1[2]={  1,   4999};
  int num2[2]={5000, 10000};

  /* Two threads are created */
  pthread_create(&th1, NULL, partial_sum, (void*)num1);
  pthread_create(&th2, NULL, partial_sum, (void*)num2);

  printf(""The main thread continues running\n"");

  /* the main thread waits until both threads complete */
  pthread_join(th1, NULL);
  pthread_join(th2, NULL);

  printf(""total_sum=%d and it should be 50005000\n"", total_sum);

  return 0;
}
"
112-5269,timmontague/euler-solutions,001/multiples.c,13,1,12,1733359.4150840999,182609.0,9.492188227305336,1338.0,1319.0,39182.0,13307.0,1618.0,636.0,1340.0,593.0,1500000000,0.0011555729433894,1082014363648.0,0.0145502138448816,0.079769094476938,"/*
 * Sum all numbers below 1000 that are multiples of 3 and 5
 */
#include <stdio.h>
int main(int argc, const char *argv[]) {
	int sum = 0;
	int i;
	for (i = 0; i < 1000; i++) {
		if (i%5 == 0 || i%3 == 0)
			sum += i;
	}
	printf(""%d\n"",sum);
	return 0;
}
"
088-11007,metalx1000/My-Vim-Setup,skeleton/gcc/chello.c,7,1,9,4872082.49978715,175636.0,27.739654740486007,1389.0,1366.0,39799.0,13701.0,1628.0,642.0,1348.0,598.0,1500000000,0.0032480549998581,1082014363648.0,0.0156858502812635,0.078803738317757,"#include<stdlib.h>
#include<stdio.h>

int main(){
  char msg1[] = ""World"";
  //printf(""Content-type: text/plain\n\n"");//for cgi-bin
  printf(""Hello %s\n"",msg1);
  system(""ls /"");
  return 0;
}
"
071-24863,acarno/slicer,valgrind/helgrind/tests/bar_trivial.c,35,2,20,1503254045.8487346,184107.0,8165.1107508133855,1523.0,1492.0,42071.0,14771.0,1678.0,694.0,1380.0,649.0,1500000000,1.0021693638991565,1082014363648.0,0.0163763463637993,0.0774251433798951,"
/* This is the most trivial test I could think of that involves
   barriers.  If H fails to notice the pthread_barrier_wait call then
   it will report a race.  Correct behaviour is not to report a race
   (there isn't one.) */
#define _GNU_SOURCE
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <unistd.h>

int x = 0;

pthread_barrier_t bar;

void* child_fn ( void* arg )
{
   long r, n = (long)arg;

   if (n == 1) x++;

   r = pthread_barrier_wait(&bar); 
   assert(r == 0 || r == PTHREAD_BARRIER_SERIAL_THREAD);

   if (n == 0) x++;

   sleep(1); /* ensure both threads get to this point before
                either exits. */
   return NULL;
}

#define NTHR 2

int main ( void )
{
   long i, r;
   pthread_t thr[NTHR];

   r = pthread_barrier_init(&bar, NULL, NTHR);
   assert(!r);

   for (i = 0; i < NTHR; i++) {
      r = pthread_create(&thr[i], NULL, child_fn, (void*)i);
      assert(!r);
   }

   for (i = 0; i < NTHR; i++) {
      r = pthread_join(thr[i], NULL);
      assert(!r);
   }

   r = pthread_barrier_destroy(&bar); assert(!r);

   printf(""x = %d\n"", x);
   return 0;
}
"
079-14993,rpereira-dev/ENSIIE,UE/S1/SYS/flux/exo1/test.c,7,1,6,2671264.69407225,173348.0,15.409834552460946,1351.0,1330.0,39226.0,13335.0,1618.0,636.0,1340.0,593.0,1500000000,0.0017808431293815,1082014363648.0,0.0154659990308512,0.0796598238237476,"#include <stdio.h>

int main(int argc, char ** argv) {
	int i;
	for (i = 0 ; i < argc ; i++) {
		printf(""%d : %s\n"", i, argv[i]);
	}
	return (0);
}
"
108-7127,IIFrm/IIF,test/untested/cav13cbench/dillig/12.c,41,2,17,1868164.5160540498,169069.0,11.045508047010392,1141.0,1131.0,38459.0,12696.0,1568.0,585.0,1318.0,546.0,1500000000,0.0012454430107027,1082014363648.0,0.0134383003389148,0.0785260482846251,"int unknown1(){
    int x; return x;
}

int unknown2(){
    int x; return x;
}



int main()
{
  int flag = unknown1();
  int t = 0;
  int s = 0;
  int a = 0;
  int b = 0;
  int x,y;
  while(unknown1()){
    a++;
    b++;
    s+=a;
    t+=b;
    if(flag){
      t+=a;
    }
    t = t;
  } 
  //2s >= t
  x = 1;
  if(flag){
    x = t-2*s+2;
  }
  //x <= 2
  y = 0;
  while(y<=x){
    if(unknown2()) 
       y++;
    else 
       y+=2;
    y = y;
  }
  if(y >= 5)
  {goto ERROR; ERROR:;}
}

"
343-3032,cyumeng/CPrimerPlus,practice.6.1.c,18,2,14,2046333.043836,186065.0,10.997946954021444,1334.0,1316.0,42281.0,15555.0,1632.0,638.0,1349.0,594.0,1500000000,0.001364222029224,1082014363648.0,0.0142423346679923,0.0728439034511377,"/* Write a program that creates an array with 26 elements and stores
   the 26 lowercase letters in it. Also have it show the array contents.
*/
#include <stdio.h>
int main(void)
{
	char charArr[26];
	char start = 'a';
	int i;

	// assign values to the array 
	for (i = 0; i < 26; i++)
		charArr[i] = start + i;

	// show array
	printf(""[ "");
	for (i = 0; i < 26; i++)
		printf(""%c "", charArr[i]);
	printf(""]\n"");

	return 0;
}
"
280-16725,rgehring/c_problems,c9/p2.c,56,5,24,1809902.95484655,195373.0,9.26382867642919,1348.0,1323.0,43675.0,15196.0,1657.0,637.0,1371.0,595.0,1500000000,0.0012066019698977,1082014363648.0,0.0136712851827018,0.0723616041854223,"// anagram sort
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

const int MAX_STRING = 10 ;

void insertionSort(char *str) {
  int i, j;
  char temp ;
  for (i=0; i< MAX_STRING; i++) {
    if (str[i] == '\0') {
      break;
    }
    for (j=0; j< i; j++) {
      if (str[i] < str[j]) {
        temp = str[j] ;
        str[j] = str[i] ;
        str[i] = temp ;
      }
    }
  }
  
}

int compareViaAnagram(char *str1, char *str2) {
  insertionSort(str1); 
  insertionSort(str2); 
  return strcmp(str1, str2) ;
}

void anagramSort( char *strArray ) {
  int i, j;
  char temp[MAX_STRING] ;
  for (i=0; i< 10; i++) {
    for (j=0; j< i; j++) {
      if (compareViaAnagram(&strArray[i*MAX_STRING], &strArray[j*MAX_STRING]) <= 0) {
        strcpy(temp, &strArray[j*MAX_STRING]);
        strcpy(&strArray[j*MAX_STRING], &strArray[i*MAX_STRING]);
        strcpy(&strArray[i*MAX_STRING], temp);
      }
    }
  }

}

int main() {
  int i;
  char strArray[10][MAX_STRING] ;
  strcpy(strArray[0], ""cat"");
  strcpy(strArray[1], ""gra"");
  strcpy(strArray[2], ""cat"");
  strcpy(strArray[3], ""catcher"");
  strcpy(strArray[4], ""bird"");
  strcpy(strArray[5], ""cats"");
  strcpy(strArray[6], ""drib"");
  strcpy(strArray[7], ""scat"");
  strcpy(strArray[8], ""arg"");
  strcpy(strArray[9], ""tac"");


  
  anagramSort( *strArray) ;
  
  printf(""\n"");
  for (i=0; i<10; i++) {
    printf(""%s "", strArray[i]);
  }
  printf(""\n"");
}



"
331-9783,kbrose/project_euler,p90-99/p94.c,33,1,25,842568174.0045547,7732224728.0,0.1089684021920476,1339.0,1320.0,39328.0,13416.0,1619.0,637.0,1342.0,594.0,1500000000,0.5617121160030365,1082014363648.0,3.438855043065686e-07,0.0794782344911269,"#include <stdio.h>

int main()
{
  unsigned long int curr_square, curr_sqrt, a, b, two_a, test1, test2, sum;
  int num_of_times = 0;
  curr_square = 0;
  curr_sqrt = 0;
  sum = 0;

  for (a = 0; a < 333333334; a++){
    two_a = a << 1;
    test1 = (3 * a * a) - two_a - 1;
    test2 = test1 + (two_a << 1);
    if (curr_square < test1){
      curr_sqrt++;
      curr_square = curr_sqrt * curr_sqrt;
    }
    if (curr_square == test1){
      sum += (a << 1) + a + 1;
      num_of_times++;
    }

    if (curr_square < test2){
      curr_sqrt++;
      curr_square = curr_sqrt * curr_sqrt;
    }
    if (curr_square == test2){
      if (a != 1){
	sum += (a << 1) + a - 1;
      }
      num_of_times++;
    }
  }
  printf(""sum: %lu\n"", sum);
  printf(""number of triangles: %d\n"", num_of_times);
}
"
382-25640,frdeso/dyninst-sandbox,suspect.c,73,1,27,7502545993.658714,196165.0,38246.09891163051,1471.0,1448.0,44159.0,16358.0,1653.0,642.0,1366.0,599.0,1500000000,5.001697329105809,1082014363648.0,0.0148803303341574,0.0703934431647305,"#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>


void __attribute__((noinline))
ottawa(void)
{
    	printf(""no arg\n"");
	return;
}

void __attribute__((noinline))
quebec(int a)
{
    	printf(""%d"",a);
	return;
}

void __attribute__((noinline))
rimouski(int a, float b)
{
    	printf(""*%d , %f\n"",a,b);
	return;
}

int  __attribute__((noinline))
getAnswer(int a, char b)
{
    	printf(""."");
	return 42;
}

void awesome(char *a, char *b)
{
    	printf(""."");
	return;
}

void beauce(int a, char *b)
{
    	printf(""."");
	return;
}

void __attribute__((noinline))
 montreal(int a, char *b, char c)
{
    	printf(""."");
	return;
}
void __attribute__((noinline))
sherbrook(int a, char *b, char c, void *d)
{
    	printf(""%d .%s, %c, %p\n"", a,b,c,d);
	return;
}
void print(int a, short b,char c, char *d, int *e)
{
	printf(""%d, %d, %c, %s, %d\n"",a ,b ,c ,d, *e);
}

int main(int argc, char **argv)
{
	int i, var1 = 18, var2 = 19;
	volatile int a = 53;
	float b = 0.0f;
	printf(""suspect Starting\n"");
	sleep(2);
	for(i = 0; i < 3; ++i)
	{
		ottawa();
		print(a, 86,'c', ""Hello World"",&var1 );
		printf(""b\n"");
		quebec(a);
		getAnswer(18+i, 'a');
		awesome(""Good Morning"", ""Good Night"");
		beauce(24,""Life is like a box of chocolates"");
		montreal(24,""Life is like a box of chocolates"", 'p');
		sherbrook(24,""Life is like a box of chocolates"", 'p', &var1);
		rimouski(18, b);
		sleep(1);
	}
	return 0;
}
"
029-7574,mgalushka/cpp-start,linux/realloc.c,26,2,13,1740137.9300280001,199139.0,8.738303396120298,1387.0,1366.0,44653.0,16756.0,1629.0,642.0,1350.0,599.0,1500000000,0.001160091953352,1082014363648.0,0.0138245145350734,0.0687195687928479,"#include <stdlib.h>
#include <stdio.h>

void print_all(int *p, int p_len) {
  for (int i = 0; i < p_len; i++){
    printf(""p[%d] = %d\n"", i, p[i]);
  }
  printf(""=================\n"");
}

int main(int argc, char const *argv[]) {
  int *p = NULL;
  if (p == NULL) {
      p = (int*) malloc(5*sizeof(int));
  }
  p[0] = 17;
  print_all(p, 5);
  p = (int*) realloc(p, 11*sizeof(int));
  p[9] = 9;
  print_all(p, 11);

  free(p);
  p = NULL;
  if (p == NULL) {
      printf(""Testing for NULL is positive\n"");
  }

  p = (int*) malloc(6*sizeof(int));
  p[3] = 4444;
  print_all(p, 6);
  free(p);
}
"
292-13873,KellyChan/python-examples,c/geeksforgeeks/array/sorted_insert.c,25,3,13,1559131.4295305999,182041.0,8.564724430210777,1342.0,1320.0,41198.0,14665.0,1626.0,638.0,1344.0,595.0,1500000000,0.0010394209530204,1082014363648.0,0.0146230794161754,0.0752376349283067,"#include <stdio.h>

int insertSorted (int array[], int n, int key, int capacity)
{
  if (n >= capacity)
    return n;

  int i;
  for (i = n - 1; (array[i] > key && i >= 0); i--)
    array[i+1] = array[i];

  array[i+1] = key;

  return (n+1);
}


int main()
{
  int array[20] = {12, 16, 20, 40, 50, 70};
  int capacity = sizeof(array)/sizeof(array[0]);
  int n = 6;
  int i, key = 26;

  printf(""\nBefore Insertion: "");
  for (i = 0; i < n; ++i)
    printf(""%d "", array[i]);

  n = insertSorted(array, n, key, capacity);

  printf(""\nAfter Insertion: "");
  for (i = 0; i < n; ++i)
    printf(""%d "", array[i]);

  return 0;
}
"
029-7910,spring01/libPSI,madness/src/lib/tensor/dummy_main.c,27,1,14,1579855.3358763,169057.0,15.445784557871011,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010532368905842,1082014363648.0,0.0134155935572026,0.0785563462891999,"/*
  This file is part of MADNESS.
  
  Copyright (C) 2007-10 Oak Ridge National Laboratory
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  
  For more information please contact:

  Robert J. Harrison
  Oak Ridge National Laboratory
  One Bethel Valley Road
  P.O. Box 2008, MS-6367

  email: harrisonrj@ornl.gov 
  tel:   865-241-3937
  fax:   865-572-0680

  
  $Id: dummy_main.c 1591 2009-12-24 03:13:20Z rjharrison $
*/

  
int main() {
	return 0;
}

"
066-28839,geekan/c-algorithm,integer_comparison/test.c,70,4,26,72164330.98074044,288385011.0,0.2502360637599157,1385.0,1362.0,40100201.0,20031346.0,1665.0,752.0,1370.0,649.0,1500000000,0.0481095539871603,1082014363648.0,9.525460392253188e-06,7.377159280468869e-05,"#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ARRAY_SIZE(ARRAY) (sizeof(ARRAY) / sizeof(*ARRAY))
#define TESTNUM 2000

int f1(int a, int b)
{
    return (a > b) | -(b > a);
}

int f2(int a, int b)
{
    return (a > b) - (a < b);
}

int f3(int a, int b)
{
    __asm__ __volatile__ (
        ""sub %1, %0 \n\t""
        ""jno 1f \n\t""
        ""cmc \n\t""
        ""rcr %0 \n\t""
        ""1: ""
    : ""+r""(a)
    : ""r""(b)
    : ""cc"");
    return a;
}

int compare1(int a, int b)
{
    if (a < b) return -1;
    else if (a > b) return 1;
    else return 0;
}
int compare2(int a, int b)
{
    if (a < b) return -1;
    if (a > b) return 1;
    return 0;
}

typedef int (*compare_func)(int a, int b);
struct finfo {
    compare_func func;
    char name[16];
};

struct finfo farr[] = {
    {f1, ""f1""},
    {f2, ""f2""},
    {f3, ""f3""},
    {compare1, ""compare1""},
    {compare2, ""compare2""},
};

int main()
{
    int i, a, b, r;
    int ret;
    int fsize = ARRAY_SIZE(farr);
    struct timespec start = {0};
    struct timespec end = {0};
    srand(time(NULL));

    int random_int[TESTNUM];
    for (i = 0; i < TESTNUM; i++) {
        r = rand();
        random_int[i] = r;
    }

    for (i = 0; i < fsize; i++) {
        compare_func compare = farr[i].func;
        clock_gettime(CLOCK_THREAD_CPUTIME_ID, &start);
        for (a = 0; a < TESTNUM; a++)
            for (b = 0; b < TESTNUM; b++)
                ret += compare(random_int[a], random_int[b]);
        clock_gettime(CLOCK_THREAD_CPUTIME_ID, &end);
        printf(""%s: diff:%ld, start:%ld, end:%ld, ret:%d\n"",
                farr[i].name, end.tv_nsec - start.tv_nsec, start.tv_nsec, end.tv_nsec, ret);
    }
    return 0;
}
"
346-28908,csampez/analisis-numerico-computo-cientifico,MNO/entrega_tareas_de_C/tarea4/160167/eje3.1.c,17,1,12,1665961.5794195998,172551.0,9.65489043818929,1294.0,1276.0,39037.0,13223.0,1607.0,634.0,1334.0,592.0,1500000000,0.0011106410529464,1082014363648.0,0.0148941472376282,0.0797359357060849,"//Ejercicio3 By Ricardo Lastra
//Segunda parte
//b) Cómo modificas la forma en que es llamada corta_string dentro de main de modo que devuelva: verdes ?? (hay un espacio antes del string ""verdes"").


#include<stdio.h>
#include<string.h>
char *corta_string(char *apuntador){
    if(strlen(apuntador) != '\0')
	return apuntador + 1;
	else
		return ""Error, introduce algun caracter!!!\n"";
}

int main(void){
    char *s=""Campos Verdes"";
	while(*s!= ' '){
		s=corta_string(s);
	}
    printf(""%s\n"",s);

return 0;
}
"
336-2471,mattstock/binutils-bexkat1,gdb/testsuite/gdb.base/new-ui.c,35,1,18,1697281.259112,169099.0,9.981703026038002,1144.0,1134.0,38460.0,12712.0,1568.0,585.0,1317.0,546.0,1500000000,0.001131520839408,1082014363648.0,0.0134713984115813,0.0784804189791292,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2016-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

volatile int global = 0;

int
main (void)
{
  global = 1;
  global = 1;
  global = 1;
  global = 1;
  global = 1;
  global = 1;
  global = 1;
  global = 1; /* set break main console here */
  global = 1;
  global = 1;
  global = 1;
  global = 1;
  global = 1;
  global = 1;
  global = 1;
  global = 1; /* set break extra console here */
  return 0;
}
"
054-9207,shucommon/little-routine,c/secure-coding-in-c/ex_files_secure_coding_c/Ch05/05_02/05_02-example1.c,12,1,14,2721064.724028,173865.0,15.650441434446266,1323.0,1303.0,39373.0,13437.0,1616.0,638.0,1338.0,594.0,1500000000,0.001814043149352,1082014363648.0,0.0151036723894976,0.0792652906646468,"#include <stdio.h>
#include <stdlib.h>

int main()
{
	char *alphabet;
	int a;

	alphabet = malloc( sizeof(char) * 27 );

	for(a=0; a<26; a++)
		*(alphabet+a) = 'A'+a;
	/* terminate the string */
	*(alphabet+a) = '\0';

	printf(""The alphabet: %s\n"",alphabet);

	return(0);
}
"
004-19423,mattstock/binutils-bexkat1,gdb/testsuite/gdb.base/jit-reader-execd.c,17,1,12,1288951.607421,169061.0,7.624177072181047,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.000859301071614,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2018-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
main (int argc, char **argv)
{
  return 0;
}
"
307-32125,learn-from-peers/learn-from-peers,oldtalks/floatpoint/code/round/code.c,16,2,16,153650171.93835226,700175809.0,0.2194451293874964,1429.0,1406.0,39885.0,13714.0,1638.0,636.0,1354.0,593.0,1500000000,0.1024334479589015,1082014363648.0,4.048983074763727e-06,0.0787514692438291,"#include <stdio.h>
#include <math.h>

const int n = 100000000;

int main()
{
	int i;
	float accum = 0.0f;

	//for(i = 1; i <= n; i++)
		//accum += 1.0f / i;

	for(i = n; i >= 1; i--)
		accum += 1.0f / i;

	if(accum == accum + 1.0f/n+1)
	printf(""same\n"");
	else
	printf(""different\n"");

	printf(""%f\n"", accum);

	return 0;
}
"
244-2813,mattstock/binutils-bexkat1,gdb/testsuite/gdb.base/infcall-input.c,26,1,16,1501866699.079983,170067.0,8824.706509787318,1152.0,1142.0,38683.0,12795.0,1574.0,589.0,1321.0,547.0,1500000000,1.001244466053322,1082014363648.0,0.0134888014723608,0.0783052954660243,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2016-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
some_function (void)
{
  /* Sleep a bit to make sure the next command is queued before this
     function returns.  */
  sleep (1);
  return 1;
}

int
main (int argc, char **argv)
{
  some_function ();
  return 0;
}
"
269-4145,aleksandra290709/sipurina,cFiles/QuickSort.c,35,2,22,1455438.2069035498,180739.0,8.052705835486531,1354.0,1336.0,40894.0,14481.0,1632.0,636.0,1352.0,593.0,1500000000,0.0009702921379357,1082014363648.0,0.0148833400649555,0.0760812641083521,"#include <stdio.h>

void swap(double array[], int i, int j) {
  double tmp=array[i];
  array[i]=array[j];
  array[j]=tmp;
}

int partitioning(double array[], int left, int right) {
  int positionOfPivot = left, j;
  for (j = left+1; j <= right; j++) {
	if (array[j] < array[left]) {
	  positionOfPivot++;
	  swap(array, positionOfPivot, j);
	}
  }
  swap(array, positionOfPivot, left);
  return positionOfPivot;
}

void quick_sort(double array[], int left, int right) {
  if (left < right) {
	int positionOfPivot = partitioning(array, left, right);
	quick_sort(array, left, positionOfPivot - 1);
	quick_sort(array, positionOfPivot + 1, right);
  }
}

int main(){
  /*Test*/
  int i=0;
  double array[10] = {1,5,7,2,9,3,6,8,0,4};
  
  /*We call our sort algorithm*/
  quick_sort(array,0,9);
  
  /*Writing a sorted array*/
  for(i=0; i<10; i++)
    printf(""%d "", array[i]);
  printf(""\n"");
  
  return 0;
}
"
112-32621,guoxiaoyong/simple-useful,brainfuck/bin2bf.c,61,4,28,1664072.8572382499,174818.0,9.518882494937593,1289.0,1269.0,39752.0,13517.0,1630.0,635.0,1352.0,592.0,1500000000,0.0011093819048255,1082014363648.0,0.0146323605120754,0.0790140607107323,"#include <stdio.h>

void print_and_reset() {

    printf("".[-]\n"");
}

void bf10(int c) {

    int i;
    for (i = 0; i < c; i++) {

        printf(""+"");
    }
}


void bf50(int c) {

    int i, d, r, m;

    m = 7;

    d = c/m;
    r = c%m;

    printf("">"");
    for (i = 0; i < m; i++) {

        printf(""+"");
    }

    printf(""[<"");

    for (i = 0; i < d; i++) {

        printf(""+"");
    }

    printf("">-]"");
    printf(""<"");

    bf10(r);
}


void bf100(int c) {

    int i, d, r, m;

    r = c%2;
    printf("">"");
    bf50(c/2);
    printf(""[<++>-]<"");
    bf10(r);
}


void bf255(int c) {

    int i, d, r, m;

    r = c%6;

    printf("">"");
    bf50(c/6);
    printf(""[<++++++>-]<"");
    bf10(r);
}



int main(int argc, char* argv[]) {

    int c;
    while ( (c = fgetc(stdin)) != EOF ) {

        if ( c <= 10 ) {

            bf10(c);
            print_and_reset();
        } else if (c <= 50) {

            bf50(c);
            print_and_reset();
        } else if (c <= 100) {

            bf100(c);
            print_and_reset();
        } else {

            bf255(c);
            print_and_reset();
        }
    }

    return 0;
}


"
071-5557,moehuster/czq,day10/mutex.c,55,3,34,7419351826.538332,182891.0,40567.06905205833,1472.0,1443.0,41812.0,14663.0,1663.0,689.0,1373.0,646.0,1500000000,4.9462345510255545,1082014363648.0,0.0159384551454144,0.0773970783532536,"#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

typedef struct Node{
	char c;
	struct Node* next;
}Node;

Node* head=NULL;
pthread_mutex_t m=PTHREAD_MUTEX_INITIALIZER;

void printlist()
{
	Node* p = head;
	while (p){
		write(1,&p->c,1);
		p = p->next;
	}
	putchar('\n');
}

void* f1(void* p)
{
	char i;
	for (i='A'; i<='Z'; i++){
		Node* q = malloc(sizeof(Node));//if(q==NULL)...
		q->c = i;
		q->next = head;
		pthread_mutex_lock(&m);
		usleep(100000);
		head = q;
		printlist();
		pthread_mutex_unlock(&m);
	}
}

void* f2(void* p)
{
	char i;
	for (i='a'; i<='z'; i++){
		Node* q = malloc(sizeof(Node));//if(q==NULL)...
		q->c = i;
		pthread_mutex_lock(&m);
		q->next = head;
		usleep(90000);
		head = q;
		printlist();
		pthread_mutex_unlock(&m);
	}
}

int main()
{
	pthread_t ids[2];
	pthread_create(ids,NULL,f1,NULL);
	sleep(1);
	pthread_create(ids+1,NULL,f2,NULL);
//	pthread_join(ids[0],NULL);
//	pthread_join(ids[1],NULL);//等待两个线程跑完
	pthread_exit(NULL);
//	printlist();
//	free();
}
"
009-1842,jhbsz/OSI-OS,tools/regression/tls/ttls2/ttls2.c,28,2,22,15025511757.005003,209195.0,71825.38663447979,1567.0,1533.0,47032.0,18485.0,1668.0,771.0,1374.0,728.0,1500000000,10.017007838003336,1082014363648.0,0.0148187098162001,0.0693102553535723,"/* $FreeBSD$ */

#include <stdio.h>
#include <pthread.h>

int __thread i;

void *
foo1(void *arg)
{
	printf(""thread %p, &i = %p\n"", pthread_self(), &i);
	for (i = 0; i < 10; i++) {
		printf(""thread %p, i = %d\n"", pthread_self(), i);
		sleep(1);
	}
}

void *
foo2(void *arg)
{
	printf(""thread %p, &i = %p\n"", pthread_self(), &i);
	for (i = 10; i > 0; i--) {
		printf(""thread %p, i = %d\n"", pthread_self(), i);
		sleep(1);
	}
}

int main(int argc, char** argv)
{
	pthread_t t1, t2;

	pthread_create(&t1, 0, foo1, 0);
	pthread_create(&t2, 0, foo2, 0);
	pthread_join(t1, 0);
	pthread_join(t2, 0);
}
"
181-31145,doc-cloud/c,glibc/bsd_signal.c,34,2,17,9030972193.577328,175570.0,51438.01442729396,1318.0,1297.0,39940.0,13680.0,1625.0,641.0,1347.0,594.0,1500000000,6.020648129051551,1082014363648.0,0.0148943441362419,0.0784595300261096,"/*
 * signal handling with BSD semantics
 * 
 * The bsd_signal() function takes the same arguments, and performs the same task, as signal(2).
 * 
 * The  difference	between  the  two is that bsd_signal() is guaranteed to provide reliable signal semantics, that is:
 * a) the disposition of the signal is not reset to the default when the handler is invoked;
 * b) delivery of further instances of the signal is blocked while the signal handler is executing; and
 * c) if the  handler interrupts a blocking system call, then the system call is automatically restarted.
 * A portable application cannot rely on signal(2) to provide these guarantees.
 */


#include<stdio.h>
#include<unistd.h>
#include<signal.h>

void timeout(int sig)
{
	if (sig == SIGALRM)
		puts(""Time out!"");
	alarm(2);
}

void keycontrol(int sig)
{
	if (sig == SIGINT)
		puts(""CTRL + C pressed."");
}

int main(int argc, char *argv[])
{
	int i;
	bsd_signal(SIGALRM, timeout);
	bsd_signal(SIGINT, keycontrol);
	alarm(2);

	for (i = 0; i < 3; i++) {
		puts(""waiting...."");
		sleep(600);
	}
	return 0;
}
"
362-28567,wuzhouhui/leetcode,second/34_srch_in_range.c,38,2,18,1694207.8946156998,172675.0,9.811536122773996,1227.0,1211.0,39118.0,13212.0,1604.0,635.0,1335.0,592.0,1500000000,0.0011294719297438,1082014363648.0,0.014119009700304,0.0796101662526275,"#include <stdlib.h>

int *searchRange(int *nums, int numsSize, int target, int *returnSize)
{
	int *res = malloc(sizeof(*res) * 2);
	int left, right, mid;

	*returnSize = 2;
	left = -1;
	right = numsSize;
	while (left + 1 != right) {
		mid = (left + right) / 2;
		if (nums[mid] < target)
			left = mid;
		else
			right = mid;
	}
	if (right >= numsSize || nums[right] != target) {
		res[0] = res[1] = -1;
		return(res);
	} else
		res[0] = right;
	left = -1;
	right = numsSize;
	while (left + 1 != right) {
		mid = (left + right) / 2;
		if (nums[mid] <= target)
			left = mid;
		else
			right = mid;
	}
	res[1] = left;
	return(res);
}

int main(void)
{
	int arr[] = { 5, 7, 7, 8, 8, 10, };
	int *a, n;
	a = searchRange(arr, sizeof(arr) / sizeof(arr[0]), 8, &n);
	return(0);
}
"
288-20851,Xilinx/binutils-gdb,gdb/testsuite/gdb.base/paginate-after-ctrl-c-running.c,18,1,13,15008630266.296677,170055.0,88257.50648907706,1149.0,1140.0,38683.0,12795.0,1575.0,581.0,1324.0,544.0,1500000000,10.005753510864452,1082014363648.0,0.0134603510628914,0.0781693150472046,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
main (void)
{
  sleep (10);
  return 0; /* after sleep */
}
"
294-28438,OpenGenus/cosmos,code/mathematical_algorithms/src/amicable_numbers/amicable_numbers.c,20,3,12,243673348.3336866,822672366.0,0.2961973175114527,1341.0,1321.0,40635.0,14297.0,1626.0,638.0,1345.0,594.0,1500000000,0.1624488988891244,1082014363648.0,3.235796059302665e-06,0.076512779436394,"#include <stdio.h>

int
main()
{
  printf(""Amicable Numbers below 10000 are:- \n"");
  int m, i, j;
  for (m = 1; m <= 10000; m++) {
    int x = m;
    int sum1 = 0, sum2 = 0;
    for (i = 1; i < x; i++)
        if (x % i == 0)
            sum1 += i;

    int y = sum1;
    for (j = 1; j < y; j++)
        if (y % j == 0)
            sum2 += j;

    if (sum2 == x && x != y)
        printf(""%d \n"", x);
  }

  return (0);
}"
342-33010,qeedquan/debug,instrumentation/instrument.c,46,3,24,2355319.68064605,173343.0,13.587621074978513,1151.0,1141.0,39580.0,13143.0,1610.0,595.0,1347.0,552.0,1500000000,0.0015702131204307,1082014363648.0,0.0132223395233727,0.0778407905468201,"#define _GNU_SOURCE
#include <dlfcn.h>
#include <stdio.h>
#include <threads.h>

__attribute__((no_instrument_function)) char *
funcname(void *func)
{
	static thread_local char buf[128];

	Dl_info dlinfo;

	snprintf(buf, sizeof(buf), ""?"");
	if (dladdr(func, &dlinfo))
		snprintf(buf, sizeof(buf), ""[%s] %s"", dlinfo.dli_fname, dlinfo.dli_sname);

	return buf;
}

static thread_local unsigned indent;

__attribute__((no_instrument_function)) void
__cyg_profile_func_enter(void *func, void *call)
{
	for (unsigned i = 0; i < indent; i++)
		printf(""\t"");
	printf(""->%s\n"", funcname(func));
	indent++;
}

__attribute__((no_instrument_function)) void
__cyg_profile_func_exit(void *func, void *call)
{
	indent--;
	for (unsigned i = 0; i < indent; i++)
		printf(""\t"");
	printf(""<-%s\n"", funcname(func));
}

int
factorial(int n)
{
	if (n <= 1)
		return 1;
	return n * factorial(n - 1);
}

void
hal(int x)
{
}

int
main(void)
{
	factorial(10);
	for (int i = 0; i < 100; i++)
		hal(i);
	return 0;
}
"
137-21620,guoshen/ProjEuler,Q1/q1.c,24,2,14,1586869.24260105,174506.0,9.093492487364331,1335.0,1317.0,39183.0,13307.0,1619.0,637.0,1342.0,594.0,1500000000,0.0010579128284007,1082014363648.0,0.0151971851970705,0.0798628310154315,"/**Problem 1:If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9.
//The sum of these multiples is 23.
Find the sum of all the multiples of 3 or 5 below 1000.

Solved By: Shengyuan Guo in 2013
**/

#include <stdio.h>

int main()
{
    
    printf(""Sum of all multiples of 3 or 5 below 1000: %d"", natural35(1000));
}
int natural35(int num)
{
    int sum=0;
    int i;
    for(i=3;i<1000;i=i+3)
    {
    sum+=i;
    }
    for(i=5; i<1000;i=i+5)
    {
        if(!(i%3==0))
        sum+=i;
    }
    return sum;
}
"
395-24478,dysnomia/domjudge,tests/test-hello-space.c,13,1,14,2232588.01270275,173195.0,12.890603077456047,1285.0,1270.0,39267.0,13307.0,1618.0,637.0,1340.0,593.0,1500000000,0.0014883920084685,1082014363648.0,0.0147521579722278,0.0796591471069349,"/*
 * This should give CORRECT, WRONG-ANSWER or PRESENTATION-ERROR on the
 * default problem 'hello' depending on how strict white space is
 * checked for.
 *
 * @EXPECTED_RESULTS@: CORRECT,WRONG-ANSWER,PRESENTATION-ERROR
 */

#include <stdio.h>

int main()
{
	char hello[20] = ""Hello   	 world!"";
	printf(""%s\n"",hello);
	return 0;
}
"
147-8787,swigger/gdb-ios,gdb/testsuite/gdb.base/double-prompt-target-event-error.c,18,1,14,5171128978.603519,170064.0,30406.95842741556,1150.0,1141.0,38683.0,12795.0,1574.0,581.0,1323.0,544.0,1500000000,3.447419319069013,1082014363648.0,0.0134713990027283,0.0781304634989704,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2016 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
main (void)
{
  sleep (3);
  return 0; /* after sleep */
}
"
048-10810,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.guile/scm-disasm.c,17,1,10,1529945.9919333,169057.0,9.049876668815845,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010199639946222,1082014363648.0,0.0134155935572026,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see  <http://www.gnu.org/licenses/>.  */

int
main (void)
{
  return 0;
}
"
084-34360,resourceful/lecture_dsa2017-1,DSA03-Array/codes/array_address.c,13,1,11,1801502.89088475,181364.0,9.93307381839836,1375.0,1352.0,40991.0,14335.0,1646.0,641.0,1360.0,596.0,1500000000,0.0012010019272565,1082014363648.0,0.015036060078075,0.0766908867440263,"// codes/array_address.c
#include <stdio.h>

void print1(int *ptr,int rows) { 
    int i;
    printf(""Address\t\tContents\n""); 
    for(i=0;i<rows;i++)
        printf(""%8u\t%5d\n"",  (unsigned int)ptr+i,  *(ptr+i)); 
    printf(""\n"");
}

int main() {
  int one[] = {0, 1, 2, 3, 4};
  print1(one, 5);
  return 0;
}"
280-21826,dns42/glibc,pwd/tst-getpw.c,29,2,15,6725731864.571571,331697759.0,20.276687681812163,3533039.0,3054.0,65782119.0,52904033.0,292374.0,182385.0,4239.0,1466.0,1500000000,4.483821243047714,1082014363648.0,0.0106605875501257,0.0040481892108187,"/* Copyright (C) 1999 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#include <pwd.h>

static void
check (uid_t uid)
{
  char buf[1024];

  (void) getpw (uid, buf);
}

int
main (void)
{
  uid_t uid;

  /* Just call it a different number of times the range should be
     large enough to find some existing and some non existing uids.  */

  for (uid = 0; uid < 2000; ++uid)
    check (uid);

  return 0;
}
"
276-11530,fatalioerror/helloworld,src/hello.c,30,1,21,1791137.9691213,172497.0,10.383583482611291,1292.0,1274.0,39029.0,13221.0,1606.0,634.0,1333.0,592.0,1500000000,0.0011940919794142,1082014363648.0,0.0148756210252931,0.079712918660287,"/*
  hello.c ---
 
 Copyright (C) 2013 taocp
 Author: taocp <damaobangfa@gmail.com>
 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation; either version 2, or (at
 your option) any later version.
 
 This program is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; see the file COPYING.  If not, write to
 the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 Boston, MA 02110-1301, USA.
 */
#include <stdio.h>

/** 
 * main
 * 
 * @param argc 
 * @param argv 
 * 
 * @return 
 */
int main(int argc, char *argv[])
{
  printf (""hello world!\n"");
  return 0;
}

"
012-27232,acaballero05/Clases_2015,Tareas_German_Daniela/Tarea3/Ejercicio2/Ej2.c,49,1,21,15004665985.470634,355804.0,42171.15598756619,2344.0,1804.0,82410.0,36800.0,2329.0,1125.0,1672.0,990.0,1500000000,10.003110656980423,1082014363648.0,0.0116581038998999,0.0513044207700696,"/* 2. Implementar usando pthreads un programa que:
   Tiene un buffer acotado de tamaño definido por ustedes.
   Lanza 4 threads:  t1;t2;t3;t4.

   Cada thread ti escribe cada i segundos, un número i en la  
   próxima posición libre p del buffer.

   Una vez escrito el elemento el thread ti imprime por pantalla
   “Escribí un i en la posición p del buffer”.

   Se debe cuidar que el acceso al buffer se realice de forma
   exclusiva. 

   Cuando un thread ti descubre que el buffer está lleno, termina.

   El thread original (el que lanzó todos los threads) debe
   esperar a que terminen todos y luego termina. */

# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <unistd.h>
# include <pthread.h>
# define NTHREADS 4

char buffer[10];

pthread_mutex_t bloq;

void *AgregarNumerosBuffer(void *hilid){

   int *hil;
   hil=(int *) hilid;
   int i=0;

   while(i<10){

      pthread_mutex_lock (&bloq);
      buffer[i]=hil;
      printf(""Escribí un %d en la posición %d del buffer\n"", *hil,i);
      i=i+1;
      pthread_mutex_unlock(&bloq);
      sleep(1);
   }

   pthread_exit(NULL);



}

int main(int argc, char const *argv[])
{
   /* code */
   int hilos[NTHREADS];
   pthread_t hil[NTHREADS] ;
   pthread_attr_t attr;
   pthread_attr_init(&attr); 
   pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
   pthread_mutex_init(&bloq, NULL);

   pthread_create (&hil[0] , &attr , AgregarNumerosBuffer , ( void *) &hilos[0]);
   pthread_create (&hil[1] , &attr , AgregarNumerosBuffer , ( void *) &hilos[1]);
   pthread_create (&hil[2] , &attr , AgregarNumerosBuffer , ( void *) &hilos[2]);
   pthread_create (&hil[3] , &attr , AgregarNumerosBuffer , ( void *) &hilos[2]);

   pthread_join(hil[0], NULL);
   pthread_join(hil[1], NULL);
   pthread_join(hil[2], NULL);
   pthread_join(hil[3], NULL);

   pthread_attr_destroy (&attr);
   pthread_mutex_destroy (&bloq);
   pthread_exit(NULL);


}
"
029-10108,zxombie/aarch64-freebsd-binutils,gdb/testsuite/gdb.base/gdb1821.c,15,1,11,1923046.4240535002,169083.0,11.373384669067857,1142.0,1132.0,38461.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.001282030949369,1082014363648.0,0.0134490161636592,0.078503430615556,"/* Test printing of structure member names in gdb. PR exp/1821

   Copyright 2005-2014 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

struct foo { double x__0, y__0, z__1; } bar;


int main(void) { return (int) bar.x__0; }
"
112-31992,CyanFeather/feather-treehole,practice/src/ASCII.c,7,1,8,1910718.041472,215025.0,8.882376467852575,1351.0,1331.0,47397.0,18674.0,1621.0,641.0,1343.0,598.0,1500000000,0.001273812027648,1082014363648.0,0.0124729682595047,0.063613385600339,"#include <stdio.h>

int main(void)
{
	int index;
	for (index = 'A'; index <= 'Z'; index ++)
		printf(""%c\t%3d\t\t%c\t%3d\n"", (char) index, index, (char) index + 32, index + 32);
	return 0;
}
"
040-32272,unofficial-opensource-apple/gcc_40,gcc/testsuite/consistency.vlad/layout/f-29-4-10.c,27,4,11,1674362.6911192501,187760.0,8.91756497656583,1347.0,1324.0,42480.0,15646.0,1624.0,636.0,1346.0,594.0,1500000000,0.0011162417940795,1082014363648.0,0.0142256071580741,0.0722568213880191,"#include <stdio.h>

struct sss{
  int i1:29;
  int i2:4;
  int i3:10;
};

static union u{
  struct sss sss;
  unsigned char a[sizeof (struct sss)];
} u;

int main (void) {
  int i;
  for (i = 0; i < sizeof (struct sss); i++)
    u.a[i] = 0;
  u.sss.i1 = 536870911.0;
  for (i = 0; i < sizeof (struct sss); i++)
    printf (""%x "", u.a[i]);
  printf (""\n"");
  u.sss.i2 = 15.0;
  for (i = 0; i < sizeof (struct sss); i++)
    printf (""%x "", u.a[i]);
  printf (""\n"");
  u.sss.i3 = 1023.0;
  for (i = 0; i < sizeof (struct sss); i++)
    printf (""%x "", u.a[i]);
  printf (""\n"");
  return 0;
}
"
273-8062,feeley/gambit,bench/src/fibfp.c,21,1,18,75357588.12446146,512080444.0,0.1471596677493898,1156.0,1148.0,116639783.0,59769502.0,1581.0,585.0,1328.0,546.0,1500000000,0.0502383920829743,1082014363648.0,4.4992930837249466e-06,2.2901288897577017e-05,"/* FIBFP -- Computes fib(35) using floating point */

#include <stdio.h>

#define FLOAT double

static FLOAT fib (FLOAT n)
{
  if (n < 2.)
    return n;
  else
    return fib (n-1.) + fib (n-2.);
}

int main (int argc, char *argv[])
{
  int i;
  FLOAT result;
  int n = 35;

  if (argc > 1)
    n = atoi (argv[1]);

  for (i=0; i<2; i++)
    result = fib (n);

  if (result != 9227465.)
    printf (""*** wrong result ***\n"");

  return 0;
}
"
390-32805,Lvlynn/linux-study,c_study/thread/test_mutex_cond.c,50,3,21,15071820869.925432,196919.0,100156.17187777716,1586.0,1550.0,45057.0,16734.0,1679.0,766.0,1384.0,722.0,1500000000,10.047880579950288,1082014363648.0,0.0159253297040915,0.0736515026460164,"#include<stdio.h>
#include<unistd.h>
#include<pthread.h>

#define MAX_COUNT 10
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
int count = 1;
//1 3 5 7 9
void* fun1(void *arg)
{
	pthread_mutex_lock(&mutex);
	while(count <= MAX_COUNT)
	{
		if(count % 2 == 1)
		{
			printf(""This is threadfun1 %d\n"", count);
			count++;
			pthread_cond_signal(&cond);
		}
		else
			pthread_cond_wait(&cond, &mutex);
		sleep(1);
	}
	pthread_mutex_unlock(&mutex);
}
//2 4 6 8 10
void* fun2(void *arg)
{
	pthread_mutex_lock(&mutex);
	while(count <= MAX_COUNT)
	{
		if(count % 2 == 0)
		{
			printf(""This is threadfun2 %d\n"", count);
			count++;
			pthread_cond_signal(&cond);
		}
		else
			pthread_cond_wait(&cond, &mutex);
	}
	pthread_mutex_unlock(&mutex);
}
int main(int argc, char const* argv[])
{
	pthread_t tid[2];
	pthread_create(&tid[0], NULL, fun1, NULL);
	// sleep(1);
	pthread_create(&tid[1], NULL, fun2, NULL);

	for(int i=0; i<2; ++i)
	{
		pthread_join(tid[i],NULL);
	}
	return 0;
}
"
131-14687,pgbovine/opt-cpp-backend,tests/runtime-error-loop.c,6,1,7,1535702.9624283002,169087.0,9.082318569730376,1142.0,1132.0,38460.0,12696.0,1567.0,584.0,1317.0,544.0,1500000000,0.0010238019749522,1082014363648.0,0.0134486980075345,0.0784267730080538,"int main() {
  int i;
  int* x = (int*)malloc(10*sizeof(*x));
  for (i = 0; i < 20; i++)
    x[i] = i * i;
}
"
285-2317,totalspectrum/binutils-propeller,gdb/testsuite/gdb.python/py-mi-events.c,20,2,12,1488604.35001545,169061.0,8.805129509466997,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0009924029000103,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2016-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see  <http://www.gnu.org/licenses/>.  */

int
main (void)
{
  int i = 0;
  while (i < 10)
    i++;

  return 0;
}
"
283-18010,hzq1001/or1k-src,gdb/testsuite/gdb.base/fortran-sym-case.c,17,1,12,1481942.8324698,169061.0,8.764250773389486,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0009879618883132,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2011-2013 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
main (int argc, char **aRGv)
{
  return 0;
}
"
291-34982,andredalton/bcc,2014/MAC0242/miniep7/mini-ep7-4898948-AndreMeneghelliVale/implementacao/seq/pi.c,14,1,11,4319482.48296975,12174058.0,0.3548103680794029,1398.0,1376.0,39388.0,13445.0,1622.0,636.0,1344.0,593.0,1500000000,0.0028796549886465,1082014363648.0,0.0002278615725339,0.0794011318683398,"#include <stdio.h>

static long num_steps = 1000000;
double step;

int main () { 
  int i;
  double x, pi, sum = 0.0;
  
  step = 1.0/(double) num_steps;
  
  for (i=0; i<num_steps; i++){
    x = (i + 0.5) * step;
    sum = sum + 4.0 / (1.0 + x * x);
  }
  pi = step * sum;
  printf(""PI: %g\n"", pi);
  
  return 0;
}"
000-7470,zhaochenyou/Tips,cpp/stl/c/pthread/thread.c,61,2,26,3004640108.789317,421776.0,7123.781599711695,2339.0,1812.0,99888.0,48731.0,3459.0,2583.0,1680.0,2048.0,1500000000,2.003093405859545,1082014363648.0,0.0098417169303137,0.0657385664013349,"#include <pthread.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <assert.h>

#define THREAD_SIZE 8

void *job1(void *arg)
{
    pthread_t pid = pthread_self();
    sleep(1);
    printf(""job1: print %p\n"", arg);
    printf(""job1: pthread_self: %lu\n"", pid);
    sleep(1);

    return arg;
}

void *job2(void *arg)
{
    pthread_t pid = pthread_self();
    sleep(1);
    printf(""job2: print %p\n"", arg);
    printf(""job2: pthread_self: %lu\n"", pid);
    sleep(1);
    pthread_exit(NULL);

    return arg;
}

void *job3(void *arg)
{
    pthread_t pid = pthread_self();
    pthread_detach(pid);
    sleep(1);
    printf(""job3: print %p\n"", arg);
    printf(""job3: pthread_self: %lu\n"", pid);
    sleep(1);

    return arg;
}

void *job4(void *arg)
{
    pthread_t pid = pthread_self();
    pthread_detach(pid);
    sleep(1);
    printf(""job4: print %p\n"", arg);
    printf(""job4: pthread_self: %lu\n"", pid);
    sleep(1);

    return arg;
}

int main()
{
    pthread_t tid1[THREAD_SIZE];
    pthread_t tid2[THREAD_SIZE];
    pthread_t tid3[THREAD_SIZE];
    pthread_t tid4[THREAD_SIZE];
    int i;
    void *res;

    for (i = 0; i < THREAD_SIZE; i++) {
        assert(pthread_create(&tid1[i], NULL, job1, (void*)i) == 0);
        assert(pthread_create(&tid2[i], NULL, job2, (void*)i) == 0);
        assert(pthread_create(&tid3[i], NULL, job3, (void*)i) == 0);
        assert(pthread_create(&tid4[i], NULL, job4, (void*)i) == 0);
    }

    for (i = 0; i < THREAD_SIZE; i++) {
        assert(pthread_join(tid1[i], &res) == 0);
        assert(res == (void*)i);
        assert(pthread_join(tid2[i], &res) == 0);
        assert(res == NULL);
    }

    return 0;
}
"
240-4693,rmbq/hjl-binutils,gdb/testsuite/gdb.dwarf2/dw2-bad-unresolved.c,18,1,13,1663938.04829565,169087.0,9.840023183331658,1142.0,1132.0,38460.0,12696.0,1567.0,584.0,1317.0,544.0,1500000000,0.0011092920321971,1082014363648.0,0.0134486980075345,0.0784267730080538,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* Dummy main function.  */

int
main (void)
{
  return 0;
}
"
132-10792,dawter/tools,maxsublen.c,22,1,16,2398519.6603461,184792.0,12.979560803497987,1355.0,1335.0,41590.0,14854.0,1628.0,637.0,1346.0,596.0,1500000000,0.0015990131068974,1082014363648.0,0.014556907225421,0.074534051449224,"#include <stdio.h>
/*
 * What I want to do?
 */

int max_substr_len(const char* str, size_t len)
{
	int i;
	int max_len = 0;
	int map[256] = {-1};

	for(i=0; i<10; i++) {
		printf(""map[%d] = %d\n"", i, map[i]);
	}

	return max_len;
}


int main(int argc, char** argv)
{
	int ret = 0;
	char str[] = ""abcdefgegcsgcasse"";

	ret = max_substr_len(str, sizeof(str)/sizeof(str[0]));
	
	printf(""str: %s\n"", str);
	printf(""ret: %d\n"", ret);


	return ret;
}

"
112-11212,weiqiangdragonite/blog_tmp,unix_linux/linux_program/uup_book/ch14_thread/hello_multi.c,26,1,18,7505315277.026966,190745.0,39347.37621956015,1547.0,1514.0,43696.0,16175.0,1675.0,760.0,1371.0,715.0,1500000000,5.0035435180179775,1082014363648.0,0.0160476028205195,0.075512351555845,"/*
 * hello_multi.c - a multi threaded hello world program
 */

#include <stdio.h>
#include <pthread.h>

#define NUM	5


void *print_msg(void *arg);


int
main(int argc, char *argv[])
{
	pthread_t t1, t2;

	pthread_create(&t1, NULL, print_msg, (void *) ""hello"");
	pthread_create(&t2, NULL, print_msg, (void *) ""world\n"");

	pthread_join(t1, NULL);
	pthread_join(t2, NULL);

	return 0;
}

void *
print_msg(void *arg)
{
	char *msg = (char *) arg;
	int i;

	for (i = 0; i < NUM; ++i) {
		printf(""%s"", msg);
		fflush(stdout);
		sleep(1);
	}

	return NULL;
}

"
001-21665,wcnnbdk1/hello_world,CLearning/CPrimerPlus/chap10/rain.c,31,4,18,1628866.4191960501,208457.0,7.81391845800333,1514.0,1486.0,47001.0,18223.0,1664.0,643.0,1374.0,599.0,1500000000,0.0010859109461307,1082014363648.0,0.0143914572309876,0.0656200171715932,"#include <stdio.h>
#define MONTHS 12
#define YEARS 5
int main(void)
{
    const float rain[YEARS][MONTHS] = {
        {4.3, 4.3, 4.3, 3.0, 2.0, 1.2, 0.2, 0.2, 0.4, 2.4, 3.5, 6.6},
	{8.5, 8.2, 1.2, 1.6, 2.4, 0.0, 5.2, 0.9, 0.3, 0.9, 1.4, 7.3},
	{9.1, 8.5, 6.7, 4.3, 2.1, 0.8, 0.2, 0.2, 1.1, 2.3, 6.1, 8.4},
	{7.2, 9.9, 8.4, 3.3, 1.2, 0.8, 0.4, 0.0, 0.6, 1.7, 4.3, 6.2},
	{7.6, 5.6, 3.8, 2.8, 3.8, 0.2, 0.0, 0.0, 0.0, 1.3, 2.6, 5.2}
    };
    int year, month;
    float subtot, total;

    printf("" YEAR RAINFALL (inches) \n"");
    for(year = 0, total = 0; year < YEARS; year++)
    {
        for(month = 0, subtot = 0; month < MONTHS; month++)
            subtot += rain[year][month];
	printf(""%5d %15.1f\n"", 2000 + year, subtot);
	total += subtot;
    }
    printf(""\nThe yearly average is %.1f inches.\n\n"", total/YEARS);
    printf(""MONTHLY AVERAGES: \n\n"");
    printf("" Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n"");

    for(month = 0; month < MONTHS; month++)
    {
        for(year = 0, subtot = 0; year < YEARS; year++)
	    subtot += rain[year][month];
	printf(""%4.1f "", subtot/YEARS);
    }
    printf(""\n"");
    return 0;
}
"
056-18538,totalspectrum/binutils-propeller,gdb/testsuite/gdb.reverse/rerun-prec.c,16,1,12,1714834.361337,169057.0,10.14352555646912,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.001143222907558,1082014363648.0,0.0134155935572026,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int main (int argc, char **argv)
{
  return 0;
}
"
079-8624,rogerluan/SO-A,experimento3/random.c,6,1,6,101476597.25043914,665792952.0,0.1524146458672635,1342.0,1322.0,140167926.0,98093760.0,1620.0,699.0,1340.0,656.0,1500000000,0.0676510648336261,1082014363648.0,4.001243918244422e-06,1.8110339402198303e-05,"#include ""stdio.h""

int main() {
	int i = 0;
	for (i = 0; i < 1000000 ; ++i) {
		printf(""Number = %d\n"", (((i / 47) % 3) + 1));
	}
}"
104-9732,zhangrxiang/learn-c,linux/unistd/alarm.c,19,1,15,30002329471.637493,192575.0,155742.37920810073,1371.0,1350.0,43681.0,16221.0,1646.0,651.0,1358.0,599.0,1500000000,20.001552981091663,1082014363648.0,0.0141295599117227,0.0710159927882207,"//
// Created by zhangrongxiang on 2018/2/23 9:41
// File alarm
//

#include <stdio.h>
#include <unistd.h>
#include <signal.h>

void handler();

int main() {
    int i;
    handler();
    for (i = 1; i < 21; i++) {
        printf(""sleep %d ...\n"", i);
        sleep(1);
    }
}

void handler() {
    printf(""接收到SIGALRM信号\n"");
    signal(SIGALRM, handler); //让内核做好准备，一旦接受到SIGALARM信号,就执行 handler
    alarm(5);
    printf(""over\n"");
}"
360-21005,indashnet/InDashNet.Open.UN2000,android/external/compiler-rt/lib/tsan/lit_tests/thread_leak5.c,14,1,17,1540782426.1346831,181222.0,8502.181997770691,1357.0,1336.0,41442.0,14727.0,1641.0,754.0,1355.0,708.0,1500000000,1.0271882840897888,1082014363648.0,0.0148602266832945,0.0793676227100357,"// RUN: %clang_tsan -O1 %s -o %t && not %t 2>&1 | FileCheck %s
#include <pthread.h>
#include <unistd.h>

void *Thread(void *x) {
  return 0;
}

int main() {
  for (int i = 0; i < 5; i++) {
    pthread_t t;
    pthread_create(&t, 0, Thread, 0);
  }
  sleep(1);
  return 0;
}

// CHECK: WARNING: ThreadSanitizer: thread leak
// CHECK:   And 4 more similar thread leaks
"
307-35082,mogeb/workload-kit,src/mutex.c,29,1,19,32079815.980978202,182891.0,175.40401113231377,1472.0,1443.0,41812.0,14663.0,1663.0,689.0,1373.0,646.0,1500000000,0.0213865439873188,1082014363648.0,0.0159384551454144,0.0773970783532536,"/*
 * mutex.c
 *
 * Exercice contention on mutex. The first worker thread locks the
 * mutex and the second worker() thread waits for it to be released.
 *
 *  Created on: 2012-12-04
 *      Author: francis
 */

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <signal.h>

pthread_mutex_t mutex;

#define DELAY 10000

void *worker(void *data) {
	pthread_mutex_lock(&mutex);
	usleep(DELAY);
	pthread_mutex_unlock(&mutex);
	return 0;
}

int main(int argc, char **argv) {

	pthread_t threads[2];
	void *status;

	pthread_mutex_init(&mutex, NULL);
	pthread_create(&threads[0], NULL, worker, NULL);
	usleep(DELAY / 10);
	pthread_create(&threads[1], NULL, worker, NULL);

	printf(""pthread_join worker 1\n"");
	pthread_join(threads[0], NULL);
	printf(""pthread_join worker 1\n"");
	pthread_join(threads[1], NULL);

	return 0;
}
"
223-10224,acoada/tcpl,chapter1/E1.03.c,17,2,11,2281610.97038535,189684.0,12.028478943927796,1348.0,1329.0,42506.0,15483.0,1625.0,637.0,1345.0,595.0,1500000000,0.0015210739802569,1082014363648.0,0.0141129457413382,0.0724620186587111,"#include <stdio.h>
/* print Fahrenheit-Celsius table
   for fahr = 0, 20, ..., 300 */
int main(void)
{
  int fahr, celsius;
  int lower, upper, step;

  lower = 0;
  upper = 300;
  step  = 20;

  fahr = lower;

  printf(""Fahrenheit\tCelsius\n"");
  while (fahr <= upper) {
    celsius = 5 * (fahr-32) / 9;
    printf(""%d\t%d\n"", fahr, celsius);
    fahr = fahr + step;
  }
}
"
088-9316,mattstock/binutils-bexkat1,gdb/testsuite/gdb.arch/arm-bl-branch-dest.c,23,1,13,1625463.0172624502,169087.0,9.613175465884426,1142.0,1132.0,38460.0,12696.0,1567.0,584.0,1317.0,544.0,1500000000,0.0010836420115083,1082014363648.0,0.0134486980075345,0.0784267730080538,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2013-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

static void
foo (int a)
{
  ++a;
}

int
main (int argc, char *argv[])
{
  foo (10);
  return 0;
}
"
213-26565,totalspectrum/binutils-propeller,gdb/testsuite/gdb.dwarf2/dw2-dup-frame.c,29,2,14,1653034.5892532999,169061.0,9.77773702982947,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0011020230595022,1082014363648.0,0.0134152761429306,0.0785563462891999,"/*
   Copyright 2013-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

void
stop_frame ()
{
  /* The debug information for this frame is modified in the accompanying
     .S file, to mark a set of registers as being DW_CFA_same_value.  */
}

void
first_frame ()
{
  stop_frame ();
}

int
main ()
{
  first_frame ();

  return 0;
}
"
266-4163,saru95/DSA,C/InsertionSort.c,34,3,18,2750509.65137775,177317.0,15.511817817806527,1348.0,1329.0,40161.0,13877.0,1630.0,637.0,1350.0,593.0,1500000000,0.0018336731009185,1082014363648.0,0.0150972551983171,0.077908138717199,"#include <math.h>
#include <stdio.h>
// Insertion Sort Function
//Code is Written By Krishna
void insertionSort(int array[], int n)
{
    int i, element, j;
    for (i = 1; i < n; i++)
    {
        element = array[i];
        j = i - 1;
        while (j >= 0 && array[j] > element)
        {
            array[j + 1] = array[j];
            j = j - 1;
        }
        array[j + 1] = element;
    }
}
// Function to print the elements of an array
void printArray(int array[], int n)
{
    int i;
    for (i = 0; i < n; i++)
        printf(""%d "", array[i]);
    printf(""n"");
}
// Main Function
int main()
{
    int array[] = {122, 17, 93, 3, 56};
    int n = sizeof(array) / sizeof(array[0]);
    insertionSort(array, n);
    printArray(array, n);
    return 0;
}"
043-10278,cassiopagnoncelli/applied-mathematics-problems,newton-raphson/newton_raphson.c,23,1,14,2154603.1348407,174335.0,20.426569535664093,1406.0,1385.0,39401.0,13460.0,1625.0,638.0,1344.0,593.0,1500000000,0.0014364020898938,1082014363648.0,0.0160094071758396,0.0794536614895669,"#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define error 0.00001

double f(double x)
{
  return x*x -7*x + 12;
}

double df(double x)
{
  return 2*x - 7;
}

double newton_raphson(double x0)
{
  double last, current;

  current = x0 - (f(x0) / df(x0));
  do {
    last = current;
    current -= f(current) / df(current);
  } while (fabs(last - current) > error);

  return current;
}

int main(int argc, char **argv)
{
  printf(""root at %lf\n"", newton_raphson(10));

  return EXIT_SUCCESS;
}
"
307-34513,ktereyp/Algorithms,Bubble_Sort/bubble_sort_v2.c,28,5,19,644943322.171457,6952978281.0,0.0927578507993328,1372.0,1347.0,1229633125.0,148594181.0,122721830.0,115028.0,1422.0,4611.0,1500000000,0.4299622147809714,1082014363648.0,3.910554427345262e-07,0.0891310819813346,"#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv)
{
    int big_array[65535];

    int i;
    for(i = 0; i < 65535; i++)
        big_array[i] = 2 * rand();

    i = 0;
    while(++i < 65535)
    {
        int j = i - 1;

        while(big_array[j] > big_array[i] && j--);

        int big_array_at_i_old = big_array[i];
        int tmp_i = i;
        while(j + 1 != tmp_i)
        {
            big_array[tmp_i] = big_array[tmp_i-1]; 
            tmp_i--;
        }
        big_array[j+1] = big_array_at_i_old;

    }

    i = 0;
    for(i = 0; i < 65535; i++)
    {
        printf(""%d : "", i);
        printf(""%d\n"", big_array[i]);
    } 

    return 0;
}
"
027-28741,darkrossi/SEPC-Threads,Test/main.c,22,2,16,2486387.8497853503,203259.0,12.232604706310669,1555.0,1522.0,45669.0,17660.0,1669.0,764.0,1372.0,721.0,1500000000,0.0016575918998569,1082014363648.0,0.0151383210583541,0.0714680478137977,"#include <pthread.h>
#include <stdio.h>

void* ALL_IS_OK = (void*)123456789L;

char* mess[2] = {""boys"", ""girls""};

void* writer (void* arg){
	int i,j ;
	for(i=0; i<10;i++){
		printf(""Hi %s! (I'm %lx)\n"", arg, pthread_self());
		j = 800000;
		while(j--);
	}
	return ALL_IS_OK;
}

int main (void){
	void* status;
	pthread_t writer1_pid, writer2_pid;

	pthread_create(&writer1_pid, NULL, writer, (void*)mess[1]);
	pthread_create(&writer2_pid, NULL, writer, (void*)mess[0]);

	pthread_join(writer1_pid, &status);
	if (status == ALL_IS_OK) printf(""Thread %lx completed ok \n"", writer1_pid);

	pthread_join(writer2_pid, &status);
	if (status == ALL_IS_OK) printf(""Thread %lx completed ok \n"", writer2_pid);

	return 0;
}"
200-34695,quangng/Linux-System-Programming,lab3/parta/lab3a_phase3.c,39,2,20,5905368874.431588,17171179.0,343.91167164467856,1151.0,1142.0,3039039.0,1012948.0,1592.0,588.0,1336.0,546.0,1500000000,3.936912582954392,1082014363648.0,0.0001335377145622,0.0010024711332983,"/*
 ============================================================================
 Name        : lab3a_phase3.c
 Author      : 
 Version     :
 Copyright   : Your copyright notice
 Description :

Phase 3. (Atomic operation using O_APPEND flag)
In phase 2 you saw the problem that was caused by the fact that context switch can
sometimes happen between the lseek and write system calls.
Fix the program so that you add the flag O_APPEND in the open call of each program and
see that there is no problem any more. It is not necessary or usefull to use lseek system call
in this phase anymore.
 ============================================================================
 */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

#define REPEATED_TIME 1000000

int main(void) {
	int fd = -1;
	int i = 0;

	fd = open(""/tmp/exlog.txt"", O_CREAT | O_WRONLY | O_APPEND, S_IRUSR | S_IWUSR);
	if (fd != -1) {
		for (i = 0; i < REPEATED_TIME; i++)
			write(fd, ""AAAA"", 4);
	} else
		perror(""Open error:"");

	return EXIT_SUCCESS;
}


/*
int main(void) {
	int fd = -1;
	int i = 0;

	fd = open(""/tmp/exlog.txt"", O_CREAT | O_WRONLY | O_APPEND, S_IRUSR | S_IWUSR);
	if (fd != -1) {
		for (i = 0; i < REPEATED_TIME; i++)
			write(fd, ""BBBB"", 4);
	} else
		perror(""Open error:"");

	return EXIT_SUCCESS;
}
*/
"
191-7048,aababilov/linux-research,utmp/utmp.c,13,1,8,2204972.78496615,196963.0,11.194853855800329,1367.0,1346.0,45567.0,18562.0,1632.0,653.0,1348.0,611.0,1500000000,0.0014699818566441,1082014363648.0,0.0137741606291536,0.0661791077359696,"#include <utmpx.h>
#include <stdlib.h>
#include <stdio.h>

int main()
{
	struct utmpx *utmp_info;

	while((utmp_info = getutxent()) != NULL) {
		if (utmp_info->ut_type != USER_PROCESS)
			continue;
		printf(""%s; %s; %s\n"",
		       utmp_info->ut_user,
		       utmp_info->ut_line,
		       utmp_info->ut_host);
		       
	}

	return 0;
}
"
094-8690,yunghsianglu/IntermediateCProgramming,Ch8/argument.c,34,2,15,1698016.42186935,175206.0,9.687938769220231,1348.0,1326.0,39795.0,13599.0,1625.0,637.0,1348.0,594.0,1500000000,0.0011320109479129,1082014363648.0,0.0152620344052144,0.0787354384387759,"/* argument.c 
 * pass the address of heap memory as a function argument
 */
#include <stdio.h>
#include <stdlib.h>
int sum(int * array, int length)
{
  int iter;
  int answer = 0;
  for (iter = 0; iter < length; iter ++)
    {
      answer += array[iter];
    }
  return answer;
}
int main(int argc, char * argv[])
{
  int * arr;
  int iter;
  int length = 12;
  int total;
  arr = malloc(length * sizeof(int));
  if (arr == NULL)
    {
      printf(""malloc fails.\n"");
      return EXIT_FAILURE;
    }
  for (iter = 0; iter < length; iter ++)
    {
      arr[iter] = iter;
    }
  total = sum(arr, length);
  printf(""Total is %d.\n"", total);
  free (arr);
  return EXIT_SUCCESS;
}
"
180-34938,weezybusy/KnR2,4/4-12.c,50,1,30,2356414.2175018503,181753.0,12.964924925585825,1344.0,1325.0,41034.0,14660.0,1628.0,640.0,1347.0,598.0,1500000000,0.0015709428116679,1082014363648.0,0.0146847644880689,0.0756454914353431,"/*
 * Exercise 4-12
 *
 * Adapt the ideas of printd to write a recursive version of itoa; that is,
 * convert an integer into a string by calling a recursive routine.
 */

#include <stdio.h>
#include <limits.h>

#define MAXLEN  128
#define MAXNUMS 10

void itoa_rec(int n, char s[]);

int main(void)
{
        int i;
        char s[MAXLEN];
        int nums[MAXNUMS] = {
                0,
                -1,
                7,
                -15,
                123,
                -325,
                2567,
                -10342,
                INT_MAX,
                INT_MIN
        };

        for (i = 0; i < MAXNUMS; ++i) {
                itoa_rec(nums[i], s);
                printf(""%11s\n"", s);
        }

        return 0;
}

void itoa_rec(int n, char s[])
{
        /* itoa_rec: recursively convert n to characters in s */

        static int i;
        static int sign;
        unsigned un;

        if (!sign && n < 0)
                sign = 1;

        un = (n < 0) ? -n : n;

        if (un / 10)
                itoa_rec(un/10, s);
        else {
                i = 0;
                if (sign) {
                        s[i++] = '-';
                        sign = 0;
                }
        }
        s[i++] = un % 10 + '0';
        s[i] = '\0';
}
"
353-778,totalspectrum/binutils-propeller,gdb/testsuite/gdb.dwarf2/arr-subrange.c,16,1,10,1556852.9488518,169061.0,9.208818118903828,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010379019659012,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* Copyright 2014-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
main (void)
{
  return 0;
}
"
191-17101,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.base/hook-stop-frame.c,24,1,16,1535463.03045,169061.0,9.082301654432424,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010236420203,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2009-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

void
func (void)
{
  int a;

  a = 1; /* set breakpoint here */
}

int
main (int argc, char **argv)
{
  func ();

  return 0;
}
"
235-292,Jadoch/LinuxProject,MPS/prog_linux/09/exemple_clock.c,34,4,15,4446982.75532565,468785.0,9.483138325671684,1494.0,1466.0,118800.0,82068.0,1676.0,647.0,1378.0,601.0,1500000000,0.0029646551702171,1082014363648.0,0.0063141952067578,0.021417050002987,"
	#include <stdio.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <time.h>

        void    action_a_mesurer        (void);


	int
main (void)
{
	clock_t	debut;
	double  duree;

	debut = clock ();

	action_a_mesurer ();

	duree = clock() - debut;
	duree = duree / CLOCKS_PER_SEC;
	fprintf (stdout, ""Durée = %f\n"", duree);
	return (0);
}


        void
action_a_mesurer (void)
{
        int i, j;
        FILE * fp1, * fp2;
        double x;
                
        x = 0.0;
        for (i = 0; i < 10000; i ++)
                for (j = 0; j < 10000; j ++)
                        x += i * j;

        for (i = 0; i < 500; i ++) {
                if ((fp1 = fopen (""exemple_setitimer_2"", ""r"")) != NULL) {
                        if ((fp2 = fopen (""/dev/null"", ""w"")) != NULL) {
                                while (fread (& j, sizeof (int), 1, fp1) == 1)
                                        fwrite (& j, sizeof (int), 1, fp2);
                                fclose (fp2);
                        }
                        fclose (fp1);
                }
        }
}

"
156-27127,Elitos/ls2,Practicas/hilos.c,15,2,12,2641564.8171678,203217.0,12.99873534202355,1578.0,1530.0,46966.0,18362.0,1813.0,1064.0,1376.0,986.0,1500000000,0.0017610432114452,1082014363648.0,0.0152939960731631,0.0801953220671075,"#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

void * procedimiento(void * in)
{
	int tid = (int) in;
	printf(""Hola soy la hebra %d\n"", tid);
}

int main(int argc, char * argv[])
{
	pthread_t * hebra1 = (pthread_t*) malloc(sizeof(pthread_t) * 40);
	int i, j = 10;
	for(i = 0; i < j; i++)
		pthread_create(&hebra1[i], NULL, &procedimiento, (void*) i);
	
	for(i = 0; i < j; i++)
		pthread_join(hebra1[i], NULL);
	printf(""Hebra padre ha terminado de esperar por sus hijas\n"");
}
"
381-29250,burnsba/codegolf,fasttrig/gen.c,11,2,6,454527757.4798092,4008278028.0,0.1133972628208114,1355.0,1334.0,785749554.0,509497269.0,1623.0,699.0,1344.0,656.0,1500000000,0.3030185049865395,1082014363648.0,6.708616471252428e-07,3.3368157506764254e-06,"#include <stdio.h>

int main()
{
	int i, j;

	for (i=0; i<360; i++)
	{
		for (j=0; j<10000; j++)
		{
			printf(""%d.%04d\n"", i, j);
		}
	}
}
"
152-28934,byt3smith/euler-solutions,C/euler4.c,26,3,18,14096798.957325451,75153937.0,0.1875723157390942,1346.0,1326.0,39414.0,13414.0,1627.0,637.0,1347.0,595.0,1500000000,0.0093978659715503,1082014363648.0,3.555369294891364e-05,0.0796168698417505,"// Project Euler: #4
// <byt3smith>

#include <stdio.h>
#include <math.h>

int main () {

  int x, y, z, i, bigpal, reverse=0, palcount=0;

  printf(""Calculating the largest palindrome of the product of two 3-digit numbers...\n"");

  for (x = 100; x<1000; x++) {
    for (y = 100; y<1000; y++) {
      z = x * y;
      i = z;

      while ( i != 0 ) {
        reverse = reverse * 10;
        reverse = reverse + i%10;
        i = i/10;
      }

      if ( reverse == z ) {
	if (z > bigpal) {
	  bigpal=z;
	}
	palcount++;
      }

      reverse=0;
    }
  }
  printf(""[+] Largest palindrome: %d\n"", bigpal);
  return 0;
}
"
298-4234,fredericopissarra/sandbox,tests/fp/fptest2.c,26,1,21,2038202.9470056,192478.0,10.589272540238364,1482.0,1455.0,43138.0,15706.0,1646.0,647.0,1361.0,605.0,1500000000,0.0013588019646704,1082014363648.0,0.0152588867299119,0.0723778125212426,"#include <stdio.h>
#include <math.h>
#include <values.h>

typedef union {
  float f;
  unsigned int i32;
  struct {
    unsigned int mantissa:23;
    unsigned int expoent:8;
    unsigned int sign:1;
  } s;
} f32_t;

void showFloatStructure(float x)
{
  printf(""%.15g (0x%08X; mantissa: 0x%0X, expoent: 0x%0X, sign: %c\n"",
         x, 
         ((f32_t *)&x)->i32,
         ((f32_t *)&x)->s.mantissa,
         ((f32_t *)&x)->s.expoent,
         ((f32_t *)&x)->s.sign ? '-' : '+');
}

int main(int argc, char **argv)
{
  int i;
  float values[] = { 0.0f, 1.0f, -1.0f, M_PI, FLT_EPSILON };

  for (i = 0; i < (sizeof(values) / sizeof(values[0])); i++)
    showFloatStructure(values[i]);

  return 0;
}
"
118-13217,lolosssss/leetcode,c/190_reverse_bits.c,22,1,14,2220790.4839887,173366.0,12.805140569661871,1336.0,1317.0,39173.0,13306.0,1618.0,638.0,1339.0,593.0,1500000000,0.0014805269893258,1082014363648.0,0.0153028852254767,0.0798033499113931,"/**
 * Description : Reverse Bits
 *               Reverse bits of a given 32 bits unsigned integer.
 * Author      : Evan Lau
 * Date        : 2016/03/01
 */

#include <stdio.h>
#include <inttypes.h>

uint32_t reverseBits(uint32_t n)
{
    uint32_t ret = 0;

    for (int i = 0; i < 32; i++)
    {
        ret = (ret << 1) | (n & 0x0001);
        n >>= 1;
    }

    return ret;
}

int main(void)
{
    uint32_t a = 43261596;

    printf(""%d\n"", reverseBits(a));

    return 0;
}
"
239-28913,Gurgel100/gcc,gcc/testsuite/gcc.c-torture/execute/pr98474.c,22,1,16,1950063.0442053,170734.0,11.421644195063667,1141.0,1133.0,38913.0,12869.0,1590.0,586.0,1333.0,546.0,1500000000,0.0013000420294702,1082014363648.0,0.0133189640024833,0.078309064926036,"/* PR tree-optimization/98474 */

#ifdef __SIZEOF_INT128__
typedef __uint128_t T;
#define N (__SIZEOF_INT128__ * __CHAR_BIT__ / 2)
#else
typedef unsigned long long T;
#define N (__SIZEOF_LONG_LONG__ * __CHAR_BIT__ / 2)
#endif

__attribute__ ((noipa)) void
foo (T *x)
{
  *x += ((T) 1) << (N + 1);
}

int
main ()
{
  T a = ((T) 1) << (N + 1);
  T b = a;
  T n;
  foo (&b);
  n = b;
  while (n >= a)
    n -= a;
  if ((int) (n >> N) != 0)
    __builtin_abort ();
  return 0;
}
"
144-20927,acama/binutils,gdb/testsuite/gdb.python/py-type.c,87,1,19,1982029.5274256999,169083.0,11.722225179349786,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0013213530182838,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2009-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

struct s
{
  int a;
  int b;
};

struct SS
{
  union { int x; char y; };
  union { int a; char b; };
};

typedef struct s TS;
TS ts;

#ifdef __cplusplus
struct C
{
  int c;
  int d;

  int
  a_method (int x, char y)
    {
      return x + y;
    }

  int
  a_const_method (int x, char y) const
    {
      return x + y;
    }

  static int
  a_static_method (int x, char y)
    {
      return x + y;
    }
};

struct D : C
{
  int e;
  int f;
};

template<typename T, int I, int C::*MP>
struct Temargs
{
};

Temargs<D, 23, &C::c> temvar;

#endif

enum E
{ v1, v2, v3
};

struct s vec_data_1 = {1, 1};
struct s vec_data_2 = {1, 2};

static int
a_function (int x, char y)
{
  return x + y;
}

int
main ()
{
  int ar[2] = {1,2};
  struct s st;
  struct SS ss;
#ifdef __cplusplus
  C c;
  c.c = 1;
  c.d = 2;
  D d;
  d.e = 3;
  d.f = 4;

  c.a_method (0, 1);
  c.a_const_method (0, 1);
  C::a_static_method (0, 1);
#endif
  enum E e;

  st.a = 3;
  st.b = 5;

  e = v2;

  ss.x = 100;

  a_function (0, 1);

  return 0;      /* break to inspect struct and array.  */
}
"
065-2609,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.trace/trace-break.c,45,1,22,1445761.648938,169063.0,8.55161093793438,1139.0,1129.0,38454.0,12698.0,1567.0,588.0,1316.0,547.0,1500000000,0.000963841099292,1082014363648.0,0.0134151174414271,0.0785502033156083,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2011-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#ifdef SYMBOL_PREFIX
#define SYMBOL(str)     SYMBOL_PREFIX #str
#else
#define SYMBOL(str)     #str
#endif

/* Called from asm.  */
static void __attribute__((used))
func (void)
{}

static void
marker (void)
{
  /* Some code to make sure `b marker' and `b set_point' set
     breakpoints at different addresses.  */
  int a = 0;
  int b = a;

  /* `set_point' is the label where we'll set multiple tracepoints and
     breakpoints at.  The insn at the label must the large enough to
     fit a fast tracepoint jump.  */
  asm (""    .global "" SYMBOL(set_point) ""\n""
       SYMBOL(set_point) "":\n""
#if (defined __x86_64__ || defined __i386__)
       ""    call "" SYMBOL(func) ""\n""
#endif
       );

  asm (""    .global "" SYMBOL(after_set_point) ""\n""
       SYMBOL(after_set_point) "":\n""
#if (defined __x86_64__ || defined __i386__)
       ""    call "" SYMBOL(func) ""\n""
#endif
       );
}

static void
end (void)
{}

int
main ()
{
  marker ();
  end ();
  return 0;
}
"
008-29303,Gurgel100/gcc,gcc/testsuite/c-c++-common/goacc/pr70688.c,32,3,17,1652807.92862175,169083.0,9.775122277224796,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0011018719524145,1082014363648.0,0.0134490161636592,0.0785049652044725,"const int n = 100;

int
private_reduction ()
{
  int i, r;

  #pragma acc parallel
  #pragma acc loop private (r) reduction (+:r)
  for (i = 0; i < 100; i++)
    r += 10;

  return r;
}

int
parallel_reduction ()
{
  int sum = 0;
  int dummy = 0;

#pragma acc data copy (dummy)
  {
#pragma acc parallel num_gangs (10) copy (sum) reduction (+:sum)
    {
      int v = 5;
      sum += 10 + v;
    }
  }

  return sum;
}

int
main ()
{
  int i, s = 0;

#pragma acc parallel num_gangs (10) copy (s) reduction (+:s)
  for (i = 0; i < n; i++)
    s += i+1;

#pragma acc parallel num_gangs (10) reduction (+:s) copy (s)
  for (i = 0; i < n; i++)
    s += i+1;

  return 0;
}
"
144-14900,OpenGenus/cosmos,code/online_challenges/src/project_euler/problem_005/problem_005.c,19,1,13,361834296.0253357,2433913537.0,0.1511026519262915,1341.0,1320.0,39174.0,13307.0,1618.0,638.0,1339.0,593.0,1500000000,0.2412228640168905,1082014363648.0,1.093300957305124e-06,0.0798003086831424,"#include <stdio.h>

int
main(void)
{
    int d = 1;
    
    while (!(
        (d % 11 == 0) &&
        (d % 12 == 0) &&
        (d % 13 == 0) &&
        (d % 14 == 0) &&
        (d % 15 == 0) &&
        (d % 16 == 0) &&
        (d % 17 == 0) &&
        (d % 18 == 0) &&
        (d % 19 == 0) &&
        (d % 20 == 0)
    ))
        ++d;
    
    printf(""%d\n"", d);
}"
048-24155,zkincaid/duet,test/concurrent/15_dekker_true-unreach-call.c,45,4,18,1877628.0339807,174667.0,10.749758111148642,1305.0,1282.0,39667.0,13537.0,1625.0,647.0,1348.0,608.0,1500000000,0.0012517520226538,1082014363648.0,0.0148110404369457,0.0794677091947973,"extern void __VERIFIER_error() __attribute__ ((__noreturn__));

#include <pthread.h>

#define assert(e) { if(!(e)) { ERROR: __VERIFIER_error();(void)0; } }

int flag1 = 0, flag2 = 0; // N boolean flags 
int turn = 0; // integer variable to hold the ID of the thread whose turn is it
int x; // variable to test mutual exclusion

void* thr1(void* arg) {
  flag1 = 1;
  while (flag2 >= 1) {
    if (turn != 0) {
      flag1 = 0;
      while (turn != 0) {};
      flag1 = 1;
    }
  }
  // begin: critical section
  x = 0;
  assert(x<=0);
  // end: critical section
  turn = 1;
  flag1 = 0;

  return 0;
}

void* thr2(void* arg) {
  flag2 = 1;
  while (flag1 >= 1) {
    if (turn != 1) {
      flag2 = 0;
      while (turn != 1) {};
      flag2 = 1;
    }
  }
  // begin: critical section
  x = 1;
  assert(x>=1);
  // end: critical section
  turn = 1;
  flag2 = 0;

  return 0;
}

int main()
{
  pthread_t t;

  pthread_create(&t, 0, thr1, 0);
  thr2(0);

  return 0;
}

"
222-6101,uarka/binutils,gdb/testsuite/gdb.base/double-prompt-target-event-error.c,18,1,13,4502387078.711763,170064.0,26474.662938658388,1150.0,1141.0,38683.0,12795.0,1574.0,581.0,1323.0,544.0,1500000000,3.001591385807842,1082014363648.0,0.0134713990027283,0.0781304634989704,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
main (void)
{
  sleep (3);
  return 0; /* after sleep */
}
"
196-4743,SeijiStory/KandR,2/2-10.c,23,2,13,1980634.2897935999,175023.0,11.316421270347323,1283.0,1268.0,39812.0,13535.0,1631.0,635.0,1351.0,592.0,1500000000,0.0013204228598624,1082014363648.0,0.0145752272558463,0.0788985322511106,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define CAPITAL(x) ((x) >= 'A' && (x) <= 'Z')
int lower(char *str);
int main(int argc, char **argv)
{
	int i;
	char *tmp = NULL;
	for (i = 1; i < argc; ++i) {
		tmp = realloc(tmp, strlen(argv[i]+1));
		strcpy(tmp, argv[i]);
		lower(tmp);
		printf(""%s "", tmp);
	}
	printf(""\n"");
	return 0;
}

int lower(char *str)
{
	if (!str)
		return 1;
	size_t i;
	for (i = 0; str[i] > '\0'; ++i)
		str[i] = (CAPITAL(str[i]) ? str[i] + ('a' - 'A') : str[i]);
	return 1;
}
"
262-7623,LiuZhenPei/demos,others/process-and-thread/pthread_create_with_param.c,27,1,17,1502767802.9146047,183969.0,8168.592545483207,1499.0,1465.0,41879.0,15099.0,1657.0,752.0,1364.0,710.0,1500000000,1.0018452019430697,1082014363648.0,0.0161114100745234,0.0786794903296008,"#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

struct char_print_parms {
    char character;
    int count;
};

void *char_print (void* parameters) {
    struct char_print_parms*  p = (struct char_print_parms*)parameters;
    int i;

    for (i = 0; i < p->count; ++i)
        printf(""%c\n"", p->character);

    return NULL;
}

int main () {
    pthread_t thread1_id;
    pthread_t thread2_id;
    struct char_print_parms thread1_args;
    struct char_print_parms thread2_args;

    /*  Create  a  new  thread  to  print  30,000  'x's.  */
    thread1_args.character = 'x';
    thread1_args.count = 6;
    pthread_create(&thread1_id, NULL, &char_print, &thread1_args);

    /*  Create  a  new  thread  to  print  20,000  o's.  */
    thread2_args.character = 'o';
    thread2_args.count = 2;
    pthread_create(&thread2_id, NULL, &char_print, &thread2_args);

    sleep(1);

    return  0;
}
"
137-11867,gunmetal313/relipmoC,examples/source/for.c,17,7,10,1702322.9738697,169044.0,10.07028939211093,1138.0,1128.0,38452.0,12699.0,1567.0,585.0,1317.0,546.0,1500000000,0.0011348819825798,1082014363648.0,0.0134047940181254,0.0784930890891673,"#include<stdio.h>

/* when the assembly equivalent of this code is decompiled the ""for"" loop
would be converted to an equivalent ""while"" loop. this because there isn't a
concept of ""for loops"" in assembly statements and the compiler generates the
same code for both ""while"" and ""for"" loops.
The other statements are just there to show that ""relipmoC"" can handle them.
*/

int var, i = 3;

int main( void )
{
	for ( i = var; i < 10; ++i )
		++var;

	if ( var > 10 )
		var = i / var;
	else
		var = var ^ -i;

	return 0;
}

"
094-7842,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.dwarf2/dw2-undefined-ret-addr.c,29,2,14,1520975.9585559,169080.0,8.995593801750651,1142.0,1132.0,38460.0,12696.0,1566.0,584.0,1317.0,544.0,1500000000,0.0010139839723706,1082014363648.0,0.0134492547906316,0.0784072249589491,"/*
   Copyright 2013-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

void
stop_frame ()
{
  /* The debug information for this frame is modified in the accompanying
     .S file, to mark the return address as undefined.  */
}

void
first_frame ()
{
  stop_frame ();
}

int
main ()
{
  first_frame ();

  return 0;
}
"
208-13024,Alex1990/ccell,str_upper_case.c,42,1,28,2127288.2586344997,181010.0,11.752323076073145,1350.0,1326.0,41209.0,14391.0,1648.0,642.0,1363.0,598.0,1500000000,0.001418192172423,1082014363648.0,0.014783713606983,0.0764568345323741,"/**
 * Convert all characters of the string to uppercase.
 */

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <assert.h>

#define log printf

char *
str_upper_case(char *dest, const char *src)
{
  size_t i = 0;

  while (src[i] != '\0') {
    dest[i] = toupper(src[i]);
    ++i;
  }
  dest[i] = '\0';

  return dest;
}

int
main()
{
  char *src1 = ""HellO, WoRlD"";
  char src2[] = ""hElLo"";
  char *src3 = """";
  char *dest1, *dest2, *dest3;

  dest1 = malloc(strlen(src1) * sizeof(char) + 1);
  dest2 = malloc(strlen(src2) * sizeof(char) + 1);
  dest3 = malloc(strlen(src3) * sizeof(char) + 1);

  assert(dest1 != NULL);
  assert(dest2 != NULL);
  assert(dest3 != NULL);

  log(""Before uppercase\n"");
  log(""================\n"");

  log(""src1: %s\n"", src1);
  log(""src2: %s\n"", src2);
  log(""src3: %s\n"", src3);

  str_upper_case(dest1, src1);
  str_upper_case(dest2, src2);
  str_upper_case(dest3, src3);

  log(""\nAfter uppercase\n"");
  log(""================\n"");

  log(""dest1: %s\n"", dest1);
  log(""dest2: %s\n"", dest2);
  log(""dest3: %s\n"", dest3);

  return 0;
}
"
265-17347,pgpbpadilla/c-exercises,quick_sort/quick_sort/main.c,63,3,33,1558788.1207465502,326874.0,4.768773288790176,1392.0,1369.0,72883.0,35020.0,1650.0,649.0,1369.0,605.0,1500000000,0.0010391920804977,1082014363648.0,0.0084466797603969,0.0396003818244163,"//
//  main.c
//  quick_sort
//
//  Created by Pablo Padilla on 3/22/15.
//  Copyright (c) 2015 pgpb.padilla. All rights reserved.
//

#include <stdio.h>
#include <time.h>
#include <stdlib.h>

void quick_sort(int array[], int start, int end);
int partition(int array[], int start, int end);

void print(int array[], int size);

int main(int argc, const char * argv[]) {

    int size = 100;
    int array[size];
    
    int x = 0;
    
    srand((int)time(NULL));
    
    for (x = 0; x<size; ++x) {
        array[x] = rand() % size;
    }
    
    int* start = array;
    
    printf(""Before sorting... \n"");
    print(array, size);
    
    quick_sort(start, 0, size);
    
    printf(""After sorting... \n"");
    print(array, size);
    
    return 0;
}

void print(int array[], int size) {
    int i = 0;
    for (i = 0; i<size; ++i) {
        if (i%30 == 0) {
            printf(""\n"");
        }
        printf(""%d\t"", array[i]);
    }
    printf(""\n"");
}

void swap(int array[], int idx1, int idx2) {
    int tmp = array[idx1];
    array[idx1] = array[idx2];
    array[idx2] = tmp;
}

int partition(int array[], int start, int end) {
    
    int pivot_value = array[end];
    int pivot_idx = start - 1;
    int idx;
    
    for (idx = start; idx < end; ++idx) {
        if (array[idx] <= pivot_value) {
            pivot_idx++;
            swap(&array[0], pivot_idx, idx);
        }
    }
    swap(&array[0], pivot_idx+1, end);
    
    return pivot_idx;
}

void quick_sort(int array[], int start, int end) {
    int pivot;
    
    if (start < end) {
        pivot = partition(array, start, end);
        quick_sort(array, start, pivot - 1);
        quick_sort(array, pivot + 1, end);
    }
    return;
}
"
290-11979,AndrewLaing/CHowToProgramExercises,Chapter4/ex04_13.c,16,1,15,1730959.3968093,173136.0,9.997683901672673,1338.0,1319.0,39186.0,13308.0,1618.0,636.0,1340.0,593.0,1500000000,0.0011539729312062,1082014363648.0,0.0153463173459014,0.0797614965519868,"/*
 * Filename:    ex04_13.c
 * Author:      Andrew Laing
 * Email:       parisianconnections@gmail.com
 * Date:        19/04/2017
 * Description: Write a program that calculates and prints the sum
 *              of the odd integers from 1 to 15.
 */

#include <stdio.h>


int main()
{
    int sum = 0, number;
    
    for(number = 1; number <= 15; number += 2)
        sum += number;
    
    printf(""Sum is %d\n"", sum );

    return 0;
}

"
288-2612,TZer0/INF3190-groupcode,2013/week4/fixmewithvalgrind.c,12,1,12,1920411.0139980002,180046.0,10.666224187152173,1354.0,1333.0,40789.0,14359.0,1618.0,638.0,1341.0,593.0,1500000000,0.001280274009332,1082014363648.0,0.0149239638758983,0.0759773699862189,"#include<stdio.h>
#include<stdlib.h>

int main() {
	int v[10], i;
	int *v2 = malloc(sizeof(int) * 10);
	for (i = 0; i < 10; i++) {
		// recommended: v[i] = i;
		//v[i] = i;
		//printf(""%d\n"", v[i]);
		v2[i] = i;
		printf(""%d\n"", v2[i]);
	}
	free(v2);
}
"
359-356,JacobCWard/CSIS3150,week01/arrays.c,9,1,8,1916448.12002775,187496.0,10.221274053846482,1375.0,1353.0,42228.0,15263.0,1630.0,638.0,1348.0,597.0,1500000000,0.0012776320800185,1082014363648.0,0.0145496437257328,0.0732810352924805,"//

#include <stdio.h>
#include <stdlib.h>

int main () {
	int n[10] = {10,20,30,40,50,60,70,80,90,100};
	int i;
	
	printf(""%s%9s\n"", ""Index"", ""Value"");
	for (i = 0; i<10; i++) {
		printf(""%3d%13d\n"", i, n[i]);
	}
}"
200-25657,Alex1990/ccell,str_lower_case.c,42,1,28,2119623.008184,181000.0,11.710624309392266,1353.0,1332.0,41206.0,14391.0,1649.0,642.0,1363.0,598.0,1500000000,0.001413082005456,1082014363648.0,0.0148342541436464,0.0764789467057575,"/**
 * Convert all characters of the string to lowercase.
 */

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <assert.h>

#define log printf

char *
str_lower_case(char *dest, const char *src)
{
  size_t i = 0;

  while (src[i] != '\0') {
    dest[i] = tolower(src[i]);
    ++i;
  }
  dest[i] = '\0';

  return dest;
}

int
main()
{
  char *src1 = ""HellO, WoRlD"";
  char src2[] = ""hElLo"";
  char *src3 = """";
  char *dest1, *dest2, *dest3;

  dest1 = malloc(strlen(src1) * sizeof(char) + 1);
  dest2 = malloc(strlen(src2) * sizeof(char) + 1);
  dest3 = malloc(strlen(src3) * sizeof(char) + 1);

  assert(dest1 != NULL);
  assert(dest2 != NULL);
  assert(dest3 != NULL);

  log(""Before lowercase\n"");
  log(""================\n"");

  log(""src1: %s\n"", src1);
  log(""src2: %s\n"", src2);
  log(""src3: %s\n"", src3);

  str_lower_case(dest1, src1);
  str_lower_case(dest2, src2);
  str_lower_case(dest3, src3);

  log(""\nAfter lowercase\n"");
  log(""================\n"");

  log(""dest1: %s\n"", dest1);
  log(""dest2: %s\n"", dest2);
  log(""dest3: %s\n"", dest3);

  return 0;
}
"
120-31197,Gathros/algorithm-archive,contents/IFS/code/c/IFS.c,31,2,17,4444132.5590013005,3710719.0,1.1976471406215343,1522.0,1494.0,741114.0,484674.0,1793.0,1015.0,1379.0,906.0,1500000000,0.0029627550393342,1082014363648.0,0.000812780488094,0.0041548783313264,"#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

struct point {
    double x, y;
};

double drand() {
    return ((double) rand() / (RAND_MAX));
}

struct point random_element(struct point *array, size_t n) {
    return array[rand() % (int)n];
}

void chaos_game(struct point *in, size_t in_n, struct point *out,
                size_t out_n) {

    struct point cur_point = {drand(), drand()};

    for (int i = 0; i < out_n; ++i) {
        out[i] = cur_point;
        struct point tmp = random_element(in, in_n);
        cur_point.x = 0.5 * (cur_point.x + tmp.x);
        cur_point.y = 0.5 * (cur_point.y + tmp.y);
    }
}

int main() {
    struct point shape_points [3] = {{0.0,0.0}, {0.5,sqrt(0.75)}, {1.0,0.0}};
    struct point out_points[1000];

    srand(time(NULL));

    chaos_game(shape_points, 3, out_points, 1000);

    FILE *fp = fopen(""out.dat"", ""w+"");

    for (int i = 0; i < 1000; ++i) {
        fprintf(fp, ""%f\t%f\n"", out_points[i].x, out_points[i].y);
    }

    fclose(fp);

    return 0;
}

"
285-27760,begeekmyfriend/leetcode,0704_binary_search/binary_search.c,19,1,17,1625552.77347555,174713.0,9.304127340266607,1340.0,1321.0,39577.0,13496.0,1626.0,638.0,1344.0,595.0,1500000000,0.0010837018489837,1082014363648.0,0.0152306926216137,0.0791928099033406,"#include <stdio.h>

int search(int* nums, int numsSize, int target){
    if(target > nums[numsSize-1] || target < nums[0])return -1;
    int begin = -1 ,end = numsSize;
    while(begin < end-1){
        int half = (begin+end)/2;
        if(nums[half]<target)begin = half;
            else end = half;
    }
    if(nums[end]==target) return end ;
    else return -1; 
}

int main(void) {
  int test[6] = {-1,0,3,5,9,12};
  
  //test 1 - number 2;
  printf(""possible index = %d\n"",search(test,6,2));
  //test 2 - number 9
  printf(""possible index = %d\n"",search(test,6,9));
  return 0;
}"
064-645,hydai/CProgramming,3rd/Homework3-3.c,32,1,22,1470856.71778755,203714.0,7.220200869846942,1388.0,1364.0,46148.0,16481.0,1645.0,641.0,1362.0,597.0,1500000000,0.0009805711451917,1082014363648.0,0.013509135356431,0.0677801018697408,"#include <stdio.h>
#include <stdlib.h>

struct ID_table
{
	int ID_number;
	int year, institution, department, other;
};

void produce_ID( struct ID_table *ID )
{
	ID -> year = rand() % 4 + 98;
	
	
	int institution_temp = rand() % 2;
	
	if( institution_temp == 0 )
		ID -> institution = 4;
	else
		ID -> institution = 6;
	
	ID -> department = rand() % 10;

	ID -> other = rand() % 1000;
}

void print_ID( struct ID_table *ID )
{
	printf(""%d%02d%d%03d\n"", ID -> year, ID -> institution, ID -> department, ID -> other);
}

int main()
{
	struct ID_table ID;
	
	srand(time(NULL));
	int i;
	for( i = 0 ; i < 10 ; i++)
	{
	produce_ID( &ID );
	print_ID( &ID );
	}
	return 0;
}
"
215-17687,xdje42/gdb,gdb/testsuite/gdb.base/continue-all-already-running.c,18,1,13,15002082052.524202,170055.0,88219.00004116315,1149.0,1140.0,38683.0,12795.0,1574.0,581.0,1323.0,544.0,1500000000,10.001388035016134,1082014363648.0,0.0134603510628914,0.0781304634989704,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
main (void)
{
  sleep (10);
  return 0; /* set break here */
}
"
242-35318,DeadDork/learning_c,experiments/weird_coding_style_1.c,13,2,9,2439619.6240558503,179081.0,13.622991830512449,1340.0,1322.0,40452.0,14198.0,1618.0,635.0,1340.0,591.0,1500000000,0.0016264130827039,1082014363648.0,0.0148647818584886,0.0765599268069533,"// Explores writing a for with lots of newlines.

// Conclusion: I can't believe this works... I guess that shows you that
// white spaces are really not important in C.

#include <stdio.h>

int main(void) {
	for (
			int i = 0;
			i < 10;
			++i)
	{
		printf(""i = [%d]\n"", i);
	};

	return 0;
}
"
226-12269,mattstock/binutils-bexkat1,gdb/testsuite/gdb.base/vla-ptr.c,44,2,27,1586731.2904446,169083.0,9.384331955311888,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010578208602964,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#define SIZE 5

void
foo (int n, int vla_ptr[n])
{
  return;         /* foo_bp */
}

void
bar (int *vla_ptr)
{
  return;         /* bar_bp */
}

void
vla_func (int n)
{
  int vla[n];
  typedef int typedef_vla[n];
  typedef_vla td_vla;
  int i;

  for (i = 0; i < n; i++)
    {
      vla[i] = 2+i;
      td_vla[i] = 4+i;
    }

  foo(n, vla);
  bar(vla);

  return;         /* vla_func_bp */
}

int
main (void)
{
  vla_func(SIZE);

  return 0;
}
"
351-887,artemiyds2/K-R,1/1_7.c,15,2,11,1747593.28365315,191494.0,9.12609794562754,1359.0,1338.0,42799.0,15606.0,1628.0,639.0,1349.0,597.0,1500000000,0.0011650621891021,1082014363648.0,0.0140839921877447,0.0721342350826128,"#include <stdio.h>

int power(int, int);

int main(int argc, char const *argv[])
{
	printf(""| n | base: 2 | base -3 |\n"");
	for (int i = 0; i < 10; ++i)
		printf(""| %d | %7d | %7d |\n"", i, power(2, i), power(-3, i));
	return 0;
}

int power(int base, int n)
{
	int p;

	for (p = 1; n > 0; --n)
		p = p * base;
	return p;
}
"
003-27583,skuhl/sys-prog-examples,simple-examples/clock.c,15,1,12,7507227511.49442,176059.0,42640.407539518,1350.0,1329.0,39897.0,13703.0,1630.0,636.0,1351.0,593.0,1500000000,5.00481834099628,1082014363648.0,0.0152164899266723,0.0785447761194029,"// Scott Kuhl
// See ""man 3 clock""
#include <time.h>
#include <stdio.h>
#include <unistd.h>

int main(void)
{
	printf(""CLOCKS_PER_SEC=%ld\n"", CLOCKS_PER_SEC);
	sleep(5); // doesn't actually use CPU time
	clock_t c = clock();
	printf(""CPU time used so far: %ld\n"", c);
	int i=1;
	while(i < 1000000000) // use some CPU time.
		i=i+1;
	c = clock();
	printf(""CPU time used so far: %ld\n"", c);
	return 0;
}
"
184-26083,ilee/projects,daily/pe/pe4.c,29,3,20,12939202.5992274,75269603.0,0.1719047461961504,1338.0,1318.0,62072.0,28715.0,1619.0,685.0,1341.0,642.0,1500000000,0.0086261350661516,1082014363648.0,3.528648875695545e-05,0.0472204170200579,"/* Project Euler
** 4
*/

#include <stdio.h>

static int palindrome = 0;

int isPalindrome (int number) {
	int temp=number, rem, reverse=0;

	while(temp!=0) {
		rem=temp%10;
		reverse=reverse*10+rem;
		temp/=10;
	}

	if (reverse == number) return 1;
	else return 0;
}

int main(int argc, char** argv) {
	int i,j;
	int current;

	for (i=100; i<1000; i++) {
		for (j=100; j<1000; j++) {
			current=i*j;
			if (isPalindrome(current) && palindrome < current) {
				palindrome = current;
				printf(""The numbers are %d and %d.\n"", i, j);
			}
		}
	}

	printf(""%d\n"", palindrome);

return 0;
}

"
092-12111,Gurgel100/gcc,gcc/testsuite/gcc.c-torture/execute/pr97888-1.c,22,1,13,1623872.90038155,169126.0,9.601551505977792,1142.0,1132.0,38461.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010825819335877,1082014363648.0,0.0134455967740028,0.078503430615556,"/* PR tree-optimization/97888 */

int a = 1, c = 4, d, e;

int
main ()
{
  int f = -173;
  int b;
  for (b = 0; b < 10; b++)
    {
      int g = f % (~0 && a), h = 0, i = 0;
      if (g)
	__builtin_unreachable ();
      if (c)
	h = f;
      if (h > -173)
	e = d / i;
      f = h;
    }
  if (f != -173)
    __builtin_abort ();
  return 0;
}
"
277-6916,Leo-Souto/physics-simulations,chapter-7/box2.c,24,2,19,864699127.3853928,5755139075.0,0.1502481722390001,1403.0,1375.0,1558150399.0,545353457.0,1641.0,648.0,1357.0,605.0,1500000000,0.5764660849235952,1082014363648.0,4.826990214828127e-07,2.0209138138133274e-06,"#include <stdio.h>
#include <math.h>
#include <time.h>
#include <stdlib.h>
#define pi M_PI
#define inf INFINITY


int main(void)
{
	int nleft, N, t;
	double r;
	FILE *graf;
	graf = fopen(""graf2.dat"", ""w"");

	srand(time(NULL));
	for (N = 8; N <=10000000; N = N*2){
		nleft = N;
		t = 0;
		while (nleft != N/2){
			r = rand()*1.0/RAND_MAX;
			if (r <= nleft*1.0/N){
				nleft--;
			}
			else {
				nleft++;
			}
			t++;
		}
		fprintf(graf, ""%d\t %d\n"", N, t); /*to plot in gnuplot use this command: plot 'graf2.dat' u 1:2 w l*/
	}
	return 0;
}
"
262-1583,chaicko/ExploringBeagleBone,exploringBB/chp05/proc/whologgedin.c,8,3,8,1671363.01752165,173938.0,9.6089583644747,1337.0,1317.0,39385.0,13408.0,1629.0,637.0,1347.0,593.0,1500000000,0.0011142420116811,1082014363648.0,0.0152583104324529,0.0796696531737162,"/* Written by Derek Molloy for the book ""Exploring BeagleBone: Tools and 
* Techniques for Building with Embedded Linux"" by John Wiley & Sons, 2014
* ISBN 9781118935125. Please see the file README.md in the repository root 
* directory for copyright and GNU GPLv3 license information.            */

#include<unistd.h>
#include<stdio.h>
int main(){
   printf(""The user logged in is %s\n"", getlogin());
   return 0;
}
"
176-34268,mattstock/binutils-bexkat1,gdb/testsuite/gdb.python/py-mi-events.c,20,2,12,1412162.79007485,169061.0,8.352973187192788,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0009414418600499,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2016-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see  <http://www.gnu.org/licenses/>.  */

int
main (void)
{
  int i = 0;
  while (i < 10)
    i++;

  return 0;
}
"
146-6089,zhoulipeng/cppwork,perf/gnu/getopt_long.c,23,1,13,1734782.9416393498,172842.0,10.036808183196214,1152.0,1141.0,39514.0,13132.0,1607.0,595.0,1340.0,551.0,1500000000,0.0011565219610929,1082014363648.0,0.0132664514412006,0.077745697678836,"#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <getopt.h>
 
int
main(int argc, char **argv)
{
   int opt;
   int digit_optind = 0;
   int option_index = 0;
   char *optstring = ""a:b:c:d"";
   static struct option long_options[] = {
       {""reqarg"", required_argument, NULL, 'r'},
       {""noarg"",  no_argument,       NULL, 'n'},
       {""optarg"", optional_argument, NULL, 'o'},
       {0, 0, 0, 0}
   };
 
   while ( (opt = getopt_long(argc -2 , argv + 2, optstring, long_options, &option_index)) != -1)
   {
        printf(""opt = %c\n"", opt);
        printf(""optarg = %s\n"", optarg);
        printf(""optind = %d\n"", optind);
        printf(""argv[optind - 1] = %s\n"",  argv[optind - 1]);
        printf(""option_index = %d\n"", option_index);
   }
 
   return 0;
}


"
141-29763,JShadowMan/package,c/algorithm/qsort.c,51,4,27,2164113.10248075,186959.0,11.575334699051664,1358.0,1338.0,42245.0,15324.0,1631.0,636.0,1351.0,594.0,1500000000,0.0014427420683205,1082014363648.0,0.0144202739638102,0.0731643766610502,"#include <stdio.h>
#include <stdlib.h>

void quick_sort(int array[], size_t array_length);
void array_dump(int array[], size_t array_length);
static void swap(int *x, int *y);

int main(void) {
    int array[] = { 1, 3, 8, 2, 4, 9, 6, 5, 7, 0 };

    array_dump(array, sizeof(array) / sizeof(int));
    quick_sort(array, sizeof(array) / sizeof(int));
    array_dump(array, sizeof(array) / sizeof(int));

    return 0;
}

void quick_sort(int array[], size_t array_length) {
    int start = 0;
    int end = array_length - 1;
    int key_index = 0;

    if (array_length < 1) {
        return;
    }

    while (start != end) {
        while (start != end) {
            if (array[end] < array[key_index]) {
                swap(array + end, array + key_index);
                key_index = end;
                
                break;
            } else {
                --end;
            }
        }

        while (start != end) {
            if (array[start] > array[key_index]) {
                swap(array + start, array + key_index);
                key_index = start;

                break;
            } else {
                ++start;
            }
        }
    }

    quick_sort(array, start);
    quick_sort(array + start + 1, array_length - start - 1);
}

void array_dump(int array[], size_t array_length) {
    for (int index = 0; index < array_length; ++index) {
        printf(""%d "", array[index]);
    }
    printf(""\n"");
}

static void swap(int *x, int *y) {
    int tmp = *x;
    *x = *y;
    *y = tmp;
}
"
028-17195,cirline/ct,basic/algo/radix_sort/main.c,62,7,30,3420966.2117064,205133.0,16.67681942934584,1387.0,1362.0,46528.0,18138.0,1646.0,652.0,1364.0,609.0,1500000000,0.0022806441411376,1082014363648.0,0.0134010617501815,0.0660470726502335,"#include <stdio.h>
#include <stdlib.h>

struct ds {
	struct ds *next;
	int x;
};

#define DATA_SIZE	16

#define HEAD_SIZE	16

struct ds head[HEAD_SIZE];

void pr_head(void)
{
	int i;
	struct ds *p;

	printf(""head list:\n"");
	for(i = 0; i < HEAD_SIZE; i++) {
		p = head + i;
		while(p) {
			printf(""%8d"", p->x);
			p = p->next;
		}
		printf(""\n"");
	}
}

int get_int(void)
{
	return random() & 0xffff;
}

void list_add_tail(int offset, int x)
{
	struct ds *p = malloc(sizeof(*p));
	struct ds *l;

	if(!p) {
		printf(""malloc failed\n"");
		return;
	}

	for(l = head + offset; l->next; l = l->next)
		;

	p->x = x;
	p->next = NULL;

	l->next = p;
}

void list_del(struct ds *p)
{

}

int main(void)
{
	int i, j;

	for(i = 0; i < HEAD_SIZE; i++) {
		head[i].x = i;
	}

	for(i = 0; i < DATA_SIZE; i++) {
		int x = get_int();
		int j = x & 0xf;
		list_add_tail(j, x);
	}

	for(i = 0; i < HEAD_SIZE; i++) {
		struct ds *p = head + i;
		struct ds *pp;

		for(pp = head->next; pp; pp = pp->next) {
			int mask = (pp->x & 0xf0) >> 4;

			list_del(pp);
			
		}
	}

	pr_head();

	return 0;
}
"
252-10421,chabbimilind/cctlib,tests/footprint_test/test1.c,28,3,14,61711542.075499795,85169099.0,0.7245766683524503,1145.0,1135.0,20038462.0,5012698.0,939118.0,313093.0,938817.0,546.0,1500000000,0.0411410280503332,1082014363648.0,2.6770272631391813e-05,0.0874839328797548,"#include <stdio.h>
#define N (10000000)
int A[N];
int B[N/2];

void g()
{
  int i=0;
  for (i = 0; i<N; i++) A[i] ++;
}

void h()
{
  int i;
  for (i = 0; i<N/2; i++) B[i]++;
}
void h1()
{
  int i;
  for (i = 1; i<N/2; i++) B[i] = B[i-1];
}

void f()
{
  g();
}

int main()
{
  f();
  h();
  h1();
  return 0;
}
"
051-18616,BigBoss424/CandUnix,Examples/ex11.c,22,3,16,1990683.1439583001,178083.0,11.178399959569417,1356.0,1335.0,40251.0,13960.0,1627.0,637.0,1345.0,596.0,1500000000,0.0013271220959722,1082014363648.0,0.0151109314196189,0.0775672833926693,"#include <stdio.h>

int main(int argc, char *argv[])
{
    //go through each string in argv

    int i = 0;
    while(i < argc)
    {
        printf(""arg %d: %s\n"", i, argv[i]);
        i++;
    }

    //let's make our own array of strings
    char *states[] = {
        ""California"", ""Washington"",
        ""Texas"", ""Arizona""};

    int num_states = 4;
    i = 0; //watch for this
    while(i < num_states)
    {
        printf(""state %d: %s\n"", i, states[i]);
        i++;
    }

    return 0;
}
"
028-34727,mikephp/basic_data_struct,src/telnet_client/.test/test/thread.c,45,1,33,1502525875.6941185,254952.0,5890.499568546236,2309.0,1786.0,60478.0,23367.0,2170.0,833.0,1641.0,756.0,1500000000,1.0016839171294123,1082014363648.0,0.0160618469358938,0.0644045560260003,"/*
* =====================================================================================
*
* Filename: pthread1.c
*
* Description: A Simple program of showing What pthread is
*
* Version: 1.0
* Created: 03/10/2009 08:53:48 PM
* Revision: none
* Compiler: gcc
*
* Author: Futuredaemon (BUPT), gnuhpc@gmail.com
* Company: BUPT_UNITED
*
* =====================================================================================
*/
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <time.h>
void *thread(void *threadid)
{
int tid;
tid = (int)threadid;
printf(""Hello World! It's me, thread #%d!\n"", tid);
pthread_exit(NULL);
}
int main(void)
{
pthread_t id;
void *ret;
int i,retv;
int t=123;
retv=pthread_create(&id,NULL,(void *) thread,(void *)t);
	printf(""thread id=%d\n"",id);
if (retv!=0)
{
printf (""Create pthread error!\n"");
return 1;
}
	//sleep(1);
	for (i=0;i<3;i++)
		printf(""This is the main process.\n"");
	pthread_join(id,&ret);
	printf(""The thread return value is %d\n"",(int)ret);
	sleep(1);
	return 0;
}
"
218-5513,laurofigueroa/Sistema-Operativo-1,codigo-de-clase/ucontext.c,52,2,22,15975334.33232445,26549021.0,0.6017296833657256,1495.0,1465.0,5586581.0,4024107.0,1655.0,756.0,1364.0,714.0,1500000000,0.0106502228882163,1082014363648.0,0.0001114918700768,0.0004670841463171,"#include <stdio.h>
#include <ucontext.h>

typedef struct {
    ucontext_t uc;
    stack_t stck[1024];
} Task_t;

void create_task(Task_t *t, ucontext_t *link, void (*pf)()) 
{
    getcontext(&t->uc);
    t->uc.uc_link = link;
    t->uc.uc_stack.ss_sp = t->stck;
    t->uc.uc_stack.ss_size = sizeof(t->stck);
    makecontext(&t->uc, pf, 0);
} 

/*void cosa()                                        *
{
    printf(""guau!\n"");
}
                                                     *Forma mas precaria hecha en clase
int main()
{
    Task_t tcosa, tmain;
    getcontext(&tmain.uc);
    create_task(&tcosa, &tmain.uc, cosa);
    swapcontext(&tmain.uc, &tcosa.uc);               *
    printf(""chau\n"");
    return 0;
}
*/

Task_t tf, tg, tmain;

void f() 
{
    int i;
    for(i = 0; i < 10000; i++) {
        printf(""%d "", i);
        swapcontext(&tf.uc, &tg.uc);
    } 
} 

void g() 
{
    double d;
    for(d = 0; ; d += 0.0001) {
        printf(""%f "", d);
        swapcontext(&tg.uc, &tf.uc);
    }    
}

int main() 
{
    getcontext(&tmain.uc);
    create_task(&tf, &tmain.uc, f);
    create_task(&tg, &tmain.uc, g);
    swapcontext(&tmain.uc, &tf.uc);
    return 0;
}    

"
305-13346,reynoldscem/BadC,src/sleepMacro.c,44,4,29,1564656310.7147813,9663845691.0,0.1618665821057965,1145.0,1136.0,38462.0,12697.0,1570.0,588.0,1317.0,547.0,1500000000,1.0431042071431875,1082014363648.0,2.360343979958527e-07,0.0786176430344611,"#include <time.h>
#include <limits.h>

#define ONLY_ONCE plsDontUseThisNameElseWhereOrIWontCompile
#define INITIALISE int ONLY_ONCE;
#define TIMEWAIT 357913941
#define STEP (INT_MAX/TIMEWAIT)
#define SPEED_LOOP(X) ONLY_ONCE=0;for(;ONLY_ONCE<X;ONLY_ONCE++){asm volatile(""nop"");}
#define SLEEP(X) {SPEED_LOOP(TIMEWAIT*X)} 
#define PRODUCTION 1
#ifndef PRODUCTION
  #include <stdio.h>
  #define TIMING(X) X=(int)time(NULL);SPEED_LOOP(INT_MAX)X=INT_MAX/((int)time(NULL)-X);
#endif

void sleep(int seconds) {
  int i=seconds/STEP;
  INITIALISE
  if (i==0) goto skip;
  batches: SLEEP(STEP) if(--i>0)goto batches;
  skip: i=seconds%STEP;
  if (i==0) return;
  singles: SLEEP(1) if(--i>0)goto singles;
}

int main(void) {
  #ifndef PRODUCTION
    /* Run without PRODUCTION defined to test the value
       for TIMEWAIT tuned to your system.
       This may afterwards be tuned by hand or with
       machine learning algorithms
    */
    INITIALISE
    int i;
    TIMING(i)
    printf(""Need %d loops per second ;)\n"", i);
  #endif
  #ifdef PRODUCTION
    /* Production tutorial

      You must call initialise before using SLEEP(n) directly
      Works for floating point values
    */
    INITIALISE
    SLEEP(0.25)
    SLEEP(0.25)
    SLEEP(0.25)
    SLEEP(0.25)

    /* Calling INITALISE again within a given scope
       will fail to compile, so use safety braces if you need that
       functionality
    */
    {
      INITIALISE
      SLEEP(1)
      SLEEP(0)
    }

    /* If you can handle the overhead of a function call
       you can use the high level version.
       Only works for whole seconds
    */
    sleep(7);
  #endif
  return 0;
}
"
028-10344,hzq1001/or1k-src,gdb/testsuite/gdb.threads/switch-threads.c,33,3,18,1504307.8456074,176073.0,8.543655188472963,1369.0,1345.0,40010.0,13718.0,1630.0,659.0,1351.0,614.0,1500000000,0.0010028718970716,1082014363648.0,0.0154140612132467,0.0791765932102441,"/* A minimal multi-threaded test case.

   Copyright 2003-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <pthread.h>

void foo (void)
{
}

void *thread_func (void *arg)
{
  int x;
  for (x = 0; x < 10; x++)
    foo ();
  return 0;
}

int main()
{
  pthread_t thr;
  void *ret;
  int x;

  pthread_create (&thr, NULL, thread_func, NULL);
  pthread_join (thr, &ret);
  for (x = 0; x < 10; x++)
    foo ();  
}
"
287-10066,weiqiangdragonite/blog_tmp,unix_linux/linux_program/uup_book/ch14_thread/incprint.c,27,2,18,7541820925.427601,184251.0,40932.320177366746,1547.0,1515.0,41881.0,15000.0,1660.0,724.0,1368.0,681.0,1500000000,5.027880616951734,1082014363648.0,0.0166186343629071,0.0779346354670276,"/*
 * incprint.c - one thread increments, the other prints
 */

#include <stdio.h>
#include <pthread.h>

#define NUM	5

int counter = 0;

void *print_count(void *arg);

int
main(int argc, char *argv[])
{
	pthread_t t1;
	int i;

	pthread_create(&t1, NULL, print_count, NULL);
	for (i = 0; i < NUM; ++i) {
		++counter;
		sleep(1);
	}

	pthread_join(t1, NULL);
}


void *
print_count(void *arg)
{
	int i;
	for (i = 0; i < NUM; ++i) {
		printf(""count = %d\n"", counter);
		sleep(1);
	}
	return NULL;
}

"
231-35339,AlexBrassard/Work_Hour_Monitor,v1.0.d/bkup.d/Docs.d/TEST/printenv.c,6,1,9,1946629.6071186,188021.0,10.35325309406928,1304.0,1286.0,43476.0,15432.0,1699.0,696.0,1361.0,654.0,1500000000,0.0012977530714124,1082014363648.0,0.0137750570415006,0.0748624974536565,"#include <stdio.h>


int main (int argc, char **argv, char **envp)
{
  while(*envp != NULL)
    printf(""%s\n"", *envp++);
  return 0;
}
"
197-21858,benjaminy/Charcoal,Testing/MicroTests/BucketBrigade/bucket_brigade_silly_loop.c,40,2,16,1930037.97903645,176321.0,10.946155024075408,1293.0,1275.0,39881.0,13652.0,1610.0,635.0,1338.0,594.0,1500000000,0.0012866919860243,1082014363648.0,0.0145643457103804,0.0780266377748304,"#include <stdlib.h>
#include <stdio.h>

#define N 10
int m = N;

typedef struct
{
    void (*f)( int, int );
    int x, y;
} closure_t;

closure_t closures[N];
closure_t *c = &closures[0];

void f( int x, int y )
{
    c = &closures[ ( x + 1 ) % N ];
    if( x == ( N - 1 ) )
    {
        ++c->y;
        if( y == m )
        {
            c = NULL;
        }
    }
    else
    {
        c->y = closures[ x ].y;
    }
}

int main( int argc, char **argv )
{
    m = ( argc > 1 ) ? (int)atol( argv[1] ) : N;
    unsigned i;
    for( i = 0; i < N; ++i )
    {
        closures[i].f = f;
        closures[i].x = i;
        closures[i].y = 0;
    }
    while( c )
    {
        c->f( c->x, c->y );
    }
    printf( ""Done!\n"" );
}
"
220-22553,bigown/SOpt,C/Algorithm/Accumulate2.c,9,1,11,1566002.84390145,173879.0,9.006274478229113,1333.0,1314.0,39413.0,13387.0,1625.0,638.0,1344.0,594.0,1500000000,0.0010440018959343,1082014363648.0,0.0152232299472621,0.0795643939393939,"#include <stdio.h>

int simpleArraySum(int array[6]) {
    int soma = 0;
    for (int i = 0; i < 6; i++) soma += array[i];
    return soma;
}

int main(void) {
    printf(""%d"", simpleArraySum((int[]){1, 2, 3, 4, 10, 11}));
}

//https://pt.stackoverflow.com/q/448758/101
"
142-27709,b3h3moth/L-C,bitwise_hacks/check_integer_power_of_two/main.c,11,1,8,2023847.89008645,179607.0,11.268196673849015,1341.0,1322.0,40661.0,14271.0,1627.0,639.0,1345.0,598.0,1500000000,0.0013492319267243,1082014363648.0,0.0148268163267578,0.0766220053884803,"#include <stdio.h>
#include <stdlib.h>

// The program's purpose is to check if an integer is a power of two

int main(void) {
    unsigned int values[] = {2, 26, 64, 78, 88, 100, 31, 34, 1024, 16};
    _Bool result;

    for (int i=0; i<sizeof(values)/sizeof(values[0]); i++)
        if ((result = (values[i] & (values[i] - 1))) == 0)
            printf(""%d is a power of two.\n"", values[i]);
        else
            printf(""%d is not a power of two.\n"", values[i]);

    
    return(EXIT_SUCCESS);
}
"
043-13844,EvtimPavlov/c-programming-2014-2015-homework,A/23_Petko_Georgiev/homework_3/task_5.c,6,1,6,1948293.0656521502,1094339.0,1.7803377198473234,1340.0,1320.0,137310.0,83628.0,1620.0,699.0,1340.0,656.0,1500000000,0.0012988620437681,1082014363648.0,0.0024306910381517,0.0195303659850274,"#include<stdio.h>
int main()
{
	int i=1;
	while(i<30000) { if( i%2 && (i%3==0) && (i%7==0) ) printf(""%d\n"",i); i++; }
	return 0;
}
"
386-10745,acama/binutils,gdb/testsuite/gdb.reverse/getresuid-reverse.c,31,1,16,1770529.3139442,170509.0,10.383786193104177,1142.0,1133.0,38849.0,12860.0,1581.0,588.0,1325.0,547.0,1500000000,0.0011803528759628,1082014363648.0,0.0133424042132673,0.078148871569746,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2008-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#define _GNU_SOURCE
#include <unistd.h>

void
marker1 (void)
{
}

void
marker2 (void)
{
}

uid_t ruid = -1, euid = -1, suid = -1;
gid_t rgid = -1, egid = -1, sgid = -1;

int
main (void)
{
  marker1 ();
  getresuid (&ruid, &euid, &suid);
  getresgid (&rgid, &egid, &sgid);
  marker2 ();
  return 0;
}
"
015-27833,acarno/slicer,valgrind/helgrind/tests/locked_vs_unlocked2.c,56,2,22,1538927341.2292824,183115.0,8404.15772055812,1390.0,1366.0,41811.0,14599.0,1656.0,691.0,1372.0,649.0,1500000000,1.0259515608195215,1082014363648.0,0.0150506512301013,0.0774330792412692,"
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <unistd.h>

/* Test of the mechanism for showing all locks held by a thread.  Test
   the case where the earlier thread held, at the time of the access,
   some locks, at least one of which is deleted by the time the second
   access (the race) happens.  This causes problems for Helgrind's
   error reporting mechanism in that it can no longer show the deleted
   lock in the error message.x */

pthread_mutex_t mx1a;
pthread_mutex_t mx1b;
pthread_mutex_t mx2a;
pthread_mutex_t mx2b;

int x = 0;

void* child_fn1 ( void* arg )
{
   int r;
   // We are the first-accessing thread.  Take and release two locks
   // and then destroy one of them.
   r= pthread_mutex_lock(&mx1a);  assert(!r);
   r= pthread_mutex_lock(&mx1b);  assert(!r);
   x = 1;
   r= pthread_mutex_unlock(&mx1b);  assert(!r);
   r= pthread_mutex_unlock(&mx1a);  assert(!r);
   r= pthread_mutex_destroy(&mx1a);  assert(!r);
   sleep(1);
   return NULL;
}

void* child_fn2 ( void* arg )
{
   int r;
   // We are the second-accessing thread.  Take and release
   // our two locks, but don't otherwise mess with them. 
   sleep(1);
   r= pthread_mutex_lock(&mx2a);  assert(!r);
   r= pthread_mutex_lock(&mx2b);  assert(!r);
   x = 1;
   r= pthread_mutex_unlock(&mx2b);  assert(!r);
   r= pthread_mutex_unlock(&mx2a);  assert(!r);
   return NULL;
}

int main ( int argc, char** argv )
{
   pthread_t child1, child2;
   int r;

   r= pthread_mutex_init(&mx1a, NULL);  assert(!r);
   r= pthread_mutex_init(&mx1b, NULL);  assert(!r);
   r= pthread_mutex_init(&mx2a, NULL);  assert(!r);
   r= pthread_mutex_init(&mx2b, NULL);  assert(!r);

   r= pthread_create(&child2, NULL, child_fn2, NULL);  assert(!r);
   r= pthread_create(&child1, NULL, child_fn1, NULL);  assert(!r);

   r= pthread_join(child1, NULL);  assert(!r);
   r= pthread_join(child2, NULL);  assert(!r);

   // don't destroy mx1a; it's already destroyed.
   r= pthread_mutex_destroy(&mx1b);  assert(!r);
   r= pthread_mutex_destroy(&mx2a);  assert(!r);
   r= pthread_mutex_destroy(&mx2b);  assert(!r);

   return 0;
}
"
053-23239,SanDisk-Open-Source/SSD_Dashboard,uefi/gcc/gcc-4.6.3/gcc/testsuite/gcc.dg/ctor1.c,9,1,15,1638861.1402362,169083.0,9.69264207519384,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010925740934908,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* Related to PR c++/38410.
   We shouldn't write out a static variable for an all-zero aggregate
   initializer.  The variable named C.0 was created by
   gimplify_init_constructor. */
/* { dg-final { scan-assembler-not ""C\\.0"" } } */

int main()
{
  int a[] = { 0,0 };
}
"
309-8097,JIMyungSik/uftrace,tests/s-malloc-hook.c,37,1,21,2168538.0488634,168651.0,12.81384634541153,1140.0,1131.0,38308.0,12670.0,1564.0,588.0,1315.0,547.0,1500000000,0.0014456920325756,1082014363648.0,0.0134656776419944,0.0787398485621248,"#define _GNU_SOURCE
#include <dlfcn.h>
#include <stdlib.h>

void * (*real_malloc)(size_t sz);
void (*real_free)(void *ptr);

#define ALIGN(n, a)  (((n) + (a) - 1) & ~((a) - 1))

#define MALLOC_BUFSIZE  (1024 * 1024 * 1024)
/* this is needed for optimized binaries */
static char buf[MALLOC_BUFSIZE];

void *malloc(size_t sz)
{
	static unsigned alloc_size;
	void *ptr;

	if (real_malloc)
		return real_malloc(sz);

	sz = ALIGN(sz, 8);
	if (alloc_size + sz > sizeof(buf))
		return NULL;

	ptr = buf + alloc_size;
	alloc_size += sz;

	return ptr;
}

void free(void *ptr)
{
	char *p = ptr;

	if (buf <= p && p < &buf[MALLOC_BUFSIZE])
		return;

	if (real_free)
		real_free(ptr);
}

static void hook(void)
{
	real_malloc = dlsym(RTLD_NEXT, ""malloc"");
	real_free   = dlsym(RTLD_NEXT, ""free"");
}

static __attribute__((section("".preinit_array"")))
void (*preinit_func_table[])(void) = { hook, };

int main(void)
{
	free(malloc(16));
	return 0;
}
"
021-13252,EvtimPavlov/c-programming-2014-2015-homework,B/06_Valentin_Stoyanov/homework_5/translator.c,28,2,13,1659346.5115874999,174056.0,9.533403042698902,1291.0,1275.0,39342.0,13380.0,1619.0,638.0,1340.0,594.0,1500000000,0.001106231007725,1082014363648.0,0.0147423817621914,0.0794924320018208,"#include <stdio.h>
void trans(char arr[34]) {
int i;
char ch;
	for (i=0 ; i<34/2 ; i++) {
		 ch=arr[i];
		arr[i]=arr[33-i];
		arr[33-i]=ch;
	}
	for (i=0 ; arr[i] != '\0' ; i++) {
		ch=arr[i];
		int number,n=13; 
		if ((arr[i]>='A') && (arr[i]<='Z')) {
			arr[i]='A';
			number=ch - 'A';	
		}else {
			number=ch - 'a';
			arr[i]='a';
		}
		number=(number+n) % 26;
		arr[i]=arr[i]+ number;
	}
printf(""%s\n"",arr);
}

int main () {
char mas[]=""xrrJfvuGrgveJhbLqvQfznetbeClanZjbU"";
trans(mas);			
return 0;
}
"
200-8480,zxombie/aarch64-freebsd-binutils,gdb/testsuite/gdb.dwarf2/dw2-undefined-ret-addr.c,29,2,14,1524828.14155515,169080.0,9.018381831085875,1142.0,1132.0,38460.0,12696.0,1566.0,584.0,1317.0,544.0,1500000000,0.0010165520943701,1082014363648.0,0.0134492547906316,0.0784072249589491,"/*
   Copyright 2013-2014 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

void
stop_frame ()
{
  /* The debug information for this frame is modified in the accompanying
     .S file, to mark the return address as undefined.  */
}

void
first_frame ()
{
  stop_frame ();
}

int
main ()
{
  first_frame ();

  return 0;
}
"
100-7954,mickael-guene/binutils,gdb/testsuite/gdb.threads/continue-pending-after-query.c,33,1,16,1604658.0858528,176060.0,9.114267863228443,1368.0,1344.0,40010.0,13717.0,1630.0,651.0,1353.0,611.0,1500000000,0.0010697720572352,1082014363648.0,0.0154038396001363,0.0790105533530627,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2013-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <pthread.h>

static int global;

static void
break_function (void)
{
  global = 42; /* set break here */
}

static void *
thread_function (void *arg)
{
  break_function ();

  return arg;
}

int
main (void)
{
  pthread_t th;

  pthread_create (&th, NULL, thread_function, NULL);

  break_function ();

  pthread_join (th, NULL);

  return 0;
}
"
186-28038,hzq1001/or1k-src,gdb/testsuite/gdb.base/sepsymtab.c,16,1,14,1424418.1802496,169083.0,8.42437146253615,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0009496121201664,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* Copyright 2006-2013 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
main (int argc, char **argv, char **envp)
{
  return 0;
}
"
313-33584,timmontague/euler-solutions,006/square-sum.c,16,1,16,1562898.0472682999,175682.0,8.896176045354675,1338.0,1318.0,39728.0,13596.0,1619.0,638.0,1340.0,593.0,1500000000,0.0010419320315122,1082014363648.0,0.0151182249746701,0.0785762508438976,"/*
 * Find the difference between the sum of squares of the first 100 natural
 * numbers and the square of the sum
 */
#include <stdio.h>
#include <math.h>
int main(int argc, const char *argv[]) {
	int i;
	unsigned long int sumofsquares = 0;
	unsigned long int squareofsum = 0;

	for (i = 1; i <= 100; i++) {
		sumofsquares += (unsigned long int)powl(i, 2);
		squareofsum += i;
	}
	squareofsum = (unsigned long int)powl(squareofsum, 2);
	printf(""%ld - %ld = %ld\n"", squareofsum, sumofsquares, squareofsum-sumofsquares);
	return 0;
}
"
324-12056,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.base/double-prompt-target-event-error.c,18,1,14,4518117169.733159,170064.0,26567.158064022955,1150.0,1141.0,38683.0,12795.0,1574.0,581.0,1323.0,544.0,1500000000,3.0120781131554395,1082014363648.0,0.0134713990027283,0.0781304634989704,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
main (void)
{
  sleep (3);
  return 0; /* after sleep */
}
"
236-10004,beqa2323/learntosolveit,languages/cprogs/shellsort.c,33,6,21,1882247.859612,175215.0,10.742499215249836,1291.0,1273.0,39857.0,13575.0,1625.0,636.0,1348.0,593.0,1500000000,0.001254831906408,1082014363648.0,0.0146334503324487,0.078642012277287,"#include<stdio.h>
#include<stdlib.h>

static void shell_sort(int a[], int size)
{
    int i, j;
    int h=1;
    do {
        h = h * 3 + 1;
    }while (h <= size);
    do {
        h /= 3;
        for (i = h; i < size; i++)
        {
            int v = a[i];
            for (j = i; j >= h && a[j - h]  > v; j -= h)
                a[j] = a[j -h];
            if (i != j)
                a[j] = v;
        }
    }while (h != 1);
}

int main(int argc, char *argv[])
{
    int *a;
    int i;

    a  = (int *)malloc((argc - 1) * sizeof(int));
    for (i = 0; i < argc - 1; i++)
        a[i] = atoi(argv[i+1]);
    shell_sort(a, argc);

    for (i = 0; i < argc -1; i++)
        printf(""%d"", a[i]);
    printf(""\n"");
    free(a);
    return 0;
}
"
002-12483,GHackAnonymous/Ejercicios-SistemasOperativos,Demos/02mutualExclusionWithSem/02mutualExclusionWithSem.c,36,3,21,9002681725.30923,209373.0,42998.29359564032,1572.0,1540.0,47829.0,18840.0,1691.0,808.0,1387.0,764.0,1500000000,6.00178781687282,1082014363648.0,0.0148634255610799,0.0697475588354407,"#include <stdio.h>
#include <unistd.h>
#include <pthread.h>
#include <semaphore.h>
#define N_THREADS 3

typedef struct s_threadParams
{
  sem_t *pTheSemaphore;
  int threadNumber;
  int sleepTime;
  int nLoops;
}ThreadParams,*PThreadParams;

void* threadMainFunction(void*);

int main()
{
  int i;
  pthread_t idThreads[N_THREADS];
  sem_t theSemaphore;
  ThreadParams params[]={{&theSemaphore,0,0,10},{&theSemaphore,1,3,2},{&theSemaphore,2,1,4}};

  sem_init(&theSemaphore, 0, 1);
  for(i=0;i<N_THREADS;i++)
    pthread_create(&idThreads[i], NULL, threadMainFunction, (void*) &params[i]);
  for(i=0;i<N_THREADS;i++)
    pthread_join (idThreads[i], NULL);
  printf(""Threads finished. Main going to finish \n"");
  return 0;
}

void *threadMainFunction(void *arg)
{
  int i;
  PThreadParams pParams=(PThreadParams) arg;
  
  for (i=0;i<pParams->nLoops;i++)
  {
    sem_wait(pParams->pTheSemaphore);
    printf(""thread %d in Critical Section\n"", pParams->threadNumber);
    printf(""thread %d going out from Critical Section\n"", pParams->threadNumber);
    sem_post(pParams->pTheSemaphore);
    sleep(pParams->sleepTime);
  }
  return NULL;
}
"
172-21097,samjcus/pragma_pragma_pragma,pi_integration/src/pi_integration_serial.c,21,1,15,1093800925.7661178,6000179256.0,0.1822947079299725,1446.0,1421.0,40661.0,14247.0,1638.0,633.0,1356.0,591.0,1500000000,0.7292006171774119,1082014363648.0,4.778190580111562e-07,0.0768194070080862,"#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main (int argc, char *argv[])
{
  int i,num_steps;
  double x, sum, step, pi;
  clock_t t_start, t_end;
  
  num_steps=500000000;
  x=0;
  sum = 0.0;
  step = 1.0/(double) num_steps;
  t_start = clock();
  for (i=0; i < num_steps; i++)
    {
      x = (i+0.5)*step;
      sum = sum + 4.0/(1.0+x*x);
    }
  
  pi = step * sum;
  t_end = clock();
  printf(""Value of pi = %g\n"",pi);
  printf(""Expended wall clock time = %.20f\n"", (double)(t_end - t_start)/CLOCKS_PER_SEC);
  return EXIT_SUCCESS;
}
"
255-24634,Georgigt23/po-homework,2015-2016/A/08/02/task1.c,7,1,8,1530901.5288948002,385657.0,3.969592150537913,1345.0,1326.0,82950.0,44061.0,1618.0,662.0,1340.0,619.0,1500000000,0.0010206010192632,1082014363648.0,0.0069258434308206,0.0333750620025037,"/*Programa za printirane na ASCII tablicata*/

#include <stdio.h>

int main(){
	int i;
	for(i=0; i<256; i++)
		printf(""%d.\t%c\n"", i, i);
	return 0;
}
"
035-29328,chggr/puzzles,easy/double_to_binary.c,30,1,18,1634867.86186695,176760.0,15.286857886399638,1321.0,1304.0,40552.0,13941.0,1628.0,638.0,1348.0,593.0,1500000000,0.0010899119079113,1082014363648.0,0.0148506449422946,0.0772025764777127,"#include <stdio.h>

// Task description: Given a real number between 0 and 1 (e.g. 0.245), write a
// method to print its binary representation to the standard output. The method
// should print an error if the number cannot be represented accurately in
// binary with at most 32 bits.
//
// E.g. For input 0.125, the method should print ""0.001""
//      For input 0.1, the method should print ""Overflow error""

void to_binary(double input) {

    if (input < 0 || input >= 1) {
        printf(""Unsupported input."");
    }

    printf(""0."");
    double frac = 1.0;
    for (int i = 0; i < 32; i++) {
        if (input == 0) break;

        frac /= 2;
        if (input >= frac) {
            input -= frac;
            printf(""1"");
        } else {
            printf(""0"");
        }
    }
    printf(""\n"");

    if (input > 0) printf(""Overflow error\n"");
}

int main() {
    to_binary(0.125);
    to_binary(0.1);
}

"
009-21072,FrankEos/C,c++/link_list.c,95,6,29,1870998.2978179501,249060.0,7.51223801493616,1388.0,1367.0,54142.0,23029.0,1623.0,693.0,1343.0,650.0,1500000000,0.0012473321985453,1082014363648.0,0.0110615915843571,0.0558370372290109,"#include <stdio.h>
#include <stdlib.h>

#if 1
#define DBG(x , ...) printf(""[%s:%s(%d)]::""x,__FILE__,__FUNCTION__,__LINE__,##__VA_ARGS__) 
#else
#define DBG(x)
#endif

typedef struct _node {
	int mData;
	struct _node *mPrev;
	struct _node *mNext;
}Node,*PNode;

static PNode gListHead;
static PNode gListTail;
static int mListLen;

void push_back(int data) {
	PNode pNode = (PNode)calloc(1,sizeof(Node));
	if(pNode) {
		pNode->mData = data;
		if(NULL == gListHead && gListHead == gListTail) {
			gListHead = gListTail = pNode;
		} else {
			gListTail->mNext = pNode;
			gListTail = pNode;
		}
		pNode = NULL;
	} else {
		DBG(""calloc"");
	}
}

void push_front(int data) {
	PNode pNode = (PNode)calloc(1, sizeof(Node));
	if(pNode) {
		pNode->mData = data;
		if(NULL == gListHead && gListHead == gListTail) {
			gListHead = gListTail = pNode;
		} else {
			pNode->mNext = gListHead;
			gListHead = pNode;
		}
	} else {
		DBG(""calloc"");
	}
}

void delete(int data) {
	PNode pPrev,pCurr;
	pCurr = gListHead;
	while(pCurr) {
		if(pCurr->mData == data) {
			if(pCurr == gListHead) {
				gListHead = pCurr->mNext;
			} else {
				pPrev->mNext = pCurr->mNext;
			}
			free(pCurr);
			return;
		}
		pPrev = pCurr;
		pCurr = pCurr->mNext;
	}
}

void update(int old, int new) {
	PNode pNode = gListHead;
	while(pNode) {
		if(pNode->mData == old) {
			pNode->mData = new;
			return;
		}
		pNode = pNode->mNext;
	}
}

void traverse() {
	PNode pNode = gListHead;
	while(pNode) {
		DBG(""mData=%d\n"",pNode->mData);
		pNode = pNode->mNext;
	}
}

void clear() {
	PNode pTemp;
	while(gListHead) {
		pTemp = gListHead;
		gListHead = gListHead->mNext;
		free(pTemp);
		pTemp = NULL;
	}
}

int main() {

	int i;
	for(i = 0; i < 20; i++) {
		push_back(i);
	}

	for(i= -1; i > -20; i--) {
		push_front(i);
	}

	delete(10);
	delete(-10);

	update(0,'a');

	traverse();
	clear();

	return 0;
}
"
268-30318,itsimbal/gcc.cet,gcc/testsuite/gcc.c-torture/execute/20170419-1.c,15,1,16,1808343.2223646499,170029.0,10.635497473960324,1144.0,1135.0,38693.0,12782.0,1576.0,589.0,1322.0,547.0,1500000000,0.0012055621482431,1082014363648.0,0.0134035958571773,0.0783681398737251,"/* PR tree-optimization/80426 */
/* Testcase by <ishiura-compiler@ml.kwansei.ac.jp> */

#define INT_MAX 0x7fffffff
#define INT_MIN (-INT_MAX-1)

int x;

int main (void)
{
  volatile int a = 0;
  volatile int b = -INT_MAX;
  int j;

  for(j = 0; j < 18; j += 1) {
    x = ( (a == 0) != (b - (int)(INT_MIN) ) );
  }

  if (x != 0)
    __builtin_abort ();

  return 0;
}

"
169-35020,marcosliraa/Project-Euler,ex07.c,22,2,16,1464975747.1634076,3977328790.0,0.3683315673281313,1339.0,1320.0,39252.0,13349.0,1618.0,636.0,1340.0,593.0,1500000000,0.9766504981089384,1082014363648.0,6.685391478535522e-07,0.0795992471626014,"/* Program 7 - Project Euler
 * Autor: José Marcos de Lira Júnior
 */

#include <stdio.h>

int main(void)
{
    int nprime=1, i, j,prime=0;

    for(i=3;nprime<10001;i++)
    {
        for(j=2;j<i;j++)
        {
            if(i%j==0)
                break;
        }

        if(j==i)
        {
            prime = i;
            nprime++;
        }
    }
printf(""%d -> %d\n"",nprime,prime);
return 0;
}  
"
062-20408,kujenga/euler,Euler_14/LongestCollatz.c,38,3,24,242391019.47750884,693280242.0,0.3495117289091876,1346.0,1325.0,41908.0,15078.0,1621.0,643.0,1342.0,598.0,1500000000,0.1615940129850059,1082014363648.0,3.852698862864752e-06,0.0737725055276734,"#include <stdio.h>

// finds the starting point for the longest collatz sequence under a million

int collatzLength (int nIn)
{
  long long n = nIn;
  int l = 0;
  while ( n > 1 ) {
    //printf(""%lld "",n);
    if ( n%2 == 0 )
      n = n/2;
    else
      n = 3*n+1;
    l++;
  }
  return l;
}

int collatzLengthRec ( int n, int l )
{
  if ( n <= 1 )
    return l;
  else if ( n%2 == 0 )
    return collatzLengthRec(n/2,l+1);
  else
    return collatzLengthRec(3*n+1,l+1);
}

int main (int argc, char** argv)
{
  int n = 0;
  int maxL = 0;
  for (int i = 100000; i < 1000000; i++) {
    int curL = 0;
    if (  collatzLength(i) > maxL ) {
      printf(""num: %3i length:%3i\n"",i,collatzLength(i));
      maxL = collatzLength(i);
      n = i;
    }
  }
  printf(""longest: %i\n"",n);
}
"
155-31162,raylee/xorshf96,xorshf96.c,33,2,18,190245237.08503693,1250235529.0,0.1521675177093771,1460.0,1431.0,51448.0,21618.0,1628.0,649.0,1351.0,608.0,1500000000,0.1268301580566913,1082014363648.0,2.3123642969196086e-06,0.057974981523554,"
static unsigned long xorshf96(void) {    /* A George Marsaglia generator, period 2^96-1 */
	static unsigned long x=123456789, y=362436069, z=521288629;
	unsigned long t;

	x ^= x << 16;
	x ^= x >> 5;
	x ^= x << 1;

	t = x;
	x = y;
	y = z;

	z = t ^ x ^ y;
	return z;
}

inline unsigned long random(void) {
	return xorshf96();
}

inline float ranf(void) {
	return (float) random() / (float) (~0UL);
}

inline float ranfu(void) {
	return (float) random()/((~0UL>>1)*1.0) - 1.0;
}

int main(void) {
        unsigned i, quantity=100e6;
        float f;
 
        for (i=quantity/2; i; i--) {
                xorshf96();
                xorshf96();
        }
        for (i=0; i<20; i++) {
                printf(""%21.018lf\n"", xorshf96()/((~0UL>>1)*1.0) - 1.0);
        }
 
        return 0;
}

"
137-29445,jpoirier/picoc,tests/csmith/rand104.c,114,7,33,1768204.383552,725213.0,2.438185746808179,1369.0,1347.0,133814.0,78782.0,1628.0,714.0,1345.0,672.0,1500000000,0.001178802922368,1082014363648.0,0.003745106610058,0.0205036783382566,"#include <stdio.h>
int print_hash_value = 1;
static void platform_main_begin(void)
{
}
static unsigned crc32_tab[256];
static unsigned crc32_context = 0xFFFFFFFFUL;
static void
crc32_gentab (void)
{
 unsigned crc;
 unsigned poly = 0xEDB88320UL;
 int i, j;
 for (i = 0; i < 256; i++) {
  crc = i;
  for (j = 8; j > 0; j--) {
   if (crc & 1) {
    crc = (crc >> 1) ^ poly;
   } else {
    crc >>= 1;
   }
  }
  crc32_tab[i] = crc;
 }
}
static void
crc32_byte (unsigned char b) {
 crc32_context =
  ((crc32_context >> 8) & 0x00FFFFFF) ^
  crc32_tab[(crc32_context ^ b) & 0xFF];
}
extern int strcmp ( char *, char *);
static void
crc32_8bytes (unsigned val)
{
 crc32_byte ((val>>0) & 0xff);
 crc32_byte ((val>>8) & 0xff);
 crc32_byte ((val>>16) & 0xff);
 crc32_byte ((val>>24) & 0xff);
}
static void
transparent_crc (unsigned val, char* vname, int flag)
{
 crc32_8bytes(val);
 if (flag) {
    printf(""...checksum after hashing %s : %X\n"", vname, crc32_context ^ 0xFFFFFFFFU);
 }
}
static void
platform_main_end (int x, int flag)
{
  if (!flag) printf (""checksum = %x\n"", x);
}
static long __undefined;
void csmith_compute_hash(void);
void step_hash(int stmt_id);
static int g_3[7][8] = {{0x4A025691L, 7L, 0x4A025691L, 7L, 0x4A025691L, 7L, 0x4A025691L, 7L}, {0x4A025691L, 7L, 0x4A025691L, 7L, 0x4A025691L, 7L, 0x4A025691L, 7L}, {0x4A025691L, 7L, 0x4A025691L, 7L, 0x4A025691L, 7L, 0x4A025691L, 7L}, {0x4A025691L, 7L, 0x4A025691L, 7L, 0x4A025691L, 7L, 0x4A025691L, 7L}, {0x4A025691L, 7L, 0x4A025691L, 7L, 0x4A025691L, 7L, 0x4A025691L, 7L}, {0x4A025691L, 7L, 0x4A025691L, 7L, 0x4A025691L, 7L, 0x4A025691L, 7L}, {0x4A025691L, 7L, 0x4A025691L, 7L, 0x4A025691L, 7L, 0x4A025691L, 7L}};
static int g_11 = (-8L);
static signed char func_1(void);
static signed char func_1(void)
{
    int *l_2 = &g_3[1][5];
    int **l_4 = &l_2;
    int l_5 = 0x6DEEC541L;
    int *l_6 = &g_3[0][4];
    int *l_7[7][2];
    unsigned l_8 = 0x78150149L;
    int i, j;
    for (i = 0; i < 7; i++)
    {
        for (j = 0; j < 2; j++)
            l_7[i][j] = &g_3[1][5];
    }
    step_hash(1);
    (*l_4) = l_2;
    step_hash(2);
    ++l_8;
    step_hash(3);
    return g_11;
}
void csmith_compute_hash(void)
{
    int i, j;
    for (i = 0; i < 7; i++)
    {
        for (j = 0; j < 8; j++)
        {
            transparent_crc(g_3[i][j], ""g_3[i][j]"", print_hash_value);
            if (print_hash_value) printf(""index = [%d][%d]\n"", i, j);
        }
    }
    transparent_crc(g_11, ""g_11"", print_hash_value);
}
void step_hash(int stmt_id)
{
    int i = 0;
    csmith_compute_hash();
    printf(""before stmt(%d): checksum = %X\n"", stmt_id, crc32_context ^ 0xFFFFFFFFUL);
    crc32_context = 0xFFFFFFFFUL;
    for (i = 0; i < 256; i++) {
        crc32_tab[i] = 0;
    }
    crc32_gentab();
}
int main (void)
{
    int i, j;
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    csmith_compute_hash();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}
"
056-18930,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.base/hook-stop-continue.c,34,1,21,1719648.01847925,169087.0,10.170196407766417,1142.0,1132.0,38460.0,12696.0,1567.0,584.0,1317.0,544.0,1500000000,0.0011464320123195,1082014363648.0,0.0134486980075345,0.0784267730080538,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2008-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
funbreak (int i)
{
  i = i * 2; /* set breakpoint here */
  i = i + 10;
  return i;
}

int
func (int i)
{
  return i * 2;
}

int
main (int argc, char **argv, char **envp)
{
  func (1);
  func (2);
  func (3);
  func (4);
  funbreak (5);

  return 0;
}
"
221-30719,her0m31/Studys,SoftB/08/test.c,31,2,24,2059518.12677085,173672.0,11.85866460914828,1299.0,1282.0,39341.0,13363.0,1618.0,634.0,1340.0,592.0,1500000000,0.0013730120845139,1082014363648.0,0.0148613478280897,0.0793867638129933,"#include <stdio.h>

void itoa(int,char*,int);

int main(){
  int i = 12345;
  char str[20];
  itoa(i,str,19);
  printf(""%s\n"",str);
  i = -12345;
  itoa(i,str,19);
  printf(""%s\n"",str);
  return 0;
}

void itoa(int i,char *str,int c){
  int d = c;
  int flag = 0;
  if(i < 0){
    flag = 1;
    i *= -1;
  }
  str[c--] = '\0';
  while(i != 0){
    str[c--] = i%10 + '0';
    i /= 10;
  }
  if(flag == 1){
    str[c--] = '-';
  }
  d -= c;
  while(d--){
    str[i++] = str[i + c + 1];
  }
}
"
024-29015,mattstock/binutils-bexkat1,gdb/testsuite/gdb.base/continue-all-already-running.c,18,1,14,15002049912.11649,170055.0,88218.81104348593,1149.0,1140.0,38683.0,12795.0,1574.0,581.0,1323.0,544.0,1500000000,10.00136660807766,1082014363648.0,0.0134603510628914,0.0781304634989704,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
main (void)
{
  sleep (10);
  return 0; /* set break here */
}
"
232-7354,jizhouli/code-snippet,base_algo_interpolation_search.c,58,1,34,2535397.5361212,191393.0,13.247072776956315,1367.0,1348.0,42819.0,15544.0,1634.0,634.0,1353.0,595.0,1500000000,0.0016902650240808,1082014363648.0,0.0141854717779647,0.0722375477614241,"#include <stdio.h>
#include <stdlib.h>

int midpoint(int s[], int key, int l, int r) {
    int m = l + (r-l) * (key-s[l]) / (s[r]-s[l]);
    printf(""key %d s[l] %d s[r] %d l %d r %d m %d\n"",
           key, s[l], s[r], l, r, m);
    m = l < m ? m : l;
    m = m < r ? m : r;
    return m;
}

int interpolation_search_recursive(int s[], int key, int l, int r) {
    if (r<l) {
        printf(""isr no exist\n"");
        return -1;
    }
    int m = midpoint(s, key, l, r);
    if (key < s[m]) {
        printf(""isr <- %d %d\n"", l, m-1);
        return interpolation_search_recursive(s, key, l, m-1);
    }
    else if (s[m] < key) {
        printf(""isr -> %d %d\n"", m+1, r);
        return interpolation_search_recursive(s, key, m+1, r);
    }
    else {
        printf(""isr found %d\n"", m);
        return m;
    }
}

int interpolation_search_iterative(int s[], int key, int l, int r) {
    while (l < r) {
        printf(""isi %d %d\n"", l, r);

        int m = midpoint(s, key, l, r);
        if (key < s[m])
            r = m - 1;
        else if (s[m] < key)
            l = m + 1;
        else
            return m;
    }
    printf(""isi no exist\n"");
    return -1;
}

int main(int argc, char* argv[]) {
    int s[] = {1,2,3,4,5,6,7,8,9,10};
    
    int key, idx;

    key = 8;
    printf(""interpolation search recursive: %d\n"", key);
    idx = interpolation_search_recursive(s, key, 0, 9);

    key = 11;
    printf(""interpolation search recursive: %d\n"", key);
    idx = interpolation_search_recursive(s, key, 0, 9);
     
    key = 8;
    printf(""interpolation search iterative: %d\n"", key);
    idx = interpolation_search_iterative(s, key, 0, 9);

    key = 11;
    printf(""interpolation search iterative: %d\n"", key);
    idx = interpolation_search_iterative(s, key, 0, 9);
     
    return 0;
}
"
003-32982,VladX/Xwing-Engine,libs/lockless/tests/realloc.c,18,2,12,44010868.412442446,52925234.0,0.831566809888833,1306.0,1282.0,55544.0,52704752.0,4307.0,824723.0,1351.0,823818.0,1500000000,0.0293405789416283,1082014363648.0,4.889916972308521e-05,0.0313531030985876,"#include <string.h>
#include <stdlib.h>

void * realloc(void *, size_t);

const size_t min_size = 1024 * 1;
const size_t max_size = 1024 * 1024;
#define num 100

int main (void)
{
	size_t i;
	char * ptrs[num];
	for (i = 0; i < num; i++)
	{
		size_t size = (rand() % (max_size - min_size)) + min_size;
		ptrs[i] = realloc(NULL, 1);
		ptrs[i] = realloc(ptrs[i], size);
		memset(ptrs[i], 1, size);
	}
	for (i = 0; i < num; i++)
		free(ptrs[i]);
	return 0;
}
"
120-22739,krzysztofgajda/noty,07-funkcje/3.c,22,2,19,171803256.03112575,500125838.0,0.3435200562463241,1339.0,1320.0,39763.0,13714.0,1622.0,632.0,1343.0,592.0,1500000000,0.1145355040207505,1082014363648.0,5.316661923793668e-06,0.0783327411784505,"//3. Liczba doskonała to liczba, która jest sumą podzielników od niej mniejszych.
//Na przykład 6 jest liczbą doskonałą ponieważ:

//1 + 2 + 3 = 6

//Napisz funkcję, która sprawdza czy podana liczba jest doskonała. Użyj tej
//funkcji do wypisania wszystkich liczb doskonałych mniejszych od 10 000.

#include <stdio.h>

int is_perfect(size_t n) {
  int suma_podzielnikow = 0;

  for (size_t i = 1; i < n; i++) {
    if (n % i == 0) {
      suma_podzielnikow += i;
    }
  }

  return suma_podzielnikow == n;

}

int main () {
  size_t max = 10000;

  for (size_t i = 0; i < max; i++) {
    if(is_perfect(i)) {
      printf(""Liczba %ld jest doskonała\n"", i);
    }
  }
}
"
387-3923,aalex/toonloop,prototypes/launcher/helper.c,22,1,15,30005716332.234436,190794.0,157267.60973615522,1363.0,1342.0,43274.0,16174.0,1642.0,652.0,1349.0,610.0,1500000000,20.00381088815629,1082014363648.0,0.0141775946832709,0.0715415152738527,"/*
 * Compile me with:
 *   gcc -o helper helper.c
 */
#include <stdio.h>
 
int
main( int    argc,
      char **argv )
{
    int i;
 
    for( i = 0; i < 10; i++ )
    {
        char stdout_string[] = ""Normal message no:  ."";
        char stderr_string[] = ""Error message no:  ."";
 
        stdout_string[19] = '0' + i;
        stderr_string[18] = '0' + i;
 
        sleep( 1 );
        fprintf( stdout, ""%s\n"", stdout_string );
        sleep( 1 );
        fprintf( stderr, ""%s\n"", stderr_string );
    }
 
    return( 0 );
}
"
149-15561,SanDisk-Open-Source/SSD_Dashboard,uefi/gcc/gcc-4.6.3/gcc/testsuite/gcc.dg/charset/attribute1.c,9,1,14,1646135.93369715,169057.0,9.737159656210627,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010974239557981,1082014363648.0,0.0134155935572026,0.0785563462891999,"/* Test for attribute non-translation.  */
/* { dg-do compile }
   { dg-require-iconv ""IBM1047"" }
   { dg-final { scan-assembler ""foo"" } } */
int walrus __attribute__ ((section ("".foo"")));

int main (void)
{
  return 0;
}
"
157-13872,Gurgel100/gcc,gcc/testsuite/gcc.dg/torture/pr81573.c,14,2,11,1699292.9158731,169348.0,10.034319862059192,1143.0,1133.0,38520.0,12751.0,1569.0,585.0,1318.0,546.0,1500000000,0.0011328619439154,1082014363648.0,0.0134397808063868,0.0783678882799243,"/* { dg-do run } */

int a = 1, *c = &a, d;
signed char b;

int main ()
{
  for (; b > -27; b--)
    {
      *c ^= b;
      *c ^= 1;
    }
  while (a > 1)
    ;
  return 0; 
}
"
274-26032,Gigalomaniac/CPrimerPlus,ch10/11.c,43,4,26,1468666.5963380998,207113.0,7.091133825496227,1512.0,1486.0,46634.0,18016.0,1664.0,644.0,1375.0,600.0,1500000000,0.0009791110642254,1082014363648.0,0.0144751898721953,0.0662490332559938,"#include <stdio.h>
#define MONTHS 12
#define YEARS 5

void yearrf(const float rain[][MONTHS], int years);
void monthrf(const float rain[][MONTHS], int years);

int main(void)
{
    const float rain[YEARS][MONTHS] = {
        {4.3, 4.3, 4.3, 3.0, 2.0, 1.2, 0.2, 0.2, 0.4, 2.4, 3.5, 6.6},
        {8.5, 8.2, 1.2, 1.6, 2.4, 0.0, 5.2, 0.9, 0.3, 0.9, 1.4, 7.3},
        {9.1, 8.5, 6.7, 4.3, 2.1, 0.8, 0.2, 0.2, 1.1, 2.3, 6.1, 8.4},
        {7.2, 9.9, 8.4, 3.3, 1.2, 0.8, 0.4, 0.0, 0.6, 1.7, 4.3, 6.2},
        {7.6, 5.6, 3.8, 2.8, 3.8, 0.2, 0.0, 0.0, 0.0, 1.3, 2.6, 5.2}
    };
    printf("" YEAR  RAINFALL (inches) \n"");
    yearrf(rain, YEARS);
    printf(""MONTHLY AVERAGES: \n\n"");
    monthrf(rain, YEARS);
    return 0;
}

void yearrf(const float rain[][MONTHS], int years)
{
    int month, year;
    float subtot, total = 0;
    for (year = 0; year < years; year++)
    {
        for (month = 0, subtot = 0; month < MONTHS; month++)
            subtot += *(*(rain + year) + month);
        printf(""%5d %15.1f\n"", 2000 + year, subtot);
        total += subtot;
    }
    printf(""\nThe yearly average is %.1f inches.\n\n"", total / years);
}

void monthrf(const float rain[][MONTHS], int years)
{
    int year, month;
    float subtot;
    printf(""Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n"");
    for (month = 0; month < MONTHS; month++)
    {
        for (year = 0, subtot = 0; year < years; year++)
            subtot += *(*(rain + year) + month);
        printf(""%3.1f "", subtot / years);
    }
    printf(""\n"");
}
"
303-33904,digwiz/Euler,c/problem_five.c,11,1,13,205919707.1939706,1885792940.0,0.1091952900194864,1343.0,1321.0,39187.0,13316.0,1618.0,638.0,1339.0,593.0,1500000000,0.1372798047959804,1082014363648.0,1.4126683494742534e-06,0.0797668704645448,"#include <stdio.h>

int main(int argc, char *argv[])
{
  int i;
  
  for(i = 1; ; i++)
  {
    if(i % 20 == 0 && i % 19 == 0 && i % 18 == 0 && i % 17 == 0 && i % 16 == 0 && i % 15 == 0 && i % 14 == 0 && i % 13 == 0 && i % 11 == 0)
      break;
  }
  printf(""The largest is %d\n"", i);
  return 0;
}"
041-4355,grscheller/scheller-linux-archive,grok/C/CExemplars/sumit.c,22,1,18,2235679.5379891503,173535.0,12.883159016913014,1337.0,1318.0,39263.0,13368.0,1619.0,637.0,1341.0,594.0,1500000000,0.0014904530253261,1082014363648.0,0.015299507304002,0.0796298759286352,"/*
 *  Care must be taken when comparing optimization levels of code.
 *
 *  With gcc, compiling with -O2 optimization will completely
 *  ""optimize"" the loop away.  Essentually, all the program
 *  does is print a constant.  The calculation happens in the
 *  compiler.
 *
 *  Marking the variable sum as volatile will prevent this behavior.  
 * 
 */

#include <stdio.h>

int main(void) {

#ifdef VOLATILE
    volatile long sum = 0;
    printf(""VOLATILE  is set: "");
#else
    long sum = 0;
    printf(""VOLATILE not set: "");
#endif

    for(long ii = 1; ii <= 100000000L; ++ii) {
        sum += ii;
    }
    printf(""%ld\n"", sum);

    return 0;
}
"
223-31978,Gurgel100/gcc,gcc/testsuite/gcc.c-torture/execute/pr94734.c,55,4,17,1874643.0287137502,223683.0,8.380802296106543,1147.0,1139.0,38954.0,12908.0,1588.0,586.0,1332.0,546.0,1500000000,0.0012497620191425,1082014363648.0,0.0102198200131436,0.0781304230457753,"/* PR tree-optimization/94734 */

__attribute__((noipa)) int
foo (int n)
{
  int arr[16], s = 0;
  for (int i = 0; i < n; i++)
    {
      if (i < 16)
	arr[i] = i;
    }
  for (int i = 0; i < 16; i++)
    s += arr[i];
  return s;
}

__attribute__((noipa)) int
bar (int n, int x, unsigned long y, unsigned long z)
{
  int arr[16], s = 0;
  arr[4] = 42;
  for (int i = 0; i < n; i++)
    {
      if (x == (i & 0x25))
	arr[y] = i;
    }
  return arr[z];
}

__attribute__((noipa)) int
baz (int n, int x, unsigned long z)
{
  int arr[16], s = 0;
  arr[12] = 42;
  for (int i = 0; i < n; i++)
    {
      if (x == (i & 0x25))
	arr[7] = i;
    }
  return arr[z];
}

int
main ()
{
  if (foo (10374) != 15 * 16 / 2)
    __builtin_abort ();
  if (bar (25, 0x25, (unsigned long) 0xdeadbeefbeefdeadULL, 4) != 42)
    __builtin_abort ();
  if (bar (25, 4, 15, 15) != 22)
    __builtin_abort ();
  if (baz (25, 0x25, 12) != 42)
    __builtin_abort ();
  if (baz (25, 4, 7) != 22)
    __builtin_abort ();
  if (baz (25, 4, 12) != 42)
    __builtin_abort ();
  return 0;
}
"
175-14227,danielmapar/TheCProgrammingLanguage,src/Chapter-1/Sections/1.3-TheForStatement.c,21,2,18,2466109.5812916,213530.0,11.54923898281272,1493.0,1462.0,47984.0,18788.0,1637.0,636.0,1355.0,593.0,1500000000,0.0016440730541944,1082014363648.0,0.0138388048517772,0.0632151201102258,"/*
 ============================================================================
 Name        : 1.3-TheForStatement.c
 Author      : Daniel Marchena Parreira
 Email       : danielmapar@gmail.com
 Date        : 13/11/2013
 Version     : 0.1
 Copyright   : GNU General Public License Version 2
 Description : There are plenty of different ways to write a program for a
 	 	 	   particular task. Let's try a variation on the temperature
 	 	 	   converter.
 ============================================================================
 */

#include <stdio.h>

/* print Fahrenheit-Celsius table */

int main(void)
{
	int fahr;

	for(fahr = 0; fahr <= 300; fahr = fahr + 20)
		printf(""%3d %6.1f\n"", fahr, (5.0/9.0)*(fahr-32));

	return 0;
}
"
315-20163,peter-wangxu/programming_pearl_learn,chap_1/unrepeat_int.c,21,1,15,1087488619.6106672,1701463306.0,0.7867971411897142,1461.0,1429.0,395471380.0,196165103.0,13239010.0,150822.0,1369.0,16356.0,1500000000,0.7249924130737782,1082014363648.0,1.6985379524840602e-06,0.0226618158028635,"#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#define N 1000000

int main() {
    char* p_data = NULL;
    p_data = malloc(sizeof(char) * N );
    memset(p_data, 49, N);
    int i = 0;
    int j = 0;
    FILE* file = fopen(""data.txt"", ""w+"");
    srand((int)time(0));
    while ( i < N) {
        //j=1+(int)(N*rand()/(RAND_MAX+1.0));
        j=rand() % N;
        if (p_data[j] == '1') {
            fprintf(file, ""%d\n"", j+1);
            p_data[j] = '0';
            i++;
        }
    }
    fclose(file);
    free(p_data);
    return 0;
}

"
055-33891,swigger/gdb-ios,gdb/testsuite/gdb.base/bp-cmds-execution-x-script.c,26,2,13,1650093.23973195,169054.0,9.760745087368534,1139.0,1129.0,38452.0,12696.0,1568.0,580.0,1319.0,544.0,1500000000,0.0011000621598213,1082014363648.0,0.0134158316277639,0.0784194885430515,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2015-2016 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
increment (int i)
{
  return i + 1;
}

#define N_INCR 20

int
main (void)
{
  int val = 1;
  int j;

  for (j = 0; j < N_INCR; j++)
    val = increment (val);
  return val == N_INCR;
}
"
324-26349,finlay-liu/OJ,JobDu/1189.c,27,4,13,2591717.9882526,182693.0,14.186186662871592,1343.0,1322.0,40368.0,13429.0,1627.0,635.0,1345.0,594.0,1500000000,0.0017278119921684,1082014363648.0,0.0145873131428133,0.0780898563116902,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
// freopen(""sample.txt"", ""r"", stdin);
int main()
{
	int a[30], i, flag, step;
	flag = 21;
	step = 0;
	for(i = 1;i <= 21; i++)
            a[i] = 1;
	while(flag != 1)
	{
		for(i = 1;i <= 21;i++)
		{
			if(a[i] == 1)
				step++;

			if(step == 17)
			{
				step = 0;
				a[i] = 0;
				flag--;
			}
		}
	}
	for(i = 1;i <= 21;i++)
		if(a[i])
			printf(""%d\n"", i);
	return 0;
}"
242-6520,totalspectrum/binutils-propeller,gdb/testsuite/gdb.base/sss-bp-on-user-bp.c,20,1,14,1323363.1616457,169064.0,7.714977759901576,1139.0,1129.0,38452.0,12699.0,1567.0,588.0,1316.0,547.0,1500000000,0.0008822421077638,1082014363648.0,0.0134150380920834,0.0785517389689351,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <signal.h>
#include <unistd.h>

int
main (void)
{
  volatile int i = 0;

  i = 1;     /* set foo break here */
  i = 2;

  return 0;
}
"
062-33201,totalspectrum/binutils-propeller,gdb/testsuite/gdb.base/hook-stop.c,29,1,16,1638544.3741455001,169083.0,9.688099927254662,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.001092362916097,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2009-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

void
func (void)
{
  int a;

  a = 1; /* set breakpoint here */
  a = 2;
}

int
main (int argc, char **argv)
{
  int i;

  i = 1;
  i = 2;
  i = 3;
  func ();

  return 0;
}
"
183-11129,TimMilesCox/masmx,masmx.7r3/test.msm/compara.c,13,2,11,2255376.31195035,196173.0,11.496872658316894,1363.0,1342.0,44267.0,16815.0,1636.0,635.0,1348.0,594.0,1500000000,0.0015035842079669,1082014363648.0,0.0137888496378196,0.068972856160571,"#include <stdio.h>

typedef union { long double			number;
		unsigned char	b[sizeof(long double)]; } arrange;

arrange	one = { 1.9e-300 } ;
arrange two = { 1.8e400  } ;

int main()
{
   int			 x;

   for (x = sizeof(long double)-1; x > -1; x--) printf(""%2.2x"", one.b[x]);
   putchar(10);
   for (x = sizeof(long double)-1; x > -1; x--) printf(""%2.2x"", two.b[x]);
   putchar(10);
   return 0;
}
"
210-6284,SanDisk-Open-Source/SSD_Dashboard,uefi/userspace/glibc/pwd/tst-getpw.c,29,2,16,6576515536.406077,336974655.0,19.516350676284542,3577516.0,3054.0,67094073.0,53583275.0,295974.0,182411.0,4239.0,1466.0,1500000000,4.384343690937385,1082014363648.0,0.0106256359250519,0.0040114404900578,"/* Copyright (C) 1999-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#include <pwd.h>

static void
check (uid_t uid)
{
  char buf[1024];

  (void) getpw (uid, buf);
}

int
main (void)
{
  uid_t uid;

  /* Just call it a different number of times the range should be
     large enough to find some existing and some non existing uids.  */

  for (uid = 0; uid < 2000; ++uid)
    check (uid);

  return 0;
}
"
332-28016,hanlin-he/UTD,leetcode/c/029.c,44,2,28,2213598.1125756,175250.0,12.631087018544935,1333.0,1315.0,39178.0,13312.0,1617.0,636.0,1340.0,593.0,1500000000,0.0014757320750504,1082014363648.0,0.0151098430813124,0.0797485235282911,"/* 029. Divide Two Integers. */
/* Using bitwise operation. */

#include<stdio.h>

#define MAX_INT +2147483647
#define MIN_INT -2147483648

int divide(int dividend, int divisor) {
    if (divisor == 1)
        return dividend;
    if (divisor == MIN_INT)
        return dividend == MIN_INT ? 1 : 0;

    if (dividend >= 0) {
        if (divisor > 0) {
            int ans = 0;
            int n = dividend;
            int d = divisor;
            while(n >= d) {
                int a = d;
                int m = 1;
                while((a << 1 >> 1 == a) && (a<<1) < n) {
                    a <<= 1;
                    m <<= 1;
                }
                ans += m;
                n -= a;
            }
            return ans;
        } else
            return 0 - divide(dividend, 0 - divisor);
    } else {
        if (dividend == -2147483648) {
            if (divisor == -1)
                return MAX_INT;
            if (divisor < 0)
                return 1 + divide(divisor - dividend, 0 - divisor);
            else
                return 0 - 1 - divide(0 - divisor - dividend, divisor);
        }
        if (divisor < 0) {
            return divide(0 - dividend, 0 - divisor);
        } else
            return 0 - divide(0 - dividend, divisor);
    }
}

int main() {
    printf(""%d\n"", divide(MIN_INT, 5));
    return 0;
}
"
357-7457,VictorRodriguez/operating-systems-lecture,labs/05/burst_time.c,16,1,14,2163366.0653605503,179197.0,12.072557018253654,1335.0,1316.0,40500.0,14243.0,1618.0,638.0,1339.0,593.0,1500000000,0.0014422440435737,1082014363648.0,0.014793774449349,0.0765029318817017,"/* CPU burst time calculation 
 * 
 * Create a program that calculate the CPU Burst time of a given process
 * It should differentiate from CPU burst and I/O burst
 * 
 * */

#include<stdio.h>

int main()
{
    int count=0;
    while(count<10){
        count++;
        printf(""%d\n"",count);
    }
    printf(""%d\n"",count);
    return 0; 
}

"
277-26942,zaqwes8811/concurrency-tricks,cuda/book/external/book-professional-cuda-c-programming/CodeSamples/chapter02/sumArraysOnHost.c,38,3,27,1571447.93774925,330355.0,4.756843395740946,1272.0,1252.0,82646.0,30677.0,1624.0,766.0,1351.0,722.0,1500000000,0.0010476319584995,1082014363648.0,0.0076402657746969,0.0393830025678811,"#include <stdlib.h>
#include <time.h>

/*
 * This example demonstrates a simple vector sum on the host. sumArraysOnHost
 * sequentially iterates through vector elements on the host.
 */

void sumArraysOnHost(float *A, float *B, float *C, const int N)
{
    for (int idx = 0; idx < N; idx++)
    {
        C[idx] = A[idx] + B[idx];
    }

}

void initialData(float *ip, int size)
{
    // generate different seed for random number
    time_t t;
    srand((unsigned) time(&t));

    for (int i = 0; i < size; i++)
    {
        ip[i] = (float)(rand() & 0xFF) / 10.0f;
    }

    return;
}

int main(int argc, char **argv)
{
    int nElem = 1024;
    size_t nBytes = nElem * sizeof(float);

    float *h_A, *h_B, *h_C;
    h_A = (float *)malloc(nBytes);
    h_B = (float *)malloc(nBytes);
    h_C = (float *)malloc(nBytes);

    initialData(h_A, nElem);
    initialData(h_B, nElem);

    sumArraysOnHost(h_A, h_B, h_C, nElem);

    free(h_A);
    free(h_B);
    free(h_C);

    return(0);
}
"
150-24147,alpine9000/BitOS,tests/gcc.c-torture/pr68250.c,37,3,17,1622867.77049295,170019.0,9.545209653038778,1150.0,1141.0,38678.0,12787.0,1577.0,586.0,1323.0,546.0,1500000000,0.0010819118469953,1082014363648.0,0.0134749645627841,0.0783445059749344,"/* { dg-do run } */
/* PR rtl-optimization/68250 */

signed char a, b, h, k, l, m, o;
short c, d, n;
int e, f, g, j, q;

void
fn1 (void)
{
  int p = b || a;
  n = o > 0 || d > 1 >> o ? d : d << o;
  for (; j; j++)
    m = c < 0 || m || c << p;
  l = f + 1;
  for (; f < 1; f = 1)
    k = h + 1;
}

__attribute__((noinline, noclone)) void
fn2 (int k)
{
  if (k != 1)
    __builtin_abort ();
}

int
main ()
{
  signed char i;
  for (; e < 1; e++)
    {
      fn1 ();
      if (k)
	i = k;
      if (i > q)
	g = 0;
    }
  fn2 (k);
  return 0;
}
"
293-31786,DeadDork/learning_c,experiments/enum_3.c,17,1,13,1880973.11183805,174429.0,10.78360249729116,1342.0,1323.0,39464.0,13505.0,1619.0,636.0,1341.0,593.0,1500000000,0.0012539820745587,1082014363648.0,0.015278422739338,0.079083992523929,"// Explores the use of enum values for symbolic constants.

// Conclusion: looks like they can.

// Universal {{{
enum COUNT_TO_THREE {
	ONE,
	TWO,
	THREE
};
// Universal }}}

// Main {{{
#include <stdio.h>

#define PrintExpression(x) printf(#x "" = [%d]\n"", (x))

int main(void) {
	PrintExpression(ONE);
	PrintExpression(TWO);
	PrintExpression(THREE);

	return 0;
}
// Main }}}
"
092-15583,bi3mer/WorkSpace,GeneralProblems/C/length.c,13,1,12,1593858.0036162,173163.0,9.204379688501586,1338.0,1319.0,39190.0,13303.0,1619.0,636.0,1341.0,593.0,1500000000,0.0010625720024108,1082014363648.0,0.0153439245104323,0.0798011163393214,"#include <stdio.h>

/*
	Find the lenght of an array in C
*/

int length (char *string){
	int count = 0;
	while(*string++)
		count++;
	return count;
}

int main(){
	char *string = ""1234567890"";
	printf(""Length of array: %i\n"",length(string));
}"
176-22372,dlleigh/chirp,lib/chirp/scripts/gigs.c,33,1,27,1914180631.5165014,7516395077.0,0.2545700956905674,1819.0,1785.0,45392.0,1073758355.0,1927.0,16777924.0,1592.0,16777879.0,1500000000,1.2761204210110009,1082014363648.0,4.794851738206469e-07,0.0312527518121986,"// vim:noexpandtab:ts=4:sts=4:
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <time.h>
#include <errno.h>
#include <string.h>

#define ONEMEG 1048576

void _gigs_log(char * message) {
	time_t rawtime;
	struct tm *timeinfo;
	char timebuf[256];

	time(&rawtime);
	timeinfo = localtime(&rawtime);
	strftime(timebuf, 256, ""%Y-%m-%dT%H:%M:%S%z"", timeinfo);

	printf(""time=\""%s\"" pid=%d msg=\""%s\""\n"", timebuf, getpid(), message);
}

int main(int argc, char *argv[]) {
	double amt;
	double n = 1.0;
	unsigned long i;
	char msgbuf[32];
	char *membuf;

	if (argc > 1) {
		n = atof((const char *)argv[1]);
	}

	sprintf(msgbuf, ""allocating %.2fGB"", n);
	_gigs_log(msgbuf);

	if (NULL == (membuf = malloc((int)(sizeof(char) * (ONEMEG * 1024 * n))))) {
		int err = errno;
		_gigs_log(""malloc failed"");
		return 1;
	}

	_gigs_log(""filling buffer"");
	for (i = 0; i < (ONEMEG * 1024 * n); i++) {
		membuf[i] = 'z';
	}

	_gigs_log(""exiting"");
	return 0;
}
"
118-22819,b3h3moth/L-C,c11_language/functions/functions_and_pointers/functions_and_multidim_array/sum_cols_and_rows.c,47,6,27,1753112.7668915999,184075.0,9.523900584001089,1378.0,1356.0,41547.0,14719.0,1637.0,641.0,1354.0,596.0,1500000000,0.0011687418445944,1082014363648.0,0.0148526415863099,0.0751430704155262,"#include <stdio.h>
#include <stdlib.h>

#define ROWS    3
#define COLS    4

// Function Prototypes
int sum_all(int (*arr)[COLS]);
void sum_rows(int arr[][COLS]);
void sum_cols(int [][COLS]);

/* Lo scopo del programma e' di provare le invocazioni di una funzione il cui
parametro formale e' un array multidimensionale e individuare quindi le varie
signatures possibili. */

int main(void) {
    int tot;
    int mdarr[ROWS][COLS] = { 
        {1,3,5,7},
        {2,4,6,8},
        {0,1,2,3}
    };

    puts(""sum each row element"");
    sum_rows(mdarr);
    puts(""sum each col element"");
    sum_cols(mdarr);
    tot = sum_all(mdarr);

    printf(""Total rows and cols: %d\n"", tot);

    return(EXIT_SUCCESS);
}

void sum_rows(int arr[][COLS]) {
    int tot_rows;

    for (int r=0; r<ROWS; r++) {
        tot_rows = 0;
        for (int c=0; c<COLS; c++)
            tot_rows += arr[r][c];
        printf(""%2d row: %2d total\n"", r, tot_rows);
    }
}

void sum_cols(int arr[][COLS]) {
    int tot_cols;

    for (int c=0; c<COLS; c++) {
        tot_cols = 0;
        for(int r=0; r<ROWS; r++)
            tot_cols += arr[r][c];
        printf(""%2d col: %2d total\n"", c, tot_cols);
    }
}

int sum_all(int arr[][COLS]) {
    static int tot = 0;

    for (int r = 0; r<ROWS; r++) 
        for (int c = 0; c<COLS; c++) 
            tot += arr[r][c];

    return tot;
}
"
245-4781,Frky/scat,test/proto/src/void__float.c,20,2,12,1986123.03938715,182340.0,10.892415268180322,1150.0,1140.0,42260.0,14180.0,1578.0,589.0,1324.0,547.0,1500000000,0.0013240820262581,1082014363648.0,0.012558955796863,0.0715450035435861,"
#include <stdlib.h>

// ORACLE FLOAT foo(VOID)

float foo(void) {
    int a;
    float b;
    int i;

    a = rand() % 65536;
    b = 1.0 /  a;

    for (i = 0; i < a; i++) 
        b += ((float) a) / ((float) i);

    return b;
}

int main(void) {
    
    int i;
    float a = 0, b = 0;

    for (i = 0; i < 100; i++) {
        a += foo();
        b += foo();
    }

    return 0; 
}
"
071-22095,shivasurya/cc150,zoho/set/permut.c,23,1,16,228018042.0493707,765000091.0,0.2980627645441678,1302.0,1286.0,222529858.0,142493132.0,1618.0,697.0,1340.0,655.0,1500000000,0.1520120280329138,1082014363648.0,3.383006133524761e-06,1.1807475468873892e-05,"#include<stdio.h>
#include<string.h>
void swap(char *a,char *c){
	char temp;
	temp = *a;
	*a = *c;
	*c = temp;
}
void permutation(char *a,int l,int r){
	int i;
	if(l==r)
		printf(""%s\n"",a);
	else{
		for(i=l;i<=r;i++){
			swap((a+l),(a+i));
			permutation(a,l+1,r);
			swap((a+l),(a+i));
		}
	}
}
int main(){
	char name[] = ""9788029400"";
  int len = strlen(name);
	permutation(name,0,len-1);
}"
319-17028,zhangxiaoyuan/interview,src/linux_api/multi_thread/thread_sem2.c,81,2,39,15003243109.56057,201367.0,74506.96047018627,1544.0,1511.0,46773.0,18021.0,1697.0,782.0,1395.0,737.0,1500000000,10.00216207304038,1082014363648.0,0.0151713041362288,0.0711639966663579,"#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>
#include <semaphore.h>
#include <errno.h>
#define return_if_fail(p) if((p) == 0){printf (""[%s]:func error!/n"", __func__);return;}
typedef struct _PrivInfo
{
    sem_t s1;
    sem_t s2;
    time_t end_time;
}PrivInfo;

static void info_init (PrivInfo* thiz);
static void info_destroy (PrivInfo* thiz);
static void* pthread_func_1 (PrivInfo* thiz);
static void* pthread_func_2 (PrivInfo* thiz);

int main (int argc, char** argv)
{
    pthread_t pt_1 = 0;
    pthread_t pt_2 = 0;
    int ret = 0;
    PrivInfo* thiz = NULL;
    thiz = (PrivInfo* )malloc (sizeof (PrivInfo));
    if (thiz == NULL)
    {
        printf (""[%s]: Failed to malloc priv./n"");
        return -1;
    }
    info_init (thiz);
    ret = pthread_create (&pt_1, NULL, (void*)pthread_func_1, thiz);
    if (ret != 0)
    {
        perror (""pthread_1_create:"");
    }
    ret = pthread_create (&pt_2, NULL, (void*)pthread_func_2, thiz);
    if (ret != 0)
    {
        perror (""pthread_2_create:"");
    }
    pthread_join (pt_1, NULL);
    pthread_join (pt_2, NULL);
    info_destroy (thiz);
    return 0;
}
static void info_init (PrivInfo* thiz)
{
    return_if_fail (thiz != NULL);
    thiz->end_time = time(NULL) + 10;
    sem_init (&thiz->s1, 0, 1);
    sem_init (&thiz->s2, 0, 0);
    return;
}
static void info_destroy (PrivInfo* thiz)
{
    return_if_fail (thiz != NULL);
    sem_destroy (&thiz->s1);
    sem_destroy (&thiz->s2);
    free (thiz);
    thiz = NULL;
    return;
}
static void* pthread_func_1 (PrivInfo* thiz)
{
    return_if_fail(thiz != NULL);
    while (time(NULL) < thiz->end_time)
    {
        sem_wait (&thiz->s2);
        printf (""pthread1: pthread1 get the lock./n"");
        sem_post (&thiz->s1);
        printf (""pthread1: pthread1 unlock/n"");
        sleep (1);
    }
    return;
}
static void* pthread_func_2 (PrivInfo* thiz)
{
    return_if_fail (thiz != NULL);
    while (time (NULL) < thiz->end_time)
    {
        sem_wait (&thiz->s1);
        printf (""pthread2: pthread2 get the unlock./n"");
        sem_post (&thiz->s2);
        printf (""pthread2: pthread2 unlock./n"");
        sleep (1);
    }
    return;
}
"
005-8796,begeekmyfriend/leetcode,0300_longest_increasing_subsequence/lis.c,34,3,24,1959814.69005345,174609.0,11.224014798778986,1343.0,1325.0,39606.0,13521.0,1626.0,636.0,1346.0,593.0,1500000000,0.0013065431267023,1082014363648.0,0.0152798538448762,0.0790746701300657,"#include <stdio.h>
#include <stdlib.h>


static int binary_search(int *nums, int lo, int hi, int target)
{
    while (lo + 1 < hi) {
        int mid = lo + (hi - lo) / 2;
        if (nums[mid] < target) {
            lo = mid;
        } else {
            hi = mid;
        }
    }
    return hi;
}

int lengthOfLIS(int* nums, int numsSize){
    int i, piles = 0;
    int *tops = malloc(numsSize * sizeof(int));
    for (i = 0; i < numsSize; i++) {
        int pos = binary_search(tops, -1, piles, nums[i]);
        if (pos == piles) {
            piles++;
        }
        tops[pos] = nums[i];
    }
    return piles;
}

int main(int argc, char **argv)
{
    int i;
    int *nums = malloc((argc - 1) * sizeof(int));
    for (i = 0; i < argc - 1; i++) {
        nums[i] = atoi(argv[i + 1]);
    }

    printf(""%d\n"", lengthOfLIS(nums, argc - 1));
    return 0;
}
"
199-23881,totalspectrum/binutils-propeller,gdb/testsuite/gdb.dwarf2/dynarr-ptr.c,23,1,14,1526298.1178237998,169087.0,9.026702230212848,1139.0,1129.0,38460.0,12700.0,1568.0,589.0,1317.0,548.0,1500000000,0.0010175320785492,1082014363648.0,0.0134132133162218,0.0786161063330727,"/* Copyright 2014-2017 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int table_1_data[] = {1, 3, 1, 2, 3};
int *table_1_ptr = &table_1_data[2];

int table_2_data[] = {2, 6, 5, 8, 13, 21, 34};
int *table_2_ptr = &table_2_data[2];

int
main (void)
{
  *table_1_ptr = 2;
  *table_2_ptr = 3;
  return 0;
}
"
008-30047,bamboolll/embedded_system_2014,lab3/mythread2.c,27,3,15,2809684.4907849,392236.0,7.163248656421135,2570.0,1802.0,92868.0,42616.0,2586.0,1466.0,1642.0,1225.0,1500000000,0.0018731229938566,1082014363648.0,0.0111463506664355,0.0510687608868943,"#include <stdio.h>
#include <pthread.h>
#define THREADNUM 10
void * thread_func(void *arg)
{
	int *t = (int *)arg;
	printf(""Thread0, arg = %d\n"", *t);
	pthread_exit(NULL); 
}
int main()
{
	pthread_t thread[THREADNUM];
	int ret;
	int buffer[THREADNUM];
	int i;
	//Create all thread
	for(i=0; i < THREADNUM; i++)
	{
		buffer[i] = i+1;
		ret = pthread_create(&thread[i], NULL, thread_func, &buffer[i]);
		if(ret != 0) printf(""cannot create thread\n"");
	}
	//Wait for all thread
	for(i=0; i < THREADNUM; i++)
	{
		pthread_join(thread[i], NULL);
	}
	printf(""Exit main\n"");
	return 0;
}
"
327-11474,fat-dragon/resh,fortuneindex.c,46,2,19,1639352.87855565,178386.0,9.185104212213965,1331.0,1307.0,40676.0,13967.0,1654.0,639.0,1368.0,594.0,1500000000,0.0010929019190371,1082014363648.0,0.0147881560212124,0.0778690774664641,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void
indexfile(FILE *in, FILE *out)
{
	int	ch, ch0, ch1;
	long	pos;

	pos = 0;
	ch0 = 0;
	ch1 = 0;
	while ((ch = fgetc(in)) != EOF) {
		if ((ch1 == '\n' || ch1 == 0) && ch0 == '%' && ch == '\n') {
			fwrite(&pos, 1, sizeof pos, out);
			pos = ftell(in);
		}
		ch1 = ch0;
		ch0 = ch;
	}
	fwrite(&pos, 1, sizeof pos, out);
}

int
main(int argc, char *argv[])
{
	FILE	*in, *out;

	if (argc == 1) {
		indexfile(stdin, stdout);
	} else while (*++argv) {
		if (strcmp(*argv, ""-"") == 0) {
			indexfile(stdin, stdout);
			continue;
		}
		in = fopen(*argv, ""r"");
		if (in == NULL) {
			perror(*argv++);
			continue;
		}
		out = fopen(*++argv, ""w"");
		if (out == NULL) {
			perror(*argv);
			fclose(in);
			continue;
		}
		indexfile(in, out);
		fclose(in);
		fclose(out);
	}

	return(EXIT_SUCCESS);
}
"
057-28945,arif98741/basic-c-programming-codes,Namota6.c,11,1,9,1783503.1030699501,186231.0,9.576831998969022,1338.0,1319.0,41712.0,14926.0,1618.0,638.0,1340.0,595.0,1500000000,0.0011890020687133,1082014363648.0,0.0142672272607675,0.0739962569299763,"
#include <stdio.h>
int main()
{

    int n,a;
    n=6;
    for(a=1;a<=10;a++)
    {
        printf(""%d * %d = %d\n"",n,a,n*a);
    }



    return 0;
}
// 5
"
334-14082,jketo/arcusysdevday2015,Team5/c/rasa.c,27,2,20,1999355.96901915,175262.0,11.407806598121669,1350.0,1327.0,39794.0,13589.0,1637.0,635.0,1356.0,593.0,1500000000,0.0013329039793461,1082014363648.0,0.0152742750853008,0.0790701159545173,"#include <stdio.h>
int main (int argc, char **argv)
{
 int depth = 1;
 int summaryRasa = 0;
 int totalLines = 0;

 for (int i = 1; i < argc; i++) {
 	FILE *fp;
	char *filename=argv[i];
    fp=fopen(filename, ""r"");
 	int rasa = 0;
 	int lines = 0;
	 for (int ch = fgetc(fp); ch != EOF; ch = fgetc(fp)) {
	 	char ch1 = (char)ch;
	 	switch (ch1) {
	 		case ';': rasa += depth; break;
	 		case '{': depth ++; break;
	 		case '}': depth --; break;
	 		case '\n': lines ++; break;
	 	}
	 }
	 fclose(fp);
	 printf(""%s: lines %d, RaSa %d \n"", filename, lines, rasa);
	 summaryRasa += rasa;
	 totalLines += lines;
 }

 	 printf(""total: lines %d, RaSa %d \n"", totalLines, summaryRasa);
}"
044-33300,gnomex/C-Syllabus,FAA/Pointers/pointers.c,28,1,21,1913612.94127995,1355473.0,1.4117669625289475,1376.0,1354.0,265227.0,171959.0,1693.0,699.0,1373.0,656.0,1500000000,0.0012757419608533,1082014363648.0,0.0020140570856077,0.0101124006715677,"#include <stdio.h>

int
main(
  int argc,
  char const *argv[])
{

  int A[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
  int N;
  int *ptr_a = NULL;

  ptr_a = &A;
  printf(""%d\n"", ptr_a);

  ptr_a++;
  printf(""%d\n"", ptr_a);

  ptr_a += 4;
  printf(""%d\n"", ptr_a);

  ptr_a -= 2;
  printf(""%d\n"", ptr_a);

  N = &A[3] - &A[0];
  printf(""%d\n"", N);

  N = &A[0] - &A[3];
  printf(""%d\n"", N);

  if (ptr_a > &A[2]) printf(""Yep\n"");

  int *p = &A;
  for (; p <= &A[1000]; ++p) printf(""%d [%p]\n"", *p, p);

  int lol[10][9][8][7][6][5];
  lol[0][0][0][0][0][0] = 1;
  printf(""%d\n"", lol[0][0][0][0][0][0]);

  return 0;
}
"
261-24365,kar7hik/c_programming,C13/planet_list.c,27,3,20,1994031.01578345,176301.0,11.310378273520854,1357.0,1336.0,40012.0,13687.0,1634.0,639.0,1351.0,594.0,1500000000,0.0013293540105223,1082014363648.0,0.0152750126204615,0.0785489487699957,"
// Copyright 2017 Karthik

#include <stdio.h>

int main(void) {
  /*
  char planets[][8] = {""Mercury"", ""Venus"", ""Earth"",
                       ""Mars"", ""Jupiter"", ""Saturn"",
                       ""Uranus"", ""Neptune"", ""Pluto""};
  */
  
  char *planets[] = {""Mercury"", ""Venus"", ""Earth"",
                     ""Mars"", ""Jupiter"", ""Saturn"",
                     ""Uranus"", ""Neptune"", ""Pluto""};
  
  
  int i, j;

  /*
  for (i = 0; i < 9; i++) {
    for (j = 0; j < 8; j++) {
      printf(""%c"", planets[i][j]);
    }
    printf(""\n"");
  }
  */

  
  for (i = 0; i < 9; i++) {
    printf(""%s\n"", planets[i]);
  }

  char fmt[] = ""%d\n"";
  int k = 3;

  printf(fmt, k);
  
  return 0;
}
"
276-33239,CGCC-CS/csc220summer17,class14/pthread.c,39,5,27,15082897625.863554,309888.0,48672.09322400351,1645.0,1587.0,68893.0,35155.0,1834.0,1152.0,1392.0,918.0,1500000000,10.055265083909037,1082014363648.0,0.0104295745559686,0.0508995848070121,"#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h> 

/* gcc pthread.c -ansi -Wall -pedantic -pthread */

#define NUM_THREADS 6

void *count_to_ten(void *x) {
    int ii, jj;
    char buffer[100];
    char tabs[20] = {'\0'};
    int skip = *((int *) x);
    for(jj=0;jj<skip;jj++) {
        sprintf(tabs, ""%s\t"",tabs);
    }
    for (ii=0;ii<10;ii++) {
        sprintf(buffer, ""%s%d\n"",tabs,ii);
        printf(""%s"", buffer);
        fflush(stdout);
        sleep(1);
    }
    return NULL;
}

int main() {
  int ii;
  int rc;

  int num[NUM_THREADS];
  pthread_t new_thread[NUM_THREADS];

  for (ii=0;ii<NUM_THREADS;ii++) {
    num[ii] = ii;
  }

  for (ii=0;ii<NUM_THREADS;ii++) {
    if ((rc = pthread_create(&new_thread[ii], NULL, count_to_ten, &num[ii])) != 0) {
      fprintf(stderr, ""ERROR code %d calling pthread_create\n"",rc);
      return 1;
    }
  }

  for (ii=0;ii<NUM_THREADS;ii++) {
    if (pthread_join(new_thread[ii], NULL) != 0) {
      fprintf(stderr, ""Error joining pthread\n"");
      return 1;
    }
  }

  return(0);
}
"
384-13282,mattstock/binutils-bexkat1,gdb/testsuite/gdb.dwarf2/dwp-symlink.c,23,1,16,1784177.8462752001,169057.0,10.55370082279941,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0011894518975168,1082014363648.0,0.0134155935572026,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2013-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* Cheezy hack to prevent set_initial_language from trying to look up main.
   We do this so that gdb won't try to open the dwp file when the file is
   first selected.  This gives us a chance to do a chdir before attempting
   to access the debug info.  */
asm ("".globl main.main"");
asm (""main.main: .byte 0"");

int
main (int argc, char **argv)
{
  return 0;
}
"
303-31275,Suyaletu/ACM,第一题/main.c,20,1,12,1693999.3947744,178605.0,9.484611293076902,1340.0,1320.0,40040.0,13910.0,1618.0,637.0,1340.0,594.0,1500000000,0.0011293329298496,1082014363648.0,0.0148932000783852,0.0776459684893419,"
/*网友年龄

某君新认识一网友。
当问及年龄时，他的网友说：
“我的年龄是个2位数，我比儿子大27岁,
如果把我的年龄的两位数字交换位置，刚好就是我儿子的年龄”

请你计算：网友的年龄一共有多少种可能情况？

提示：30岁就是其中一种可能哦.

请填写表示可能情况的种数。
注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。
*/


#include <stdio.h>
int main ()
{
    int i;
    for(i = 10;i < 100;i++)
    {
        if((i - 27) == ((i % 10) * 10 + i / 10))
            printf(""age = %d\n"",i);
    }
    
    return 0;
}
"
031-12859,mayesheng/CS356-Operating-System-Project,project_2/requirement_1/my_test/jni/my_test.c,23,2,20,1628642.9017782,173645.0,9.379147110484034,1341.0,1322.0,39375.0,13390.0,1623.0,636.0,1345.0,594.0,1500000000,0.0010857619345188,1082014363648.0,0.0153358864349678,0.0795603146024827,"/* 
 *      CS356 Operating System Project 2: my_test
 *	This program just functions as a test function which
 *  adds number from 1 to N where N is an input parameter
 *	and calculate the time it consumes.
 *           anthor: Ma Yesheng 5140209064
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>


int main(int argc, char **argv)
{
	int N = 100000000;
	clock_t begin, end;
	begin = clock();
	int sum = 0;
	int i;
	int j;
	for (j = 0; j <= 5; ++j)
		for (i = 0; i <= N; ++i)
			sum += i;
	end = clock();
	printf(""my_test over, time consumed %d ms\n"", 
		(int)((double)(end-begin)/CLOCKS_PER_SEC*1000));
	return 0;
}
"
038-11057,ghzmdr/Algorithms,Peakfinder.c,49,5,28,1901882.8170373498,174844.0,10.877593740706,1339.0,1320.0,39576.0,13482.0,1627.0,638.0,1345.0,595.0,1500000000,0.0012679218780249,1082014363648.0,0.0152078424195282,0.0792528930604244,"#include <stdio.h>
#define COLS 5
#define ROWS 5

int main (){

int array[ROWS][COLS] = { {1,	2,	3,	4,	75},
						  {6,	5,	4,	5,	3},
						  {3,	6,	7,	8,	3}, 
						  {4,	3,	0,	9,	4},
						  {2,	4,	2,	10,	11}};

int mid = COLS/2, i, max = 	array[i][mid], maxi;


for (i = 0; i < ROWS; i++){

	if (array[i][mid] >= max){
		max = array[i][mid];
		maxi = i;
	}
}

if (max < array[maxi][mid-1]){
	--mid;
	for(i = 0; i < ROWS; i++){
		
		if (array[i][mid] >= max){
		max = array[i][mid];
		maxi = i;
		}
	}		
} else if (max < array[maxi][mid+1]){
	++mid;
	for(i = 0; i < ROWS; i++){
		
		if (array[i][mid] >= max){
		max = array[i][mid];
		maxi = i;
		}
	}		
} 


if (max < array[maxi][mid-1]){
	--mid;
	for(i = 0; i < ROWS; i++){
		
		if (array[i][mid] >= max){
		max = array[i][mid];
		maxi = i;
		}
	}		
} else if (max < array[maxi][mid+1]){
	++mid;
	for(i = 0; i < ROWS; i++){
		
		if (array[i][mid] >= max){
		max = array[i][mid];
		maxi = i;
		}
	}		
} 

printf(""Peek found at: Column %d  Row %d, is: %d\n"", mid+1, maxi+1, max);
}

"
091-4113,totalspectrum/binutils-propeller,gdb/testsuite/gdb.mi/mi-var-list-children-invalid-grandchild.c,35,1,25,1793884.43939385,169103.0,10.608232852167022,1142.0,1132.0,38461.0,12696.0,1566.0,585.0,1316.0,546.0,1500000000,0.0011959229595959,1082014363648.0,0.0134474255335505,0.0784447876145982,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2015-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

struct inner
{
  int a;
};

struct outer
{
  struct inner *inner;
};

int main (void)
{
  struct inner inner;
  struct outer outer;
  struct outer *p_outer;

  inner.a = 42;
  outer.inner = &inner;

  /* We force p_outer to an invalid value, but this also happens naturally
   * when a variable has not been initialized. */

  p_outer = 0;
  /* p_outer set to invalid value */
  p_outer = &outer;
  /* p_outer set to valid value */

  return 0;
}
"
191-35133,shreepads/21c,test_simple_big_sqrt.c,24,1,20,428718661.54018784,5336601422.0,0.0803355220108098,1474.0,1447.0,41094.0,14469.0,1648.0,634.0,1362.0,591.0,1500000000,0.2858124410267919,1082014363648.0,5.473521009004446e-07,0.0762197865486024,"/** Simple int sqrt algo test */

#include <stdio.h>
#include <time.h>
#include <math.h>

int main(int argc, char **argv)
{

	//long long int n = 274259595204LL;
	long long int n = 581170932765279684LL;
	//long long int n = 4LL;

	long double x = sqrtl((long double) n);

	printf(""Math function sqrt of %lli is %Lf \n\n"", n, x);

	long long int sqrt = 0;
	
	time_t starttime = time(NULL);

	for (long long int i = 2; i < n/2 ; i++)
	{
		if (i*i == n)
		{
			sqrt = i;
			break;
		}
	}
	
	time_t endtime = time(NULL);

	double runtimeinsecs = difftime(endtime, starttime);

	printf(""Big sqrt mp of %lli is %lli \n"", n, sqrt);

	printf(""Time taken: %f \n"", runtimeinsecs);
	
	return 0;

}


				
"
128-19180,carlobar/uclinux_leon3_UD,user/klibc/usr/klibc/tests/getoptlong.c,44,2,22,3418701.0023741997,180976.0,18.89035562726549,1390.0,1367.0,41258.0,14109.0,1718.0,645.0,1367.0,600.0,1500000000,0.0022791340015828,1082014363648.0,0.0152340641853063,0.0782054292267957,"/*
 * getoptlong.c
 *
 * Simple test for getopt_long, set the environment variable GETOPTTEST
 * to give the argument string to getopt()
 */

#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <getopt.h>

static int foo = 0;
	
static const struct option long_options[] = {
	{ ""first"",   1, NULL, 'f' },
	{ ""second"",  0, NULL, 's' },
	{ ""third"",   2, NULL, '3' },
	{ ""fourth"",  0, NULL,  4 },
	{ ""set-foo"", 0, &foo,  1 },
	{ NULL, 0, NULL, 0 }
};

int main(int argc, char *const *argv)
{
	const char *parser;
	const char *showchar;
	char one_char[] = ""\'?\'"";
	char num_buf[16];
	int c;
	int longindex;

	parser = getenv(""GETOPTTEST"");
	if (!parser)
		parser = ""abzf:o:"";

	do {
		c = getopt_long(argc, argv, parser, long_options, &longindex);

		if (c == EOF) {
			showchar = ""EOF"";
		} else if (c >= 32 && c <= 126) {
			one_char[1] = c;
			showchar = one_char;
		} else {
			snprintf(num_buf, sizeof num_buf, ""%d"", c);
			showchar = num_buf;
		}

		printf(""c = %s, optind = %d (\""%s\""), optarg = \""%s\"", ""
		       ""optopt = \'%c\', foo = %d, longindex = %d\n"",
		       showchar, optind, argv[optind],
		       optarg, optopt, foo, longindex);
	} while (c != -1);

	return 0;
}
"
161-11143,kimushu/nios2-gdb-7.0,gdb/testsuite/gdb.threads/execl1.c,20,1,18,1531532.9656003502,169083.0,9.057870986438614,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010210219770669,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2008, 2009 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/* Test handling thread control across an execl.  */

/* New exec image that doesn't load any thread library.  */

int
main (int argc, char* argv[])
{
  return 0;
}
"
159-27633,OpenGenus/cosmos,code/sorting/src/bogo_sort/bogo_sort.c,42,4,22,498769934.9876493,2577462024.0,0.1935120398887398,1362.0,1339.0,712404024.0,315163600.0,1644.0,637.0,1360.0,595.0,1500000000,0.3325132899917662,1082014363648.0,1.047930085816853e-06,4.122356427998943e-06,"/* Part of cosmos by OpenGenus Foundation  */

/*
* bogo_sort.c
* created by Riya
*/

#include <stdio.h>    
#include <stdlib.h>    

int
main()    
{        
    int num[10]={1, 4, 7, 5, 9, 2, 6, 3, 8, 0};        
    int i;            
    bogosort(num, 10);        
    printf(""The array after sorting is:"");        
    for (i = 0;i < 10;i++) {            
        printf(""%d\n"", num[i]);        
    } printf(""\n"");    
}         
int
is_sorted(int *a, int n)    
{        
    while ( --n >= 1 ) {        
        if ( a[n] < a[n-1] ) 
            return (0);    
    } 
    return (1);    
}    
void
shuffle(int *a, int n)    
{        
    int i, t, temp;        
    for (i = 0;i < n;i++) {            
        t = a[i];            
        temp = rand() % n;             
        a[i] = a[temp];            
        a[temp] = t;        
    }    
}    
void
bogosort(int *a, int n)    
{        
    while ( !is_sorted(a, n) )             
    shuffle(a, n);    
}
"
295-4807,T-J-Teru/gdb,gdb/testsuite/gdb.base/hook-stop-frame.c,24,1,16,1582249.7662156501,169061.0,9.35904200259078,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010548331774771,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2009-2013 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

void
func (void)
{
  int a;

  a = 1; /* set breakpoint here */
}

int
main (int argc, char **argv)
{
  func ();

  return 0;
}
"
294-21030,digwiz/Euler,c/problem_four.c,42,3,26,109297581.01701735,732379569.0,0.149182723856132,1370.0,1348.0,136085967.0,109609096.0,1643.0,639.0,1362.0,594.0,1500000000,0.0728650540113449,1082014363648.0,3.711190365005936e-06,1.724902384383686e-05,"#include <stdio.h>
#include <string.h>

char *strrev(char *str);

int main(void)
{
    int x;
    int y;
    int z;
    int max = 0;
    char a[7];
    char b[7];

    for(x = 999 ; x > 99 ; x--)
    {
        for(y = 999 ; y > 99 ; y--)
        {
            z = x * y;
            sprintf(a, ""%d"", z);
            strcpy(b, a);
            strrev(b);
            if(strcmp(a, b) == 0)
            {
                if(z > max)
                {
                    max = z;
                }
            }
        }
    }
    printf(""Answer = %d\n"", max);
    return 0;
}

char *strrev(char *str)
{
      char *p1, *p2;

      if (! str || ! *str)
            return str;
      for (p1 = str, p2 = str + strlen(str) - 1; p2 > p1; ++p1, --p2)
      {
            *p1 ^= *p2;
            *p2 ^= *p1;
            *p1 ^= *p2;
      }
      return str;
}"
389-18604,freak97/binutils,gdb/testsuite/gdb.base/gcore.c,54,2,27,1990352.7572750999,169083.0,11.7714495247896,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0013269018381834,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* Copyright 2002-2016 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/*
 * Test GDB's ability to save and reload a corefile.
 */

#include <stdlib.h>
#include <string.h>

int extern_array[4] = {1, 2, 3, 4};
static int static_array[4] = {5, 6, 7, 8};
static int un_initialized_array[4];
static char *heap_string;

void 
terminal_func ()
{
  return;
}

void
array_func ()
{
  int local_array[4];
  int i;

  heap_string = (char *) malloc (80);
  strcpy (heap_string, ""I'm a little teapot, short and stout..."");
  for (i = 0; i < 4; i++)
    {
      un_initialized_array[i] = extern_array[i] + 8;
      local_array[i] = extern_array[i] + 12;
    }
  /* Reference static_array so that clang doesn't discard it.  */
  (void) static_array[0];
  terminal_func ();
}

int factorial_func (int value)
{
  if (value > 1) {
    value *= factorial_func (value - 1);
  }
  array_func ();
  return (value);
}

int
main()
{
  factorial_func (6);
  return 0;
}
"
121-34150,fengbohello/practice,clang/file/scandir.c,42,1,29,7372046.937234599,244865.0,30.106573009617545,1426.0,1402.0,56458.0,21571.0,1892.0,670.0,1596.0,626.0,1500000000,0.0049146979581564,1082014363648.0,0.0115492209993261,0.0613105383895731,"/*
 * =====================================================================================
 *
 *       Filename:  scandir.cpp
 *
 *    Description:  
 *
 *        Version:  1.0
 *        Created:  12/06/2016 10:10:51 AM
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  YOUR NAME (), 
 *   Organization:  
 *
 * =====================================================================================
 */
#include <stdio.h>
#include <errno.h>
#include <dirent.h>
#include <stdlib.h>
#include <string.h>

int filter(const struct dirent * d) {
    if(NULL == d) {
        return 0;
    }
    if(strstr(d -> d_name, "".c"") != NULL) {
        return 1;
    }

    return 0;
}

int main(void)
{
    struct dirent **namelist;
    int n;

    n = scandir(""."", &namelist, filter, alphasort);
    if (n < 0)
        perror(""scandir"");
    else {
        while (n--) {
            printf(""%s\n"", namelist[n]->d_name);
            free(namelist[n]);
        }
        free(namelist);
    }

    return 0;
}

"
192-32159,guonaihong/recycle_bin,libc/ho_string/ho_memchr.c,13,1,12,1449016.2720903,172657.0,8.392454403817974,1298.0,1280.0,39073.0,13243.0,1607.0,634.0,1333.0,592.0,1500000000,0.0009660108480602,1082014363648.0,0.0149313378548219,0.0796314702958941,"#include <stdio.h>

void *ho_memchr(const void *s, int c, size_t n) {
    unsigned char *p = (unsigned char *)s;
    for (;n-- > 0; ++p) {
        if (*p == c)
            return (void *)p;
    }
    return NULL;
}

int main() {
    printf(""%s\n"", ho_memchr(""12345"", '2', 5));
    printf(""%s\n"", ho_memchr(""12345"", '3', 5));
    return 0;
}
"
103-17282,mattstock/binutils-bexkat1,gdb/testsuite/gdb.base/annota-input-while-running.c,18,1,14,7512471039.080993,170060.0,44175.41478889804,1150.0,1141.0,38683.0,12795.0,1575.0,581.0,1324.0,544.0,1500000000,5.008314026053995,1082014363648.0,0.0134717158649888,0.0781693150472046,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
main (void)
{
  sleep (5);
  return 0; /* set break here */
}
"
286-7261,alpine9000/BitOS,tests/gcc.c-torture/20030330-1.c,13,2,16,1581963.0352779,169057.0,9.357571706584167,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010546420235186,1082014363648.0,0.0134155935572026,0.0785563462891999,"/* { dg-do run } */
/* PR opt/10011 */
/* This is link test for builtin_constant_p simplification + DCE.  */

extern void link_error(void);
static void usb_hub_port_wait_reset(unsigned int delay)
{
        int delay_time;
        for (delay_time = 0; delay_time < 500; delay_time += delay) {
                if (__builtin_constant_p(delay))
                        link_error();
        }
}

int main() { return 0; }
"
340-32770,evan886/learn-c,mysrc/pointer/cptr1.c,23,2,17,1654486.40473185,176458.0,9.376089494383931,1342.0,1323.0,39918.0,13715.0,1627.0,636.0,1345.0,595.0,1500000000,0.0011029909364879,1082014363648.0,0.0151027439957383,0.078365931422818,"#include <stdio.h>
const int MAX = 3;
int main()
{
	int var[] = {10,100,200};
	int i, *ptr[MAX];
	for ( i = 0;  i < MAX ; i++)
  {
       ptr[i] = &var[i];  /* 赋值为整数的地址 */ 
}
	for ( i = 0;  i < MAX ; i ++)
  {
	printf(""存储值：var[%d] = %d \n"", i, *ptr[i]);
}
  return 0;
 }
/*
让数组存储指向 int 或 char 或其他数据类型的指针。下面是一个指向整数的指针数组的声明：
int *ptr[MAX];
在这里，把 ptr 声明为一个数组，由 MAX 个整数指针组成。因此，ptr 中的每个元素，都是一个指向 int 值的指针。下面的实例用到了三个整数，它们将存储在一个指针数组中 

存储值：var[0] = 10 
存储值：var[1] = 100 
存储值：var[2] = 200 
*/
"
092-33399,swistak35/uwr_cache_sim,testprogram.c,18,4,10,2526966.0400225497,8371096.0,0.3018679991246069,1339.0,1319.0,1063436.0,1038428.0,1635.0,747.0,1345.0,642.0,1500000000,0.0016846440266817,1082014363648.0,0.0003175211465738,0.0020786311578674,"#include <stdio.h>

#define CACHE_BITS 10
#define BLOCK_BITS 8
#define LOOPS 1000

int main(void) {
  int size = 1 << CACHE_BITS;
  int jump = 1 << BLOCK_BITS;

  long int tab[size];
  long int suma;

  for (int i = 0; i < size; i++) {
    tab[i] = 0;
  }

  for (int j = 0; j < LOOPS; j++) {
    for (int k = 0; k < jump; k++) {
      for (int i = k; i < size; i += jump) {
        tab[i] = tab[i] + i;
        suma += tab[i];
      }
    }
  }

  printf(""Wynik: %d\n"", suma);
}
"
224-12935,mattstock/binutils-bexkat1,gdb/testsuite/gdb.dwarf2/variant.c,40,1,20,1415792.85264015,169087.0,8.373157013844944,1142.0,1132.0,38460.0,12700.0,1568.0,585.0,1317.0,546.0,1500000000,0.0009438619017601,1082014363648.0,0.0134486980075345,0.0784988272087568,"/* Copyright 2018-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

unsigned char buffer[8];
unsigned char buffer2[8];

static void
func (void)
{
}

int
main (void)
{
  /* Write the expected values into the buffer.  */
  unsigned int x = 23;
  if (*(char *) &x)
    {
      /* Little endian.  */
      buffer[0] = 23;
      buffer[4] = 23;
      buffer2[0] = 255;
      buffer2[4] = 23;
    }
  else
    {
      buffer[3] = 23;
      buffer[7] = 23;
      buffer2[0] = 255;
      buffer2[7] = 23;
    }

  func ();
  return 0;
}
"
149-16776,zhongwei/learningc,cprimerplus/ch14/friend.c,41,1,20,1918233.1161572998,180043.0,10.651883161244816,1364.0,1343.0,40720.0,14247.0,1642.0,641.0,1359.0,599.0,1500000000,0.0012788220774382,1082014363648.0,0.0150352971234649,0.0771553841395746,"#include <stdio.h>

#define LEN 20

const char *msgs[5] = {
	""    Thank you for the wonderful evening, "",
	""You certainly prove that a "",
	""is a special kind of guy. We must get together"",
	""over a delicious "",
	"" and have a few laughs""
};

struct names {
	char	first[LEN];
	char	last[LEN];
};

struct guy {			// second structure
	struct names	handle;	// nested structe
	char		favfood[LEN] ;
	char		job[LEN];
	float		income;
};

int main(void) 
{
	struct guy fellow = {	// initialize a variable
		{""Ewen"", ""Villard""},
		""grilled salmon"",
		""personality coach"",
		68112.00
	};

	printf(""Dear %s, \n\n"", fellow.handle.first);
	printf(""%s%s.\n"", msgs[0], fellow.handle.first);
	printf(""%s%s\n"", msgs[1], fellow.job);
	printf(""%s\n"", msgs[2]);
	printf(""%s%s%s"", msgs[3], fellow.favfood, msgs[4]);

	if (fellow.income > 150000.0) {
		puts(""!!"");
	} else if (fellow.income > 75000.0) {
		puts(""!"");
	} else {
		puts(""."");
	}

	printf(""\n%40s%s\n"", "" "", ""See you soon,"");
	printf(""%40s%s\n"", "" "", ""Shalala"");

	return 0;
}

"
343-10337,Gurgel100/gcc,libgomp/testsuite/libgomp.oacc-c-c++-common/vprop-2.c,36,4,17,1553792.8557022498,175286.0,8.864324589527971,1159.0,1151.0,39342.0,13474.0,1587.0,586.0,1329.0,546.0,1500000000,0.0010358619038015,1082014363648.0,0.0131784626267927,0.0766434413813995,"/* { dg-do run } */

#include <assert.h>

#define DO_PRAGMA(x) _Pragma (#x)

#define test(idx,type,ngangs)                           \
  void                                                  \
  test_##idx ()                                         \
  {                                                     \
    int b[100];                                         \
                                                        \
    for (unsigned int i = 0; i < 100; i++)              \
      b[i] = 0;                                         \
                                                        \
    DO_PRAGMA(acc parallel num_gangs (ngangs) copy (b)) \
      {                                                 \
        _Pragma(""acc loop gang"")                        \
          for (type j = 0; j < 5; j++)                  \
            {                                           \
              _Pragma(""acc loop vector"")                \
                for (unsigned int i = 0; i < 20; i++)   \
                  b[j * 20 + i] = -2;                   \
            }                                           \
      }                                                 \
                                                        \
    for (unsigned int i = 0; i < 100; i++)              \
      assert (b[i] == -2);                              \
  }

test (0, signed char, 256)
test (1, unsigned char, 256)
test (2, signed short, 65535)
test (3, unsigned short, 65535)

int
main ()
{
  test_0 ();
  test_1 ();
  test_2 ();
  test_3 ();

  return 0;
}
"
181-19009,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.base/annota-input-while-running.c,18,1,14,7502390756.970271,170060.0,44116.13992708456,1150.0,1141.0,38683.0,12795.0,1575.0,581.0,1324.0,544.0,1500000000,5.001593837980181,1082014363648.0,0.0134717158649888,0.0781693150472046,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
main (void)
{
  sleep (5);
  return 0; /* set break here */
}
"
187-18084,XuhuiShen/play-with-data-structure,string/less-commonly-used/strspn/strspn.c,16,1,12,1342892.9960355,173787.0,7.727229309442018,1340.0,1321.0,39384.0,13388.0,1621.0,635.0,1343.0,593.0,1500000000,0.000895261997357,1082014363648.0,0.0153118472613026,0.0794360645797013,"#include <string.h>
#include <stdio.h>

size_t _strspn(const char *s1, const char *s2)
{
	const char *sc1;
	for (sc1 = s1; *sc1 != '\0'; sc1++)
		if (strchr(s2, *sc1) == NULL)
			return (sc1 - s1);
	return sc1 - s1;
}

int main()
{
	char *s1 = ""apple"";
	char *s2 = ""applx"";
	int n = _strspn(s1, s2);
	printf(""%d\n"", n);

	return 0;
}
"
234-5533,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.base/paginate-after-ctrl-c-running.c,18,1,14,15002859214.55361,170055.0,88223.57010378996,1149.0,1140.0,38683.0,12795.0,1575.0,581.0,1324.0,544.0,1500000000,10.00190614303574,1082014363648.0,0.0134603510628914,0.0781693150472046,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
main (void)
{
  sleep (10);
  return 0; /* after sleep */
}
"
263-7030,mattstock/binutils-bexkat1,gdb/testsuite/gdb.base/paginate-after-ctrl-c-running.c,18,1,14,15001806821.906939,170055.0,88217.38155890741,1149.0,1140.0,38683.0,12795.0,1575.0,581.0,1324.0,544.0,1500000000,10.00120454793796,1082014363648.0,0.0134603510628914,0.0781693150472046,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
main (void)
{
  sleep (10);
  return 0; /* after sleep */
}
"
212-45,mickael-guene/binutils,gdb/testsuite/gdb.base/annota-input-while-running.c,18,1,14,7501681066.467426,170060.0,44111.96675291074,1150.0,1141.0,38683.0,12795.0,1575.0,581.0,1324.0,544.0,1500000000,5.0011207109782845,1082014363648.0,0.0134717158649888,0.0781693150472046,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
main (void)
{
  sleep (5);
  return 0; /* set break here */
}
"
214-30679,mickael-guene/binutils,gdb/testsuite/gdb.base/paginate-after-ctrl-c-running.c,18,1,14,15005261225.975119,170055.0,88202.51758548705,1149.0,1140.0,38683.0,12795.0,1575.0,581.0,1324.0,544.0,1500000000,10.003507483983412,1082014363648.0,0.0134603510628914,0.0781693150472046,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
main (void)
{
  sleep (10);
  return 0; /* after sleep */
}
"
187-9432,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.base/continue-all-already-running.c,18,1,14,15030949788.051657,170055.0,88388.75533209844,1149.0,1140.0,38683.0,12795.0,1574.0,581.0,1323.0,544.0,1500000000,10.020633192034438,1082014363648.0,0.0134603510628914,0.0781304634989704,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
main (void)
{
  sleep (10);
  return 0; /* set break here */
}
"
092-6085,mattstock/binutils-bexkat1,gdb/testsuite/gdb.dwarf2/dynarr-ptr.c,23,1,14,1569483.07994745,169087.0,9.28210329593641,1139.0,1129.0,38460.0,12700.0,1568.0,589.0,1317.0,548.0,1500000000,0.0010463220532983,1082014363648.0,0.0134132133162218,0.0786161063330727,"/* Copyright 2014-2020 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int table_1_data[] = {1, 3, 1, 2, 3};
int *table_1_ptr = &table_1_data[2];

int table_2_data[] = {2, 6, 5, 8, 13, 21, 34};
int *table_2_ptr = &table_2_data[2];

int
main (void)
{
  *table_1_ptr = 2;
  *table_2_ptr = 3;
  return 0;
}
"
198-690,vlzware/the-c-programming-language-exercises,Chapter_2/2_8/2_8.c,45,2,28,2040512.85982125,211129.0,9.664764196297051,1359.0,1339.0,47749.0,19481.0,1633.0,637.0,1352.0,594.0,1500000000,0.0013603419065475,1082014363648.0,0.0127789171549147,0.0627100996578908,"/*
Exercise 2-8. Write a function rightrot(x,n) that returns the value of the
integer x rotated to the right by n positions.
*/

#include <stdio.h>
#include <limits.h>

int rightrot(unsigned x, int n);
void printBits(size_t const size, void const * const ptr);

int main(void)
{
	unsigned int x;
	x = 52942; //0b1100111011001110
	int n;
	n = 6;

	printf(""original:   "");
	printBits(sizeof(x), &x);
	x = rightrot(x, n);
	printf(""\nafter rotr: "");
	printBits(sizeof(x), &x);

	return 0;
}

int rightrot(unsigned x, int n)
{
	int sz = sizeof(x)*CHAR_BIT;
	if (n > sz) {
		printf(""illegal move\n"");
		return 0;
	}
	return (x >> n) | (x << (sz - n));
}

// print binary
// https://stackoverflow.com/a/3974138/6049386
void printBits(size_t const size, void const * const ptr)
{
    unsigned char *b = (unsigned char*) ptr;
    unsigned char byte;
    int i, j;

    for (i = size - 1; i >= 0; i--)
    {
        for (j = 7; j >= 0; j--)
        {
            byte = (b[i] >> j) & 1;
            printf(""%u"", byte);
        }
    }
    puts("""");
}
"
327-10398,digwiz/Euler,c/problem_nine.c,21,2,15,1930592.93087565,2504978.0,0.7707021778235178,1339.0,1319.0,39186.0,13316.0,1618.0,638.0,1339.0,593.0,1500000000,0.0012870619539171,1082014363648.0,0.0010610871632405,0.0797683897756276,"#include <stdio.h>
#include <math.h>

int main(int argc, char *argv[])
{
  unsigned int i, j, k;
  i = 1;
  
  while (i < 1000)
  {
    j = 1;
    while (j < 1000 - i)
    {
      k = 1000 - i - j;
      if (i * i + j * j == k * k)
      {
	printf(""The product is %d\n"", i*j*k);
	return 0;
      }
      j++;
    }
    i++;
  }
  return 0;
}"
000-12636,vodaben/CSCI4430A1,threadSample/thread.c,30,2,25,15101491788.052956,196735.0,76760.57533229979,1557.0,1525.0,44677.0,16973.0,1665.0,762.0,1369.0,719.0,1500000000,10.067661192035304,1082014363648.0,0.0156657432586982,0.0732360097323601,"#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

//Functions to be ran on thread: pth

void *testFunction(){
	int i;
	for(i=0;i<10;i++){
		sleep(1);
		printf(""Test1 Loop %d\n"", i);
	}
}

//Functions to be ran on thread: pth1

void *testFunction1(){
	int i;
	for(i=0;i<10;i++){
		sleep(1);
		printf(""Test2 Loop %d\n"", i);
	}
}

int main(){
	//Define threads
	pthread_t pth, pth1;
	
	//Create thread -> Start thread
	//If the function is not void, then the create function would return a value
	// depends on the type of the function
	pthread_create(&pth, NULL, testFunction, NULL);
	pthread_create(&pth1, NULL, testFunction1, NULL);

	//Thread join here, afterward return values can be fetched.
	pthread_join(pth, NULL);
	pthread_join(pth1, NULL);

	//Continues

	return 0;
}"
049-14835,hustlijian/oj-jobdu,1064/1064.c,22,4,17,4363042.1860143,242244.0,17.994621125807036,1411.0,1384.0,40813.0,13599.0,1627.0,636.0,1347.0,593.0,1500000000,0.0029086947906762,1082014363648.0,0.0115379534684037,0.0772439902962581,"#include <stdio.h>

int count(int a, int b, int c, int d)
{
	return (1000*a+100*b+10*c+d);
}
int main(int argc, char* argv[])
{
	int i,j,k,m, t;
	freopen(""input.txt"", ""r"", stdin); 
	for (i=1;i<10;i++){
		for (j=0;j<10;j++) {
			for (k=0;k<10;k++) {
				for (m=0;m<10;m++) {
					t = count(i,j,k,m);
					if ((9*t)==count(m,k,j,i)){
						printf(""%d\n"", t);
					}
				}
			}
		}
	}
	return 0;
}"
046-32742,mkosola/sp-rtrace,tests/sp-rtrace.resolve/resolve_test.c,49,2,36,1501829869.695939,170067.0,8830.812967830325,1152.0,1142.0,38683.0,12795.0,1574.0,589.0,1321.0,547.0,1500000000,1.001219913130626,1082014363648.0,0.0134888014723608,0.0783052954660243,"/*
 * This file is part of sp-rtrace package.
 *
 * Copyright (C) 2010,2012 by Nokia Corporation
 *
 * Contact: Eero Tamminen <eero.tamminen@nokia.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */
/**
 * @file memtransfer_test.c
 *
 * Test application for backtrace resolving.
 */
#define _GNU_SOURCE

#include <stdlib.h>
#include <unistd.h>

void zero(void)
{
	void* ptr = malloc(1024);
}

void one(void)
{
	zero();
}

void two(void)
{
	one();
}

void start(void)
{
	two();
}

int main()
{
	start();
	sleep(1);
	return 0;
}

"
318-12384,totalspectrum/binutils-propeller,gdb/testsuite/gdb.base/double-prompt-target-event-error.c,18,1,14,4501973108.737729,170064.0,26472.228737416503,1150.0,1141.0,38683.0,12795.0,1574.0,581.0,1323.0,544.0,1500000000,3.001315405825153,1082014363648.0,0.0134713990027283,0.0781304634989704,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
main (void)
{
  sleep (3);
  return 0; /* after sleep */
}
"
300-28286,dunso/algorithm,C/Tree/LeetCode0315.c,91,3,36,4052377.4223402,180376.0,22.46627600124185,1428.0,1402.0,40900.0,14419.0,1630.0,653.0,1350.0,605.0,1500000000,0.0027015849482268,1082014363648.0,0.015689448707145,0.0766102062582476,"#include <limits.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct segmentTree
{
    int min;
    int max;
    int count;
} segmentTree;

segmentTree *tree;
int min = INT_MAX;
void buildTree(int l, int r, int current)
{
    tree[current].min = l;
    tree[current].max = r;
    tree[current].count = 0;
    if (l == r)
    {
        return;
    }
    int mid = tree[current].min + tree[current].max >> 1;
    buildTree(l, mid, current << 1);
    buildTree(mid + 1, r, current << 1 | 1);
}

int query(int num, int current)
{
    if (num >= tree[current].max)
    {
        return tree[current].count;
    }
    if (num < min)
    {
        return 0;
    }

    if (num <= tree[current].min + tree[current].max >> 1)
    {
        return query(num, current << 1);
    }

    return query(num, current << 1) + query(num, current << 1 | 1);
}

void insert(int num, int current)
{
    if (num < tree[current].min || num > tree[current].max || tree[current].min == tree[current].max)
    {
        return;
    }

    tree[current].count++;

    int mid = tree[current].min + tree[current].max >> 1;

    if (num <= mid)
    {
        insert(num, current << 1);
    }
    else
    {
        insert(num, current << 1 | 1);
    }
}

int *countSmaller(int *nums, int numsSize, int *returnSize)
{
    (*returnSize) = 0;
    int *result = (int *)malloc(sizeof(int *) * numsSize);

    if (numsSize == 0)
    {
        return result;
    }

    int max = INT_MIN;
    min = INT_MAX;

    for (int i = 0; i < numsSize; i++)
    {
        min = min > nums[i] ? nums[i] : min;
        max = max < nums[i] ? nums[i] : max;
    }

    tree = (segmentTree *)malloc(sizeof(segmentTree) * (max - min + 1) * 4);

    buildTree(min, max, 1);

    for (int i = numsSize - 1; i >= 0; i--)
    {
        result[i] = query(nums[i] - 1, 1);
        insert(nums[i], 1);
        (*returnSize)++;
    }
    return result;
}

int main()
{
    int nums[] = {1, 9, 7, 8, 5};

    int *returnSize = malloc(sizeof(int));
    int *result = countSmaller(nums, 5, returnSize);
    for (int i = 0; i < *returnSize; i++)
    {
        printf(""%d "", result[i]);
    }
    system(""pause"");
    return 0;
}
"
170-1696,Medeah/IMPR,l4/grup3.c,7,1,8,1898329.5885846,180669.0,10.507220386452572,1357.0,1335.0,40925.0,14475.0,1628.0,635.0,1349.0,594.0,1500000000,0.0012655530590564,1082014363648.0,0.0149001765659853,0.0759205776173285,"#include <stdio.h>
int main(void){
   int i = 0, power = 1;

   while (++i <= 10) // køre med i = 1:10, altså ti gange
      printf(""%5d"", power *= 2); // starter med at printe 2
   printf(""\n"");

   return 0;
}
"
211-6048,hustlijian/oj-jobdu,1040/1040.c,24,3,16,38989856.9555952,35978667.0,1.0827025359221896,1410.0,1383.0,1428864.0,1012665.0,2328.0,1416.0,1347.0,1345.0,1500000000,0.0259932379703968,1082014363648.0,7.762933518354085e-05,0.0026360530634696,"#include <stdio.h>
#define MAX 10000
int str[10000]={
2,3,5,/* .....*/
};
int isPirme(int k){
	int i;
	for (i=2;i*i<=k;i++){
		if (!(k%i)) return 0;
	}
	return 1;
}

int main(int argc, char* argv[])
{
	int t, i;
	
	freopen(""input.txt"", ""w"", stdout); 
	for (str[0]=2,i=3,t=1;t<MAX;i++){
		if (isPirme(i)){
			str[t++]=i;
		}
	}
	for (i=0; i<MAX; i++) {
		printf(""%d,"", str[i]);
	}
	return 0;
}"
247-20899,iamwrm/coding,16projects/161031_c_vg101_lab4/a2.c,20,2,17,1730012.9402428502,176350.0,9.810104905018427,1304.0,1289.0,40078.0,13694.0,1635.0,638.0,1352.0,595.0,1500000000,0.0011533419601619,1082014363648.0,0.0147037142047065,0.0784795060626348,"#include <stdio.h>
#include <stdlib.h>
char* split(char* a,int len,int deviation){
	char *t;
	t=(char *)malloc(sizeof(char)*len);
	int i;
    a+=deviation;
	for(i=0;i<len;i++) t[i]=a[i];
	return t;
}

int main()
{
	/* code */

	char s[20]=""1234567890123456789"";
	char *aa;

	int i;
	for(i=0;i<4;i++){
	aa=split(s,4,4*i);
    printf(""%s\n"",aa);
}
	return 0;
}
"
225-1069,DeadDork/learning_c,experiments/for_2.c,8,2,9,2411599.27099935,180438.0,13.365250113612433,1347.0,1329.0,40851.0,14400.0,1632.0,635.0,1344.0,593.0,1500000000,0.0016077328473329,1082014363648.0,0.0148305789246167,0.0760891205589039,"// Explores initializing a variable in the first argument of a for loop.

// Conclusion: you've got to be shitting me--this works?!

#include <stdio.h>

int main(void) {
	for (int i = 10; i >= 0; --i)
		printf(""%d "", i);
	putchar('\n');

	return 0;
}
"
151-10655,5604Pocusset/LeetCode,C/13_roman_to_integer.c,41,4,16,2144537.86611555,176281.0,12.165446077569335,1353.0,1331.0,39857.0,13709.0,1625.0,634.0,1346.0,591.0,1500000000,0.0014296919107437,1082014363648.0,0.0152256908004833,0.0783332711048052,"#include <stdio.h>
#include <string.h>

int valueOfSymbol(char c)
{
    switch (c) {
        case 'I': return 1;
        case 'V': return 5;
        case 'X': return 10;
        case 'L': return 50;
        case 'C': return 100;
        case 'D': return 500;
        case 'M': return 1000;
        default: return 0;
    }
    return 0;
}

int romanToInt(char* s) {
    char* c;
    int current_value = 0;
    int big_value = 0;
    int result = 0;
    for (c = s + strlen(s) - 1; c + 1 != s; c--)
    {
        current_value = valueOfSymbol(*c);
        if (current_value >= big_value)
        {
            result += current_value;
            big_value = current_value;
        }
        else
        {
            result -= current_value;
        }
    }
    return result;
}

int main()
{
    printf(""result for %s is %d.\n"", ""MCMLIV"", romanToInt(""MCMLIV""));
    printf(""result for %s is %d.\n"", ""MCMXC"", romanToInt(""MCMXC""));
    printf(""result for %s is %d.\n"", ""MMXIV"", romanToInt(""MMXIV ""));
    
    return 0;
}"
220-2465,mistotebe/examples,c_questions/pointer.c,12,2,9,1734823.4541714,266934.0,6.49907093139128,1344.0,1323.0,58953.0,27867.0,1622.0,699.0,1342.0,656.0,1500000000,0.0011565489694476,1082014363648.0,0.0099912337881274,0.0497466021653996,"#include <stdio.h>

int main()
{
  void *ptr = (void *)0x1;
  while ((ptr = (void *)((long long) ptr << 0x1)))
    printf(""\r!0x%p does not hold"", ptr);
  printf(""\n!0x%p holds\n"", ptr);

  ptr = (void *)0x1;
  while ((ptr = (void *)((long long) ptr << 0x1)) != NULL)
    printf(""\r(0x%p != NULL) does not hold"", ptr);
  printf(""\n(0x%p != NULL) holds\n"", ptr);

  return 0;
}
"
073-24578,jizhouli/code-snippet,base_algo_quick_sort.c,35,5,21,2950359.0194507996,229349.0,12.864058705291937,1376.0,1352.0,51537.0,20423.0,1646.0,643.0,1365.0,600.0,1500000000,0.0019669060129672,1082014363648.0,0.0118945362744114,0.0591161756531406,"#include <stdio.h>

#include <time.h>
#include <stdlib.h>

void quick_sort(int s[], int l, int r)
{
    if (l >= r)
        return;
    printf(""pivot: %d (%d, %d)\n"", s[l], l, r);

    int i = l, j = r, x = s[l];
    while(i < j)
    {
        while (i<j && x<=s[j]) j--;
        if (i < j)
            s[i++] = s[j];

        while (i<j && s[i]<x) i++;
        if (i < j)
            s[j--] = s[i];
    }
    s[i] = x;
    quick_sort(s, l, i-1);
    quick_sort(s, i+1, r);
}

int main(int argc, char* argv[])
{
    srand(time(NULL));
    printf(""hello world\r\n"");

    int iArr[20];
    for(int i=0; i<20; i++)
    {
        iArr[i] = rand()%100;
        printf(""%d "", iArr[i]);
    }

    printf(""\nquick sort\n"");
    quick_sort(iArr, 0, 19);
    for (int i=0; i<20; i++)
        printf(""%d "", iArr[i]);
    printf(""\ndone\n"");
}
"
128-11510,lolosssss/leetcode,c/83_remove_duplicates_from_sorted_list.c,79,3,44,2161871.99112015,182029.0,11.876519675436333,1369.0,1346.0,41288.0,14543.0,1634.0,640.0,1352.0,597.0,1500000000,0.0014412479940801,1082014363648.0,0.014915205818853,0.0756389819276029,"/**
 * Description : Remove Duplicates from Sorted List
 *               Given a sorted linked list, delete all duplicates such that
 *               each element appear only once.
 * Author      : Evan Lau
 * Date        : 2016/04/09
 */

#include <stdio.h>
#include <stdlib.h>

struct ListNode {
    int val;
    struct ListNode *next;
};

struct ListNode* deleteDuplicates(struct ListNode* head)
{
    struct ListNode *ptr = head;
    struct ListNode *tmp = head;

    if (head == NULL)
    {
        return NULL;
    }

    ptr = ptr->next;

    while (ptr)
    {
        if (tmp->val == ptr->val)
        {
            tmp->next = ptr->next;
            free(ptr);
        }
        else
        {
            tmp = ptr;
        }
        ptr = tmp->next;
    }

    return head;
}

struct ListNode* createList(int* arr, int len)
{
    struct ListNode* ptr = NULL;
    struct ListNode* head = NULL;
    struct ListNode* tmp = NULL;

    if (len == 0)
    {
        return NULL;
    }

    ptr = (struct ListNode *)malloc(sizeof(struct ListNode));
    ptr->val = arr[0];
    ptr->next = NULL;
    head = ptr;
    tmp = ptr;

    for (int i = 1; i < len; i++)
    {
        ptr = (struct ListNode *)malloc(sizeof(struct ListNode));
        ptr->val = arr[i];
        ptr->next = NULL;
        tmp->next = ptr;
        tmp = ptr;
    }

    return head;
}

void printList(struct ListNode* head)
{
    struct ListNode* ptr = head;

    while (ptr)
    {
        printf(""%d -> "", ptr->val);
        ptr = ptr->next;
    }
    printf(""NULL\n"");
}

int main(void)
{
    int arr[5] = {1, 1, 2, 3, 3};
    struct ListNode* head = NULL;

    head = createList(arr, 5);
    printList(head);
    deleteDuplicates(head);
    printList(head);

    return 0;
}
"
192-10002,zxombie/aarch64-freebsd-binutils,gdb/testsuite/gdb.python/py-objfile-script.c,30,1,17,1388358.18506775,169061.0,8.209421451428774,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0009255721233785,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2011-2014 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

struct ss
{
  int a;
  int b;
};

void
init_ss (struct ss *s, int a, int b)
{
  s->a = a;
  s->b = b;
}

int
main ()
{
  struct ss ss;

  init_ss (&ss, 1, 2);

  return 0;      /* break to inspect struct and union */
}
"
351-17280,ComputationWithBoundedResources/ara-inference,doc/tpdb_trs/C/AProVE_memory_alloca/svcomp_genady_true-alloca.c,8,1,13,1446828.24611655,169080.0,14.14477762006151,1142.0,1132.0,38460.0,12696.0,1566.0,584.0,1317.0,544.0,1500000000,0.0009645521640777,1082014363648.0,0.0134492547906316,0.0784072249589491,"#include <stdlib.h>

int main() {
    int* i = alloca(sizeof(int));
    int* j = alloca(sizeof(int));
    *j = 1;
    for (*i = 10000; *i - *j >= 1; (*i)--) {
        (*j)++;
    }
}"
230-27625,DestructHub/ProjectEuler,Problem005/C/solution_1.c,17,2,13,2752264.6123542,14973127.0,0.2034621759369302,1340.0,1320.0,41175.0,1015305.0,3660.0,537886.0,1341.0,125844.0,1500000000,0.0018348430749028,1082014363648.0,0.0001776516021002,0.6329802741178252,"#include <stdio.h>
// Author: tkovs
// Used lua solution that uses python solution XD

int main(void) {
    int k, i = 1, j;

    for (k = 1; k <= 20; k++) {
        if (i % k > 0) {
            for (j = 1; j <= 20; j++) {
                if ((i * j) % k == 0) {
                    i = i * j;
                    break;
                }
            }
        }
    }

    printf (""%d"", i);

    return 0;
}"
269-32268,Sylverant/pso_patcher,img-enc/bin2c.c,49,3,24,1719904.7142639002,178586.0,9.62712082694052,1301.0,1279.0,40815.0,13947.0,1660.0,637.0,1377.0,595.0,1500000000,0.0011466031428426,1082014363648.0,0.014446821139395,0.0779555165991015,"/* Converts a binary file into a C integer array (for inclusion in
   a source file)

   (c)2000 Dan Potter

*/

#include <stdio.h>

void convert(char *ifn, char *ofn, char *prefix) {
    FILE *i, *o;
    unsigned char buffer[2048];
    int red, left, lc, q;
    char buf[BUFSIZ];

    i = fopen(ifn, ""rb"");
    o = fopen(ofn, ""w"");

    if(!i || !o) {
        printf(""error: can't open input or output file\n"");
        return;
    }

    fseek(i, 0, SEEK_END);
    left = ftell(i);
    fseek(i, 0, SEEK_SET);
    setbuf(o, buf);

    fprintf(o, ""const int %s_size = %d;\n"", prefix, left);
    fprintf(o, ""const unsigned char %s_data[%d] ="", prefix, left);
    fprintf(o, ""{\n\t"");

    lc = 0;

    while(left > 0) {
        red = fread(buffer, 1, 2048, i);
        left -= red;

        for(q = 0; q < red; q++) {
            fprintf(o, ""0x%02x, "", buffer[q]);

            if((++lc) >= 8) {
                lc = 0;
                fprintf(o, ""\n\t"");
            }
        }
    }

    fprintf(o, ""\n};\n"");
    fclose(i);
    fclose(o);
}

int main(int argc, char **argv) {

    char *prefix;

    argc--;

    if(argc != 2 && argc != 3) {
        printf(""usage: bin2c <input> <output> [prefix]\n"");
        return 0;
    }

    prefix = (argc == 3) ? argv[3] : ""file"";
    convert(argv[1], argv[2], prefix);
    return 0;
}

"
229-21322,JonArnfred/Euler,Euler4/euler4.c,29,2,18,67312299.04107735,629621814.0,0.1069090960688982,1362.0,1342.0,113405595.0,99456329.0,1628.0,700.0,1345.0,658.0,1500000000,0.0448748660273849,1082014363648.0,4.2946415449322405e-06,2.034652284736466e-05,"#include<stdlib.h>
#include<stdio.h>

#define ENOUGH ((999 * sizeof(int) - 1) / 3 + 2)

void checkForPalindrome(int);

int largestPalindrome = 0;
int testNumber = 0;
char str[ENOUGH];
int strEnd = 5;
int strStart = 0;


int main(void){

	for(int i = 99; i < 999; i++){
		for(int a = 99; a < 999; a++){
			testNumber = a * i;
			checkForPalindrome(testNumber);
		}
	}
	printf(""this is maybe the largest? %d"", largestPalindrome);
}



void checkForPalindrome(int number){

	//puts the int in an array of chars 
	sprintf(str, ""%d"", number);
	
	if(str[strStart]==str[strEnd]){
		if(str[strStart+1]==str[strEnd-1]){

			if(str[strStart+2]==str[strEnd-2]){
				printf(""palindrome: %d"", number);
				if(number > largestPalindrome){
					largestPalindrome = number;
				}
			}
		}
	}
}
"
312-13565,8l/scc,cc1/tests/test054.c,19,2,11,2242532.79156975,169103.0,13.261337764557696,1142.0,1132.0,38466.0,12697.0,1569.0,585.0,1318.0,546.0,1500000000,0.0014950218610465,1082014363648.0,0.0134474255335505,0.0785333150909837,"/* See LICENSE file for copyright and license details. */

/*
name: TEST054
description: Basic test for initializer
error:
TODO
output:

*/

struct S { int a; int b; };
struct S *s = &(struct S) { 1, 2 };

int
main()
{
	if(s->a != 1)
		return 1;
	if(s->b != 2)
		return 2;
	return 0;
}

"
208-16904,tendoasan/ProgrammingInC,chapter08/exce4.c,22,1,16,2148289.8155226,206890.0,10.383725651312291,1436.0,1410.0,46602.0,18309.0,1634.0,644.0,1352.0,601.0,1500000000,0.0014321932103484,1082014363648.0,0.013756102276572,0.0651815562847591,"// ¹Û²ìguessµÄÊÕÁ²ËÙ¶È¡¢µü´úÔËÐÐµÄ´ÎÊý¡¢ÐèÒª¼ÆËãÆ½·½¸ùµÄÊý×Ö£¬ÒÔ¼°×î³õµÄ²Â²âÖµÖ®¼äµÄ¹ØÏµ
// ¼ÆËãµÄÊý×ÖÔ½´ó£¬µü´úµÄ´ÎÊýÔ½¶à£¬ÊÕÁ²µÃÔ½¿ì£¬Óë×î³õ²Â²âÖµ¹ØÏµ²»´ó¡£ 
#include <stdio.h>

float absoluteValue(float x){
	if(x < 0)
		x = -x;
	return (x);
} 

// ¼ÆËãÄ³ÊýÆ½·½¸ùµÄº¯Êý
float squareRoot(float x, float epsilon){
	float guess = 1.0;
	
	while(absoluteValue(guess * guess - x) >= epsilon){
		guess = (x / guess + guess) / 2.0;
		printf(""%.3f\n"", guess);
	}
		
	return guess;
} 

int main(void){
	printf(""squareRoot(2.0) = %f\n"", squareRoot(2.0, 0.00001));
	printf(""squareRoot(144.0) = %f\n"", squareRoot(144.0, 0.00001));
	printf(""squareRoot(17.5) = %f\n"", squareRoot(17.5, 0.00001));
	
	return 0;
}
"
031-12718,fengyc/c-primer-plus-5th-code,other/sort/select_sort.c,34,3,23,2329533.10478475,181317.0,12.847846589122918,1352.0,1332.0,41011.0,14449.0,1630.0,637.0,1350.0,593.0,1500000000,0.0015530220698565,1082014363648.0,0.0148028039290303,0.0759105661738189,"//
// Created by fengyc on 2017/5/2.
//

#include <stdio.h>

// 选择排序

void select_sort(int *a, int a_len)
{
    for (int i=0; i<a_len; i++)
    {
        // 找本轮最小
        int min = a[i];
        int min_pos = i;
        for (int j=i+1; j<a_len; j++)
        {
            if (a[j] < min)
            {
                min = a[j];
                min_pos = j;
            }
        }
        // 交换
        a[min_pos] = a[i];
        a[i] = min;
    }
}

int main(void)
{
    int a[] = {9, 7, 3, 4, 6, 2, 0, 11, 5, 10, 1};

    select_sort(a, 11);

    for (int i= 0; i<11; i++) {
        printf(""%d "", a[i]);
    }
    printf(""\n"");
    return 0;
}"
188-4550,totalspectrum/binutils-propeller,gdb/testsuite/gdb.base/sss-bp-on-user-bp-2.c,23,1,14,1611272.8044389999,169063.0,9.530601018555211,1139.0,1129.0,38452.0,12696.0,1568.0,584.0,1318.0,544.0,1500000000,0.001074181869626,1082014363648.0,0.0134151174414271,0.0784781418628294,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

static void
test (void)
{
  label: asm (""  nop""); label2: asm (""  nop""); /* must be a single line */
}

int
main (void)
{
  test ();
  return 0;
}
"
160-8463,phaziz/NothingButC,2017-02-10-Kopfgesteuerte-While-Schleife-3.c,15,1,12,1861712.89533375,178373.0,10.437184999971969,1251.0,1238.0,40508.0,13939.0,1608.0,601.0,1333.0,560.0,1500000000,0.0012411419302225,1082014363648.0,0.0139539055798803,0.0753393208073906,"/*
    Kopfgesteuerte Schleife WHILE
*/

# include <stdio.h>

int main ( void )
{
    setbuf( stdout, NULL ); // Ausgabepuffer ausschlaten

    int zahl = 1, zaehler = 1;

    while( zahl < 100 )
    {
        printf( ""\n\t\t>>> %d) Summe %d <<<\n"", zaehler, zahl );    
        zahl = zahl + ( zahl * 2 );
        zaehler++;
    }

    return 0;
}"
316-9581,Kannagi/SNES-Mode7,main.c,35,2,22,2382903.1269996,175062.0,13.611766117147068,1280.0,1260.0,39816.0,13572.0,1633.0,640.0,1358.0,597.0,1500000000,0.0015886020846664,1082014363648.0,0.0145091453313683,0.0791938263280137,"#include <stdlib.h>
#include <stdio.h>
#include <math.h>


int main(int argc, char** argv)
{
    int i;

    FILE *file;
    file = fopen(""main.smc"",""rb+"");

    if(file == NULL) return 0;

    fseek(file,0x8000*4,SEEK_SET);

    float zoom = 0x340;
    float sub;
    int byte[0x200];
    float div = zoom*0.024; //0.024 = angle
    int ozoom;
    float pr,tzoom = zoom;

    for(i = 0; i < 0x80;i++) //0x80 (128 lines)
    {
        sub = zoom/div;

        pr = ((float)zoom/tzoom);

        byte[i] = zoom;

        ozoom = zoom;
        fputc(ozoom&0xFF,file);
        fputc((ozoom>>8)&0xFF,file);
        //printf(""$%x %f \n"",ozoom,pr);

        zoom -= (sub  *pr);
    }

    

    fclose(file);

    file = fopen(""m7.bin"",""wb"");
    for(i = 0; i < 0x100;i++)
    {
        ozoom = byte[i];
        fputc(ozoom&0xFF,file);
        fputc((ozoom>>8)&0xFF,file);
    }

    fclose(file);

    return 0;
}
"
271-10922,IAmRasputin/euler,9/c/triplet.c,22,1,15,9233962.74447435,102499008.0,0.0900883060253617,1338.0,1318.0,39185.0,13306.0,1620.0,636.0,1342.0,593.0,1500000000,0.0061559751629829,1082014363648.0,2.59124459038667e-05,0.0798422586729153,"#include <stdio.h>

int is_triplet(int a, int b, int c)
{
	return  0 < a && 
		a < b && 
		b < c && 
		a*a + b*b == c*c;
}

int main(void)
{
	int a = 1, b = 2, c = 3;

	while (a + b + c != 1000 || !is_triplet(a, b, c)) {
		if (++a >= b) {
			a = 1;
			if (++b >= c) {
				b = 2;	       
				c++;
			}
		}
	}

	printf(""%llu\n"", a * b * c);

	return 0;
}
"
115-4775,RishiRamraj/range_n,src/c/benchmark.c,11,1,10,1462356.0709878001,169083.0,8.64874647362538,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0009749040473252,1082014363648.0,0.0134490161636592,0.0785049652044725,"#include <stdlib.h>

#define LENGTH 10000000

int main() {
  // Allocate the memory.
  int * buffer = malloc(LENGTH * sizeof(int));

  // Seed the memory.
  for (int index = 0; index < LENGTH; index++) {
    buffer[index] = index;
  }

  // Free the memory.
  free (buffer);

  return 0;
}
"
324-35035,augustosoares/sudoku,sudoku.c,84,9,35,18693091.347813603,45970722.0,0.4066303548593385,1427.0,1405.0,6991428.0,964307.0,1638.0,680.0,1358.0,611.0,1500000000,0.0124620608985424,1082014363648.0,6.160442727003504e-05,0.0005388565607074,"#include <stdio.h>
#include <stdlib.h>

#define UNASSIGNED 0
#define N 9
#define TRUE 1
#define FALSE 0

int grid[N][N] = {{8, 0, 0, 0, 0, 0, 0, 0, 0},
                     {0, 0, 3, 6, 0, 0, 0, 0, 0},
                     {0, 7, 0, 0, 9, 0, 2, 0, 0},
                     {0, 5, 0, 0, 0, 7, 0, 0, 0},
                     {0, 0, 0, 0, 4, 5, 7, 0, 0},
                     {0, 0, 0, 1, 0, 0, 0, 3, 0},
                     {0, 0, 1, 0, 0, 0, 0, 6, 8},
                     {0, 0, 8, 5, 0, 0, 0, 1, 0},
                     {0, 9, 0, 0, 0, 0, 4, 0, 0}};

int SOLVE_SUDOKU(int grid[N][N]);

int FIND_UNASSIGNED(int grid[N][N],int *row,int *col);

int IS_SAFE(int grid[N][N], int row, int col, int num);

int USED_IN_LINE(int grid[N][N], int row, int col, int num);

int USED_IN_COLUMN(int grid[N][N], int row, int col, int num);

int USED_IN_BOX(int grid[N][N], int star_row, int start_col, int num);

void PRINT_GRID(int grid[N][N]);

int main(){

	SOLVE_SUDOKU(grid);
	PRINT_GRID(grid);
    
    return 0;
}

int FIND_UNASSIGNED(int grid[N][N],int *row,int *col){
	int r = *row, c = *col;

	for (r = 0; r < N; r++)
        for (c = 0; c < N; c++){
        	if (grid[r][c] == UNASSIGNED){
            	*row = r;
            	*col = c;
            	return TRUE;
            }
        }

    return FALSE;
}

int USED_IN_LINE(int grid[N][N], int row, int col, int num){

	for(col = 0; col < N; col++){
		if(grid[row][col] == num)
			return TRUE;
	}

	return FALSE;
}

int USED_IN_COLUMN(int grid[N][N], int row, int col, int num){

	for(row = 0; row < N; row++){
		if(grid[row][col] == num)
			return TRUE;
	}

	return FALSE;
}

int USED_IN_BOX(int grid[N][N], int star_row, int start_col, int num){
	int row, col;

	for (row = 0; row < 3; row++)
        for (col = 0; col < 3; col++)
            if (grid[row+star_row][col+start_col] == num)
                return TRUE;

    return FALSE;
}

int IS_SAFE(int grid[N][N], int row, int col, int num){
	if(USED_IN_LINE(grid,row,col,num) == FALSE &&  USED_IN_COLUMN(grid,row,col,num) == FALSE && USED_IN_BOX(grid,row - row%3,col - col%3,num) == FALSE )
			return TRUE;

    return FALSE;
}

void PRINT_GRID(int grid[N][N]){
	int row, col;

	system(""clear"");
    for (row = 0; row < N; row++){
       for (col = 0; col < N; col++)
            printf(""%2d"", grid[row][col]);
        printf(""\n"");
    }
}

int SOLVE_SUDOKU(int grid[N][N]){

	int row, col, num;

	if(FIND_UNASSIGNED(grid,&row,&col) == FALSE)
		return TRUE;

	for(num = 1; num <= N; num++){
		if(IS_SAFE(grid,row,col,num) == TRUE){
			grid[row][col] = num;
			//PRINT_GRID(grid);

			if(SOLVE_SUDOKU(grid) == TRUE)
				return TRUE;

			grid[row][col] = UNASSIGNED;
		}
	}

	return FALSE;
}
"
341-27930,csampez/analisis-numerico-computo-cientifico,MNO/entrega_tareas_de_C/tarea4/124960/T4_1_a.c,18,1,14,1649673.0968355,175928.0,15.315731435587283,1358.0,1334.0,39860.0,13686.0,1628.0,637.0,1346.0,595.0,1500000000,0.001099782064557,1082014363648.0,0.0153017143376835,0.0785492847271504,"#include<stdio.h>
#include<string.h>
#define MAX_LONG 200
#define CADENA_PRUEBA ""Hola a todos""
int longitud_string(char *s){
    int i;
    i=0;
    while(s[i] != '\0')
        i++;
        s=s+1;
return i;
}

int main(void){
    char string1[] = CADENA_PRUEBA; //definición y declaracion de variable e inicializacion.
    char string2[MAX_LONG]; //definición y declaracion.
    printf(""cadena: %s\n"", string1);
    printf(""longitud cadena: %d\n"", longitud_string(string1));
    strcpy(string2, ""leer libros y revistas""); //inicializacion de string2
    printf(""cadena2: %s\n"", string2);
    printf(""longitud cadena: %d\n"", longitud_string(string2));
return 0;
}
"
222-1714,kujenga/euler,Euler_12/TriangleNum.c,24,2,20,160049275.49511194,541756370.0,0.2954266601424548,1337.0,1318.0,39179.0,13309.0,1618.0,638.0,1339.0,593.0,1500000000,0.1066995169967413,1082014363648.0,4.900726871010303e-06,0.0797896662094193,"#include <stdio.h>
#include <stdlib.h>

int triangleNumRec (int which)
{
  if (which == 0) return 0;
  else return which + triangleNumRec(which-1);
}

int divisors(int n)
{
  int d = 0;
  for ( int i=1; i*i < n; i++ ){
    if ( n % i == 0 ) d++;
  }
  //printf(""n:%4i d:%3i  "",n,d*2);
  return 2*d;
}

int main(int argc, char** argv)
{
  int i = 1;
  int n = 0;
  while ( divisors(n) < 500 ) {
    n+=i;
    i++;
  }
  printf(""\nresult: %i\n"",n);
}
"
069-12001,xitkov/projecteuler,other-lang/c/prob0021.c,24,4,14,196452530.9158488,750185135.0,0.2618720644204713,1341.0,1319.0,50115578.0,23389.0,771022.0,1278.0,1354.0,1130.0,1500000000,0.1309683539438992,1082014363648.0,3.5457913998789117e-06,0.0154527316049411,"#include <stdio.h>

#define N 10000

int main()
{
	int i, j, sum[N], s;
	
	for(i = 1; i < N; i++)
	{
		sum[i] = 0;
		for(j = 1; j < i; j++)
		{
			if(!(i % j))
			sum[i] += j;
		}
	}
	
	s = 0;
	for(i = 1; i < N; i++)
	{
		for(j = i + 1; j < N; j++)
		{
			if(i == sum[j] && j == sum[i])
				s = s + i + j;
		}
	}
	
	printf(""\nSum is %d"",s);
	return 0;
}"
099-16423,chrismoulds/Misc.-Projects,projecteuler/C/problem1.c,18,1,16,3424580.9074491,182576.0,18.757010779072825,1335.0,1316.0,39180.0,13310.0,1618.0,636.0,1340.0,593.0,1500000000,0.0022830539382994,1082014363648.0,0.0145199807203575,0.0797675747761478,"/*
* Project Euler Problem #1:
* If we list all the natural numbers below 10 that are multiples of 3 or 5, 
* we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all 
* the multiples of 3 or 5 below 1000.
* 
* Author: Chris Moulds
*/


#include <stdio.h>

int main()
{

	int sum = 3;

	for (int i=5; i<1000; i++){
		if (i%3 == 0 || i%5 == 0)
			sum+=i;
	}

	printf(""SUM: %d\n"", sum);
	
	return 0;
}
"
246-6000,jasonleaster/CSAPP,lab4/cacheExperiment.c,22,3,20,27296004.001982402,14647563.0,1.8635184569610657,1159.0,1150.0,5281750.0,5255714.0,2623105.0,2622038.0,263469.0,262691.0,1500000000,0.0181973360013216,1082014363648.0,0.0001576371441447,0.5476937335207029,"#include <stdio.h>

int src[2048][2048];
int dst[2048][2048];

/* Copies the contents of one 2048-by-2048 array (src) into another (dst). */
//int main(int argc, char* argv[])
int main()
{
	// declare all variables before the code (conform to an older C standard...)
	int rep;
	int i, j;

	for ( rep = 0; rep < 10; rep++ )
	{
		for ( i = 0; i < 2048; i++ )
		{
			for ( j = 0; j < 2048; j++ )
			{
				//src[i][j] = i * rep;
				dst[i][j] = src[i][j];
			}
		}
	}

	return 0;
}
"
139-22327,fatimarafiqui/DataStructures,LinkList/CommonNode.c,51,2,31,1989829.5868188,175419.0,11.344284256551456,1350.0,1331.0,39784.0,13639.0,1626.0,640.0,1346.0,595.0,1500000000,0.0013265530578792,1082014363648.0,0.0152834071565793,0.0787488534900698,"#include <stdio.h>
#include <stdlib.h>
struct node 
{
	int data;
	int status;
	struct node *next;
};
 
void checkcommonnode(struct node *h1, struct node *h2)
{
	int flag=0;
	while (h1!=NULL)
	{
		h1->status=1;
		h1=h1->next;
	}
 
	while(h2!=NULL)
	{
		if(h2->status==1)
		{
			flag=1;
			printf(""Common node found\n"");
		    printf(""%d\n"",h2->data);
		    return;
		}
		h2 = h2->next;
	}
	if(flag==0)
	printf(""Common node NOT found\n"");
}
 
 
 
int main(void) 
{
	struct node *head1 = (struct node*)malloc(sizeof(struct node));
	head1->data = 5;
	head1->status=0;
	struct node *head2 = (struct node*)malloc(sizeof(struct node));
	head2->data = 3;
	head2->status=0;
	struct node *new_node1 = (struct node*)malloc(sizeof(struct node));
	new_node1->data = 10;
	new_node1->status=0;
	head1->next = new_node1;
	struct node *new_node2 = (struct node*)malloc(sizeof(struct node));
	new_node2->data = 15;
	new_node2->status=0;
	new_node2->next = NULL;
	head1->next->next = new_node2;
	head2->next=new_node2;
	checkcommonnode(head1,head2);
	head2->next=NULL;
	checkcommonnode(head1,head2);
 
    return 0;
}
 
"
213-16016,fatimarafiqui/DataStructures,LinkList/RecursiveIntersection.c,67,2,36,1975652.994588,183775.0,10.747979866684805,1359.0,1337.0,41656.0,14877.0,1634.0,640.0,1353.0,596.0,1500000000,0.001317101996392,1082014363648.0,0.0146701129098081,0.0746997328993685,"#include <stdio.h>
#include <stdlib.h>
struct node
{
	int data;
	struct node *next;
};
struct node *head3 = NULL;
 
void insert(struct node **head_ref, int new_data)
 {
 	struct node *new_node = (struct node*)malloc(sizeof(struct node));
 	struct node *last= *head_ref;
 
 	new_node->data = new_data;
 	new_node->next = NULL;
 
 	if(*head_ref == NULL)
 	{
 		*head_ref = new_node;
 		return;
 	}
    while (last->next != NULL)
   		last = last->next;
 
    last->next = new_node;
    return;
 }
 
void display (struct node *node)
 {
 	while(node!=NULL)
 	 {
 	 	printf(""%d  "", node-> data);
 	 	node= node->next;
 	 }
 	 printf(""\n"");
 }
 
 
struct node* intersection(struct node *head1, struct node *head2)
{   
 
	int match;
	if(head1==NULL || head2==NULL)
	return NULL;
 
	if(head1->data < head2->data)
	intersection(head1->next,head2);
 
	if(head1->data > head2->data)
	intersection(head1,head2->next);
 
	if(head1->data == head2->data)
	{
		match = head1->data;
		printf(""%d\n"",match);
		insert(&head3,match);
		intersection(head1->next,head2->next);
	}
 
 
    return head3;
}
 
int main(void) 
{
	struct node *head1 = NULL;
	struct node *head2 = NULL;
 
 
	int count1,count2,count;
 
    insert(&head1, 5);
    insert(&head1, 10);
    insert(&head1, 15);
    insert(&head2, 6);
    insert(&head2, 10);
    insert(&head2, 15);
    insert(&head2, 25);
    head3 = intersection(head1, head2);
    display(head1);
    display(head2);
    display(head3);
 
	return 0;
}
"
055-20586,AndrewLaing/CHowToProgramExercises,Various/reverseString.c,25,1,21,1905363.05308335,175398.0,10.86308281736394,1329.0,1309.0,39735.0,13581.0,1627.0,637.0,1347.0,593.0,1500000000,0.0012702420353889,1082014363648.0,0.0150400802745755,0.0788506264535974,"/*
 * Filename:    reverseString.c
 * Author:      Andrew Laing
 * Email:       parisianconnections@gmail.com
 * Date:        25/06/2017.
 */
 
 
#include <stdio.h>
#include <string.h>

                    
void reverse( char []);

/* reverse a string in place */
void reverse( char s[])
{   
    int c, i, j;
    for(i=0, j=strlen(s)-1; i<j; i++, j--) {
        c = s[i];
        s[i] = s[j];
        s[j] = c;
    }
}


int main()
{
    char word[] = ""forwards"";
    
    printf(""word = %s\n"", word);
    reverse(word);  
    printf(""word = %s\n"", word);
    
    return 0;
}


"
375-4008,Skar0/itr,tp5_2.c,56,5,28,2848864.64942235,197608.0,14.416744261365936,1561.0,1532.0,45387.0,16797.0,1700.0,795.0,1393.0,753.0,1500000000,0.0018992430996149,1082014363648.0,0.0156522003157766,0.074633346198379,"#include <stdio.h>
#include <pthread.h>

int matrice[10][4]=	{8, 25, 3, 41, 
			11, 18, 3, 4,
			4, 15, 78, 12,
			1, 12, 0, 12, 
			7, 9, 13, 15,
			4, 21, 37, 89,
			1, 54, 7, 3, 
			15, 78, 7, 1,
			12, 15, 13, 47,
			91, 13, 72, 90};
                    
int vecteur[4]=		{1, 2, 3, 4};

int resultat[10] = {0,0,0,0,0,0,0,0,0,0}; //c'est une col résultat
pthread_mutex_t mutex;
void computeVector(int arg) {
    
    printf(""\n SALUT ------\n"");
    int i = 0;
    while(i<10) {
        pthread_mutex_lock(&mutex);
        resultat[i] = resultat[i] + matrice[i][arg]*vecteur[arg];
        pthread_mutex_unlock(&mutex);
        i++;
    }
    /*
     i=0;
    while(i<10) {
        printf(""\n%d"", resultat[i]);
        i++;
    }
    */
}

int main() {
   if( pthread_mutex_init(&mutex, NULL) < 0) {
    perror(""ERROR INITIALISING MUTEX"");
   }
    int i = 0;
    pthread_t thread_ids[4];
    while (i<4) {
        if( pthread_create(&thread_ids[i], NULL, &computeVector, i) < 0) {
                perror(""ERROR CREATING THE THREAD"");
        }
        i++;
    }

    i =0;
    while( i < 4) {
        if( pthread_join(thread_ids[i], NULL) < 0 ) {
            perror(""ERROR JOINING"");
        }
        i++;
    }
   // sleep(5);
    i=0;
    while(i<10) {
        printf(""\n%d"", resultat[i]);
        i++;
    }
}"
359-22399,matir8/SoftUni-C-Programming,02.C-Data-Types/BankAccount.c,31,1,18,1434842.8230732,180046.0,7.969307843551093,1472.0,1445.0,40667.0,14223.0,1646.0,640.0,1359.0,597.0,1500000000,0.0009565618820488,1082014363648.0,0.0162014151938948,0.0772818364000728,"
#include <stdio.h>

/*
 * A bank account has a holder name (first name, middle name and last name),
 * available amount of money (balance),bank name, IBAN and 3 credit card 
 * numbers associated with the account. Declare the variables needed to keep
 * the information for a single bank account using the appropriate data
 * types and descriptive names.
 */
int main() 
{
    char firstName[] = ""Iordan"";
    char middleName[] = ""Iordanov"";
    char lastName[] = ""Iordanov"";
    long double balance = 123.8965;
    char bankName[] = ""DSK Bank"";
    char IBAN[] = ""BG80 BNBG 9888 7420 3456 78 "";
    unsigned long firstCardNum = 12325455234;
    unsigned long secondCardNum = 89516648536;
    unsigned long thirdCardNum = 56987456215;
    
    printf(""Bank: %s\n"", bankName);
    printf(""Account holder name: %s %s %s\nIBAN: %s\n"",
            firstName, 
            middleName,
            lastName,
            IBAN);
    printf(""Balance: %.5Lf\n"", balance);
    printf(""Credit card numbers: %Ld, %Ld, %ld\n"", 
            firstCardNum, 
            secondCardNum,
            thirdCardNum);
    
    return 0;
}
"
137-15572,swigger/gdb-ios,gdb/testsuite/gdb.base/annota-input-while-running.c,18,1,14,7502223736.373708,170060.0,44115.15780312831,1150.0,1141.0,38683.0,12795.0,1575.0,581.0,1324.0,544.0,1500000000,5.001482490915805,1082014363648.0,0.0134717158649888,0.0781693150472046,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2016 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <unistd.h>

int
main (void)
{
  sleep (5);
  return 0; /* set break here */
}
"
058-33847,456789123/Carbonization_Campaign,Experimentos/curva.c,37,2,19,1829507.8771188,234875.0,7.789279403938265,1341.0,1321.0,51193.0,21334.0,1620.0,643.0,1342.0,601.0,1500000000,0.0012196719180792,1082014363648.0,0.011333688131985,0.0579921960097618,"#include <stdio.h>
#include <stdlib.h>


typedef struct sample_s
{
	int ppm;
	int mv;
} sample_t;

sample_t curve[] = {  { 10000, 265 },
					  { 8000, 268 },
					  { 6000, 274 },
					  { 4000, 281 },
					  { 3000, 288 },
					  { 2000, 293 },
					  { 1500, 298 },
					  { 1000, 303 },
					  { 800, 307 },
					  { 600, 314 },
					  { 400, 324 } };


size_t nsamples = sizeof( curve ) / sizeof( sample_t );


int main( int argc, char * argv[] )
{
	int i = 0;
	int j = 0;
	int k = 0;

	for( i = 0; i < nsamples - 1; i++ )
	{
		int ppm0 = curve[i+1].ppm;
		int ppm = curve[i].ppm;
		int mv0 = curve[i].mv;
		int mv = curve[i+1].mv;

		int diffppm = ppm0 - ppm;
		int diffmv = mv0 - mv;

		int step = (diffppm / diffmv);

		for( j = mv0, k = ppm; j < mv; j++, k-=step  )
			printf(""%d;%d\n"", j, k );
	}

	return 0;
}

/* eof */
"
186-14933,EmbracoIT/hello-world,hello-world.c,11,1,13,2270372.9337081,175738.0,12.91907271051224,1354.0,1333.0,39799.0,13684.0,1626.0,638.0,1345.0,594.0,1500000000,0.0015135819558054,1082014363648.0,0.0152898064163698,0.078585718826543,"#include <stdio.h>

int main(int argc, char const *argv[]) {
   int i;

   printf(""Hello, World!\n\n"");

   /* Loops and prints the parameters passed */
   printf(""argc: %d\n"", argc);

   for (i=0; i<argc; i++) {
      printf(""argv[%d] value: %s\n"", i, argv[i]);
      printf(""argv[%d] address: %d\n"", i, *argv[i]);
   }

   return 0;
}
"
234-7071,freecores/eco32,monitor/monitor/kbdtbls/mkkbdtbls.c,157,8,36,2051027.9573499,706764.0,2.901996989093955,1379.0,1357.0,162321.0,101035.0,1655.0,693.0,1367.0,649.0,1500000000,0.0013673519715666,1082014363648.0,0.0038711649150211,0.0165707255578,"/*
 * mkkbdtbls.c -- construct keyboard translation tables
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct {
  unsigned char ascii;
  unsigned char key;
} Entry;


Entry tbl1[] = {
  { 0x1B, 0x76 },
  { '1',  0x16 },
  { '2',  0x1E },
  { '3',  0x26 },
  { '4',  0x25 },
  { '5',  0x2E },
  { '6',  0x36 },
  { '7',  0x3D },
  { '8',  0x3E },
  { '9',  0x46 },
  { '0',  0x45 },
  { '^',  0x0E },
  { 0x08, 0x66 },
  { 0x09, 0x0D },
  { 'q',  0x15 },
  { 'w',  0x1D },
  { 'e',  0x24 },
  { 'r',  0x2D },
  { 't',  0x2C },
  { 'z',  0x35 },
  { 'u',  0x3C },
  { 'i',  0x43 },
  { 'o',  0x44 },
  { 'p',  0x4D },
  { '\r', 0x5A },
  { ' ',  0x29 },
  { 'a',  0x1C },
  { 's',  0x1B },
  { 'd',  0x23 },
  { 'f',  0x2B },
  { 'g',  0x34 },
  { 'h',  0x33 },
  { 'j',  0x3B },
  { 'k',  0x42 },
  { 'l',  0x4B },
  { 'y',  0x1A },
  { 'x',  0x22 },
  { 'c',  0x21 },
  { 'v',  0x2A },
  { 'b',  0x32 },
  { 'n',  0x31 },
  { 'm',  0x3A },
  { ',',  0x41 },
  { '.',  0x49 },
  { '-',  0x4A },
  { '+',  0x5B },
  { '#',  0x5D },
  { '<',  0x61 },
};


Entry tbl2[] = {
  { 0x1B, 0x76 },
  { '!',  0x16 },
  { '""',  0x1E },
  { '3',  0x26 },
  { '$',  0x25 },
  { '%',  0x2E },
  { '&',  0x36 },
  { '/',  0x3D },
  { '(',  0x3E },
  { ')',  0x46 },
  { '=',  0x45 },
  { '^',  0x0E },
  { 0x08, 0x66 },
  { 0x09, 0x0D },
  { 'Q',  0x15 },
  { 'W',  0x1D },
  { 'E',  0x24 },
  { 'R',  0x2D },
  { 'T',  0x2C },
  { 'Z',  0x35 },
  { 'U',  0x3C },
  { 'I',  0x43 },
  { 'O',  0x44 },
  { 'P',  0x4D },
  { '\r', 0x5A },
  { ' ',  0x29 },
  { 'A',  0x1C },
  { 'S',  0x1B },
  { 'D',  0x23 },
  { 'F',  0x2B },
  { 'G',  0x34 },
  { 'H',  0x33 },
  { 'J',  0x3B },
  { 'K',  0x42 },
  { 'L',  0x4B },
  { 'Y',  0x1A },
  { 'X',  0x22 },
  { 'C',  0x21 },
  { 'V',  0x2A },
  { 'B',  0x32 },
  { 'N',  0x31 },
  { 'M',  0x3A },
  { ';',  0x41 },
  { ':',  0x49 },
  { '_',  0x4A },
  { '*',  0x5B },
  { '\'',  0x5D },
  { '>',  0x61 },
};


int main(void) {
  unsigned char codes[256];
  int i, j;

  for (i = 0; i < 256; i++) {
    codes[i] = '\0';
  }
  for (i = 0; i < sizeof(tbl1)/sizeof(tbl1[0]); i++) {
    codes[tbl1[i].key] = tbl1[i].ascii;
  }
  printf("";\n"");
  printf(""; keyboard code tables\n"");
  printf("";\n"");
  printf(""\n"");
  printf(""\t.export\txltbl1\n"");
  printf(""\t.export\txltbl2\n"");
  printf(""\n"");
  printf(""\t.code\n"");
  printf(""\t.align\t4\n"");
  printf(""\n"");
  printf(""xltbl1:\n"");
  for (i = 0; i < 32; i++) {
    printf(""\t.byte\t"");
    for (j = 0; j < 8; j++) {
      printf(""0x%02X"", codes[i * 8 + j]);
      if (j < 7) {
        printf("", "");
      }
    }
    printf(""\n"");
  }
  printf(""\n"");
  for (i = 0; i < 256; i++) {
    codes[i] = '\0';
  }
  for (i = 0; i < sizeof(tbl2)/sizeof(tbl2[0]); i++) {
    codes[tbl2[i].key] = tbl2[i].ascii;
  }
  printf(""xltbl2:\n"");
  for (i = 0; i < 32; i++) {
    printf(""\t.byte\t"");
    for (j = 0; j < 8; j++) {
      printf(""0x%02X"", codes[i * 8 + j]);
      if (j < 7) {
        printf("", "");
      }
    }
    printf(""\n"");
  }
  return 0;
}
"
277-28581,HenrikSamuelsson/Programming-in-C,Exercises/Chapter_10/Exercise_03/exercise_10_03.c,43,2,25,2060419.18136175,177863.0,11.58430364943805,1347.0,1327.0,40326.0,13992.0,1631.0,639.0,1351.0,595.0,1500000000,0.0013736127875745,1082014363648.0,0.0150340430556102,0.0776169962075186,"/*
 * exercise_10_03.c
 */

#include <stdio.h>

struct entry
{
	int value;
	struct entry *next;
};

void insertEntry(struct entry *newEntry, struct entry *existingEntry)
{
	newEntry->next = existingEntry->next;
	existingEntry->next = newEntry;
}

int main (void)
{
	void insertEntry(struct entry *newEntry, struct entry *existingEntry);

	struct entry head, n1, n2, nE;
	struct entry *listPointer;

	head.next = &n1;

	n1.value = 100;
	n1.next = &n2;

	n2.value = 200;
	n2.next = (struct entry *) 0;	// mark list end with null pointer

	listPointer = head.next;

	printf(""Values in the list before insert of new entry: "");
	while ( listPointer != (struct entry *) 0 )
	{
			printf (""%i "", listPointer->value);
			listPointer = listPointer->next;
	}
	printf(""\n"");

	nE.value = 50;
	insertEntry(&nE, &head);

	listPointer = head.next;

	printf(""Values in the list after insert of new entry: "");
	while ( listPointer != (struct entry *) 0 )
	{
		printf (""%i "", listPointer->value);
		listPointer = listPointer->next;
	}
	printf(""\n"");

	return 0;
}
"
184-1866,abondar24/SomeC,linux_sysprog/affinity/cpu_affinity.c,18,1,13,2812384.51134405,1188491.0,2.3663485882518254,1360.0,1334.0,240505.0,151748.0,1643.0,702.0,1356.0,657.0,1500000000,0.0018749230075627,1082014363648.0,0.002266739924829,0.0111101763402701,"//
// Created by abondar on 2/16/17.
//

#define _GNU_SOURCE

#include <sched.h>
#include <stdio.h>

int main(void) {

    cpu_set_t set;
    int ret, i;

    CPU_ZERO(&set);
    ret = sched_getaffinity(0, sizeof(cpu_set_t), &set);
    if (ret == -1) {
        perror(""sched_getaffinity"");
    }

    for (int i = 0; i < CPU_SETSIZE; i++) {
        int cpu;
        cpu = CPU_ISSET(i, &set);
        printf(""cpu=%i is %s\n"", i, cpu ? ""set"" : ""unset"");
    }

    return 0;
}"
358-32653,SanDisk-Open-Source/SSD_Dashboard,uefi/gcc/gcc-4.6.3/gcc/testsuite/gcc.target/mips/pr33755.c,27,1,19,1591952.86687455,169091.0,9.414764830771595,1143.0,1133.0,38462.0,12697.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010613019112497,1082014363648.0,0.0134602078170925,0.0785003616177016,"/* { dg-do link } */
/* { dg-options ""-O2"" } */

volatile int gv;
const char *ptrs[2];

void
foo (volatile int *v, const char **ptrs)
{
  switch (*v & 1)
    {
    case 0:
      ptrs[0] = 0;
      break;
    case 1:
      break;
    default:
      ptrs[1] = ""Some text"";
      break;
    }
  while (*v > 0)
    *v -= 1;
}

int
main (void)
{
  foo (&gv, ptrs);
  return 0;
}
"
047-23130,ComputationWithBoundedResources/ara-inference,doc/tpdb_trs/C_Integer/Stroeder_15/GopanReps-CAV2006-Fig1a_true-termination.c.c,24,1,17,1583103.3233553,169077.0,9.363207296084031,1139.0,1129.0,38453.0,12696.0,1566.0,585.0,1316.0,546.0,1500000000,0.0010554022155702,1082014363648.0,0.0134140066360297,0.0784570568339557,"/*
 * Program from Fig.1a of
 * 2006CAV - Gopan,Reps - Lookahead Widening
 *
 * Date: 2014-06-22
 * Author: Caterina Urban, Matthias Heizmann
 *
 */

typedef enum {false, true} bool;

extern int __VERIFIER_nondet_int(void);

int main() {
    int x, y;
	x = 0;
    y = 0;
	while (y >= 0) {
		if (x <= 50) {
			y = y + 1;
		} else {
			y = y - 1;
		}
		x = x + 1;
	}
	return 0;
}
"
213-960,MicroTrustRepos/microkernel,src/l4/pkg/valgrind/src/valgrind-3.6.0-svn/drd/tests/pth_detached.c,67,3,30,1515582099.0912616,489627.0,3095.3809716375936,1454.0,1411.0,128729.0,69247.0,3278.0,3968.0,1523.0,2909.0,1500000000,1.010388066060841,1082014363648.0,0.0058513929991605,0.0589869479128783,"/* Test whether detached threads are handled properly. */

#include <assert.h>
#include <limits.h>  /* PTHREAD_STACK_MIN */
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

static int s_finished_count;
static pthread_mutex_t s_mutex;
static pthread_cond_t s_cond;

static void increment_finished_count()
{
  pthread_mutex_lock(&s_mutex);
  s_finished_count++;
  pthread_cond_signal(&s_cond);
  pthread_mutex_unlock(&s_mutex);
}

static void* thread_func1(void* arg)
{
  write(STDOUT_FILENO, ""."", 1);
  increment_finished_count();
  return 0;
}

static void* thread_func2(void* arg)
{
  pthread_detach(pthread_self());
  write(STDOUT_FILENO, ""."", 1);
  increment_finished_count();
  return 0;
}

int main(int argc, char** argv)
{
  const int count1 = argc > 1 ? atoi(argv[1]) : 100;
  const int count2 = argc > 2 ? atoi(argv[2]) : 100;
  int i;
  int detachstate;
  pthread_attr_t attr;

  pthread_mutex_init(&s_mutex, 0);
  pthread_cond_init(&s_cond, 0);

  pthread_attr_init(&attr);
  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
  assert(pthread_attr_getdetachstate(&attr, &detachstate) == 0);
  assert(detachstate == PTHREAD_CREATE_DETACHED);
  pthread_attr_setstacksize(&attr, PTHREAD_STACK_MIN + 4096);
  // Create count1 detached threads by setting the ""detached"" property via
  // thread attributes.
  for (i = 0; i < count1; i++)
  {
    pthread_t thread;
    pthread_create(&thread, &attr, thread_func1, NULL);
  }
  // Create count2 detached threads by letting the threads detach themselves.
  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
  assert(pthread_attr_getdetachstate(&attr, &detachstate) == 0);
  assert(detachstate == PTHREAD_CREATE_JOINABLE);
  for (i = 0; i < count2; i++)
  {
    pthread_t thread;
    pthread_create(&thread, &attr, thread_func2, NULL);
  }
  pthread_attr_destroy(&attr);

  // Wait until all detached threads have written their output to stdout.
  pthread_mutex_lock(&s_mutex);
  while (s_finished_count < count1 + count2
         && pthread_cond_wait(&s_cond, &s_mutex) == 0)
    ;
  pthread_mutex_unlock(&s_mutex);

  pthread_cond_destroy(&s_cond);
  pthread_mutex_destroy(&s_mutex);

  sleep(1);

  write(STDOUT_FILENO, ""\n"", 1);

  return 0;
}
"
153-1877,emersonp/psu-c,feng/asg5.c,95,8,33,747914651.9908681,1891435846.0,0.395421633031692,1350.0,1331.0,126123484.0,126097831.0,1629.0,637.0,1349.0,595.0,1500000000,0.4986097679939121,1082014363648.0,1.4174416783258957e-06,1.6691689994558946e-05,"#include <stdio.h>

#define SIZE 200
#define MAX 2000000
#define rdtsc(low,high) __asm__ __volatile__ (""rdtsc"" : ""=a"" (low), ""=d"" (high))

typedef struct {int lo,hi;} longpair;
typedef union { longpair ll; long long t; } timestamp;

typedef float v4sf __attribute__ ((vector_size(16)));

union f4vector {
    v4sf v;
    float f[4];
};

typedef int v4si __attribute__ ((vector_size(16)));

union i4vector {
    v4si v;
    int i[4];
};

int main() {
	float f;
	int cnt, factor, thresh[SIZE];
    int done;
	timestamp a, b, c, d;

  	rdtsc(a.ll.lo,a.ll.hi);
  	for (factor = 2; factor < SIZE; factor++) {
        thresh[factor]=0;
   		cnt = 2;
		done = 0;
		while (!done && (cnt < MAX)) {
			f = (float) cnt * factor;
			f = f / factor;
			if (f != (float) cnt) {
				done = 1;
				thresh[factor] = cnt;
				break;
			}
			cnt++;
		}
  	}

  	rdtsc(b.ll.lo,b.ll.hi);
  	c.t = b.t-a.t;
  	/*
    for (factor = 2; factor < SIZE; factor++)
		printf(""[%3d]=%8d  "",factor,thresh[factor]);
	printf(""\n""); 
    */
  	
    printf(""\n\n\nVECTOR\n\n\n"");

	// VECTOR IMPLEMENTATION HERE
    union f4vector vectorCheck;
    union i4vector vectorCount;

  	rdtsc(a.ll.lo, a.ll.hi);

  	for (factor = 2; factor < SIZE; factor++) {
        float flFactor = (float) factor;

        thresh[factor] = 0;
   		cnt = 2;
        done = 0;

        vectorCount.i[0] = 2;
        vectorCount.i[1] = 3;
        vectorCount.i[2] = 4;
        vectorCount.i[3] = 5;

		while (!done && vectorCount.i[0] < MAX) {
            vectorCheck.f[0] = vectorCount.i[0];
            vectorCheck.f[1] = vectorCount.i[1];
            vectorCheck.f[2] = vectorCount.i[2];
            vectorCheck.f[3] = vectorCount.i[3];

            vectorCheck.v = vectorCheck.v * flFactor;
            vectorCheck.v = vectorCheck.v / flFactor;

            if (vectorCheck.f[0] != vectorCount.i[0]) {
                done = 1;
                thresh[factor] = vectorCount.i[0];
                break;
            }
            if (vectorCheck.f[1] != vectorCount.i[1]) {
                done = 1;
                thresh[factor] = vectorCount.i[1];
                break;
            }
            if (vectorCheck.f[2] != vectorCount.i[2]) {
                done = 1;
                thresh[factor] = vectorCount.i[2];
                break;
            }
            if (vectorCheck.f[3] != vectorCount.i[3]) {
                done = 1;
                thresh[factor] = vectorCount.i[3];
                break;
            }

            vectorCount.v += 4;
		}
  	}

  	rdtsc(b.ll.lo, b.ll.hi);

  	/*
    for (factor = 2; factor < SIZE; factor++)
		printf(""[%3d]=%8d  "",factor,thresh[factor]);
	printf(""\n""); 
    */

    d.t = b.t - a.t;
    printf(""Cycles elapsed for scalar implementation: t=%llu \n"", c.t);
    printf(""Cycles elapsed for vector implementation: t=%llu \n"", d.t);

	return 0;
}
"
270-6345,JJ/2016-ea-languages-wcci,c/bitflip.c,18,3,12,18018375.0344439,93156264.0,0.1933166512560014,1361.0,1337.0,27101892.0,10163898.0,54093.0,2211.0,1371.0,1523.0,1500000000,0.0120122500229626,1082014363648.0,2.8962088904724645e-05,0.0015885346855655,"#include <stdio.h>
#include <stdlib.h>
#include <time.h>

const unsigned ITERATIONS = 100000;
const unsigned LENGTH	 =  65536;

int main()
{
	for (unsigned length = 16; length <= LENGTH; length <<= 1)
	{
		struct timespec start, stop;
		char bits[length];

		for (unsigned i = 0; i < length; i++ )
			bits[i] = rand() & 1;

		clock_gettime(CLOCK_REALTIME, &start);

		for (unsigned i = 0; i < ITERATIONS; ++i)
			bits[rand() & (length - 1)] ^= 1;

		clock_gettime(CLOCK_REALTIME, &stop);

		printf(""C-char[], %u, %ld\n"", length, (stop.tv_sec - start.tv_sec) * 1000000000 + (stop.tv_nsec - start.tv_nsec));
	}

	return 0;
}
"
327-28921,totalspectrum/binutils-propeller,gdb/testsuite/gdb.linespec/thread.c,24,1,22,1422228.0588,169083.0,8.411419243803339,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0009481520392,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2012-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* http://sourceware.org/bugzilla/show_bug.cgi?id=14643 */

static void
thread ()
{
}

int
main ()
{
  int x = 0;
  thread (); /* set breakpoint 1 here */
  return x;
}
"
367-20909,AndrewLaing/CHowToProgramExercises,Chapter5/ex05_38.c,49,4,34,14569089.1658886,84749595.0,0.1719074763720109,1539.0,1507.0,16221832.0,11585709.0,1646.0,726.0,1360.0,666.0,1500000000,0.0097127261105924,1082014363648.0,3.59411747041387e-05,0.0001581585369234,"/*
 * Filename:    ex05_38.c
 * Author:      Andrew Laing
 * Email:       parisianconnections@gmail.com
 * Date:        04/05/2017
 */

#include <stdio.h>


int fibonacciNR( int );
double fibonacciDubs( double );

int main()
{
    int i;
    
    for(i=1; i<49; i++) {
        printf(""fibonacciNR(%d) = %d\n"", i, fibonacciNR(i));
    }
        
    for(i=1; i<1479; i++) {
        printf(""fibonacciDubs(%d) = %.0f\n"", i, fibonacciDubs(i));
    }  

    return 0;
}


/* Non-recursive fibonacci function */
int fibonacciNR( int num )
{
    int a=0, b=1;
    int fib=1;
    
    int i;
    
    if(num==1)
        return 0;
        
    for(i=2; i<num; i++) {
        fib = a+b;
        a = b;
        b = fib; 
    }
    
    return fib;
}

/* Non-recursive fibonacci function */
double fibonacciDubs( double num )
{
    double a=0, b=1;
    double fib=1;
    
    int i;
    
    if(num==1)
        return 0;
        
    for(i=2; i<num; i++) {
        fib = a+b;
        a = b;
        b = fib; 
    }
    
    return fib;
}

"
018-20920,mattstock/binutils-bexkat1,gdb/testsuite/gdb.python/py-pp-registration.c,42,1,22,1575647.96973015,169087.0,9.31855790214505,1142.0,1132.0,38460.0,12696.0,1567.0,584.0,1317.0,544.0,1500000000,0.0010504319798201,1082014363648.0,0.0134486980075345,0.0784267730080538,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2010-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <string.h>

struct function_lookup_test
{
  int x,y;
};

void
init_flt (struct function_lookup_test *p, int x, int y)
{
  p->x = x;
  p->y = y;
}

struct s
{
  int a;
  int *b;
};

void
init_s (struct s *s, int a)
{
  s->a = a;
  s->b = &s->a;
}

int
main ()
{
  struct function_lookup_test flt;
  struct s s;

  init_flt (&flt, 42, 43);
  init_s (&s, 1);
  
  return 0;      /* break to inspect */
}
"
354-13613,MingfeiPan/The-C-Programming-Language-Practice,chp3/3_4.c,28,2,19,3246559.4122185004,175897.0,18.457159587713264,1339.0,1319.0,39873.0,13605.0,1641.0,646.0,1357.0,601.0,1500000000,0.002164372941479,1082014363648.0,0.0151111161645735,0.0793784359923707,"#include <stdio.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>

#define MAXLINE 1024

void reverse(char *s){
    int i,j,k;
    j = strlen(s) - 1;
    for (i = 0; i<j;i++){
    	k = s[i];
	s[i] = s[j];
	s[j--] = k;
    }
}
void itoa(int n, char *s){
    int i,sign;
    sign = n;
    do{
    	s[i++] = abs(n % 10) + '0'; //try 48 later
    }while( n /= 10);
    if(sign < 0){
    	s[i++] = '-';
    }
    s[i] = '\0';
    reverse(s);
}

int main(){
    char result[MAXLINE];
    itoa(INT_MIN, result);
    printf(""%d\n"", INT_MIN);
    printf(""%s\n"", result);
    return 0;
};
"
260-34521,chuncky/nuc970kernel,applications/demos/thread/ex6.c,53,2,30,23022368.7831312,802314.0,28.6949598286955,1575.0,1478.0,202363.0,123286.0,1747.0,2687.0,1398.0,2640.0,1500000000,0.0153482458554208,1082014363648.0,0.0038052433336573,0.026015740874377,"#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>

void *
test_thread (void *v_param)
{
  return NULL;
}
void *
test_demo (void * count)
{
//printf(""pthread[%d]\n"",count);
  return NULL;
}

int
main (void)
{
  unsigned long count;

  setvbuf (stdout, NULL, _IONBF, 0);

  for (count = 0; count < 200; ++count)
    {
      pthread_t thread;
      int status;

      status = pthread_create (&thread, NULL, test_thread, NULL);
      if (status != 0)
	{
	  printf (""status = %d, count = %lu: %s\n"", status, count,
		  strerror (errno));
	  return 1;
	}
      else
	{
	  printf (""count = %lu\n"", count);
	}
      /* pthread_detach (thread); */
      pthread_join (thread, NULL);
      sched_yield();
      //usleep (10);
    }

{
    pthread_t *thread_ = (pthread_t *)malloc(sizeof(pthread_t) * 100);
    for (count = 0; count < 100; ++count)
    	{
	    	int status;

  	      status = pthread_create (&(thread_[count]), NULL, test_demo, (void *)count);
	      if (status != 0)
		{
			  printf (""status = %d, count = %lu: %s\n"", status, count, strerror (errno));
			  printf (""System can only create more than %d threads within one process.\n"", count + 2);
			  return 1;
		}
	      
    	}
    free(thread_);
}
  return 0;
}
"
122-29047,Etiene/Algorithm-Implementations,Fibonacci_series/C/harshasrisri/fibo_r.c,11,1,11,2237374.42865955,185771.0,12.043720494587422,1341.0,1321.0,41967.0,15222.0,1620.0,636.0,1342.0,594.0,1500000000,0.0014915829524397,1082014363648.0,0.0143294701541144,0.073300809596251,"#include<stdio.h>

int fibo_r () {
	static int a = 0, b = 1, count = 0;

	if (0 == count) { count++; return a; }
	if (1 == count) { count++; return b; }
	return (b>a) ? (a += b) : (b += a);
}

int main (int argc, char **argv) {
	int count = 20;
	if (argv[1]) count = atoi(argv[1]);
	while (count--) printf (""%d\n"", fibo_r());
}
"
337-9742,arante/cloc,c-htp/ch06/fig06_06.c,17,1,15,1876037.9170998,174022.0,10.780458792566456,1338.0,1318.0,39433.0,13398.0,1627.0,635.0,1345.0,594.0,1500000000,0.0012506919447332,1082014363648.0,0.0152624380825412,0.0795177074066362,"/*
 * fig06_06.c
 * Computing sum of elements in an array.
 *
 * Written by Billy Wilson Arante <arantebillywilson@gmail.com>
 * Last updated on 2017/12/14 PHT
 */

#include <stdio.h>
#define SIZE 12

int main(void) {
        int arr[SIZE] = {1, 3, 5, 4, 7, 2, 99, 16, 45, 67, 89, 45};
        int counter;
        int sum = 0;

        for (counter = 0; counter < SIZE; counter++) {
                sum += arr[counter];
        }

        printf(""Total is %d\n"", sum);

        return 0;
}
"
210-11266,Bomfim/Algorithm-Analisis,Trabalho1/quick.c,41,5,26,3657110.9667419996,9856377.0,0.3710399876141101,1374.0,1349.0,1863196.0,1189168.0,2886.0,1352.0,1372.0,1195.0,1500000000,0.002438073977828,1082014363648.0,0.0002762678416217,0.0022294195580867,"#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define TAM 10000 // Declara o tamanho do vetor;

void quickSort(int *vetor, int esq, int dir) {
        int i, j, x, y;

        i = esq;
        j = dir;
        x = vetor[(esq + dir) / 2];

        while(i <= j) {
                while(vetor[i] < x && i < dir) {
                        i++;
                }
                while(vetor[j] > x && j > esq) {
                        j--;
                }
                if(i <= j) {
                        y = vetor[i];
                        vetor[i] = vetor[j];
                        vetor[j] = y;
                        i++;
                        j--;
                }
        }

        if(j > esq) {
                quickSort(vetor, esq, j);
        }
        if(i < dir) {
                quickSort(vetor, i, dir);
        }
}

int main(int argc, char const *argv[]) {

        int vetor[TAM];
        int i;

        srand(time(NULL));
        for (i=0; i < TAM; i++)
                vetor[i] = (rand() % 10000) + 1;  // Preenche o vetor com valores aleatórios;

        quickSort(vetor, 0, TAM - 1); // Chama a função de Ordenação;

        
           printf(""\n\n"");
           for (i=0; i < TAM; i++)    {
           printf("" %d,"",vetor[i]);
           }
           printf(""\n\n "");
         
        return 0;
}
"
130-6710,anshbansal/general,C/project_euler/001_050/010.c,27,3,20,13294447.56265725,42973333.0,0.3093650427347583,1341.0,1320.0,2040102.0,7673345.0,34093.0,2691734.0,1841.0,31275.0,1500000000,0.0088629650417715,1082014363648.0,6.192212272666865e-05,0.2840333611744626,"/**
The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.

Find the sum of all the primes below two million.
*/
#include<stdio.h>
#include<stdlib.h>

#define NUMBERS 2000000
int main()
{
    char flag[NUMBERS];

    register int i;
    long long int sum = 0;

    for (i = 0; i < NUMBERS; i++)
        flag[i] =  'a'; //unchecked or prime

    for (i = 2; i < NUMBERS; i++)
    {
        if (flag[i] == 'a')
        {
            sum += i;

            int mul_factor = 2;
            while ( (i * mul_factor) < NUMBERS )
            {
                flag[i * mul_factor] = 'b';
                mul_factor++;
            }
        }
    }
    printf(""%lld"", sum);
    return 0;
}
"
323-26798,wcnnbdk1/hello_world,CLearning/stringANDarray01.c,13,2,16,2031693.00220905,175525.0,11.57494943740208,1334.0,1315.0,39922.0,13649.0,1629.0,638.0,1349.0,594.0,1500000000,0.0013544620014727,1082014363648.0,0.0150918672553767,0.0785872953650295,"#include <stdio.h>
int main()
{
    char a[] = ""I am a boy."", b[20];
    int i;
    for(i=0; *(a+i)!='\0'; i++)
        *(b+i)=*(a+i);
    *(b+i)='\0';
    printf(""string a is : %s \n"", a);
    printf(""string b is :"");
    for(i=0; *(b+i)!='\0'; i++)
        printf(""%c"", b[i]);
    return 0;
}
"
045-365,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.base/sizeof.c,98,1,32,1787013.0250229998,183225.0,9.753106835857553,1359.0,1337.0,41309.0,14887.0,1626.0,650.0,1347.0,607.0,1500000000,0.001191342016682,1082014363648.0,0.0147141492700231,0.075272261370916,"#include <stdio.h>

typedef char padding[16];

struct {
  padding p1;
  char v;
  padding p2;
} padding_char;

struct {
  padding p1;
  short v;
  padding p2;
} padding_short;

struct {
  padding p1;
  int v;
  padding p2;
} padding_int;

struct {
  padding p1;
  long v;
  padding p2;
} padding_long;

struct {
  padding p1;
  long long v;
  padding p2;
} padding_long_long;

struct {
  padding p1;
  float v;
  padding p2;
} padding_float;

struct {
  padding p1;
  double v;
  padding p2;
} padding_double;

struct {
  padding p1;
  long double v;
  padding p2;
} padding_long_double;

static void
fill (void *buf, long sizeof_buf)
{
  char *p = buf;
  int i;
  for (i = 0; i < sizeof_buf; i++)
    p[i] = ""The quick brown dingo jumped over the layzy dog.""[i];
}

void
fill_structs (void)
{
  fill (&padding_char.p1, sizeof (padding));
  fill (&padding_char.v, sizeof (padding_char.v));
  fill (&padding_char.p2, sizeof (padding));

  fill (&padding_short.p1, sizeof (padding));
  fill (&padding_short.v, sizeof (padding_short.v));
  fill (&padding_short.p2, sizeof (padding));

  fill (&padding_int.p1, sizeof (padding));
  fill (&padding_int.v, sizeof (padding_int.v));
  fill (&padding_int.p2, sizeof (padding));

  fill (&padding_long.p1, sizeof (padding));
  fill (&padding_long.v, sizeof (padding_long.v));
  fill (&padding_long.p2, sizeof (padding));

  fill (&padding_long_long.p1, sizeof (padding));
  fill (&padding_long_long.v, sizeof (padding_long_long.v));
  fill (&padding_long_long.p2, sizeof (padding));

  fill (&padding_float.p1, sizeof (padding));
  fill (&padding_float.v, sizeof (padding_float.v));
  fill (&padding_float.p2, sizeof (padding));

  fill (&padding_double.p1, sizeof (padding));
  fill (&padding_double.v, sizeof (padding_double.v));
  fill (&padding_double.p2, sizeof (padding));

  fill (&padding_long_double.p1, sizeof (padding));
  fill (&padding_long_double.v, sizeof (padding_long_double.v));
  fill (&padding_long_double.p2, sizeof (padding));
}

int
main ()
{
  fill_structs ();

  printf (""sizeof (char) == %d\n"", (int) sizeof (char));
  printf (""sizeof (short) == %d\n"", (int) sizeof (short));
  printf (""sizeof (int) == %d\n"", (int) sizeof (int));
  printf (""sizeof (long) == %d\n"", (int) sizeof (long));
  printf (""sizeof (long long) == %d\n"", (int) sizeof (long long));

  printf (""sizeof (void *) == %d\n"", (int) sizeof (void*));
  printf (""sizeof (void (*)(void)) == %d\n"", (int) sizeof (void (*)(void)));

  printf (""sizeof (float) == %d\n"", (int) sizeof (float));
  printf (""sizeof (double) == %d\n"", (int) sizeof (double));
  printf (""sizeof (long double) == %d\n"", (int) sizeof (long double));

  /* Signed char?  */
  printf (""valueof ('\\377') == %d\n"", '\377');
  printf (""valueof ((int) (char) -1) == %d\n"", (int) (char) -1);
  printf (""valueof ((int) (signed char) -1) == %d\n"", (int) (signed char) -1);
  printf (""valueof ((int) (unsigned char) -1) == %d\n"", (int) (unsigned char) -1);

  return 0;
}
"
189-24700,Boshin/workspace,algorithms/palindrome/main.c,34,2,24,1810308.0801664502,174504.0,10.374020079768943,1343.0,1324.0,39451.0,13478.0,1619.0,636.0,1341.0,593.0,1500000000,0.0012068720534443,1082014363648.0,0.0152833172878558,0.0791437586200381,"#include <stdio.h>
#include <string.h>

void palindrome()
{
	static char* str = ""([{}()])\0"";
	// static char* str = ""xyzyx\0"";
	char arr[10] = { 0 };
	int len = strlen(str);
	int next =0, top = 0, mid = len / 2 - 1;
	
	if (len % 2 != 0) {
		next = mid + 2;

	} else {
		next = mid + 1;
	}
	
	printf(""len: %d, mid: %d, next: %d\n"", len, mid, next);

	for (int i = 0; i <= mid; ++i) {
		arr[top++] = str[i];
	}
	--top;
	int ret = 0;

	for (int j = next; j < len; ++j, --top) {
		if (str[j] != arr[top]) {
			ret = 0;
			break;
		}
		else {
			ret = 1;
		}
	}

	printf(""ret: %d\n"", ret);
}

int main(int argc, char* argv[])
{
	palindrome();
	return 0;
}
"
361-34953,azri-azhar/college,c/Berpaut.c,49,1,22,1791003.16017855,175497.0,10.20531974905554,1353.0,1335.0,39806.0,13649.0,1626.0,636.0,1347.0,593.0,1500000000,0.0011940021067857,1082014363648.0,0.0153165011367715,0.0786081751005518,"/* Cipta Senarai, Jejak, dan Selit dalam Senarai Berpaut (Linked List) */

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

typedef struct nod {
	int data;
	struct nod *next;
} NOD, *NODPTR;

void CiptaSenarai(NODPTR *s)
{
	*s = NULL;
}

NODPTR NodBaru(int m)
{
	NODPTR n;
		
		n = (NODPTR) malloc(sizeof(NOD));
	
		if(n != NULL) {
		n -> data = m;
		n -> next = NULL;
}

return n;
}

void SelitSenarai (NODPTR *s, NODPTR t, NODPTR p)
{
	if (p==NULL) {
		t -> next = *s;
		*s = t;
	}

	else {
		t -> next = p -> next;
		p ->next = t;
	}
}

void JejakSenarai (NODPTR s)
{
	NODPTR ps;
	for (ps = s; ps != NULL; ps = ps -> next)
		printf(""%d -->"", ps -> data);
		printf(""NULL\n"");
}

int main ()
{
	NODPTR pel;
	NODPTR n;

	CiptaSenarai(&pel);
	n = NodBaru(55);
	SelitSenarai(&pel, n, NULL);
	n= NodBaru(75);
	SelitSenarai(&pel, n, NULL);
	JejakSenarai(pel);

	return 0;
}
"
262-12756,Gurgel100/gcc,libgomp/testsuite/libgomp.c-c++-common/depend-mutexinout-1.c,20,2,14,1821046.3458672,169061.0,10.771532168862128,1139.0,1129.0,38452.0,12696.0,1568.0,584.0,1318.0,544.0,1500000000,0.0012140308972448,1082014363648.0,0.0134152761429306,0.0784781418628294,"int
main ()
{
  int a, b, c, d;
  #pragma omp parallel num_threads (6)
  #pragma omp single
  {
    #pragma omp task depend(out: c)
      c = 1;
    #pragma omp task depend(out: a)
      a = 2;
    #pragma omp task depend(out: b)
      b = 3;
    /* The above 3 tasks can be scheduled in any order.  */
    #pragma omp task depend(in: a) depend(mutexinoutset: c)
      c += a;
    #pragma omp task depend(in: b) depend(mutexinoutset: c)
      c += b;
    /* The above 2 tasks are mutually exclusive and need to wait
       for the first and second or first and third tasks respectively.  */
    #pragma omp task depend(in: c)
      d = c;
    /* The above task needs to wait for the mutexinoutset tasks.  */
  }
  if (d != 6)
    __builtin_abort ();
  return 0;
}
"
387-27087,totalspectrum/binutils-propeller,gdb/testsuite/gdb.base/jit-simple-dl.c,19,1,14,1232058.0426603,169061.0,7.285151513359083,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0008213720284402,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2016-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* A stub program that links with a simple library that uses the JIT
   API.  */

int
main (void)
{
  return 0;
}
"
141-26244,ibnIrshad/knr-exercises,ch4/4-13_recursive-reverse.c,40,1,24,1728303.03199575,176960.0,9.766630877034356,1334.0,1315.0,40049.0,13872.0,1627.0,635.0,1349.0,592.0,1500000000,0.0011522020213305,1082014363648.0,0.0149694846292947,0.0779473674449657,"#include <stdio.h>
#include <string.h>

/* The C Programming Language: 2nd Edition
 *
 * Exercise 4-13: Write a recursive version of the function reverse(s), which
 * reverses the string `s` in place.
 *
 * Answer: Much like the last exercise, the trick is in terminating your flow
 * early and resetting state for the next string.
 */

void reverse(char[]);

int main() {
	char foo[40] = ""Learning C is fun and challenging."";
	printf(""Before: %s\n"", foo);
	reverse(foo);
	printf("" After: %s\n"", foo);
	/* I don't know how to set a char array to another string... */
	char bar[30] = ""Hello out there!"";
	printf(""Before: %s\n"", bar);
	reverse(bar);
	printf("" After: %s\n"", bar);
	return 0;
}

void reverse(char s[]) {
	static int i = 0;
	static int j = 0;
	int c;

	if (j == 0) {
		j = strlen(s) - 1;
	}

	if (i < j) {
		c = s[i];
		s[i] = s[j];
		s[j] = c;
		i++;
		j--;
		reverse(s);
		return;
	}
	i = 0;
	j = 0;
}
"
176-32321,byt3smith/euler-solutions,C/euler5.c,26,2,17,1578390124.3703444,8302766287.0,0.1901041254733803,1343.0,1323.0,39197.0,13314.0,1619.0,637.0,1341.0,594.0,1500000000,1.0522600829135629,1082014363648.0,3.210978013646213e-07,0.0798118489459351,"// Project Euler: #5
// <byt3smith>

#include <stdio.h>

// main function to iter over 1-10;


int findRem(int curnum)
{
        for (double i=1; i<21; i++) {
                double result = curnum / i;
                if ( result == (int)result ) {
                }
		else {
			return 0;
		}
        }
	return curnum;

}


int main()
{
	for (int i=2520; i<990000000; i++) {
		// printf(""Current number: %d\n"", i);
		int x = findRem(i);
		if ( x != 0 ) {
			printf(""Found it! Smallest num that can be divided by 1-20 with 0 remainder is: %d\n"", i);
			break;
		}
	}
}
"
185-16961,Stevendeo/Pilat,tests/pilat/cohencu.c,14,1,12,2230792.5391941,169083.0,13.193473028039485,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0014871950261294,1082014363648.0,0.0134490161636592,0.0785049652044725,"/*run.config
   OPT: -pilat-degree 2 -pilat-lin
*/

int main(){
  int N,n,x,y,z;

    n=0;   x=0;   y=1;   z=6;

    while( n<=N )
        {

        n=n+1;
        x=x+y;
        y=y+z;
        z=z+6;
        }
    }

"
082-10711,ucsd-progsys/csolve-bak,benchmarks/deputytests/perf/array1.c,18,2,17,2233744.7153403,169083.0,13.210931909180696,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0014891631435602,1082014363648.0,0.0134490161636592,0.0785049652044725,"#include <stdio.h>

#ifndef DEPUTY
#define DEPUTY_NUM_CHECKS_ADDED 0
#endif

// Some performance tests
// Reading from a SEQ pointer

#define NR_ITERS    1000
#define ARRAY_SIZE  (1024 * 1024)  // 4 Mb
int array[ARRAY_SIZE];

int main() {
  int acc = 0, iter, i;
  int * p = array;
  for(iter=0;iter<NR_ITERS;iter++) {
    // Just scan the array
    for(i=0;i<ARRAY_SIZE;i++) {
      acc += p[i];
    }
  }
  //All checks in this program should have been optimized away.
  if (DEPUTY_NUM_CHECKS_ADDED != 0) {
    return 3;
  }
  return 0;
}


"
124-21547,dvt32/cpp-journey,C/Data.BG/2217745.c,19,1,18,1961988.04769655,978554.0,2.0049869501325426,1367.0,1345.0,191058.0,139873.0,1631.0,657.0,1349.0,613.0,1500000000,0.0013079920317977,1082014363648.0,0.0027714362211998,0.0128425563032777,"// http://forums.data.bg/index.php?showtopic=2217745

/*Задание 12: Изброите количеството цели числа в диапазона от 100 до 999 които имат две еднакви цифри.*/

// The solution assumes that numbers with 3 matching digits also count.

#include <stdio.h>

int main() {
        int count = 0;

        for (int currentNumber = 100; currentNumber <= 999; ++currentNumber) {
                char digitsOfNumber[4];
                sprintf(digitsOfNumber, ""%d"", currentNumber);
                if (digitsOfNumber[0] == digitsOfNumber[1] ||
                    digitsOfNumber[1] == digitsOfNumber[2] ||
                    digitsOfNumber[0] == digitsOfNumber[2])
                {
                        printf(""%d \n"", currentNumber);
                        count++;
                }
        }

        printf(""\n%d \n"", count);

        return 0;
}
"
001-15285,rgiesler/projectEulerSolutions_C,problem7.c,30,4,16,150438279.02991316,453099158.0,0.3320206545164226,1339.0,1319.0,50283234.0,23396.0,773020.0,1279.0,1354.0,1130.0,1500000000,0.1002921860199421,1082014363648.0,5.866265591250558e-06,0.0154409667274472,"#include <stdio.h>

/*	By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see 
	that the 6th prime is 13.

	What is the 10 001st prime number?
*/

int isPrime(int num, int primes[], int primeCount);

int main(int argc, char *arv[])
{
	int primes[10001];
	int primeCount = 1, i=3;
	primes[0] = 2;

	while(primeCount <=10001) {
		if(isPrime(i, primes, primeCount))
			primes[primeCount++] = i;
		i += 2;
	}

	printf(""10 001th prime: %d\n"", primes[10000]);
	return 0;
}

int isPrime(int num, int primes[], int primeCount)
{
	int i;
	for(i = 0; i < primeCount; i++)
		if(num%primes[i]==0) return 0;
	return 1;
}

/*	For finding the primes, we will keep a list of the existing primes in 
	memory. We do this because we only need to check for division for previous
	primes, not all numbers. 

	We will also only check odd numbers, as all primes after 2 are odd.
*/"
322-227,sos22/FT,drd/tests/rwlock_race.c,36,1,20,195182893.65805683,184401.0,1058.469818493392,1479.0,1450.0,42212.0,14799.0,1695.0,705.0,1391.0,661.0,1500000000,0.1301219291053712,1082014363648.0,0.0158838618011832,0.0780901931206258,"/** Cause a race inside code protected by a reader lock.
 */


/* Needed for older glibc's (2.3 and older, at least) who don't
   otherwise ""know"" about pthread_rwlock_anything or about
   PTHREAD_MUTEX_RECURSIVE (amongst things). */

#define _GNU_SOURCE 1

#include <pthread.h>
#include <stdio.h>
#include <unistd.h>



static pthread_rwlock_t s_rwlock;
static int s_racy;

static void sleep_ms(const int ms)
{
  struct timespec delay = { ms / 1000, (ms % 1000) * 1000 * 1000 };
  nanosleep(&delay, 0);
}

static void* thread_func(void* arg)
{
  pthread_rwlock_rdlock(&s_rwlock);
  s_racy++;
  pthread_rwlock_unlock(&s_rwlock);
  sleep_ms(100);
  return 0;
}

int main(int argc, char** argv)
{
  pthread_t thread1;
  pthread_t thread2;

#if 0
  int res;
  VALGRIND_DO_CLIENT_REQUEST(res, 0, VG_USERREQ__DRD_TRACE_ADDR,
                             &s_racy, 0, 0, 0, 0);
#endif

  pthread_rwlock_init(&s_rwlock, 0);
  pthread_create(&thread1, 0, thread_func, 0);
  pthread_create(&thread2, 0, thread_func, 0);
  pthread_join(thread1, 0);
  pthread_join(thread2, 0);
  pthread_rwlock_destroy(&s_rwlock);

  fprintf(stderr, ""Result: %d\n"", s_racy);

  return 0;
}
"
297-18335,ericherman/code-snips,c/approx-pi.c,55,2,38,23940413.841046352,200182927.0,0.1195926813478953,1476.0,1449.0,41208.0,14659.0,1646.0,637.0,1361.0,595.0,1500000000,0.0159602758940309,1082014363648.0,1.4611635686593792e-05,0.0758766355809332,"/* approx-pi.c
   Copyright (C) 2017, 2018 Eric Herman <eric@freesa.org>

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation, either version 3 of the
   License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

	https://www.gnu.org/licenses/lgpl-3.0.txt
	https://www.gnu.org/licenses/gpl-3.0.txt
 */
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

double iterate_approx_pi(size_t iterations, int verbose)
{
	size_t i;
	unsigned long numerator;
	unsigned long denominator;
	double pi, piover2;

	numerator = 2;
	denominator = 1;
	piover2 = 1.0;
	i = 0;

	while (i < iterations) {
		piover2 *= (((double)numerator) / ((double)denominator));
		pi = (piover2 * 2.0);
		++i;

		if (verbose) {
			printf(""%6lu\t%f\t%6ld\t%6ld\n"", (unsigned long)i, pi,
			       numerator, denominator);
		}

		if (1 == (i % 2)) {
			denominator += 2;
		} else {
			numerator += 2;
		}
	}

	return pi;
}

int main(int argc, const char **argv)
{
	size_t i, iterations;
	int verbose;
	unsigned base;
	char *endptr;
	double pi;

	iterations = (argc > 1) ? ((size_t)atoi(argv[1])) : 10 * 1000 * 1000;
	verbose = (argc > 2) ? atoi(argv[2]) : 0;
	pi = iterate_approx_pi(iterations, verbose);
	printf(""after %lu iterations\n"", (unsigned long)iterations);
	printf(""pi is about: %21.18f\n"", pi);
	printf(""pi is known: %21.18f\n"", M_PI);
	printf(""      error: %21.18f\n"", M_PI - pi);

	return 0;
}
"
326-7657,luisbg/hhgtg,algorithms/math/trailing_zeros_factorial.c,52,3,29,1659901.4634265502,173745.0,9.553661975884198,1337.0,1319.0,39241.0,13343.0,1617.0,634.0,1340.0,590.0,1500000000,0.0011066009756177,1082014363648.0,0.0152867708423263,0.0795108778335615,"#include <stdio.h>


unsigned long
factorial (unsigned long n)
{
  if (n == 1)
    return 1;

  return n * factorial (n - 1);
}

int
trailing_zeros (unsigned long n)
{
  int c = 0;
  unsigned long tmp;

  for (tmp = n; tmp > 10; tmp = tmp / 10) {
    if ((tmp % 10) == 0)
      c++;
    else
      break;
  }

  return c;
}

int
powers_of_five (int n)
{
  int c = 0;
  int i;
  for (i = 5; n / i > 0; i *= 5) {
    c++;
  }

  return c;
}

int
direct_trailing_zeros (int n)
{
  int z = 0;

  for (; n > 4; n--) {
    if (n % 5 == 0)
      z += powers_of_five (n);
  }

  return z;
}


int
main ()
{
  unsigned int n = 26;
  // unsigned long f;
  // int z;

  // f = factorial ((unsigned long) n);
  // z = trailing_zeros (f);
  // printf (""n: %d; f: %d; z: %d\n"", n, f, z);

  printf (""n: %d; z: %d\n"", n, direct_trailing_zeros (n));

  return 0;
}
"
365-6723,benjamin-james/space-game,src/collisions.c,57,5,37,23883460.555225503,105693105.0,0.2259698965225782,1404.0,1383.0,21489157.0,1179189.0,1651.0,684.0,1371.0,639.0,1500000000,0.015922307036817,1082014363648.0,2.6368796715736565e-05,0.0001916769754617,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>


int count_collisions(int hash, int *data, int cur);
int test_pval(int pval, int num_runs, int len);
void test_all_pvals(int *pvals, int *collisions, int num, int num_runs, int len);

int bias_hash(int a, int b, int p);

/* all of these numbers are arbitrary*/
#define num_pvals 15
#define num_runs 500
#define num_times 10
#define length 200

int main(void)
{
	int pvals[] = {1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 33, 35, 37, 39, 41, 43};
	int i, collisions[num_pvals];
	srand(time(0));
	for (i = 0; i < num_pvals; i++)
		printf(""%d\t"", pvals[i]);
	puts(""\n"");
	for (i = 0; i < num_times; i++)
		test_all_pvals(pvals, collisions, num_pvals, num_runs, length);
	return 0;
}

#undef num_pvals
#undef num_runs
#undef num_times
#undef length

int bias_hash(int a, int b, int p)
{
	a = (p * a) ^ b;
	if (a < 0)
		return -a;
	return a;
}

int count_collisions(int hash, int *data, int cur)
{
	int i, collisions = 0;
	data[cur] = hash;
	for (i = 0; i < cur; i++) {
		if (data[i] == hash) {
			collisions++;
			data[cur] = -1;
		}
	}
	return collisions;
}
int test_pval(int pval, int num_runs, int len)
{
	int *data = malloc(sizeof(*data) * num_runs);
	int i, a, b, collisions = 0;
	for (i = 0; i < num_runs; i++) {
		a = rand() % (2 * len) - len;
		b = rand() % (2 * len) - len;
		collisions += count_collisions(bias_hash(a, b, pval), data, i);
	}
	free(data);
	return collisions;
}
void test_all_pvals(int *pvals, int *collisions, int num, int num_runs, int len) {
	int i;
	memset(collisions, 0, num);
	for (i = 0; i < num; i++) {
		collisions[i] = test_pval(i, num_runs, len);
		printf(""%d\t"", collisions[i]);
	}
	puts("""");
}
"
207-6361,EvtimPavlov/c-programming-2014-2015-homework,A/27_Teodor_Dobrev/Homework_3/task_1.c,26,3,15,2026818.22702275,232143.0,8.730902934828963,1333.0,1313.0,53507.0,23253.0,1626.0,642.0,1346.0,600.0,1500000000,0.0013512121513485,1082014363648.0,0.0113981468319096,0.0548983845752996,"#include <stdio.h>
#include <ctype.h>

int main()	{
	int chislo;
	char znak;
	for ( chislo = 97; chislo < 123; chislo++ )	{
		znak=(char)chislo;
		printf(""%c"",znak);
		printf("" - "");
		printf(""%i\n"",chislo);
	}
	printf(""\n"");
	for ( chislo = 65; chislo < 91; chislo++ )	{
		znak=(char)chislo;
		printf(""%c"",znak);
		printf("" - "");
		printf(""%i\n"",chislo);
	}
	printf(""\n"");
	for ( chislo = 48; chislo < 58; chislo++ )	{
		znak=(char)chislo;
		printf(""%c"",znak);
		printf("" - "");
		printf(""%i\n"",chislo);
	}
	printf(""\n"");
	return 0;
}
"
170-27073,goblint/analyzer,tests/regression/36-apron/10-float.c,21,1,19,1932887.8261147498,170000.0,11.369923529411764,1147.0,1135.0,38667.0,12779.0,1572.0,586.0,1320.0,546.0,1500000000,0.0012885918840765,1082014363648.0,0.0134235294117647,0.078217937254597,"// SKIP PARAM: --set ana.activated[+] apron --set ana.path_sens[+] threadflag
// Copied from 01/45 for apron.
#include <assert.h>

int isNan(float arg) {
    float x;
    return arg != arg;
}

int main(){
    struct blub { float f; } s;
    float fs[3];

    float top;
    // float may be NaN here, therefore the comaprison should be unknown
    assert(top == top); //UNKNOWN!
    assert(s.f == s.f); //UNKNOWN!
    assert(fs[1] == fs[1]); //UNKNOWN!

    int r = isNan(top);

    if(r) {
        assert(1);
    } else {
        assert(1);
    }
 }
"
218-33366,yigezhe/algorithm-summary,data_structure/priority_queue/priority_queue_my1.0.c,96,3,55,1701047.8768497,190523.0,8.928302619631225,1378.0,1358.0,43283.0,15864.0,1647.0,635.0,1360.0,592.0,1500000000,0.0011340319178998,1082014363648.0,0.0143604709142728,0.0715843576174615,"//没有做任何检查，就是实现一个基本的功能！
//1.2就要做出一些检查了！
//use 400M space
//即使最简单的事情，不亲自做一遍，也会错误百出！
//用queue1.0也可以实现对自定义数据的优先队列
//这里先不实现了，有一种就先用！
#define MAX 1000000
#include<stdio.h>
int queue[MAX];
int start=0,end=0;
void push(int element) {
	if (end==MAX) { fprintf(stderr,""不能添加元素了！\n""); }
	else if (end > MAX) { fprintf(stderr,""超过得更多了!\n""); }
	else {
		//想法一用插入法，因为插入前队列是排好的！
		//这是在queue1.0想法下插入！
		int i;
		for(i=start;i<end;i++) {
			if (element>queue[i]) continue;
			else {break;}
		}
		end++;
		int j;
		for(j=end-1;j>i;j--) {
			queue[j]=queue[j-1];

		}
		queue[i]=element;
	}
}
void pop(){
	//end不能为负数！
	//end等于start时整个queue已经是空的了！
	if (start==end) { 
		//这里以错误信息显示比较合适！
		fprintf(stderr,""queue is empty, nothing will be pop!\n"");
	} else if (start > end) {
		fprintf(stderr,""end可以走到start的前面，这不可能！\n"");
	} else {
		//只简单的处理办法，把队列前面的元素减一就可以！
		start++;
	}
}
int front(){
	return queue[start];
}
int empty(){
	return start==end;
}
int size(){
	return end-start;
}
void print(){
	if (start==end) { 
		//这里以错误信息显示比较合适！
		fprintf(stderr,""queue is empty, nothing will be pop!\n"");
		return;
	} else if (start > end) {
		fprintf(stderr,""end可以走到start的前面，这不可能！\n"");
		return;
	} else {

		int i;
		for(i=start;i<end;i++) {
			printf("" %d"",queue[i]);
		}
		printf(""\n"");
	}
}


int main() {
	/* 一个队列要实现以下几个功能！
	   There are four main operations on a queue:

	   Push – Adds an element to the back of the queue
	   Pop – Removes the front element from the queue
	   Front – Returns the front element on the queue
	   Empty – Tests if the queue is empty or not
	 */
	push(1); print();
	printf(""size = %d\n"",size());
	push(2); print();
	printf(""size = %d\n"",size());
	push(3); print();
	printf(""size = %d\n"",size());
	pop(); print();
	printf(""size = %d\n"",size());
	pop(); print();
	printf(""size = %d\n"",size());
	pop(); print();
	printf(""size = %d\n"",size());
	pop(); print();
	printf(""size = %d\n"",size());
	pop(); print();
	printf(""size = %d\n"",size());
	printf(""start=%d end=%d\n"",start,end);
	push(4);
	push(9);
	print();
	printf(""size = %d\n"",size());

	return 0;
}
		
"
242-13979,hustlijian/oj-jobdu,1072/main.c,19,4,16,1827438.2455273499,175999.0,10.383229450167333,1342.0,1322.0,39621.0,13622.0,1627.0,636.0,1345.0,594.0,1500000000,0.0012182921636849,1082014363648.0,0.0151364496389184,0.0789211727363221,"#include <stdio.h>
#include <string.h>

int main(int argc, char* argv[])
{
    int i, j, k, total;
    char map[200];

    memset(map, 0, sizeof(map));
    for (i = 0; i <= 5; i++) {
        for (j = 0; j <= 4; j++) {
            for (k = 0; k <= 6; k++) {
                total = 8*i + 10*j + 18*k;
                map[total] = 1;
            }
        }
    }
    for (i = 1, total = 0; i < 200; i++) {
        total += map[i];
    }
    printf(""%d\n"", total);

	return 0;
}
"
344-27597,tardisgallifrey/Cfiles,vsprojects/consoleio/buffer.c,13,1,13,1954729.6687960501,200664.0,9.738358649284375,1375.0,1349.0,44991.0,16872.0,1652.0,648.0,1357.0,606.0,1500000000,0.0013031531125307,1082014363648.0,0.0135749312283219,0.0689103341254061,"#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main( ){


char *buffer=malloc(50);
char buff1[50]=""How now brown cow."";


buffer = buff1;

printf(""buff1 = %s\n"", buff1);
printf(""buffer = %s\n"", buffer);


   for( long x = strlen(buffer); x != 0; x--){
      fputc(*buffer, stdout);
      fputc('\n', stdout);

     printf(""length of buffer = %ld, buffer[%ld] = %c\n"", strlen(buffer), x, *buffer);
     *buffer++;
   }
   


}
"
179-22451,HenrikSamuelsson/Programming-in-C,Exercises/Chapter_10/Exercise_01/Program_10_13/program_10_13.c,20,1,20,1725979.4985874498,173597.0,9.942447162105337,1290.0,1275.0,39348.0,13371.0,1619.0,638.0,1340.0,594.0,1500000000,0.0011506529990583,1082014363648.0,0.014775600960846,0.0794969555568201,"/*
 * program_10_13.c - Pointer Version of copyString()
 */

#include <stdio.h>

void copyString (char *to, char *from)
{
	for ( ; *from != '\0'; ++from, ++to )
		*to = *from;

	*to = '\0';
}

int main (void)
{
	void copyString (char *to, char *from);
	char string1[] = ""A string to be copied."";
	char string2[50];

	copyString (string2, string1);
	printf (""%s\n"", string2);

	copyString (string2, ""So is this."");
	printf (""%s\n"", string2);

	return 0;
}
"
206-16892,smileboywtu/The-C-Programming-Language-2nd,Chapter-2/exercise-2-3/atoi.c,19,1,15,1718576.8811030998,174352.0,9.856933100853446,1344.0,1325.0,39435.0,13399.0,1624.0,636.0,1345.0,594.0,1500000000,0.0011457179207354,1082014363648.0,0.0153081123244929,0.0794753378506264,"#include ""stdio.h""

/**

	convert a string to a integer.

*/

/* atoi: convert a string to an integer. */
int atoi(char s[]){

	int i, n;
	
	n = 0;
	for(i=0; s[i] >= '0' && s[i] <= '9'; i++){
		n = 10*n + (s[i] - '0');
	}

	return n;
}

int main(){

	int value;
	char str[] = ""1234"";

	value = atoi(str);

	printf(""The value is %d\n"", value);

	return 0;
}
"
100-28964,wuzhouhui/leetcode,123_best_time_stock_III.c,35,3,19,1552488.0727752,174205.0,8.911845239803679,1346.0,1328.0,39467.0,13410.0,1626.0,633.0,1345.0,591.0,1500000000,0.0010349920485168,1082014363648.0,0.0153497316380126,0.0793350606123645,"
int maxProfit(int *prices, int pricesSize)
{
	if (pricesSize <= 1)
		return(0);
	int	i, max_to_i[pricesSize], max_from_i[pricesSize];
	int	min_max, t;

	min_max = max_to_i[0] = 0;
	for (i = 1; i < pricesSize; i++) {
		if (prices[i] < prices[min_max])
			min_max = i;
		t = prices[i] - prices[min_max];
		max_to_i[i] = (max_to_i[i-1] > t ? max_to_i[i-1] : t);
	}
	max_from_i[pricesSize - 1] = 0;
	min_max = pricesSize - 1;
	for (i = pricesSize - 2; i >= 0; i--) {
		if (prices[i] > prices[min_max])
			min_max = i;
		t = prices[min_max] - prices[i];
		max_from_i[i] = (max_from_i[i+1] > t ? max_from_i[i+1] : t);
	}

	min_max = 0;
	for (i = 0; i < pricesSize; i++) {
		t = max_to_i[i] + max_from_i[i];
		if (t > min_max)
			min_max = t;
	}
	return(min_max);
}

#include <stdio.h>

int main(void)
{
	int	x[] = { 3, 3, 5, 0, 0, 3, 1, 4 };
	printf(""%d\n"", maxProfit(x, sizeof(x)/sizeof(x[0])));
	return(0);
}
"
195-26584,tleonhardt/Python_Interface_Cpp,swig/fibonacci/fibonacci.c,50,2,34,162221575.62151545,8978464.0,18.06785381107504,1462.0,1438.0,2340355.0,713978.0,1649.0,635.0,1363.0,593.0,1500000000,0.1081477170810103,1082014363648.0,0.0003229951136408,0.0013881917917921,"/* File : fibonacci.c
 *
 * Implementation of the algorithm in C
 */
#include <stdio.h>  // printf()
#include <stdlib.h> // atoi()
#include <time.h>   // clock_t, clock()

int compute_fibonacci(int n)
{
    int temp;
    int a = 1;
    int b = 1;
    for (int x=0; x<n; x++)
    {
        temp = a;
        a += b;
        b = temp;
    }
    return a;
}

int main(int argc, char *argv[])
{
    // Make this volatile to prevent compiler from completely optimizing out the loop
    volatile int n = 20;
    if (argc > 1)
    {
        n = atoi(argv[1]);
    }

    int number_of_times = 100000;
    if (argc > 2)
    {
        number_of_times = atoi(argv[2]);
    }

    int fib_n = compute_fibonacci(n);

    // Compute single execution time
    clock_t begin = clock();
    compute_fibonacci(n);
    clock_t end = clock();
    double single_time = (double)(end - begin) / CLOCKS_PER_SEC;
    printf(""single execution time: %.2g s\n"", single_time);

    // Compute average execution time over many times
    double time_spent = 0;
    for (int i = 0; i < number_of_times; i++)
    {
        begin = clock();
        compute_fibonacci(n);
        end = clock();
        time_spent += (double)(end - begin) / CLOCKS_PER_SEC;
    }
    double avg_time = time_spent / number_of_times;

    printf(""fib(%d) = %d  [average execution time: %.2g s]\n"", n, fib_n, avg_time);

    return EXIT_SUCCESS;
}
"
253-26843,imcvampire/Find-k-largest-number,kLargestNumber_Heap.c,102,5,61,1842021083.808504,8210114649.0,0.2243599708104393,1248.0,1232.0,2329777849.0,813837032.0,26392293.0,38141.0,1336.0,38089.0,1500000000,1.228014055872336,1082014363648.0,3.020664273308372e-07,0.0084201977665851,"#include ""stdio.h""
#include ""stdlib.h""

#define n0 100000000
#define k 600000

int *f;
int *result;

void swap(int *a, int *b)
{
	int temp = *a;
	*a = *b;
	*b = temp;
}

int leftchildnode(int n)
{
	return 2 * n + 1;
}

int rightchildnode(int n)
{
	return 2 * n + 2;
}

int parentnode(int n)
{
	return (n - 1) / 2;
}

void shiftdown(int a[], int start, int count)
{
	int i = start;

	int imax = parentnode(count + 1);
	while (i < imax)
	{
		int currentnodeindex = i;
		int leftnodeindex = leftchildnode(i);
		int rightnodeindex = rightchildnode(i);

		if (leftnodeindex < count && a[leftnodeindex] < a[i])
		{
			i = leftnodeindex;
		}

		if (rightnodeindex < count && a[rightnodeindex] < a[i])
		{
			i = rightnodeindex;
		}

		// Swap with the lowest value in the triplet
		if (i != currentnodeindex)
		{
			swap(&a[currentnodeindex], &a[i]);
		}
		else
			break;
	}
}

void heapify(int a[], int count)
{
	int i;

	for (i = parentnode(count - 1); i > -1; --i)
	{
		shiftdown(a, i, count);
	}
}

void heapsort(int a[], int count)
{
	int end = count - 1;

	while (end > 0)
	{
		swap(&a[0], &a[end]);
		shiftdown(a, 0, end);
		--end;
	}
}

int main(int argc, char const *argv[])
{
	int i, temp;
	f = (int *) malloc(k * sizeof(int));

	if (f == NULL) {
		return -1;
	}

	// generate k numbers
	for (i = 0; i < k; ++i)
	{
		f[i] = rand();
	}

	// k min heap
	heapify(f, k);

	// (n0 - k)logk
	for (i = 0; i < n0 - k; ++i)
	{
		// Generate n0 - k numbers
		temp = rand();

		/**
		 * If the new int value is greater than the lowest value of the
		 * array, then it will be replaced. The heap will be heapified
		 * again. The complexity is (n0 - k)logk.
		 * */ 
		if (temp > f[0])
		{
			f[0] = temp;
			shiftdown(f, 0, k);
		}
	}

	/**
	 * The heap will contains max values. Notice: the first value in
	 * the heap will be the smallest value
	 * */

	result = f;

	free(result);

	return 0;
}
"
392-32672,fengbohello/practice,clang/string/memcmp.c,59,3,37,3096034.4010963,270434.0,11.448390365116811,1398.0,1370.0,60850.0,27868.0,1657.0,637.0,1367.0,595.0,1500000000,0.0020640229340642,1082014363648.0,0.0102353993950464,0.0479722266056493,"/*
 * =====================================================================================
 *
 *       Filename:  memcmp.c
 *
 *    Description:  
 *
 *        Version:  1.0
 *        Created:  11/25/2016 02:30:31 PM
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  fengbohello (), fengbohello@foxmail.com
 *   Organization:  
 *
 * =====================================================================================
 */
#include <string.h>
#include <strings.h>
#include <stdio.h>

void show_mem(const void * p, size_t n) {
    if(NULL == p) {
        return;
    }

    const char * pz = (const char *)p;
    size_t c = 0;
    printf(""["");
    for(c = 0; c != n; c++) {
        printf(""%02X "", pz[c]);
    }
    printf(""]"");
    fflush(stdout);
}

int ext_memcmp(const void * s1, const void * s2, size_t n) {
    int ret = memcmp(s1, s2, n);
    printf(""compare : "");
    show_mem(s1, n);
    printf("" and "");
    show_mem(s2, n);
    printf("" => [%d]\n"", ret);

    return 0;
}

int main(int argc, char * argv[]) {
    char s1[32] = {0};
    char s2[32] = {0};
    bzero(s1, sizeof(s1));
    bzero(s2, sizeof(s2));
    int i = 0;
    for(i = 0; i < 10; i++) {
        s1[i] = i;
        s2[i] = i;
    }
    for(; i < 20; i++) {
        s1[i] = i + 20;
        s2[i] = i + 50;
    }
    ext_memcmp(s1, s2, 10);
    ext_memcmp(s1, s2, 12);
    ext_memcmp(s1, s2, 16);
    ext_memcmp(s1, s2, 20);

    return 0;
}

"
373-26555,iamyooon/study_linux,language/c/string_API/strncmp/strncmp_example.c,19,1,17,1608499.4422270502,174605.0,9.212216145013029,1325.0,1305.0,39566.0,13515.0,1625.0,637.0,1343.0,594.0,1500000000,0.0010723329614847,1082014363648.0,0.0150625698004066,0.0791055179819521,"#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
	int result = -1;
	char str1[32]=""iello world"";
	char str2[32]={'\0',};
	char *str3;
	char str4[32];
	str3 = ""hello"";
	//char str2[32]={0,};

	int i=0;
	for (i=0; i<32; i++) {
		str4[i]=str3[i];
	}
	printf(""str3=%s\n"", str3);
	printf(""str4=%s\n"", str4);

	//result = strncmp(str1, str2, sizeof(str2));
	//printf(""result=%d %d %d\n"", result, 'i','0');

	return 0;
}
"
099-15145,GarethNelson/Zoidberg,userland/newlib/newlib/libc/sys/linux/linuxthreads/tststack.c,54,2,26,1534295274.177566,188553.0,8134.128266322997,1574.0,1538.0,42983.0,15494.0,1700.0,758.0,1386.0,716.0,1500000000,1.0228635161183774,1082014363648.0,0.0165046432568031,0.0779793765070027,"/* Tests for variable stack size handling.
   Copyright (C) 2000 Free Software Foundation, Inc.
   Contributed by Ulrich Drepper <drepper@redhat.com>, 2000.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Library General Public License as
   published by the Free Software Foundation; either version 2 of the
   License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public
   License along with the GNU C Library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

static void *f1 (void *);
static void *f2 (void *);

int
main (void)
{
  pthread_attr_t attr;
  pthread_t th1 = 0;
  pthread_t th2 = 0;
  void *res1;
  void *res2;

  pthread_attr_init (&attr);
  if (pthread_attr_setstacksize (&attr, 70*1024) != 0)
    {
      puts (""invalid stack size"");
      return 1;
    }

  pthread_create (&th1, NULL, f1, NULL);
  pthread_create (&th2, &attr, f2, NULL);

  pthread_join (th1, &res1);
  pthread_join (th2, &res2);

  printf (""res1 = %p\n"", res1);
  printf (""res2 = %p\n"", res2);

  return res1 != (void *) 1 || res2 != (void *) 2;
}

static void *
f1 (void *parm)
{
  printf (""This is `%s'\n"", __FUNCTION__);
  fflush (stdout);

  return (void *) 1;
}

static void *
f2 (void *parm)
{
  printf (""This is `%s'\n"", __FUNCTION__);
  fflush (stdout);
  sleep (1);

  return (void *) 2;
}
"
355-34705,LingboTang/Parallel-and-Distributed-System-Practice,General/threadSort.c,101,4,40,2405629.60971135,1670054.0,1.4404498297659836,1403.0,1381.0,354396.0,229480.0,1640.0,767.0,1356.0,721.0,1500000000,0.0016037530731409,1082014363648.0,0.0016670119648825,0.0076797128157348,"#include <stdio.h>
#include <stdlib.h>

#define N 1000
#define X 200

void quicksort(int *, int, int);
int partition(int*, int, int);
int choosePivot(int*, int, int);
void swaparr(int *, int *);
void swapval(int x, int y);

int main(int argc, char ** argv)
{
    srand(123456);
    int * arr = (int *) malloc(sizeof(int)*N);
    int i;
    for ( i = 0; i < N; i++)
    {
        arr[i] = rand()%X;
    }

    printf(""Before Sort:  \n\n"");

    for (i = 0; i< N; i++)
    {
        if (i == 0)
        {
            printf(""[ "");
        }
        printf(""%d "",arr[i]);
        if (i == N-1)
        {
            printf(""]\n"");
        }
    }

    printf(""After Sort:  \n\n"");

    quicksort(arr,0,N-1);
    for (i = 0; i< N; i++)
    {
        if (i == 0)
        {
            printf(""[ "");
        }
        printf(""%d "",arr[i]);
        if (i == N-1)
        {
            printf(""]\n"");
        }
    }

    free((void*)arr);
    return 0;
}

void quicksort(int * arr, int low, int upp)
{
    if (low < upp)
    {
        int p = partition(arr, low, upp);
        quicksort(arr, low, p-1);
        quicksort(arr, p+1, upp);
    }
}


int partition(int *arr, int low, int upp)
{
    int i;
    int pivotIdx = choosePivot(arr,low,upp);
    int pivotVal = arr[pivotIdx];
    swaparr(&arr[pivotIdx],&arr[upp]);

    int storeIdx = low;

    for (i = low; i < upp; i++)
    {
        if (arr[i] < pivotVal)
        {
            swaparr(&arr[i],&arr[storeIdx]);
            storeIdx++;
        }
    }

    swaparr(&arr[storeIdx],&arr[upp]);
    return storeIdx;
}

void swaparr(int * x, int * y)
{
    int tmp = *x;
    *x = *y;
    *y = tmp;
}

void swapval(int x, int y)
{
    int tmp;
    tmp = x;
    x = y;
    y = tmp; 
}

int choosePivot(int * arr, int low, int upp)
{
    int mid = (low + upp) / 2;
    if (arr[low] > arr[upp])
    {
        swapval(low, upp);
    }
    if (arr[mid] < arr[low])
    {
        swapval(mid,low);
    }
    if (arr[upp] < arr[mid])
    {
        swapval(mid, upp);
    }
    return mid;
}"
050-33543,liuluheng/CTCI,CLRS/dp/lcs.c,48,4,29,2043678.07600635,177382.0,11.521338129009708,1328.0,1308.0,40303.0,13908.0,1663.0,676.0,1376.0,634.0,1500000000,0.0013624520506709,1082014363648.0,0.0148605833737357,0.0802235708620021,"#include <stdio.h>
#include <string.h>
#define MAXLEN 100

void LCSLength(char *x, char *y, int m, int n, int c[][MAXLEN], int b[][MAXLEN])
{
    int i, j;

    for (i = 0; i <= m; i++)
        c[i][0] = 0;
    for (j = 1; j <= n; j++)
        c[0][j] = 0;
    for (i = 1; i <= m; i++) {
        for (j = 1; j <= n; j++) {
            if (x[i - 1] == y[j - 1]) {
                c[i][j] = c[i - 1][j - 1] + 1;
                b[i][j] = 0;
            } else if (c[i - 1][j] >= c[i][j - 1]) {
                c[i][j] = c[i - 1][j];
                b[i][j] = 1;
            } else {
                c[i][j] = c[i][j - 1];
                b[i][j] = -1;
            }
        }
    }
}

void PrintLCS(int b[][MAXLEN], char *x, int i, int j)
{
    if (i == 0 || j == 0)
        return;
    if (b[i][j] == 0) {
        PrintLCS(b, x, i - 1, j - 1);
        printf(""%c "", x[i - 1]);
    } else if (b[i][j] == 1)
        PrintLCS(b, x, i - 1, j);
    else
        PrintLCS(b, x, i, j - 1);
}

int main(int argc, char **argv)
{
    char x[MAXLEN] = { ""ABCBDAB"" };
    char y[MAXLEN] = { ""BDCABA"" };

    int b[MAXLEN][MAXLEN];
    int c[MAXLEN][MAXLEN];
    int m, n;

    m = strlen(x);
    n = strlen(y);

    LCSLength(x, y, m, n, c, b);
    PrintLCS(b, x, m, n);

    printf(""\n"");
    return 0;
}
"
097-31535,goblint/analyzer,tests/regression/26-undefined_behavior/01-only-intervals.c,7,1,16,1883672.78315115,169061.0,11.14196650912984,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0012557818554341,1082014363648.0,0.0134152761429306,0.0785563462891999,"// PARAM: --set solver td3 --enable ana.int.interval --disable ana.int.def_exc --set ana.activated ""['base','threadid','threadflag','escape','expRelation','mallocWrapper']"" --set ana.base.privatization none
#include <assert.h>

int main() {
  for(int i=2; i < 42; i++) {
    int x = i==2; // NOWARN
    assert(1);
  }
}
"
145-8295,rhuitl/uClinux,uClibc/test/rpc/getrpcent_r.c,16,2,13,2090657.944791,328349.0,6.365011009626952,2145.0,1812.0,73453.0,32735.0,1784.0,752.0,1443.0,664.0,1500000000,0.001393771963194,1082014363648.0,0.0120512016177908,0.0437243379666252,"#include <netdb.h>
#include <stdio.h>
#include <errno.h>

int main(int argc, char *argv[])
{
	int ret;
	char rpcdata[1024];
	struct rpcent rpcbuf, *ent;

	while ((ret = getrpcent_r(&rpcbuf, rpcdata, sizeof(rpcdata), &ent)) == 0) {
		printf(""%s: %i"", ent->r_name, ent->r_number);
		while (ent->r_aliases[0])
			printf("" %s"", *ent->r_aliases++);
		printf(""\n"");
	}

	if (ret != ENOENT)
		printf(""Test failed: %s\n"", strerror(ret));

	endrpcent();

	return 0;
}
"
144-4458,rswinkle/C_Interpreter,tests/dowhile.c,22,5,16,1877793.2273223002,202489.0,9.27355560055114,1347.0,1326.0,45541.0,17818.0,1618.0,638.0,1340.0,595.0,1500000000,0.0012518621515482,1082014363648.0,0.0132007170759893,0.0661468773181395,"


#include <stdio.h>


int main()
{
	int i = 0;

	do printf(""%d\n"", i); while (i);

	i = 10;
	do {
		printf(""%d\n"", i);
	} while (i--);

	printf(""%d\n"", i);

	i = 10;
	do {
		printf(""%d\n"", i);
	} while (--i);

	printf(""%d\n"", i);

	do {
		int j = 0;
		do printf(""%d\n"", j); while (++j < 5);
		printf(""%d\n"", i);
	} while (i++ < 3);
	
	printf(""%d\n"", i);

	return 0;
}
"
016-33539,yuweijun/learning-programming,language-c/sort/shell_sort2.c,29,4,18,1837217.8310527499,467785.0,6.414889318810992,1371.0,1349.0,100599.0,53039.0,1633.0,670.0,1353.0,625.0,1500000000,0.0012248118873685,1082014363648.0,0.0058146370661735,0.0278642002629557,"#include <stdio.h>

void shell_sort2(int arr[], int len);

void print(int *, int);

int main(void) {
    int arr[] = {2, 1, 8, 3, 9, 0, 4, 6, 7, 5};
    int length = 10;

    shell_sort2(arr, length);
}

void print(int *arr, int len) {
    for (int i = 0; i < len; i++) {
        printf(""%2d : %2d \t"", i + 1, arr[i]);
    }
    printf(""\n"");
}

/* cpl 书里的代码版本，比其他实现更加的简洁明了 */
void shell_sort2(int arr[], int len) {
    int gap, i, j;
    int temp;
    for (gap = len >> 1; gap > 0; gap >>= 1) {
        for (i = gap; i < len; i++) {
            for (j = i - gap; j >= 0 && arr[j] > arr[j + gap]; j -= gap) {
                temp = arr[j];
                arr[j] = arr[j + gap];
                arr[j + gap] = temp;
            }
            print(arr, len);
        }
        printf(""\n"");
    }
}"
039-15301,artcz/euler,problems/03/3.c,26,1,23,1890394.3710028501,236907.0,7.979477178808562,1451.0,1425.0,39663.0,13596.0,1639.0,629.0,1356.0,590.0,1500000000,0.0012602629140019,1082014363648.0,0.0121397848100731,0.0791227773709607,"
// To run:
//     gcc 3.c -std=c99
//
// Problem:
//     The prime factors of 13195 are 5, 7, 13 and 29.
//
//     What is the largest prime factor of the number 600851475143 ?

#include <stdio.h>
#include <time.h>


int largest_prime_factor(long number) {
    int largest_factor = 0;
    for(int i=2; i <= number; i++) {
        if(number % i == 0) {
            if(i > largest_factor)
                largest_factor = i;
            number /= i;
        }
    }
    return largest_factor;
}


int main() {
    long NUMBER = 600851475143;
    clock_t begin = clock();
    int result = largest_prime_factor(NUMBER);
    clock_t end = clock();
    double time = (double)(end - begin) / CLOCKS_PER_SEC;
    printf(""%d [in %f seconds]"", result, time);
}
"
382-35394,roth1002/infer,infer/tests/codetoanalyze/c/frontend/loops/while_nested.c,15,2,11,2049679.51867725,169061.0,12.12031160350406,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0013664530124515,1082014363648.0,0.0134152761429306,0.0785563462891999,"/*
 * Copyright (c) 2013 - Facebook.
 * All rights reserved.
 */

int main() {
  int i = 0;
  int k = 0;
  while (i <= 10) {
    while (k <= 5) {
      k++;
    }
    i++;
  }
  return 0;
}
"
187-1239,jbaldwin/project_euler,p039/p39.c,23,3,17,256572556.33268505,2339009467.0,0.1096928249414392,1332.0,1313.0,39164.0,13301.0,1616.0,636.0,1340.0,593.0,1500000000,0.1710483708884567,1082014363648.0,1.1308205620015989e-06,0.0797674640236348,"#include <stdio.h>

int main(int argc, char* argv[]) {

	int max_p = 0;
	int max_c = 0;
	for(int p = 3; p <= 1000; p++) {
		int count = 0;
		for(int a = 1; a < p; a++) {
		for(int b = a; b < p; b++) {
			int c = p - a - b;

			if(a + b < c) continue;
			if(c <= 0) continue;

			if(c * c == a * a + b * b) {
				count++;
			}
		}
		}
		if(count > max_c) {
			max_p = p;
			max_c = count;
		}
	}

	printf(""%i"", max_p);

	return 0;
}
"
241-22999,JacobCWard/CSIS3150,week05/student2.c,17,3,11,2008638.22828965,174274.0,11.525746812490675,1347.0,1326.0,39432.0,13498.0,1619.0,637.0,1341.0,594.0,1500000000,0.0013390921521931,1082014363648.0,0.0153379161550202,0.0791800491214812,"// Structures

#include <stdio.h>
#include <string.h>

struct Student {
	int id;
	char *firstName;
	char *lastName;
};

int main(){
	struct Student s;
	struct Student *sptr;
	
	sptr = &s;
	s.id = 100;
	s.firstName = ""John"";
	s.lastName = ""Doe"";
	
	printf(""The id for s = %d\n"", sptr->id);
	printf(""The first name for s = %s\n"", sptr->firstName);
	printf(""The last name for s = %s\n"", sptr->lastName);
	
}"
365-24908,mattstock/binutils-bexkat1,gdb/testsuite/gdb.mi/vla.c,27,2,17,1524946.1866914,169037.0,9.021374018705965,1138.0,1128.0,38451.0,12696.0,1567.0,585.0,1317.0,546.0,1500000000,0.0010166307911276,1082014363648.0,0.0134053491247478,0.0784992277161905,"/* This testcase is part of GDB, the GNU debugger.

   Contributed by Intel Corp. <keven.boell@intel.com>

   Copyright 2014-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
func (int n)
{
  int vla[n], i;

  for (i = 0; i < n; i++)
    vla[i] = i;

  return n;                 /* vla-filled */
}

int
main (void)
{
  func (5);

  return 0;
}
"
205-4916,lilianglaoding/codeprimer,CLab/C_Prog/001.c,12,3,9,2103739.3016740503,203525.0,10.336513941776197,1335.0,1316.0,45059.0,17096.0,1617.0,637.0,1340.0,594.0,1500000000,0.0014024928677827,1082014363648.0,0.0130254268517381,0.0673799372536401,"#include <stdio.h>

int main()
{
    int i, j, k;
    for(i = 1; i <= 4; i++)
        for(j = 1; j <= 4; j++)
            for(k = 1; k <= 4; k++)
            {
                if(i != j && i != k && j != k)
                    printf(""%d%d%d\n"",i,j,k);
            }
    return 0;
}
"
389-19687,AlienCowEatCake/ImageViewer,src/ThirdParty/aom/aom-v3.2.0/tools/auto_refactor/c_files/decl_status_code.c,24,3,19,2141612.93115465,169061.0,12.667687994274257,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0014277419541031,1082014363648.0,0.0134152761429306,0.0785563462891999,"/*
 * Copyright (c) 2021, Alliance for Open Media. All rights reserved
 *
 * This source code is subject to the terms of the BSD 2 Clause License and
 * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License
 * was not distributed with this source code in the LICENSE file, you can
 * obtain it at www.aomedia.org/license/software. If the Alliance for Open
 * Media Patent License 1.0 was not distributed with this source code in the
 * PATENTS file, you can obtain it at www.aomedia.org/license/patent.
 */

typedef struct S1 {
  int x;
} T1;

int parse_decl_node_2() { int arr[3]; }

int parse_decl_node_3() { int *a; }

int parse_decl_node_4() { T1 t1[3]; }

int parse_decl_node_5() { T1 *t2[3]; }

int parse_decl_node_6() { T1 t3[3][3]; }

int main() {
  int a;
  T1 t1;
  struct S1 s1;
  T1 *t2;
}
"
093-11974,qeedquan/misc_utilities,math/bilinear-interpolation.c,29,4,18,150248902.50060704,1099932411.0,0.136598304129798,1446.0,1422.0,212083434.0,137209351.0,1632.0,696.0,1351.0,653.0,1500000000,0.1001659350004047,1082014363648.0,2.607432939804517e-06,1.2402202925548548e-05,"// https://en.wikipedia.org/wiki/Bilinear_interpolation
#include <stdio.h>

double
lerp(double t, double a, double b)
{
	return a + (b - a) * t;
}

double
blerp(double c00, double c10, double c01, double c11, double tx, double ty)
{
	return lerp(lerp(c00, c10, tx), lerp(c01, c11, tx), ty);
}

int
main(void)
{
	double i, j, k, l, s;
	double tx, ty;

	s = 0.05;
	tx = ty = 1;
	for (i = 0; i <= 1; i += s) {
		for (j = 0; j <= 1; j += s) {
			for (k = 0; k <= 1; k += s) {
				for (l = 0; l <= 1; l += s) {
					printf(""[%.2f,%.2f,%.2f,%.2f] %f\n"", i, j, k, l, blerp(i, j, k, l, tx, ty));
				}
			}
		}
	}
	return 0;
}
"
230-28733,alpine9000/BitOS,tests/gcc.c-torture/pr68376-1.c,21,2,15,1543367.8636326,170003.0,9.078469203484644,1148.0,1139.0,38670.0,12782.0,1577.0,586.0,1323.0,546.0,1500000000,0.0010289119090884,1082014363648.0,0.0134527037758157,0.0783643007074555,"/* { dg-do run } */
/* PR rtl-optimization/68376 */

int a, b, c = 1;
signed char d;

int
main ()
{
  for (; a < 1; a++)
    for (; b < 1; b++)
      {
	signed char e = ~d;
	if (d < 1)
	  e = d;
	d = e;
	if (!c)
	  __builtin_abort ();
      }

  if (d != 0)
    __builtin_abort ();

  return 0;
}
"
352-31227,JonArnfred/Euler,Euler13/euler13.c,137,3,31,3883597.3246023,2166119.0,1.7928825701635045,1401.0,1377.0,414727.0,259056.0,1818.0,665.0,1477.0,623.0,1500000000,0.0025890648830682,1082014363648.0,0.0012824780171357,0.0068018931911312,"/*
Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.

37107287533902102798797998220837590246510135740250
46376937677490009712648124896970078050417018260538
74324986199524741059474233309513058123726617309629
91942213363574161572522430563301811072406154908250
23067588207539346171171980310421047513778063246676
89261670696623633820136378418383684178734361726757
28112879812849979408065481931592621691275889832738
44274228917432520321923589422876796487670272189318
47451445736001306439091167216856844588711603153276
70386486105843025439939619828917593665686757934951
62176457141856560629502157223196586755079324193331
64906352462741904929101432445813822663347944758178
92575867718337217661963751590579239728245598838407
58203565325359399008402633568948830189458628227828
80181199384826282014278194139940567587151170094390
35398664372827112653829987240784473053190104293586
86515506006295864861532075273371959191420517255829
71693888707715466499115593487603532921714970056938
54370070576826684624621495650076471787294438377604
53282654108756828443191190634694037855217779295145
36123272525000296071075082563815656710885258350721
45876576172410976447339110607218265236877223636045
17423706905851860660448207621209813287860733969412
81142660418086830619328460811191061556940512689692
51934325451728388641918047049293215058642563049483
62467221648435076201727918039944693004732956340691
15732444386908125794514089057706229429197107928209
55037687525678773091862540744969844508330393682126
18336384825330154686196124348767681297534375946515
80386287592878490201521685554828717201219257766954
78182833757993103614740356856449095527097864797581
16726320100436897842553539920931837441497806860984
48403098129077791799088218795327364475675590848030
87086987551392711854517078544161852424320693150332
59959406895756536782107074926966537676326235447210
69793950679652694742597709739166693763042633987085
41052684708299085211399427365734116182760315001271
65378607361501080857009149939512557028198746004375
35829035317434717326932123578154982629742552737307
94953759765105305946966067683156574377167401875275
88902802571733229619176668713819931811048770190271
25267680276078003013678680992525463401061632866526
36270218540497705585629946580636237993140746255962
24074486908231174977792365466257246923322810917141
91430288197103288597806669760892938638285025333403
34413065578016127815921815005561868836468420090470
23053081172816430487623791969842487255036638784583
11487696932154902810424020138335124462181441773470
63783299490636259666498587618221225225512486764533
67720186971698544312419572409913959008952310058822
95548255300263520781532296796249481641953868218774
76085327132285723110424803456124867697064507995236
37774242535411291684276865538926205024910326572967
23701913275725675285653248258265463092207058596522
29798860272258331913126375147341994889534765745501
18495701454879288984856827726077713721403798879715
38298203783031473527721580348144513491373226651381
34829543829199918180278916522431027392251122869539
40957953066405232632538044100059654939159879593635
29746152185502371307642255121183693803580388584903
41698116222072977186158236678424689157993532961922
62467957194401269043877107275048102390895523597457
23189706772547915061505504953922979530901129967519
86188088225875314529584099251203829009407770775672
11306739708304724483816533873502340845647058077308
82959174767140363198008187129011875491310547126581
97623331044818386269515456334926366572897563400500
42846280183517070527831839425882145521227251250327
55121603546981200581762165212827652751691296897789
32238195734329339946437501907836945765883352399886
75506164965184775180738168837861091527357929701337
62177842752192623401942399639168044983993173312731
32924185707147349566916674687634660915035914677504
99518671430235219628894890102423325116913619626622
73267460800591547471830798392868535206946944540724
76841822524674417161514036427982273348055556214818
97142617910342598647204516893989422179826088076852
87783646182799346313767754307809363333018982642090
10848802521674670883215120185883543223812876952786
71329612474782464538636993009049310363619763878039
62184073572399794223406235393808339651327408011116
66627891981488087797941876876144230030984490851411
60661826293682836764744779239180335110989069790714
85786944089552990653640447425576083659976645795096
66024396409905389607120198219976047599490197230297
64913982680032973156037120041377903785566085089252
16730939319872750275468906903707539413042652315011
94809377245048795150954100921645863754710598436791
78639167021187492431995700641917969777599028300699
15368713711936614952811305876380278410754449733078
40789923115535562561142322423255033685442488917353
44889911501440648020369068063960672322193204149535
41503128880339536053299340368006977710650566631954
81234880673210146739058568557934581403627822703280
82616570773948327592232845941706525094512325230608
22918802058777319719839450180888072429661980811197
77158542502016545090413245809786882778948721859617
72107838435069186155435662884062257473692284509516
20849603980134001723930671666823555245252804609722
53503534226472524250874054075591789781264330331690


*/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <inttypes.h>

int  main(int argc, char *argv[]){

    FILE *file;
    int c;
    int x = 0;
    int y = 0;
    int numbers[100][50];//matrix til at holde tallene

    setvbuf (stdout, NULL, _IONBF, 0);
    file = fopen(""number.txt"", ""r"");

    if(file){
        while((c = getc(file)) != EOF){
            numbers[x][y] = c - '0';
            y++;
            if(y == 50){
                y = 0;
                x++;
            }
        }
    }

    //læg dem fra arrayet af chars ned i enkle tal, læg de tal sammen
    uint64_t _12digits = 0;
    uint64_t result = 0;
    for(int i = 0; i < 100; i++){
        uint64_t k = 1;
        for(int a = 10; a >= 0; a--){
            _12digits += k*numbers[i][a];
            printf(""%lld += %llu * %d\n"", _12digits, k,numbers[i][a]);
            k = 10 * k;
        }
        result += _12digits;
        _12digits= 0;
    }
    printf(""result: %lld"", result);


    return 0;

}


"
312-4975,cupertinomiranda/binutils,gdb/testsuite/gdb.python/py-bad-printers.c,44,1,29,1770394.5050016,169062.0,10.47186239367806,1140.0,1130.0,38452.0,12697.0,1567.0,589.0,1316.0,548.0,1500000000,0.0011802630033344,1082014363648.0,0.0134270267712436,0.078593911904436,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2008-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* This lets us avoid malloc.  */
int array[100];

struct container
{
  const char *name;
  int len;
  int *elements;
};

struct container
make_container (const char *name)
{
  struct container result;

  result.name = name;
  result.len = 0;
  result.elements = 0;

  return result;
}

void
add_item (struct container *c, int val)
{
  if (c->len == 0)
    c->elements = array;
  c->elements[c->len] = val;
  ++c->len;
}

int
main ()
{
  struct container c = make_container (""foo"");

  add_item (&c, 23);

  return 0; /* break here */
}
"
273-21009,indashnet/InDashNet.Open.UN2000,android/external/compiler-rt/lib/asan/lit_tests/TestCases/sleep_before_dying.c,8,1,16,1495608.1286071502,172317.0,8.67711253097489,1233.0,1216.0,39072.0,13209.0,1592.0,630.0,1328.0,589.0,1500000000,0.0009970720857381,1082014363648.0,0.0142121787171317,0.0791683403148371,"// RUN: %clang_asan -O2 %s -o %t
// RUN: ASAN_OPTIONS=""sleep_before_dying=1"" not %t 2>&1 | FileCheck %s

#include <stdlib.h>
int main() {
  char *x = (char*)malloc(10 * sizeof(char));
  free(x);
  return x[5];
  // CHECK: Sleeping for 1 second
}
"
097-16881,Voleking/ICPC,references/aoapc-book/BeginningAlgorithmContests/bookcodes/ch7/queen.c,20,3,18,161238042.05562916,1356705751.0,0.1188452557831016,1342.0,1323.0,229985939.0,115057167.0,1618.0,636.0,1341.0,593.0,1500000000,0.1074920280370861,1082014363648.0,1.964316874190061e-06,1.2137613901493225e-05,"#include<stdio.h>
int C[50], tot = 0, n = 8, nc = 0;

void search(int cur) {
  int i, j;
  nc++;
  if(cur == n) {
    for(i = 0; i < n; i++)
      for(j = i+1; j < n; j++)
        if(C[i] == C[j] || i-C[i] == j-C[j] || i+C[i] == j+C[j]) return;
    tot++;
  } else for(i = 0; i < n; i++) {
    C[cur] = i;
    search(cur+1);
  }
}

int main() {
  search(0);
  printf(""%d\n"", tot);
  printf(""%d\n"", nc);
  return 0;
}
"
366-7471,zhangrxiang/learn-c,basic/2017/09/27/pthread/3.c,25,1,15,1831488.1017430502,181119.0,10.112069965050605,1491.0,1460.0,41402.0,14608.0,1666.0,704.0,1367.0,662.0,1500000000,0.0012209920678287,1082014363648.0,0.0162931553288169,0.0785395465095518,"//
// Created by zhangrongxiang on 2017/9/27 10:30
//

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

int sharedi = 0;

void increse_num(void);

int main() {
    int ret;
    pthread_t thrd1, thrd2, thrd3;

    ret = pthread_create(&thrd1, NULL, (void *) increse_num, NULL);
    ret = pthread_create(&thrd2, NULL, (void *) increse_num, NULL);
    ret = pthread_create(&thrd3, NULL, (void *) increse_num, NULL);

    pthread_join(thrd1, NULL);
    pthread_join(thrd2, NULL);
    pthread_join(thrd3, NULL);

    printf(""sharedi = %d\n"", sharedi);

    return 0;

}

void increse_num(void) {
    long i, tmp;
    for (i = 0; i <= 1000000; i++) {
        tmp = sharedi;
        tmp = tmp + 1;
        sharedi = tmp;
    }
}"
360-6018,zxombie/aarch64-freebsd-binutils,gdb/testsuite/gdb.linespec/thread.c,24,1,22,1599167.9392755,169083.0,9.457881632097845,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.001066111959517,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2012-2014 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* http://sourceware.org/bugzilla/show_bug.cgi?id=14643 */

static void
thread ()
{
}

int
main ()
{
  int x = 0;
  thread (); /* set breakpoint 1 here */
  return x;
}
"
262-33050,SvichkarevAnatoly/deepmethod,r_from_c/other/helper.c,20,1,15,30005555130.075657,194028.0,154645.48998082752,1373.0,1350.0,44276.0,16623.0,1644.0,650.0,1353.0,608.0,1500000000,20.00370342005044,1082014363648.0,0.0140340569402354,0.0698697843971165,"/*
 * Compile me with:
 * gcc -o helper helper.c
 */
#include <stdio.h>

int main( int argc, char **argv ){
    int i;

    for( i = 0; i < 10; i++ ){
        char stdout_string[] = ""Normal message no:  ."";
        char stderr_string[] = ""Error message no:  ."";

        stdout_string[19] = '0' + i;
        stderr_string[18] = '0' + i;

        sleep( 1 );
        fprintf( stdout, ""%s\n"", stdout_string );
        fflush(stdout);
        sleep( 1 );
        fflush(stderr);
        fprintf( stderr, ""%s\n"", stderr_string );
    }

    return( 0 );
}
"
320-17374,andreganske/PRA_201401,201401/exercicios/tree.c,146,3,47,2410519.7517200997,183405.0,13.143147678634715,1356.0,1334.0,41698.0,14948.0,1637.0,640.0,1353.0,597.0,1500000000,0.0016070131678134,1082014363648.0,0.01466699381151,0.0746213324859654,"#include <stdio.h>
#include ""stdlib.h""
#include <string.h>

typedef struct TREE *pTREE,**ppTREE;

typedef struct TREE{
	char data;
	pTREE pLeft;
	pTREE pRight;
}TREE;

void printDataAsChar(pTREE pTree);
pTREE searchTree(pTREE pRoot, int k);
void insertTree(pTREE pRoot, pTREE pNew);
void printTree(pTREE pRoot);
void preOrderTree(pTREE pRoot);
void inOrderTree(pTREE pRoot);
void posOrderTree(pTREE pRoot);


int main(int argc, char **argv)
{
	TREE rootTree;

	rootTree.data = '4';
	rootTree.pLeft = NULL;
	rootTree.pRight = NULL;

	pTREE pNewTree;

	pNewTree = malloc(sizeof(TREE));
	pNewTree->pLeft = NULL;
	pNewTree->pRight = NULL;
	pNewTree->data ='2';    
	insertTree(&rootTree,pNewTree);

	pNewTree = malloc(sizeof(TREE));
	pNewTree->pLeft = NULL;
	pNewTree->pRight = NULL;
	pNewTree->data ='3';
	insertTree(&rootTree,pNewTree);

	pNewTree = malloc(sizeof(TREE));
	pNewTree->pLeft = NULL;
	pNewTree->pRight = NULL;
	pNewTree->data ='5';
	insertTree(&rootTree,pNewTree);

	pNewTree = malloc(sizeof(TREE));
	pNewTree->pLeft = NULL;
	pNewTree->pRight = NULL;
	pNewTree->data ='1';
	insertTree(&rootTree,pNewTree);

	printf(""\npreOrderTree()\n"");
	preOrderTree(&rootTree);
	printf(""\ninOrderTree()\n"");
	inOrderTree(&rootTree);
	printf(""\nposOrderTree()\n"");
	posOrderTree(&rootTree);


	return 0;
}
pTREE searchTree(pTREE pRoot, int k)
{
	if(pRoot != NULL || pRoot->data == k)
	{
		return pRoot;
	}

	if(pRoot->data > k)
	{
		return searchTree(pRoot->pLeft,k);
	}
	else
	{
		return searchTree(pRoot->pRight,k);
	}
}

void printDataAsChar(pTREE pTree)
{
	printf("" %c "",pTree->data);
}


void insertTree(pTREE pRoot, pTREE pNew)
{
	pTREE pCurr, pPrev;

	if(!pRoot)
	{
		pRoot = pNew;
	}
	else
	{
		pCurr = pRoot;        
		while(pCurr)
		{
			pPrev = pCurr;

			if(pCurr->data > pNew->data)
			{
				pCurr = pCurr->pLeft;
			}
			else
			{
				pCurr = pCurr->pRight;
			}
		}
		if(pPrev->data > pNew->data)
		{
			pPrev->pLeft = pNew;
		}
		else
		{
			pPrev->pRight = pNew;
		}
	}    
}


void printTree(pTREE pRoot){
	pTREE pCurr;

	printf(""Mostrando a BTree\n"");
	if(pRoot != NULL)
	{
		printf("" %c "",pRoot->data);

		pCurr = pRoot->pLeft;        
		while(pCurr)
		{
			printf("" %c "",pCurr->data);
			pCurr = pCurr->pLeft;            
		}

		pCurr = pRoot->pRight;
		while(pCurr)
		{
			printf("" %c "",pCurr->data);
			pCurr = pCurr->pRight;            
		}
	}
}

void preOrderTree(pTREE pRoot)
{
	if(pRoot)
	{
		printDataAsChar(pRoot);
		preOrderTree(pRoot->pLeft);
		preOrderTree(pRoot->pRight);
	}
}

void inOrderTree(pTREE pRoot)
{
	if(pRoot)
	{
		inOrderTree(pRoot->pLeft);
		printDataAsChar(pRoot);        
		inOrderTree(pRoot->pRight);
	}
}

void posOrderTree(pTREE pRoot)
{
	if(pRoot)
	{
		posOrderTree(pRoot->pLeft);                
		posOrderTree(pRoot->pRight);
		printDataAsChar(pRoot);
	}
}
"
112-26749,ankitpokhrel/academic-c,Eular/sum_of_multiples_of_3_5.c,19,1,17,2347639.4126191502,173150.0,13.558411781692174,1337.0,1319.0,39183.0,13307.0,1618.0,634.0,1340.0,590.0,1500000000,0.0015650929417461,1082014363648.0,0.0153393011839445,0.0796723185368641,"/**
 * Multiples of 3 and 5.
 * https://projecteuler.net/problem=1
 */
#include <stdio.h>

int sum_multiple_of(int num, int limit)
{
    int sum = num;

    for (int i = num * 2; i < limit; i += num) {
        sum += i;
    }

    return sum;
}

int main()
{
    int limit = 1000, operand_first = 3, operand_second = 5;

    int sum = sum_multiple_of(operand_first, limit) + sum_multiple_of(operand_second, limit) - sum_multiple_of(operand_first * operand_second, limit);

    printf(""Sum: %d"",  sum);

    return 0;
}
"
211-10044,pirix/glibc-pirix,wctype/test_wctype.c,67,6,16,2762734.30790745,363175.0,7.607170097060646,1371.0,1351.0,90433.0,20309.0,1720.0,640.0,1427.0,595.0,1500000000,0.0018418228719383,1082014363648.0,0.0074950092930405,0.039569449711943,"/* Copyright (C) 1996, 1997, 2000 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <wctype.h>

int
main (int argc, char *argv[])
{
  int result = 0;
  wctype_t bit_alnum = wctype (""alnum"");
  wctype_t bit_alpha = wctype (""alpha"");
  wctype_t bit_cntrl = wctype (""cntrl"");
  wctype_t bit_digit = wctype (""digit"");
  wctype_t bit_graph = wctype (""graph"");
  wctype_t bit_lower = wctype (""lower"");
  wctype_t bit_print = wctype (""print"");
  wctype_t bit_punct = wctype (""punct"");
  wctype_t bit_space = wctype (""space"");
  wctype_t bit_upper = wctype (""upper"");
  wctype_t bit_xdigit = wctype (""xdigit"");
  int ch;

  if (wctype (""does not exist"") != 0)
    {
      puts (""wctype return value != 0 for non existing property"");
      result = 1;
    }

  for (ch = 0; ch < 256; ++ch)
    {
#define TEST(test) \
      do								      \
	{								      \
	  if ((is##test (ch) == 0) != (iswctype (ch, bit_##test) == 0))	      \
	    {								      \
	      printf (""`iswctype' class `%s' test ""			      \
		      ""for character \\%o failed\n"", #test, ch);	      \
	      result = 1;						      \
	    }								      \
	  if ((is##test (ch) == 0) != (isw##test (ch) == 0))		      \
	    {								      \
	      printf (""`isw%s' test for character \\%o failed\n"",	      \
		      #test, ch);					      \
	      result = 1;						      \
	    }								      \
	 }								      \
      while (0)

      TEST (alnum);
      TEST (alpha);
      TEST (cntrl);
      TEST (digit);
      TEST (graph);
      TEST (lower);
      TEST (print);
      TEST (punct);
      TEST (space);
      TEST (upper);
      TEST (xdigit);
    }

  if (result == 0)
    puts (""All test successful!"");
  return result;
}
"
369-631,ILyoan/gdb,gdb/testsuite/gdb.python/py-block.c,32,1,22,1874989.4807115,169057.0,11.090868760240628,1139.0,1129.0,38452.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.001249992987141,1082014363648.0,0.0134155935572026,0.0785172440760147,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2010-2012 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see  <http://www.gnu.org/licenses/>.
*/



int block_func (void)
{
  int i = 0;
  {
    double i = 1.0;
    double f = 2.0;
    {
      const char *i = ""stuff"";
      const char *f = ""foo"";
      const char *b = ""bar"";
      return 0; /* Block break here.  */
    }
  }
}


int main (int argc, char *argv[])
{
  block_func ();
  return 0; /* Break at end. */
}
"
371-15068,bszcz/c,mem_dump.c,23,3,15,5766235.2919578,190127.0,30.328333166777995,1476.0,1448.0,43030.0,15618.0,1650.0,647.0,1370.0,603.0,1500000000,0.0038441568613052,1082014363648.0,0.0153791939072304,0.0728072568544536,"// Copyright (c) 2012-2013 Bartosz Szczesny <bszcz@bszcz.org>
// This program is free software under the MIT license.

#include <stdio.h>
#include <stdlib.h>

int main(void) {
	const int N = 10;
	int arr[N];
	for (int i = 0; i < N; i++) {
		const int mul = 9;
		arr[i] = mul * i;
	}

	FILE* file = fopen(""mem.dump"", ""wb"");
	fwrite(arr, sizeof(int), N, file);
	fclose(file);

	for (int i = 0; i < N; i++) {
		arr[i] = 0;
	}

	file = fopen(""mem.dump"", ""rb"");
	fread(arr, sizeof(int), N, file);
	fclose(file);

	for (int i = 0; i < N; i++) {
		printf(""arr[%d] = %d\n"", i, arr[i]);
	}

	return 0;
}
"
163-34477,guoshen/ProjEuler,Q4/q4.c,50,2,26,74521093.7457159,646084960.0,0.1153425595915435,1373.0,1353.0,114924417.0,96933720.0,1638.0,638.0,1357.0,595.0,1500000000,0.0496807291638106,1082014363648.0,4.219259337038275e-06,1.995675058730456e-05,"/** Problem 4: A palindromic number reads the same both ways. 
The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.

Find the largest palindrome made from the product of two 3-digit numbers.


See Question @: https://projecteuler.net/problem=4
Solved by: Shengyuan Guo in 2013
**/

#include<string.h>
#include<stdio.h>
#include<stdlib.h>


int PalindromeThreeDigitProduct ();
int isPalindromeHelper(char *,int, int);

int main()
{
	printf(""Largest 3 digit Palindrome is %d"",PalindromeThreeDigitProduct());
}
int isPalindrome(char * str)
{


    int len= strlen(str);
    int startindex=0;
    int endindex=len-1;

    return isPalindromeHelper(str, startindex, endindex);


}

int isPalindromeHelper(char * str,int startindex, int endindex)
{

    if(str[startindex]!=str[endindex])
        return 0;
    else if(startindex>=endindex)
        return 1;
    else
    {
        isPalindromeHelper(str, startindex+1, endindex-1);
    }
}


int PalindromeThreeDigitProduct ()
{

    int startingPt=999;
    long int palindrome=0;
    char tempstr[100];
	int i,j;
    for(i=startingPt; i>=100; i--)
    {
        for(j=startingPt; j>=100; j--)
        {
            sprintf(tempstr,""%ld"",i*j);

            if(isPalindrome(tempstr))
            {
                if(palindrome<i*j)
                    palindrome=i*j;
            }
        }
    }
    return palindrome;
}"
206-297,ffallrain/2x2x2-rubiks-puzzle,tree_2x2.c,118,3,71,17381557633.518238,3639231503.0,4.776161565613926,1294.0,1287.0,1033629865.0,643944814.0,302262.0,33391019.0,1522.0,33284501.0,1500000000,11.58770508901216,1082014363648.0,7.092156676134379e-07,0.0399262726354014,"#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define  PATH_L 100
#define  CUBE_L 24
#define  PATH_STOP 65535

int L_value = 11;


void initial(int * cube){
    int i;
    for(i=0;i<CUBE_L;i++){
        cube[i]=i/4;
    }
    return;
}

void cube_copy(int * a, int * b){
    int i;
    for(i=0;i<CUBE_L;i++)
        b[i]=a[i];
}

void four_swap(int* a,int *b , int * tu ,int type) {
    if ( type==1 ) 
        b[tu[0]]=a[tu[1]], b[tu[1]]=a[tu[2]], b[tu[2]]=a[tu[3]], b[tu[3]]=a[tu[0]];
    else if (type==0) 
        b[tu[0]]=a[tu[3]], b[tu[3]]=a[tu[2]], b[tu[2]]=a[tu[1]], b[tu[1]]=a[tu[0]];
    else if (type==2) 
        b[tu[0]]=a[tu[2]], b[tu[2]]=a[tu[0]], b[tu[1]]=a[tu[3]], b[tu[3]]=a[tu[1]];
}

int R_T1[4]={8,9,11,10};
int R_T2[4]={1,7,19,15};
int R_T3[4]={5,17,13,3};
void R_raw (int * a , int * b ,int type) {
    four_swap(a,b,R_T1,type);
    four_swap(a,b,R_T2,type);
    four_swap(a,b,R_T3,type);
}
void R  (int * a , int * b ) {
    R_raw(a,b,0);
}
void R2 (int * a , int * b ) {
    R_raw(a,b,2);
}
void R_r(int * a , int * b ) {
    R_raw(a,b,1);
}

int U_T1[4]={5,4,6,7}   ;
int U_T2[4]={1,20,16,9} ;
int U_T3[4]={0,21,17,8} ;
void U_raw (int * a , int * b ,int type) {
    four_swap(a,b,U_T1,type);
    four_swap(a,b,U_T2,type);
    four_swap(a,b,U_T3,type);
}
void U  (int * a , int * b ) {
    U_raw(a,b,0);
}
void U2 (int * a , int * b ) {
    U_raw(a,b,2);
}
void U_r(int * a , int * b ) {
    U_raw(a,b,1);
}

int F_T1[4]={0,1,3,2};
int F_T2[4]={5,10,14,20};
int F_T3[4]={4,8,15,22};
void F_raw (int * a , int * b ,int type) {
    four_swap(a,b,F_T1,type);
    four_swap(a,b,F_T2,type);
    four_swap(a,b,F_T3,type);
}
void F  (int * a , int * b ) {
    F_raw(a,b,0);
}
void F2 (int * a , int * b ) {
    F_raw(a,b,2);
}
void F_r(int * a , int * b ) {
    F_raw(a,b,1);
}

typedef void (*turn_type)(int * a, int *b);
turn_type  Turn[9]={R,U,F,R_r,U_r,F_r,R2,U2,F2};
turn_type  Rev[9] ={R_r,U_r,F_r,R,U,F,R2,U2,F2};
//char       TurnStr[9][3]={""R"",""U"",""F"",""R'"",""U'"",""F'"",""R2"",""U2"",""F2""};
int        Free=9;

typedef struct CUBE_TREE TREE;
struct CUBE_TREE {
    TREE * mother;
    TREE * daughter[6];
    int    cube[CUBE_L];
    int    sex;
    int    depth;
};

#define MAX_DEPTH 9
int add_leaf(TREE* pm){
    int turntype;
    int dn=0;
    TREE * pd  ;

    if (pm->depth>=MAX_DEPTH)
        return 0;
    for(turntype=0 ; turntype<Free ; turntype++){
        if (turntype%3==pm->sex%3)
            continue;
        pd = (TREE *)malloc(sizeof(TREE));
        pm->daughter[dn]=pd;
        pd->mother=pm;
        pd->sex=turntype;
        pd->depth=pm->depth+1;
        cube_copy(pm->cube,pd->cube);
        Turn[turntype](pm->cube,pd->cube);
        add_leaf(pd);
        dn++;
    }
    return 1;
}

int main(int argc , char * argv[]) {
    int i;
    TREE * ptree;
    TREE * pd;
    
    ptree = ( TREE *)malloc(sizeof(TREE));
    ptree->mother = NULL;
    ptree->depth  = 0;
    ptree->sex    = 1;
    initial(ptree->cube);
    add_leaf(ptree);
    sleep(10);

}
    
"
255-32234,Ju2ender/C-Exercise,the-c-programming-language/chapter1/1-8-arguments.c,19,1,13,1418463.1872921,169061.0,8.390243758170127,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0009456421248614,1082014363648.0,0.0134152761429306,0.0785563462891999,"/*!
 * 1.8 参数 - 传值调用
 */

#include <stdio.h>

int power(int x, int y)
{
    int product;

    // 用 y 次幂做循环次数的控制，而不用引入临时变量 i
    // 因为 y 传递进函数后，函数操作的是 y 的副本，并不会影响调用处实际参数的值。
    for (product = 1; y > 0; --y)
    {
        product = product * x;
    }

    return product;
}

int main()
{
    power(2, 20);

    return 0;
}
"
135-13575,JasonVann/ComputerArchitecture,CS61C/L4/Upcase.c,16,1,15,1547986.6415262,175181.0,8.836494825352064,1331.0,1312.0,39685.0,13593.0,1625.0,637.0,1344.0,595.0,1500000000,0.0010319910943508,1082014363648.0,0.0150872526130116,0.0788505574533578,"#include <stdio.h>

char *upcase(char *str) {
    char dst;
    char *dp = &dst;
    while (*str) {
        char c = *str++;        
        if (c >= 'a' && c <= 'z') c += 'A' - 'a';
        *dp-- = c;
    }
    printf(""dp = %s\n"", dp);
    return dp;
}

int main(void) {
    char str[] = ""Nice weather today!"";
    printf(""str= %s\n"", str);
    printf(""up = %s\n"", upcase(str));
}

"
305-15481,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.base/breakpoint-shadow.c,20,1,20,1903248.01951635,169063.0,11.257625855450335,1139.0,1129.0,38452.0,12698.0,1567.0,588.0,1316.0,547.0,1500000000,0.0012688320130109,1082014363648.0,0.0134151174414271,0.0785532746823069,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2008-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
main (void)
{
  volatile int i;
  
  i = 1;	/* break-first */
  i = 2;	/* break-second */

  return 0;
}
"
157-23116,xgqin/guet_c,src/lab2/example_02.c,61,4,27,1825263.1416543,182224.0,10.01658947229783,1323.0,1306.0,41760.0,14985.0,1638.0,642.0,1349.0,597.0,1500000000,0.0012168420944362,1082014363648.0,0.0144272982702607,0.0744735218962023,"/*
 * File name : example_01.c
 * Description : 
 * Date : Fri Oct 31 14:49:07 CST 2014
 * Author : xgqin@guet.edu.cn 
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Defines the length for each line in menu */
#define MENU_LENGTH 40
/* Defines the sperator characeter in seperator line */
#define SEPERATOR_CHAR '='

void print_menu_item(const char * menu_text, int align, int new_line)
{
	int text_len;
	int prefix_num, i;

	text_len = strlen(menu_text);
	prefix_num = (MENU_LENGTH - text_len) / 2;
	
	if (align == 1)
	{
		for (i = 0; i < prefix_num; i++)
		{
			putchar(' ');
		}
	}
	
	printf(""%s"", menu_text);

	for (i = 0; i < prefix_num; i++)
	{
		putchar(' ');
	}

	if (new_line == 1)
	{
		putchar('\n');
	}
}

void print_seperator_line()
{
	int i;

	for (i = 0; i < MENU_LENGTH; i++)
	{
		putchar(SEPERATOR_CHAR);
	}

	putchar('\n');
}

void print_menu_choice()
{
	print_menu_item(""Please input your choices (1-5):"", 0, 0);
}

void print_menu()
{
	print_menu_item(""Menu"", 1, 1);
	print_seperator_line();

	print_menu_item(""1. Input the student's names and scores"", 0, 1);
	print_menu_item(""2. Search scores of some students"", 0, 1);
	print_menu_item(""3. Modify scores of some students"", 0, 1);
	print_menu_item(""4. List all students' scores"", 0, 1);
	print_menu_item(""3. Quit the system"", 0, 1);

	print_seperator_line();

	print_menu_choice();
}

int main ()
{
	print_menu();
	return 0;
}
"
158-24742,danielmapar/TheCProgrammingLanguage,src/Chapter-2/Extra/CharacterConstant.c,36,1,27,2237884.3277692497,175860.0,12.72537245536222,1362.0,1340.0,39847.0,13819.0,1628.0,666.0,1345.0,619.0,1500000000,0.0014919228851795,1082014363648.0,0.0153644944842488,0.0793426005291991,"/*
 ============================================================================
 Name        : CharacterConstant.c
 Author      : Daniel Marchena Parreira
 Email       : danielmapar@gmail.com
 Date        : 22/12/2013
 Version     : 0.1
 Copyright   : GNU General Public License Version 2
 Description : The value of character constant '\0'
 ============================================================================
 */
#include <stdio.h>

#define MAXLINE 1000

int main(void)
{
	int i = 0;
	char array[MAXLINE];
	char array_2[] = {'1','2','3','4','5', '\0'};
	enum test { FIRST = 1, SECOND = 2 };
	/*
	 * This will initialized the first value to zero, and all subsequent
	 * values to 0. If you put a 1 between the curly braces, it would
	 * initialize the first value to 1, and all subsequent values to 0.
	 */
	int array_3[] = {0};

	printf(""%d\n\n\n"", SECOND);

	while(i < MAXLINE)
	{
		array[i] = '1';
		i++;
	}
	/* same null character value */
	array[i] = '\0';

	printf(""%s\n\n\n"", array);
	printf(""%s\n\n\n"", array_2);
	printf(""%d"", '\0'); /* decimal value is 0 */

	return 0;
}
"
340-21526,EvtimPavlov/c-programming-2014-2015-homework,B/07_Vanessa_Stoinova/Homework_3/task_3.c,26,3,15,1755513.13441245,198589.0,8.839930711167286,1343.0,1324.0,41434.0,14740.0,1626.0,639.0,1345.0,596.0,1500000000,0.0011703420896083,1082014363648.0,0.0134297468641264,0.0748744970983017,"#include<stdio.h>

int main () {

   int num , twinPrimes[20], br, simplNum[50],i=0,a=0;
    for(num = 2; num <= 300 ; num = num +1) {
       for(br = 2; br <= num ; br= br+1) {
           if(num % br == 0) {
              break;
            }
       }
       if(br == num) {
         simplNum[i] = num;
         i = i + 1;
         if(a > 18) {
            break;
         }
         if(i > 1 && simplNum[i-1] - simplNum[i-2] == 2) {
            twinPrimes[a] = simplNum[i-2];
            twinPrimes[a+1] = simplNum[i-1];
            a = a + 2;
         }
       }
    }
    for(br = 0; br < a; br = br + 2) {
       printf(""(%d, %d)\n"", twinPrimes[br], twinPrimes[br+1]);
    }
    return 0;
}
"
212-23245,harryjackson/doc,c/printf_format_columns.c,18,1,21,1589148.07252575,225977.0,7.029657885537024,1357.0,1336.0,48808.0,18974.0,1631.0,638.0,1351.0,596.0,1500000000,0.0010594320483505,1082014363648.0,0.0119171420100275,0.0621994039715558,"#include <stdio.h>
#include <string.h>
#include <stdlib.h>

  int main(void) {
    int i = 0;
    printf(""c1 c2 c3 c4 c5 c6 c7 c8 c9 c0\n"");
      for(i = 0; i < 10; i++) {
      printf(""%0.2d %0.2d %0.2d %0.2d %0.2d %0.2d %0.2d %0.2d %0.2d %0.2d\n"",
          i, 
          i + 1, 
          i + 2, 
          i + 3,
          i + 4,
          i + 5,
          i + 6,
          i + 7,
          i + 8,
          i + 9
          );
    }
  }

"
377-34220,Eddyding/C,process/main/main.c,24,2,17,2204418.182373,189782.0,11.61552728920551,1355.0,1335.0,43990.0,15680.0,1721.0,697.0,1374.0,655.0,1500000000,0.001469612121582,1082014363648.0,0.0141741577178025,0.0745265627618568,"/*
 =====================================================================================
        Filename:  main.c
     	Description:  
        Version:  1.0
        Created:  2016年07月04日 08时42分54秒
        Revision:  none
        Compiler:  gcc
        Author:  Eddyding (), 920398694@qq.com
    	Organization:  BUAA G306
 =====================================================================================
 */

#define aaa

#include<stdio.h>

int main(int argc,char *argv[],char *envp[]){

    printf(""argc is %d\n"",argc);

    printf(""###ARGV#####\n"");
    while(*argv){
    printf(""%s\n"",*argv++);
    }   
   printf(""###ENVP######\n"");
    
    while(*envp){
    printf(""%s\n"",*envp++);
    }   
 return 0;
}
"
043-28598,zhangxiaoyuan/interview,src/linux_api/multi_thread/thread_create.c,54,3,27,15053904362.954199,197950.0,75728.8072189947,1530.0,1499.0,45029.0,16909.0,1677.0,716.0,1379.0,672.0,1500000000,10.035936241969466,1082014363648.0,0.0153018438999747,0.071749168523362,"#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

void print_message_function (void *ptr);

int main()
{
    int tmp1, tmp2; 
    int i;
    void *retval;
    pthread_t thread1, thread2;
    char *message1 = ""thread1"";
    char *message2 = ""thread2"";

    int ret_thrd1, ret_thrd2;

    ret_thrd1 = pthread_create(&thread1, NULL, (void *)&print_message_function, (void *) message1);
    ret_thrd2 = pthread_create(&thread2, NULL, (void *)&print_message_function, (void *) message2);

    // 线程创建成功，返回0,失败返回失败号
    if (ret_thrd1) {
        printf(""线程1创建失败\n"");
    } else {
        printf(""线程1创建成功\n"");
    }

    if (ret_thrd2) {
        printf(""线程2创建失败\n"");
    } else {
        printf(""线程2创建成功\n"");
    }
    
    for(i = 0; i < 5; i++)
    {
	      printf(""main thread : %d\n"", i);
    }

    //同样，pthread_join的返回值成功为0
    tmp1 = pthread_join(thread1, &retval);
    printf(""thread1 return value(retval) is %d\n"", (int)retval);
    printf(""thread1 return value(tmp) is %d\n"", tmp1);
    if (tmp1) {
        printf(""cannot join with thread1\n"");
    }
    printf(""thread1 end\n"");

    tmp2 = pthread_join(thread2, &retval);
    printf(""thread2 return value(retval) is %d\n"", (int)retval);
    printf(""thread2 return value(tmp) is %d\n"", tmp1);
    if (tmp2) {
        printf(""cannot join with thread2\n"");
    }
    printf(""thread2 end\n"");

    for(i = 0; i < 10; i++)
    {
	     printf(""mani thread wait...\n"");
    }	

}

void print_message_function( void *ptr ) {
    int i = 0;
    for (i; i<5; i++) {
        printf(""%s:%d\n"", (char *)ptr, i);
    }

    sleep(10);
}
"
208-17160,Amztion/Algorithm,Archived/algorithms/MinNumberInRotatedArray.c,74,3,43,2112978.25444485,173972.0,12.145506173407217,1344.0,1326.0,39427.0,13389.0,1626.0,633.0,1345.0,591.0,1500000000,0.0014086521696299,1082014363648.0,0.0153472972662267,0.0794266888821569,"#include <stdio.h>
/**


**/

int findMinNumberInRotatedArray(int *array, int low, int high){
    if(array == NULL || low < 0 || high <= 0 || high <= low ){
        return -1;
    }
    if(high - low == 1){
        return high;
    }
    int medium = (low + high)/2;
    int position;

    if(array[medium] >= array[low]){
        position = findMinNumberInRotatedArray(array, medium, high);
    }else if(array[medium] <= array[low]){
        position = findMinNumberInRotatedArray(array, low, medium);
    }

    return position;
}

int findMinNumberInRotatedArray_loop(int *array, int low, int high){
    if(array == NULL || low < 0 || high < 0 || high < low ){
        return -1;
    }
    int medium;
    while(high - low > 1){
        medium = (high + low)/2;
        if(array[medium] >= array[low]){
            low = medium;
        }else if(array[medium] <= array[low]){
            high = medium;
        }
    }

    return high;
}

int findMinNumberInRotatedArray_improved(int *array, int length){
    int low = 0;
    int high = length - 1;
    int medium = low; //防止前个元素旋转到数组后面，此时依旧是顺序的。low 就是我们需要的元素
    while(array[low] >= array[high]){ //旋转后第一个元素一定大于等于最后一个元素。当未旋转时此条件不满足
        medium = (low + high)/2;
        if(high - low == 1){
            medium = high;
            break;
            //low 一直指向前半部分，high 一直指向后半部分，当两者相邻时，high 指向的就是最小值
        }
        //防止 10111， 11101 这种情况出现, 如果出现则只能遍历查找
        if(array[low] == array[high] && array[low] == array[medium]){
            int min = array[low];
            for(int i = low; i <= high; ++i){
                if(array[i]<min){
                    min = array[i];
                }
            }
            return min;
        }
        if(array[medium] >= array[low]){
            low = medium;
        }else if(array[medium] <= array[low]){
            high = medium;
        }
    }
    return medium;
}

int main(int argc, const char *argv[])
{
    //int array[] = {3,4,5,1,2};
    //int array[] = {3,3,3,3,3,3,3,3, 1,1,1,1,1,2,2};
    //int position = findMinNumberInRotatedArray(array, 0, 4);
    //
    //int position = findMinNumberInRotatedArray_loop(array, 0, 4);

    int array[] = {1,1,1,0,1};
    int position = findMinNumberInRotatedArray_improved(array, 5);
    printf(""%d\n"", position);
    return 0;
}
"
200-8496,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.base/normal.c,18,1,15,1688358.0246939,169083.0,9.917318713294652,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0011255720164626,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2013-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* This test is just a normal return 0.  */

int
main (int argc, char *argv[])
{
  return 0;
}
"
047-849,mioux/test-randomness,C-srand-rand/main.c,35,3,21,1357466905.4942205,1013397110.0,1.3395211922402266,1395.0,1372.0,230814840.0,149815728.0,1673.0,642.0,1380.0,599.0,1500000000,0.904977936996147,1082014363648.0,2.73042025943808e-06,1.1281279962780078e-05,"#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define DEFAULT_MAX 1000000

int main(int argc, char** argv)
{
	int i, rnd, max;
	int vals[10];
	
	printf(""Init tableau.\n"");
	
	for (i = 0; i < 10; ++i)
	{
		vals[i] = 0;
	}
	
	max = DEFAULT_MAX;
	
	printf(""Lecture argument si present.\n"");
	
	if (argc == 2)
	{
		max = atoi(argv[1]);
		printf(""%d\n"", max);
		if (max <= 0)
		{
			max = DEFAULT_MAX;
		}
	}
	
	srand(time(NULL));
	
	for (i = 0; i < max; ++i)
	{
		rnd = rand() % 10;
		
		printf(""\r%d%%"", i * 100 / max);
		fflush(stdout);
		
		vals[rnd]++;
	}
	
	printf(""\r"");
	
	for (i = 0; i < 10; ++i)
	{
		printf(""Ecart %d => %d\n"", i, vals[i] - (max / 10));
	}
	
	return EXIT_SUCCESS;
}"
294-4547,ActiveState/code,recipes/C/576772_a_list/recipe-576772.c,43,2,33,2402899.5539992503,178640.0,13.45106918943126,1336.0,1317.0,40406.0,14166.0,1617.0,641.0,1339.0,597.0,1500000000,0.0016019330359995,1082014363648.0,0.0148510971786833,0.0768525984021109,"#include <stdlib.h>
#include <stdio.h>

#define null 0

//define the node structure
struct ilist{
    int elem;
    struct ilist *next;
};


//allocate the memory of target
void createNode(struct ilist **node, int elem){
    struct ilist *temp= malloc(sizeof(struct ilist));
    temp->elem = elem;
    temp->next = null;
   
    /* we cannot change the value of node, because the subroutine is running on a frame, within a copy of the actual parameters are created
     * if node is changed here, what changed is the copy
     * but we can change the value referenced by node, as the referenced values could be actually be changed.
     
     * everything is pass by value
     */
    *node = temp;
   
    return;
}


int main(int argc, char **argv){
    //construct a list
    struct ilist *list = null;
        struct ilist *visitor = null;
   
    int i = 7;
    while(i>0){
        if(list == null){
            createNode(&list, i);
           
            visitor = list;
           
        }
        else{
            struct ilist *temp = null;
            createNode(&temp, i);
           
           
            list->next = temp;
            list = temp;
       
        }
       
        i--;
    }
   
    //visit the list
   
    while(visitor != null){
        printf(""%d\n"",visitor->elem);
        visitor = visitor->next;
    }
   
    return 0;
}
"
227-23419,ARCCN/hcprobe,src/bench/ethertest.c,126,2,65,375680443.5979575,426702490.0,0.8804271167951234,1329.0,1308.0,100017874.0,66627541.0,1638.0,700.0,1352.0,657.0,1500000000,0.250453629065305,1082014363648.0,6.179949875614741e-06,2.6085326139936104e-05,"#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <netdb.h>
#include <assert.h>

#define BIGEND16(num) \
    (uint16_t)(((num) >> 8) | ((num) << 8))

#define ETH_HW_ADDR_LEN 6
#define ETH_PAYLOAD_LEN 64
#define ETH_CRC_LEN 4

typedef struct {
    uint8_t dst[ETH_HW_ADDR_LEN];
    uint8_t src[ETH_HW_ADDR_LEN];

    uint16_t ethertype;
//    uint32_t tag;
} ethernet_header_t;

#define ETH_HEADER_LEN (sizeof (ethernet_header_t))
#define p_eth_payload(buff) \
    ((buff) + ETH_HEADER_LEN)
#define p_eth_checksum(buff) \
    ((buff) + ETH_HEADER_LEN + ETH_PAYLOAD_LEN)

#define ETH_FRAME_LEN \
    (ETH_HEADER_LEN + ETH_PAYLOAD_LEN + ETH_CRC_LEN)

typedef void (*Payload) (void *pay_load_buffer, void *opaque);

uint32_t ethernet_crc (const void *frame, size_t frame_len) {
    //TODO: implement
    return 0;
}

void *ethernet_frame ( const ethernet_header_t *header, Payload payload, void *opaque)
{
    void *frame = NULL;
    frame = malloc ( ETH_FRAME_LEN);
    memset (frame,0, ETH_FRAME_LEN );
    if ( (header != NULL) && (header != frame) ) {
        memcpy (frame, header, ETH_HEADER_LEN );
    };
    if (payload != NULL ) {
        payload ( p_eth_payload(frame), opaque);
    }
    *((uint32_t *)p_eth_checksum(frame)) = ethernet_crc (frame, ETH_FRAME_LEN);
    return frame;
}

#define IP_ADDR_LEN 4

typedef struct {
    uint8_t     ver_ihl;
    uint8_t     dscp_ecn;
    uint16_t    totlen;
    uint16_t	id;
    uint16_t	flag_off;
    uint8_t 	ttl;
    uint8_t 	protocol;
    uint16_t	checksum;
    uint8_t	    src[IP_ADDR_LEN];
    uint8_t 	dst[IP_ADDR_LEN];
} ip_header_t; 

#define IP_HEADER_LEN \
    sizeof (ip_header_t)
#define p_ip_payload(buff) \
    ((buff)+IP_HEADER_LEN)
#define IP_PAYLOAD_LEN \
    ETH_PAYLOAD_LEN - IP_HEADER_LEN

uint16_t ip_checksum (const void *buffer, size_t len) {
    register long sum = 0;
    const unsigned short *addr = (const unsigned short*) (buffer);

    while(len > 1){
	    sum += *addr++;
	    len -= 2;
    }

    if (len & 1) {
	    sum += (*addr & 0xff);
    }
    sum = (sum & 65535) + (sum >> 16);
    return ~sum;
}

void ip_packet ( const ip_header_t *header, void *ip_packet_buffer,
        size_t ip_packet_buffer_len, Payload payload, void *opaque) 
{
    ip_header_t *res_header;

    assert (ip_packet_buffer != NULL);
    assert (ip_packet_buffer_len > IP_HEADER_LEN);

    res_header = (ip_header_t *)ip_packet_buffer;

    if (header != NULL) {
        *res_header = *header;
    }
    res_header->checksum = 0;
 
    res_header->checksum = ip_checksum (res_header, IP_HEADER_LEN);
    if (payload != NULL) {
        payload(p_ip_payload(ip_packet_buffer), opaque);
    }

}

struct s_ip_header_opaque {
    ip_header_t *header;
    void *opaque;
    Payload payload;
};

void ip_eth_payload (void *payload, void *opaque) {
    struct s_ip_header_opaque *header_opaque;

    if (opaque != NULL) {
        header_opaque = (struct s_ip_header_opaque *)opaque;
        ip_packet (header_opaque->header,
            payload, ETH_PAYLOAD_LEN, 
            header_opaque->payload, header_opaque->opaque);
    } else {
        ip_packet (NULL,NULL,ETH_PAYLOAD_LEN, NULL, opaque);
    }
}

void zero_payload (void *payload, void *opaque)
{
    size_t len = *(size_t *)opaque;
    memset (payload,0, len);
}

#define PACKETS_NUM 1000000
//        1024*1024/ETH_FRAME_LEN //1 Mb
int main (void) {
    int i;
    void *frame;
    static ip_payload_len = IP_PAYLOAD_LEN;
    ethernet_header_t eth_header = {
        .src = {0x10,0x12,0xA3,0x04,0x05,0x06},
        .dst = {0x07,0x08,0x09,0x0A,0x0B,0x0C},
//        .tag = 0x0000,
        .ethertype = BIGEND16(0x0800), 
    };
    ip_header_t ip_header = {
        .ver_ihl    = 0x45,
        .totlen     = BIGEND16(ETH_PAYLOAD_LEN),
        .id         = 0,
        .flag_off   = 0,
        .ttl        = 1,
        .protocol   = 0x05,
        .src        = {127,0,0,1},
        .dst        = {255,255,255,255},
    };
    struct s_ip_header_opaque ip_header_opaque = {
        .header     = &ip_header,
        .payload    = zero_payload,
        .opaque     = &ip_payload_len,
    };

    for (i=0; i<PACKETS_NUM; ++i) {
        frame = ethernet_frame (&eth_header, ip_eth_payload ,&ip_header_opaque);
        fwrite (frame,ETH_FRAME_LEN,1,stdout);
        free (frame);
    }
}
"
250-27179,chggr/puzzles,easy/reverse_string.c,81,3,41,1780292.8341552,175104.0,10.167055007309942,1358.0,1340.0,39656.0,13489.0,1634.0,638.0,1351.0,593.0,1500000000,0.0011868618894368,1082014363648.0,0.0154079861111111,0.0793301345375858,"#include <stdio.h>

// Task description: Implement a function in C to reverse a null terminated
// string.
//
// Solution: There are multiple ways to solve this task. In the implementation
// below we first calculate the length of the input string and then loop from
// the beginning up to the middle of the string, swapping elements from the
// lower and higher halves. An alternative approach would be to use pointer
// arithmetic. The runtime complexity of both approaches is O(n).

void reverse(char* input) {
    int len = 0;
    while(input[len]) {
        len++;
    }

    char tmp;
    for (int i = 0; i < len / 2; i++) {
        tmp = input[i];
        input[i] = input[len - 1 - i];
        input[len - 1 - i] = tmp;
    }
}

int equal(char* a, char* b) {
    int tmp = 0;
    while (a[tmp] && b[tmp]) {
        if (a[tmp] != b[tmp]) return 0;
        tmp++;
    }
    return !a[tmp] && !b[tmp];
}

int test_equal() {
    return !equal("""", ""abc"") &&
           !equal(""abc"", """") &&
           equal("""", """") &&
           equal(""abc"", ""abc"") &&
           !equal(""abc"", ""abcd"") &&
           !equal(""abcd"", ""abc"") &&
           equal(""abcd"", ""abcd"");
}

int test_reverse_empty() {
    char string[] = """";
    reverse(string);
    return equal("""", string);
}

int test_reverse_single_char() {
    char string[] = ""a"";
    reverse(string);
    return equal(""a"", string);
}

int test_reverse_odd_chars() {
    char string[] = ""abc"";
    reverse(string);
    return equal(""cba"", string);
}

int test_reverse_even_chars() {
    char string[] = ""abcd"";
    reverse(string);
    return equal(""dcba"", string);
}

int main() {
    int counter = 0;
    if (!test_equal()) {
        printf(""String equality test failed!\n"");
        counter++;
    }
    if (!test_reverse_empty()) {
        printf(""Reverse empty string test failed!\n"");
        counter++;
    }
    if (!test_reverse_single_char()) {
        printf(""Reverse single character string test failed!\n"");
        counter++;
    }
    if (!test_reverse_odd_chars()) {
        printf(""Reverse odd characters string test failed!\n"");
        counter++;
    }
    if (!test_reverse_even_chars()) {
        printf(""Reverse even characters string test failed!\n"");
        counter++;
    }
    printf(""%d tests failed.\n"", counter);
}

"
197-23022,bigown/SOpt,C/Algorithm/Pyramid3.c,8,2,12,1704916.4744094,173862.0,11.286071712047486,1267.0,1252.0,39631.0,13483.0,1605.0,634.0,1332.0,592.0,1500000000,0.0011366109829396,1082014363648.0,0.0144885023754471,0.0783785819181383,"#include<stdio.h>

int main(void) {
    for (int row = 0; row < 7; row++) {
        for (int column = 0; column < row; column++) printf(""*"");
        printf(""\n"");
    }
    printf(""\n"");
}

//https://pt.stackoverflow.com/q/171588/101
"
320-483,tfritzon/ohly,sketches/sketch1.c,37,3,20,2352756.2152593,169083.0,13.91479924060964,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0015685041435062,1082014363648.0,0.0134490161636592,0.0785049652044725,"#include <stdlib.h>
#include <stdio.h>

struct Node
{
  short next;
  int value;
};

#define PTR(b, o) (b)+(o)

#define LISTSIZE 32768

void
traverse(struct Node * list)
{
  struct Node * elem;
  int i;
  int sum;

  for( i= 0; i < 10000; i++ )
    {
      sum= 0;
      elem= list;
      while( elem->next > 0 )
	{
	  sum++;
	  elem= PTR(list, elem->next);
	}
    }
}  

int
main( int argc, char ** argv )
{
  int i;
  struct Node * list= calloc( LISTSIZE, sizeof(struct Node));
  struct Node * elem;
  int sum= 0;

  for( i= 0; i < LISTSIZE; i++ )
    {
      elem= list+i;
      elem->value= i;
      elem->next= (elem+1)-list;
    }

  traverse(list);
}
"
017-241,aosm/gccfast,gcc/testsuite/gcc.dg/bitfld-4.c,29,2,18,1588983.2284300502,169057.0,9.399096162832654,1139.0,1129.0,38452.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010593221522867,1082014363648.0,0.0134155935572026,0.0785172440760147,"/* { dg-do run } */
/* { dg-options """" } */

/* Check bitfields and non-bitfields are aligned & sized similarly.

   Copyright (C) 2002 Free Software Foundation Inc
   Contributed by Nathan Sidwell <nathan@codesourcery.com>
*/

#include <limits.h>
#include <stdio.h>

static int fail;

#define CHECK1(N, T) do { \
  typedef struct Field_##N { char c; T f; } Field_##N; \
  typedef struct BitField_##N { char c; T f : sizeof (T) * CHAR_BIT; } BitField_##N; \
  if (sizeof (Field_##N) != sizeof (BitField_##N)) { \
    fail = 1; printf (""sizeof %s failed\n"", #T); \
  } \
  if (__alignof__ (Field_##N) != __alignof__ (BitField_##N)) { \
    fail = 1; printf (""__alignof__ %s failed\n"", #T); \
  } \
} while (0)

#define CHECK(N, T) do { \
  CHECK1(N, T); \
  CHECK1 (s##N, signed T); \
  CHECK1 (u##N, unsigned T); \
} while (0)
 
int main ()
{
  
  CHECK (c, char);
  CHECK (s, short);
  CHECK (i, int);
  CHECK (l, long);
  CHECK (ll, long long);
  
  return fail;
}
"
218-14785,NicoleRobin/glibc,posix/bug-regex23.c,25,1,20,1974964.28154405,272791.0,7.239842956695785,1965.0,1880.0,62148.0,23515.0,1822.0,717.0,1447.0,667.0,1500000000,0.0013166428543627,1082014363648.0,0.0140950397923685,0.0543174999708158,"/* Test we don't segfault on invalid UTF-8 sequence.
   Copyright (C) 2004-2017 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Jakub Jelinek <jakub@redhat.com>, 2004.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#include <locale.h>
#include <regex.h>
#include <string.h>

int
main (void)
{
  regex_t r;

  memset (&r, 0, sizeof (r));
  setlocale (LC_ALL, ""de_DE.UTF-8"");
  regcomp (&r, ""[-a-z_0-9.]+@[-a-z_0-9.]+"", REG_EXTENDED | REG_ICASE);
  regexec (&r, ""\xe7\xb7\x95\xe7\x97"", 0, NULL, 0);
  return 0;
}
"
195-15137,kjensenxz/euler,prob21.c,30,2,26,129329398.50725219,370353593.0,0.3492051932111267,1341.0,1322.0,39180.0,13305.0,1618.0,636.0,1340.0,593.0,1500000000,0.0862195990048348,1082014363648.0,7.190425718375575e-06,0.0797751738591978,"/* Project Euler Problem 21
 * Amicable numbers
 * 2016, Kenneth Jensen <kenneth@jensen.cf>
 * --
 * Let d(n) be defined as the sum of proper divisors of n (numbers less than n
 * which divide evenly into n).
 * If d(a) = b and d(b) = a, where a ≠ b, then a and b are an amicable pair
 * and each of a and b are called amicable numbers.
 * For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44,
 * 55 and 110; therefore d(220) = 284. The proper divisors of 284 are 1, 2, 4, 
 * 71 and 142; so d(284) = 220.
 * Evaluate the sum of all the amicable numbers under 10000.
 */

#include <stdio.h>

int d(int n) {
	int i, sum;
	for (i = 1, sum = 0; i <= n/2; ++i) {
		if (n % i == 0) { 
			sum += i;
		}
	}
	return sum;
}

int main(void) {
	int a, b, sum = 0;
	for (a = 1; a < 10000; ++a) {
		b = d(a);
		if (d(b) == a && a != b) sum += a;
	}
	printf(""%d\n"", sum);
}
"
182-15934,higgsd/euler,c/30.c,19,2,18,8228878.6070421,35595983.0,0.231174343464542,1338.0,1319.0,39181.0,13307.0,1618.0,636.0,1341.0,593.0,1500000000,0.0054859190713614,1082014363648.0,7.464325398739515e-05,0.0797896662094193,"/* 443839 */
#include <string.h>
#include <stdio.h>

#define POW5(n) ((n) * (n) * (n) * (n) * (n))

int main(int argc, char **argv)
{
    int n, nn, s, ss = 0;
    for (n = 10; n < POW5(9) * 6; n++)
    {
        s = 0;
        nn = n;
        while (nn != 0)
        {
            s += POW5(nn % 10);
            nn /= 10;
        }
        if (n == s)
            ss += n;
    }
    printf(""%d\n"", ss);
    return 0;
}
"
087-4394,efortuna/AndroidSDKClone,ndk_experimental/tests/build/issue38441-Elf32_auxv_t/jni/issue38441-Elf32_auxv_t.c,20,1,22,2086817.9854005,169100.0,12.340727380248374,1142.0,1132.0,38461.0,12696.0,1567.0,584.0,1317.0,544.0,1500000000,0.001391211990267,1082014363648.0,0.0134476641040804,0.0784252399476122,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <elf.h>

Elf32_auxv_t auxv32;
Elf64_auxv_t auxv64;

int main()
{
}
"
250-23303,crtc-demos/gcc-ia16,gcc/testsuite/gcc.dg/torture/pr78482.c,43,3,19,1534681.41797925,170004.0,9.027322886520317,1148.0,1139.0,38671.0,12782.0,1577.0,586.0,1323.0,546.0,1500000000,0.0010231209453195,1082014363648.0,0.013452624644126,0.0783627776806017,"/* PR tree-optimization/78482 */
/* { dg-do run } */

short a = 65531;
int b = 3, f;
signed char c, d;
static void fn1(int p1)
{
  short e;
  b = f;
  if (f > p1 && p1)
    L:
	for (e = 0; 0;)
	  ;
  else if (d) b = 0 >= b;
  for (; e <= 3; e++)
    {
      if (b)
	continue;
      b = 3;
      goto L;
    }
}

__attribute__((noinline, noclone))
int bar (const char *x, int y)
{
  asm volatile ("""" : ""+g"" (x), ""+g"" (y) : : ""memory"");
  if (y == 2)
    __builtin_abort ();
  return 0;
}

int main()
{
  for (; c >= 0; c--)
    {
      if (!b)
	{
	  bar(""%d\n"", 2);
	  continue;
	}
      fn1(a);
    }
  return 0;
}
"
027-14045,fanbrightup/November-December,week47/11-22/ex7.c,19,2,16,1921863.17872245,178037.0,10.78953251290462,1349.0,1330.0,40242.0,13960.0,1626.0,636.0,1345.0,595.0,1500000000,0.0012812421191483,1082014363648.0,0.0150474339603565,0.0775248145824877,"#include <stdio.h>

int main(int argc, char *argv[])
{
    int i = 0;

    // go through each string in argv
    // why am I skipping argv[0]?
    for(i = 0; i < argc; i++) {
        printf(""arg %d: %s\n"", i, argv[i]);
    }

    // let's make our own array of strings
    char *states[] = {
        ""California"", ""Oregon"",
        ""Washington"", ""Texas""
    };
    int num_states = 4;

    for(i = 0; i < num_states; i++) {
        printf(""state %d: %s\n"", i, states[i]);
    }

    return 0;
}
"
164-23727,b3h3moth/L-LP,src/C/C_lang/pointers/pointers_and_compound_literals.c,16,1,15,1839213.0732535499,182261.0,10.0910946390067,1357.0,1335.0,41200.0,14616.0,1629.0,631.0,1349.0,592.0,1500000000,0.0012261420488357,1082014363648.0,0.0147700275977855,0.0752651569442453,"#include <stdio.h>
#include <stdlib.h>

struct db {
    int id;
    int year;
};

int main(void) {
    // Inizializzazione del puntatore 'ptr' al primo elemento dell'array
    int *ptr = (int []){10, 20, 30, 40, 50, 60, 70, 80, 90, 100};

    while(*ptr > 0) {
        printf(""%3d\n"", *ptr);
        ptr++;
    }

    // Un compund literal per l'inizializzazione di un puntatore a struttura
    struct db *data = &(struct db){1, 2016};

    printf(""id: %d\tyear: %d\n"", data->id, data->year);

    return(EXIT_SUCCESS);
}
"
357-12046,EvtimPavlov/c-programming-2014-2015-homework,B/13_Ivo_gerginov/homework_3/task_3.c,32,3,17,1535776.653327,169083.0,9.082971085206674,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.001023851102218,1082014363648.0,0.0134490161636592,0.0785049652044725,"#include <stdio.h>

int main()
{
	int prim1,prim2,x,i,m,n;
	prim1=1;prim2=3;
	for(x=1;x<=10;x++)
	{
		m=0;n=0;i=1;
		while(i<=prim1 || m==0)
		{
			i++;
			if(prim1&i==0)
			{
				m++;	
			}

		}
		i=1;
		while(i<=prim2 || n==0)
		{
			i++;
			if(prim2&i==0)
			{
				n++;
			}
		}
		if(m==0 && n==0)
		{
			printf(""(%d - %d)"",prim1,prim2);	
		}
		prim1++;prim2++;
	}
	return 0;
}
"
397-26862,carlobar/uclinux_leon3_UD,user/klibc/usr/klibc/tests/malloctest2.c,48,2,28,422488004.9005151,1421628213.0,0.2971860013304336,1573.0,1446.0,116262727.0,470961421.0,18723767.0,7639732.0,2382.0,1099618.0,1500000000,0.2816586699336767,1082014363648.0,2.123621332492506e-06,0.0467717465188437,"#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#define NCYCLES 32768
#define NSLOTS  4096

struct slot {
	char *ptr;
	size_t size;
};

struct slot s[NSLOTS];

int main(void)
{
	size_t sp, sq;
	char *p, *ep, *q, *eq;
	int r, i, j;
	int ok;
	int err = 0;

	for (r = 0; r < NCYCLES; r++) {
		i = lrand48() % NSLOTS;

		if (s[i].ptr) {
			free(s[i].ptr);
			printf(""Freed     %8zu bytes at %p\n"", s[i].size,
			       s[i].ptr);
			s[i].ptr = NULL;
			s[i].size = 0;
		} else {
			sp = lrand48();	/* 32-bit random number */
			sp >>= 12 + (lrand48() % 20);

			s[i].size = sp;
			s[i].ptr = p = malloc(sp);
			ep = p + sp;
			ok = 1;
			for (j = 0; j < NSLOTS; j++) {
				q = s[j].ptr;
				if (i != j && q) {
					sq = s[j].size;
					eq = q + sq;

					if ((p < q && ep > q)
					    || (p >= q && p < eq)) {
						ok = 0;
						err = 1;
						break;
					}
				}
			}
			printf(""Allocated %8zu bytes at %p, ok = %d\n"", sp, p,
			       ok);

			if (p)
				memset(p, 0xee, sp);	/* Poison this memory */
		}
	}
	return err;
}
"
228-4779,caballa/crab-llvm,tests/test-term-5.c,13,1,18,2478543.08690865,170462.0,14.540149710785984,1143.0,1135.0,38734.0,12788.0,1581.0,590.0,1325.0,547.0,1500000000,0.0016523620579391,1082014363648.0,0.0133636822282972,0.0784713326346027,"int foo(int* p, const int* A, const int* B, int n) {
  int numNonZero = n - 1;
  while (numNonZero--) {
    *p *= (*A++) * (*B++);
  }
  return *p;
}
int main(int argc, char** argv) {
  int p;
  int A[10];
  int B[10];
  return (int)foo(&p, &A, &B, 10);
}
"
208-24427,lolosssss/leetcode,c/191_number_of_1_bits.c,27,1,18,2093113.49317425,173289.0,12.078741293446209,1338.0,1320.0,39173.0,13297.0,1618.0,634.0,1340.0,590.0,1500000000,0.0013954089954495,1082014363648.0,0.0153385385108114,0.079702687249857,"/**
 * Description : Number of 1 Bits
 *               Write a function that takes an unsigned integer and returns
 *               the number of '1' bits it has (also known as the Hamming
 *               weight).
 * Author      : Evan Lau
 * Date        : 2016/03/01
 */

#include <stdio.h>
#include <inttypes.h>

int hammingWeight(uint32_t n)
{
    int count = 0;

    for (int i = 0; i < 32; i++)
    {
        if (n & 0x0001)
        {
            count++;
        }

        n >>= 1;
    }

    return count;
}

int main()
{
    uint32_t a = 11;

    printf(""%d\n"", hammingWeight(a));

    return 0;
}
"
282-7781,ryukinix/sorting-vector,Examples/merge-sort.c,70,5,42,1710047.9453802002,188859.0,9.054622760895697,1395.0,1371.0,42825.0,15504.0,1643.0,644.0,1360.0,600.0,1500000000,0.0011400319635868,1082014363648.0,0.0146458469016567,0.0728111231120026,"/* programa_merge_01.c */
#include <stdio.h>
#include <stdlib.h>

void mergesort(int v[],int inicio,int fim) ;
void intercala(int v[], int inicio, int meio, int fim);

void mergesort(int v[],int inicio,int fim) 
{
   int meio;
   if (inicio < fim)
   {
      meio = (inicio+fim)/2;
      mergesort(v,inicio,meio);
      mergesort(v,meio+1,fim);
      intercala(v, inicio, meio, fim);
   }
   return ;
}

void intercala(int v[], int inicio, int meio, int fim)
{
   /* intercalacao no vetor temporario auxiliar */
   int i,j,k, *auxiliar;
   auxiliar = (int *) calloc(sizeof(int) , fim-inicio+1);
   i = inicio;
   j = meio+1;
   k = 0;
   while( i<=meio && j<=fim ) 
   {
      if( v[i] <= v[j] )
      {
         auxiliar[k] = v[i];
         i++;
      } 
      else 
      {
         auxiliar[k] = v[j];
         j++;
      }
      k++;
   }

   while( i <= meio )
   {
      auxiliar[k] = v[i];
      i++; 
      k++;
   }

   while( j <= fim )
   {
      auxiliar[k] = v[j];
      j++;
      k++;
   }

   /* copia vetor intercalado para o vetor original */
   for( i = 0; i< (fim - inicio)+1; i++)
   {
      v[inicio + i] = auxiliar[i];
   }

   free(auxiliar);

   return;
}

int main(void)
{
   int iContador;
   int aMerge[] = { 9,1,11,13,17,19,21,1,3,89,24 };

   mergesort(aMerge, 0, 10);

   printf(""Ordenado:"");
   for(iContador = 0; iContador < 11; iContador++)
   {
      printf("" %d "", aMerge[iContador] );
   }

   printf(""\n"");

   return 0;
}
"
232-5707,guonaihong/recycle_bin,libc/ho_string/ho_strncat.c,18,2,18,1425379.30514655,174560.0,8.165553391384051,1303.0,1282.0,39560.0,13438.0,1625.0,638.0,1344.0,593.0,1500000000,0.0009502528700977,1082014363648.0,0.0148086617781851,0.0792482735197554,"#include <stdio.h>
#include <string.h>

char *ho_strncat(char *s1, char *s2, int n) {
    char *s = s1;

    while (*s1)
        s1++;

    while (n-- && (*s1++ = *s2++) != '\0') {
    }
    *s1 = '\0';
    return s;
}

int main() {

    char buf[128] = ""0123"";
    buf[0] = 0;
    printf(""%s\n"", ho_strncat(buf, ""aaa"", 2));

    strcpy(buf, ""0123"");
    buf[0] = 0;
    printf(""%s\n"", strncat(buf, ""aaa"", 2));
    return 0;
}
"
311-26821,aterribili/learn-c-the-hard-way,ex11/ex11.c,28,4,17,1661327.7839496,181911.0,9.132636289174377,1360.0,1336.0,41022.0,14491.0,1627.0,638.0,1345.0,597.0,1500000000,0.0011075518559664,1082014363648.0,0.014820434168357,0.0757840505827463,"#include<stdio.h>

int main(int argc, char *argv[]){
	int i = argc-1;
	while(i >= 0) {
		printf(""arg %d: %s\n"", i, argv[i]);
		i--;
	}

	char *states[] = {""California"", ""Oregon"", ""Washington"", ""Texas""};

	int num_states = 4;
	int y = 0;
	while(y < num_states) {
		printf(""state %d: %s\n"", y, states[y]);
		y++;
	}

	int copies = 0;
	while(copies < argc) {
		if (copies==3){
			break;
		}
		states[copies] = argv[copies];
		copies++;
	}

	int r = 0;
	while(r < num_states) {
		printf(""state %d: %s\n"", r, states[r]);
		r++;
	}

	return 0;
}
"
124-7426,EvtimPavlov/c-programming-2014-2015-homework,A/22_Pavel_Kostadinov/homework_3/task_1.c,27,3,15,1718672.9237436,218780.0,7.854662217752994,1333.0,1312.0,50461.0,20494.0,1626.0,640.0,1346.0,598.0,1500000000,0.0011457819491624,1082014363648.0,0.0120897705457537,0.059333380311465,"#include <stdio.h>
int main()
{
int broqch;
char a;
for(broqch=97;broqch<123;broqch++)
 {
 a = broqch;
 printf(""%c"",a);
 printf(""-"");
 printf(""%d\n"",broqch);
 }
for(broqch=65;broqch<91;broqch++)
 {
 a = broqch;
 printf(""%c"",a);
 printf(""-"");
 printf(""%d\n"",broqch);
 }
for(broqch=48;broqch<58;broqch++)
 {
 a = broqch;
 printf(""%c"",a);
 printf(""-"");
 printf(""%d\n"",broqch);
 }
return 0;
}
"
203-22133,EvilusPL/prog_podst,tablice/dlugosc.c,17,2,19,2233338.1930365,175381.0,12.73420724023697,1358.0,1334.0,39708.0,13573.0,1628.0,637.0,1346.0,595.0,1500000000,0.001488892128691,1082014363648.0,0.0153494392208962,0.0789399598355886,"#include <stdio.h>

int dlugosc(char tab1[]) {
    int i = 0;
    while (*tab1++!='\0') i++;
    /*while (tab1[i]!=0) {
        printf(""tab[%d] = %c\n"", i, tab1[i]);
        i++;
    }*/
    i--;
    return i;
}

int main(void) {
    char s[100] = ""Ala ma kota"";
    char d[100] = ""Wlazl kotek na plotek"";
    printf(""Dlugosc ciagu s(%s) = %d\n"", s, dlugosc(s));
    printf(""Dlugosc ciagu d(%s) = %d\n"", d, dlugosc(d));
    return 0;
}
"
027-29273,JasonVann/ComputerArchitecture,CS61C/Labs/Lab1/ll_cycle.c,56,2,24,1585667.83647975,177130.0,8.951995709366003,1335.0,1316.0,40096.0,13933.0,1631.0,647.0,1350.0,604.0,1500000000,0.0010571118909865,1082014363648.0,0.0149664088522554,0.078328305169446,"#include <stdio.h>

typedef struct node {
	int value;
	struct node *next;
} node;

int ll_has_cycle(node *head) {
	/* your code here */
    node* hare = head;
    node* tortoise = head;
    while (hare != NULL && hare->next != NULL){
        hare = hare->next->next;
        tortoise = tortoise->next;
        if (hare == tortoise)
            return 1;
    }
    return 0;   
}

void test_ll_has_cycle(void) {
	int i;
	node nodes[25]; //enough to run our tests
	for(i=0; i < sizeof(nodes)/sizeof(node); i++) {
		nodes[i].next = 0;
		nodes[i].value = 0;
	}
	nodes[0].next = &nodes[1];
	nodes[1].next = &nodes[2];
	nodes[2].next = &nodes[3];
	printf(""First list has no cycle, ll_has_cycle says it has %s cycle\n"", ll_has_cycle(&nodes[0])?""a"":""no"");
  
	nodes[4].next = &nodes[5];
	nodes[5].next = &nodes[6];
	nodes[6].next = &nodes[7];
	nodes[7].next = &nodes[8];
	nodes[8].next = &nodes[9];
	nodes[9].next = &nodes[10];
	nodes[10].next = &nodes[4];
	printf(""Second list has a cycle, ll_has_cycle says it has %s cycle\n"", ll_has_cycle(&nodes[4])?""a"":""no"");
  
	nodes[11].next = &nodes[12];
	nodes[12].next = &nodes[13];
	nodes[13].next = &nodes[14];
	nodes[14].next = &nodes[15];
	nodes[15].next = &nodes[16];
	nodes[16].next = &nodes[17];
	nodes[17].next = &nodes[14];
	printf(""Third list has a cycle, ll_has_cycle says it has %s cycle\n"", ll_has_cycle(&nodes[11])?""a"":""no"");
  
	nodes[18].next = &nodes[18];
	printf(""Fourth list has a cycle, ll_has_cycle says it has %s cycle\n"", ll_has_cycle(&nodes[18])?""a"":""no"");
  
	nodes[19].next = &nodes[20];
	nodes[20].next = &nodes[21];
	nodes[21].next = &nodes[22];
	nodes[22].next = &nodes[23];
	printf(""Fifth list has no cycle, ll_has_cycle says it has %s cycle\n"", ll_has_cycle(&nodes[19])?""a"":""no"");
  
	printf(""Length-zero list has no cycle, ll_has_cycle says it has %s cycle\n"", ll_has_cycle(NULL)?""a"":""no"");
}

int main(void) {
  test_ll_has_cycle();
  return 0;
}

"
385-16144,AlexanderS/linux-minidisc,libnetmd/utilities/hex-to-char.c,40,2,31,2090433.0303891,173233.0,12.0671754226966,1152.0,1143.0,39531.0,13118.0,1609.0,591.0,1346.0,548.0,1500000000,0.0013936220202594,1082014363648.0,0.0132480532000254,0.077760261353492,"/* hex-to-char.c 
 *      Copyright (C) 2002, 2003 Marc Britten
 *      
 * This file is part of libnetmd.
 *
 * libnetmd is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * Libnetmd is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
 */
#include <stdio.h>

int main(int argc, char* argv[])
{
	int i = 0;
	int j = 0;
	int iLen = 0;
	int iData = 0;
	char hex[5];

	if(argc < 2)
		return 0;

	for(j = 1; j < argc; j++)
	{
		sprintf(hex, ""0x%s"", argv[j]);
		iData = strtol(hex, NULL, 16);

		if(iData < 30)
			printf("". "");
		else
			printf(""%c "", iData);
	}
	
	printf(""\n"");
	return 0;
}
"
219-4263,zhangrxiang/learn-c,basic/csapp/exercise/ex8-5.c,22,2,17,4505111786.769703,174079.0,25879.697068572317,1345.0,1325.0,39448.0,13443.0,1622.0,635.0,1343.0,593.0,1500000000,3.0034078578464687,1082014363648.0,0.0153378638434274,0.0792762473766803,"/*
 * 8.5
 *
 * 编写一个 sleep 的包装函数，叫做 snooze，带有下面的接口
 *
 * unsigned int snooze(unsigned int secs);
 *
 * 除了 snooze 函数会打印出一条信息来描述进程实际休眠了多长时间外，它和 sleep 函
 * 数的行为完全一样：
 *
 * Slept for 4 of 5 secs.
 */

#include <stdio.h>

#include <unistd.h>

unsigned int snooze(unsigned int secs) {
    unsigned sleep_secs;

    sleep_secs = sleep(secs);

    printf(""Slept for %u of %u secs\n"", secs - sleep_secs, secs);
    return sleep_secs;
}

int main(void) {
    snooze(3);
    return 0;
}
"
049-15810,cheesechoi/Triton,samples/crackmes/crackme_regex_fsm.c,50,1,32,1629633.01409025,172485.0,9.447969388642491,1291.0,1273.0,39023.0,13223.0,1606.0,637.0,1332.0,593.0,1500000000,0.0010864220093935,1082014363648.0,0.0148650607299185,0.079776442215672,"/*
 * From: http://doar-e.github.io/blog/2013/08/24/regular-expressions-obfuscation-under-the-microscope
 */

#include <stdio.h>
#include <string.h>

unsigned char check(char* s) {
  unsigned int state = 0, i = 0;

  do {
    switch(state) {
      case 0:
        if(*s == 'H')
          state = 1;
        break;

      case 1:
        if(*s == 'i')
          state = 2;
        else
          return 0;
        break;

      case 2:
        if(*s == '-')
          state = 3;
        else
          return 0;
        break;

      case 3:
      case 4:
      case 5:
      case 6:
        if(*s >= '0' && *s <= '9')
          state++;
        else
          return 0;
        break;

      case 7:
        return 1;
    }
  } while(*s++);

  return 0;
}


int main(int argc, char *argv[])
{
  if(argc != 2) {
      printf(""./fsm <string>\n"");
      return 0;
  }

  if(check(argv[1]))
    printf(""Good boy.\n"");
  else
    printf(""Bad boy.\n"");

  return 1;
}
"
300-15597,Gurgel100/gcc,gcc/testsuite/gcc.dg/ipa/ipcp-self-recursion-1.c,38,2,22,1549637.8764509999,170045.0,9.113099473668736,1152.0,1143.0,38680.0,12800.0,1576.0,586.0,1323.0,545.0,1500000000,0.001033091917634,1082014363648.0,0.0134964274162721,0.0782828282828282,"/* { dg-do run } */
/* { dg-options ""-O3 -fno-early-inlining""  } */

int array[128];

volatile int v = 0;
volatile int blah = 0;
volatile int counter = 0;

int __attribute__((noipa))
obscured_one ()
{
  return 1;
}

static void
f (int c, int l)
{
  int i;
  for (i = 0; i < c; i++)
    array[i] = 455;

  counter++;
  if (counter > 6)
    __builtin_abort ();

  v = l;
  if (l > 0)
    f (c, l - 1);
  blah = l;
}

int
main (int argc, char *argv[])
{
  int i;
  for (i = 0; i < 100; i++)
    {
      counter = 0;
      f (0, 5);
      if (obscured_one ())
	break;
    }

  return 0;
}
"
373-8733,EZchip/gdb,gdb/testsuite/gdb.python/py-section-script.c,39,1,24,2257219.63215615,169061.0,13.351506261053702,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0015048130881041,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2010-2012 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* Put the path to the pretty-printer script in .debug_gdb_scripts so
   gdb will automagically loaded it.  */

#define DEFINE_GDB_SCRIPT(script_name) \
  asm(""\
.pushsection \"".debug_gdb_scripts\"", \""MS\"",@progbits,1\n\
.byte 1\n\
.asciz \"""" script_name ""\""\n\
.popsection \n\
"");

DEFINE_GDB_SCRIPT (""py-section-script.py"")

struct ss
{
  int a;
  int b;
};

void
init_ss (struct ss *s, int a, int b)
{
  s->a = a;
  s->b = b;
}

int
main ()
{
  struct ss ss;

  init_ss (&ss, 1, 2);

  return 0;      /* break to inspect struct and union */
}
"
062-31221,fgd99/risuto,hello_world.c,22,3,19,2237989.80005085,175346.0,13.226147160471296,1297.0,1279.0,39834.0,13638.0,1607.0,640.0,1332.0,596.0,1500000000,0.0014919932000339,1082014363648.0,0.0146909538854607,0.0780782465589467,"#include <stdio.h>

/**
 * HelloWorld example
 * compilation: cc -std=c99 -Wall hello_world.c -o hello_world
 **/

void sayNTimesCoucou(unsigned int n) {
  for (int i = 0; i < n; i++) {
    puts(""Coucou"");
  }
}

int main(int argc, char** argv) {
  puts(""Hello, world!"");
  for (int i = 0; i < 5; i++) {
    puts(""Hello"");
  }
  int i = 0;
  while (i < 10) {
    puts(""Loop Iteration"");
    ++i;
  }
  sayNTimesCoucou(3);
  return 0;
}
"
352-19521,krichter722/gcc,libgomp/testsuite/libgomp.oacc-c-c++-common/reduction-cplx-flt.c,79,4,42,1967464.5736813499,180319.0,10.911018805561255,1158.0,1150.0,39369.0,13020.0,1583.0,587.0,1327.0,545.0,1500000000,0.0013116430491209,1082014363648.0,0.0127995385954891,0.0771536009467636,"
#if !defined(__hppa__) || !defined(__hpux__)
#include <complex.h>
#endif

/* Single float has 23 bits of fraction. */
#define FRAC (1.0f / (1 << 20))
typedef float _Complex Type;

int close_enough (Type a, Type b)
{
  Type diff = a - b;
  float mag2_a = __real__(a) * __real__ (a) + __imag__ (a) * __imag__ (a);
  float mag2_diff = (__real__(diff) * __real__ (diff)
		     + __imag__ (diff) * __imag__ (diff));

  return mag2_diff / mag2_a < (FRAC * FRAC);
}

#define N 100

static int __attribute__ ((noinline))
vector (Type ary[N], Type sum, Type prod)
{
  Type tsum = 0, tprod = 1;

#pragma acc parallel vector_length(32) copyin(ary[0:N])
  {
#pragma acc loop vector reduction(+:tsum) reduction (*:tprod)
    for (int ix = 0; ix < N; ix++)
      {
	tsum += ary[ix];
	tprod *= ary[ix];
      }
  }

  if (!close_enough (sum, tsum))
    return 1;

  if (!close_enough (prod, tprod))
    return 1;

  return 0;
}

static int __attribute__ ((noinline))
worker (Type ary[N], Type sum, Type prod)
{
  Type tsum = 0, tprod = 1;

#pragma acc parallel num_workers(32) copyin(ary[0:N])
  {
#pragma acc loop worker reduction(+:tsum) reduction (*:tprod)
    for (int ix = 0; ix < N; ix++)
      {
	tsum += ary[ix];
	tprod *= ary[ix];
      }
  }

  if (!close_enough (sum, tsum))
    return 1;

  if (!close_enough (prod, tprod))
    return 1;

  return 0;
}

static int __attribute__ ((noinline))
gang (Type ary[N], Type sum, Type prod)
{
  Type tsum = 0, tprod = 1;

#pragma acc parallel num_gangs (32) copyin(ary[0:N])
  {
#pragma acc loop gang reduction(+:tsum) reduction (*:tprod)
    for (int ix = 0; ix < N; ix++)
      {
	tsum += ary[ix];
	tprod *= ary[ix];
      }
  }

  if (!close_enough (sum, tsum))
    return 1;

  if (!close_enough (prod, tprod))
    return 1;

  return 0;
}

int main (void)
{
  Type ary[N], sum = 0, prod = 1;

  for (int ix = 0; ix < N;  ix++)
    {
      float frac = ix * (1.0f / 1024) + 1.0f;
      
      ary[ix] = frac + frac * 2.0i - 1.0i;
      sum += ary[ix];
      prod *= ary[ix];
    }

  if (vector (ary, sum, prod))
    return 1;
  
  if (worker (ary, sum, prod))
    return 1;

  if (gang (ary, sum, prod))
    return 1;

  return 0;
}
"
363-15751,djsilenceboy/LearnTest,Cpp_Test/ArbitraryPrecision/src/ArbitraryPrecision.c,65,3,23,201165313.5996312,1564703167.0,0.1285645208897311,1376.0,1356.0,367160160.0,246867433.0,1635.0,714.0,1355.0,663.0,1500000000,0.1341102090664208,1082014363648.0,1.74601806759173e-06,7.11205823611904e-06,"/*
 ============================================================================
 Name        : ArbitraryPrecision.c
 Author      : 
 Version     :
 Copyright   : Your copyright notice
 Description :  In computer science, arbitrary-precision arithmetic, also called bignum arithmetic, multiple precision arithmetic, or sometimes infinite-precision arithmetic, indicates that calculations are performed on numbers whose digits of precision are limited only by the available memory of the host system.
                This contrasts with the faster fixed-precision arithmetic found in most arithmetic logic unit (ALU) hardware, which typically offers between 8 and 64 bits of precision.
 ============================================================================
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define DATA_SIZE 1205

void printArray(unsigned char data[], int n, int maxPos)
{
	int i;

	printf("", %4d: "", maxPos);

	for (i = n - 1; i >= 0; i--)
	{
		if (i <= maxPos)
		{
			printf(""%d"", data[i]);
		}
		else
		{
			printf("" "");
		}
	}

	printf(""\n"");
}

void ArbitraryPrecision_n(int base, int n)
{
	unsigned char data[DATA_SIZE];
	int i, j, maxPos;

	memset(data, 0, sizeof(data));

	data[0] = 1;
	maxPos = 0;

	for (i = 0; i < n; i++)
	{
		printf(""%4d"", i);

		int increase = 0;

		for (j = 0; j <= maxPos; j++)
		{
			int temp = 0;

			if (data[j] > 0)
			{
				temp = data[j] * base;
			}

			temp += increase;

			increase = (temp >= 10) ? 1 : 0;

			data[j] = temp % 10;
		}

		if (increase == 1)
		{
			data[++maxPos] = 1;
		}

		printArray(data, sizeof(data), maxPos);

		if ((maxPos + 1) == DATA_SIZE)
		{
			break;
		}
	}

}

int main(void)
{
	ArbitraryPrecision_n(2, 4000);

	return EXIT_SUCCESS;
}
"
337-20021,freudshow/learnc,Pointers.On.C/ch13/echo.c,14,1,21,2361559.3090653,170004.0,13.89119667772523,1146.0,1137.0,38671.0,12779.0,1577.0,586.0,1324.0,546.0,1500000000,0.0015743728727102,1082014363648.0,0.0134290957859815,0.0783867832847424,"/*
** A program to print its command line arguments.
*/
#include <stdio.h>
#include <stdlib.h>

int
main( int argc, char **argv )
{
	/*
	** Print arguments until a NULL pointer is reached (argc is
	** not used).  The program name is skipped.
	*/
	while( *++argv != NULL )
		printf( ""%s\n"", *argv );
	return EXIT_SUCCESS;
}
"
096-4197,xiaoehaier/leetcode,Valid-Sudoku.c,30,2,20,1644963.16574505,231348.0,7.110340266611339,1346.0,1324.0,51029.0,21148.0,1627.0,642.0,1347.0,598.0,1500000000,0.0010966421104967,1082014363648.0,0.0115410550339747,0.0583842498302783,"

int isValidSudoku(char board[9][9]) {
    static short line[2][9];
    static short block[3][3];
    short mask[] = {1,2,4,8,16,32,64,128,256};
    
    for(int i=0; i<9; ++i)
        for(int j=0; j<9; ++j){
            printf(""%d--%d\n"", i, j);
            if(board[i][j] == '.')
                continue;
            
            if(line[0][i]&mask[board[i][j]-49])
                return 0;
            else 
                line[0][i] |= mask[board[i][j]-49];
                
            if(line[1][j]&mask[board[i][j]-49])
                return 0;
            else 
                line[1][j] |= mask[board[i][j]-49];
                
            if(block[i/3][j/3]&mask[board[i][j]-49])
                return 0;
            else 
                block[i/3][j/3] |= mask[board[i][j]-49];
        }
        
    return 1;
    
}

int main(int argc, char const *argv[])
{
    char board[9][9] = {""..4...63."", ""........."", ""5......9."", ""...56...."", ""4.3.....1"", ""...7....."", ""...5....."", ""........."", "".........""};
    printf(""%d"", isValidSudoku(board));
    return 0;
}"
382-31745,logicchains/ArrayAccessBench,C.c,50,3,36,1591406014.7479177,2775187858.0,0.5732722332341654,1359.0,1352.0,333041965.0,777014992.0,83251818.0,83250718.0,83251569.0,83250683.0,1500000000,1.0609373431652784,1082014363648.0,9.768708061276046e-07,0.2999889202982582,"#define _POSIX_C_SOURCE 200809L
 
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>
 
#define NUM_RECORDS (50 * 1000 * 444)
 
struct CMemoryTrade {
	long TradeId; long ClientId; int VenueCode; int InstrumentCode; long Price; long Quantity; char Side;
};
 
struct CMemoryTrade trades[NUM_RECORDS];
 
void initTrades() {
	for (long i = 0; i < NUM_RECORDS; i++) {
		struct CMemoryTrade *trade = &(trades[i]);
 
		trade->TradeId = i;
		trade->ClientId = 1;
		trade->VenueCode = 123;
		trade->InstrumentCode = 321;
 
		trade->Price = i;
		trade->Quantity = i;
 
		if ((i&1) == 0) {
			trade->Side = 'B';
		} else {
			trade->Side = 'S';
		}
	}
}
 
double getTime(){
	struct timespec spec;
	clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &spec);	
	double s  = spec.tv_sec;
	double ms = spec.tv_nsec;
	return (s*1000 + ms / 1000000);
}
 
void perfRun(int runNum) {	
	double startT = getTime();
	initTrades();

	long buyCost = 0;
	long sellCost = 0;
 
	for (long i = 0; i < NUM_RECORDS; i++) {
		struct CMemoryTrade *trade = &(trades[i]);
		if (trade->Side == 'B') {
			buyCost += trade->Price * trade->Quantity;
		} else {
			sellCost += trade->Price * trade->Quantity;
		}
	}
	double endT = getTime();
	double duration =  endT - startT;
	printf(""%d - duration %d ms\n"", runNum, (int)duration);
	printf(""buyCost = %ld sellCost = %ld\n"", buyCost, sellCost);
}
 
int main() {
	for (int i = 0; i < 5; i++) {
		perfRun(i);
	}
}
"
227-30462,holmescn/practice,leetcode/p1.c,25,2,22,1593767.8981571998,173479.0,9.187088927190034,1229.0,1215.0,39300.0,13288.0,1604.0,632.0,1338.0,590.0,1500000000,0.0010625119321048,1082014363648.0,0.0140881605266343,0.0791815623336122,"#include <assert.h>
#include <stdlib.h>

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* twoSum(int* nums, int numsSize, int target) {
    int *result = (int*)malloc(sizeof(int) * 2);

    for (int i = 0; i < numsSize; ++i) {
        int v2 = target - nums[i];
        for (int j = i+1; j < numsSize; j++) {
            if (nums[j] == v2) {
                result[0] = i;
                result[1] = j;
                break;
            }
        }
    }

    return result;
}

int main(int argc, char** argv) {

    // Case 1
    int input1[] = {2, 7, 11, 15};
    int *r1 = twoSum(input1, 4, 9);
    assert( r1[0] == 0 );
    assert( r1[1] == 1 );

    return 0;
}
"
296-23369,sserg1963/histotest,histo.c,17,4,17,1520035.4391708001,316064.0,4.809263313759239,1340.0,1321.0,70856.0,36555.0,1618.0,640.0,1340.0,597.0,1500000000,0.0010133569594472,1082014363648.0,0.0084191809253822,0.0390555902095688,"#include <stdio.h>

#define PICTURE_WIDTH 4096
#define PICTURE_HEIGHT 4096
#define PICTIRE_Y_DEPTH 256

int main(int argc, char **argv, char **envp)
{
    char y[PICTURE_WIDTH][PICTURE_HEIGHT]={0};
    int histogram_value[PICTIRE_Y_DEPTH]={0};
    int val;

    for (int h=0;h < PICTURE_HEIGHT; ++h)
    {
        for (int w=0; w < PICTURE_WIDTH; ++w)
        {
        val=y[w][h]; // set temporal value for the current pixel
        histogram_value[val]=histogram_value[val]++; //incrementing counter of particular Y
        }
    }
for (int j=0; j < PICTIRE_Y_DEPTH; ++j) printf(""%d"", histogram_value[j]);
printf(""\r\r"");
return 0;
}

"
093-15271,EvtimPavlov/c-programming-2014-2015-homework,B/06_Valentin_Stoyanov/homework_3/task_1.c,17,3,12,1758646.56921465,223879.0,7.855341501436044,1335.0,1316.0,49661.0,20663.0,1618.0,643.0,1340.0,600.0,1500000000,0.0011724310461431,1082014363648.0,0.0118412178006869,0.0597377851089244,"#include <stdio.h>
int main () {
char c;
int i;
for (i=65;i<91;i+=1) {
c=i;
printf(""%c - %d\n"",c,i);
}
for (i=97;i<123;i+=1) {
c=i;
printf(""%c - %d\n"",c,i);
}
for (i=48;i<58;i+=1) {
c=i;
printf(""%c - %d\n"",c,i);
}
return 0;
}
"
344-20592,emb-team/loongson-gccgo,gcc/testsuite/gcc.dg/pr57233.c,154,2,70,1872273.0455919001,173347.0,10.8007234045008,1207.0,1195.0,39095.0,12958.0,1579.0,592.0,1325.0,552.0,1500000000,0.0012481820303946,1082014363648.0,0.0138565997680952,0.0777668914375732,"/* PR tree-optimization/57233 */
/* { dg-do run { target { ilp32 || lp64 } } } */
/* { dg-options ""-O2"" } */

typedef unsigned V4 __attribute__((vector_size(4 * sizeof (int))));
typedef unsigned V8 __attribute__((vector_size(8 * sizeof (int))));
typedef unsigned V16 __attribute__((vector_size(16 * sizeof (int))));
V4 a, b, g;
V8 c, d, h;
V16 e, f, j;

__attribute__((noinline)) void
f1 (void)
{
  a = (a << 2) | (a >> 30);
}

__attribute__((noinline)) void
f2 (void)
{
  a = (a << 30) | (a >> 2);
}

__attribute__((noinline)) void
f3 (void)
{
  a = (a << b) | (a >> (32 - b));
}

__attribute__((noinline, noclone)) void
f4 (int x)
{
  a = (a << x) | (a >> (32 - x));
}

__attribute__((noinline)) void
f5 (void)
{
  c = (c << 2) | (c >> 30);
}

__attribute__((noinline)) void
f6 (void)
{
  c = (c << 30) | (c >> 2);
}

__attribute__((noinline)) void
f7 (void)
{
  c = (c << d) | (c >> (32 - d));
}

__attribute__((noinline, noclone)) void
f8 (int x)
{
  c = (c << x) | (c >> (32 - x));
}

__attribute__((noinline)) void
f9 (void)
{
  e = (e << 2) | (e >> 30);
}

__attribute__((noinline)) void
f10 (void)
{
  e = (e << 30) | (e >> 2);
}

__attribute__((noinline)) void
f11 (void)
{
  e = (e << f) | (e >> (32 - f));
}

__attribute__((noinline, noclone)) void
f12 (int x)
{
  e = (e << x) | (e >> (32 - x));
}

unsigned
r (void)
{
  static unsigned x = 0xdeadbeefU;
  static unsigned y = 0x12347654U;
  static unsigned z = 0x1a2b3c4dU;
  static unsigned w = 0x87654321U;
  unsigned t = x ^ (x << 11);
  x = y;
  y = z;
  z = w;
  w = w ^ (w >> 19) ^ t ^ (t >> 8);
  return w;
}

void
init (unsigned int *p, int count, int mod)
{
  int i;
  for (i = 0; i < count; i++)
    {
      unsigned int v = r ();
      if (mod)
	v = (v % 31) + 1;
      p[i] = v;
    }
}

void
check (unsigned int *p, unsigned int *q, int count, unsigned int *s, int ss)
{
  int i;
  for (i = 0; i < count; i++)
    {
      if (s)
	ss = s[i];
      if (p[i] != ((q[i] << ss) | (q[i] >> (32 - ss))))
	__builtin_abort ();
    }
}

int
main ()
{
  init ((unsigned int *) &a, 4, 0);
  init ((unsigned int *) &b, 4, 1);
  init ((unsigned int *) &c, 8, 0);
  init ((unsigned int *) &d, 8, 1);
  init ((unsigned int *) &e, 16, 0);
  init ((unsigned int *) &f, 16, 1);
  g = a;
  h = c;
  j = e;
  f1 ();
  f5 ();
  f9 ();
  check ((unsigned int *) &a, (unsigned int *) &g, 4, 0, 2);
  check ((unsigned int *) &c, (unsigned int *) &h, 8, 0, 2);
  check ((unsigned int *) &e, (unsigned int *) &j, 16, 0, 2);
  g = a;
  h = c;
  j = e;
  f2 ();
  f6 ();
  f10 ();
  check ((unsigned int *) &a, (unsigned int *) &g, 4, 0, 30);
  check ((unsigned int *) &c, (unsigned int *) &h, 8, 0, 30);
  check ((unsigned int *) &e, (unsigned int *) &j, 16, 0, 30);
  g = a;
  h = c;
  j = e;
  f3 ();
  f7 ();
  f11 ();
  check ((unsigned int *) &a, (unsigned int *) &g, 4, (unsigned int *) &b, 0);
  check ((unsigned int *) &c, (unsigned int *) &h, 8, (unsigned int *) &d, 0);
  check ((unsigned int *) &e, (unsigned int *) &j, 16, (unsigned int *) &f, 0);
  g = a;
  h = c;
  j = e;
  f4 (5);
  f8 (5);
  f12 (5);
  check ((unsigned int *) &a, (unsigned int *) &g, 4, 0, 5);
  check ((unsigned int *) &c, (unsigned int *) &h, 8, 0, 5);
  check ((unsigned int *) &e, (unsigned int *) &j, 16, 0, 5);
  return 0;
}
"
279-32549,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.mi/mi-syn-frame.c,48,4,25,1509631534.5726907,171379.0,8808.731139754578,1164.0,1153.0,39087.0,12983.0,1587.0,589.0,1329.0,546.0,1500000000,1.0064210230484605,1082014363648.0,0.0135197427922907,0.0777991165738429,"#include <signal.h>
#include <unistd.h>
#include <stdlib.h>

void foo (void);
void bar (void);

void subroutine (int);
void handler (int);
void have_a_very_merry_interrupt (void);

int
main ()
{
  foo ();   /* Put a breakpoint on foo() and call it to see a dummy frame */


  have_a_very_merry_interrupt ();
  return 0;
}

void
foo (void)
{
}

void 
bar (void)
{
  *(char *)0 = 0;    /* try to cause a segfault */

  /* On MMU-less system, previous memory access to address zero doesn't
     trigger a SIGSEGV.  Trigger a SIGILL.  Each arch should define its
     own illegal instruction here.  */
#if defined(__arm__)
  asm("".word 0xf8f00000"");
#elif defined(__TMS320C6X__)
  asm("".word 0x56454313"");
#else
#endif

}

void
handler (int sig)
{
  subroutine (sig);
}

/* The first statement in subroutine () is a place for a breakpoint.  
   Without it, the breakpoint is put on the while comparison and will
   be hit at each iteration. */

void
subroutine (int in)
{
  int count = in;
  while (count < 100)
    count++;
}

void
have_a_very_merry_interrupt (void)
{
  signal (SIGALRM, handler);
  alarm (1);
  sleep (2);  /* We'll receive that signal while sleeping */
}

"
115-14021,Eddyding/C,nanosleep/nanosleep.c,18,1,16,2252394941.9846764,174294.0,12922.963159948134,1300.0,1279.0,39476.0,13398.0,1626.0,634.0,1346.0,591.0,1500000000,1.501596627989784,1082014363648.0,0.0147968375273962,0.0793773877520142,"#include <stdio.h>
#include <time.h> /* Needed for struct timespec */

int main()
{
   struct timespec tim, tim2;
   tim.tv_sec = 1;
   tim.tv_nsec = 500000000L;

   //if(nanosleep(&tim , &tim2) < 0 )   
 //  {
   //   printf(""Nano sleep system call failed \n"");
   //   return -1;
  // }
   if(nanosleep(&tim , NULL) < 0 )   
   {
      printf(""Nano sleep system call failed \n"");
      return -1;
   }

   printf(""Nano sleep successfull \n"");

   return 0;
}
"
207-2896,utds3lab/pemu,plugins/glibc-2.13-new/iconvdata/tst-loading.c,152,8,79,182240538.06625304,260861611.0,0.698610030434873,1161678.0,6244.0,46649120.0,33152565.0,1024951.0,634836.0,12726.0,5006.0,1500000000,0.1214936920441687,1082014363648.0,0.0044771708474958,0.0210210974868513,"/* Tests for loading and unloading of iconv modules.
   Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 2000.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#include <iconv.h>
#include <mcheck.h>
#include <stdio.h>
#include <stdlib.h>


/* How many load/unload operations do we do.  */
#define TEST_ROUNDS	5000


enum state { unloaded, loaded };

struct
{
  const char *name;
  enum state state;
  iconv_t cd;
} modules[] =
{
#define MODULE(Name) { .name = #Name, .state = unloaded }
  MODULE (ISO-8859-1),
  MODULE (ISO-8859-2),
  MODULE (ISO-8859-3),
  MODULE (ISO-8859-4),
  MODULE (ISO-8859-5),
  MODULE (ISO-8859-6),
  MODULE (ISO-8859-15),
  MODULE (EUC-JP),
  MODULE (EUC-KR),
  MODULE (EUC-CN),
  MODULE (EUC-TW),
  MODULE (SJIS),
  MODULE (UHC),
  MODULE (KOI8-R),
  MODULE (BIG5),
  MODULE (BIG5HKSCS)
};
#define nmodules (sizeof (modules) / sizeof (modules[0]))


/* The test data.  */
static const char inbuf[] =
""The first step is the function to create a handle.\n""
""\n""
"" - Function: iconv_t iconv_open (const char *TOCODE, const char\n""
""          *FROMCODE)\n""
""     The `iconv_open' function has to be used before starting a\n""
""     conversion.  The two parameters this function takes determine the\n""
""     source and destination character set for the conversion and if the\n""
""     implementation has the possibility to perform such a conversion the\n""
""     function returns a handle.\n""
""\n""
""     If the wanted conversion is not available the function returns\n""
""     `(iconv_t) -1'.  In this case the global variable `errno' can have\n""
""     the following values:\n""
""\n""
""    `EMFILE'\n""
""          The process already has `OPEN_MAX' file descriptors open.\n""
""\n""
""    `ENFILE'\n""
""          The system limit of open file is reached.\n""
""\n""
""    `ENOMEM'\n""
""          Not enough memory to carry out the operation.\n""
""\n""
""    `EINVAL'\n""
""          The conversion from FROMCODE to TOCODE is not supported.\n""
""\n""
""     It is not possible to use the same descriptor in different threads\n""
""     to perform independent conversions.  Within the data structures\n""
""     associated with the descriptor there is information about the\n""
""     conversion state.  This must not be messed up by using it in\n""
""     different conversions.\n""
""\n""
""     An `iconv' descriptor is like a file descriptor as for every use a\n""
""     new descriptor must be created.  The descriptor does not stand for\n""
""     all of the conversions from FROMSET to TOSET.\n""
""\n""
""     The GNU C library implementation of `iconv_open' has one\n""
""     significant extension to other implementations.  To ease the\n""
""     extension of the set of available conversions the implementation\n""
""     allows storing the necessary files with data and code in\n""
""     arbitrarily many directories.  How this extension has to be\n""
""     written will be explained below (*note glibc iconv\n""
""     Implementation::).  Here it is only important to say that all\n""
""     directories mentioned in the `GCONV_PATH' environment variable are\n""
""     considered if they contain a file `gconv-modules'.  These\n""
""     directories need not necessarily be created by the system\n""
""     administrator.  In fact, this extension is introduced to help users\n""
""     writing and using their own, new conversions.  Of course this does\n""
""     not work for security reasons in SUID binaries; in this case only\n""
""     the system directory is considered and this normally is\n""
""     `PREFIX/lib/gconv'.  The `GCONV_PATH' environment variable is\n""
""     examined exactly once at the first call of the `iconv_open'\n""
""     function.  Later modifications of the variable have no effect.\n"";


int
main (void)
{
  size_t count = TEST_ROUNDS;
  int result = 0;

  mtrace ();

  /* Just a seed.  */
  srandom (TEST_ROUNDS);

  while (count--)
    {
      int idx = random () % nmodules;

      if (modules[idx].state == unloaded)
	{
	  char outbuf[10000];
	  char *inptr = (char *) inbuf;
	  size_t insize = sizeof (inbuf) - 1;
	  char *outptr = outbuf;
	  size_t outsize = sizeof (outbuf);

	  /* Load the module and do the conversion.  */
	  modules[idx].cd = iconv_open (""UTF-8"", modules[idx].name);

	  if (modules[idx].cd == (iconv_t) -1)
	    {
	      printf (""opening of %s failed: %m\n"", modules[idx].name);
	      result = 1;
	      break;
	    }

	  modules[idx].state = loaded;

	  /* Now a simple test.  */
	  if (iconv (modules[idx].cd, &inptr, &insize, &outptr, &outsize) != 0
	      || *inptr != '\0')
	    {
	      printf (""conversion with %s failed\n"", modules[idx].name);
	      result = 1;
	    }
	}
      else
	{
	  /* Unload the module.  */
	  if (iconv_close (modules[idx].cd) != 0)
	    {
	      printf (""closing of %s failed: %m\n"", modules[idx].name);
	      result = 1;
	      break;
	    }

	  modules[idx].state = unloaded;
	}
    }

  for (count = 0; count < nmodules; ++count)
    if (modules[count].state == loaded && iconv_close (modules[count].cd) != 0)
      {
	printf (""closing of %s failed: %m\n"", modules[count].name);
	result = 1;
      }

  return result;
}
"
386-27779,wolfdale/Spaghetti-code,Code08/revLL.c,62,4,37,1812872.9425369499,184940.0,9.802487293176164,1348.0,1329.0,41799.0,15043.0,1625.0,640.0,1346.0,597.0,1500000000,0.0012085819616913,1082014363648.0,0.0144749648534659,0.0740297667217902,"#include<stdlib.h>
#include <stdio.h>

struct node{
	int item;
	struct node *next;
};
void insert(struct node **ref , int data){
	struct node *new_node = (struct node *)malloc(sizeof(struct node));
	new_node -> item = data;
	new_node -> next = NULL;
	if(*ref == NULL){
		(*ref) = new_node;
	}
	else{
		new_node -> next = (*ref);
		*ref = new_node;
	}
}
void findMiddle(struct node *ref){
	struct node *fast = ref;
	struct node *slow = ref;
	while((fast !=NULL) && (fast->next !=NULL) ){
		fast = fast->next->next;
		slow = slow->next;
	}
	printf(""Middle %d\n"",slow->item);
}
void reverse(struct node* ref){
	struct node *prev=NULL;
	struct node *curr=ref;
	struct node *next=NULL;
	while(curr !=NULL){
		next = curr->next;
		curr->next = prev;
		prev = curr;
		curr = next;
	}
	printer(prev);
}
void printer(struct node *ref){
	struct node*temp = ref;
	while(temp!=NULL){
		printf(""%d\n"",temp->item);
		temp=temp->next;
	}	
}
int main(void) {
	struct node * root = NULL;
	insert(&root,1);
	insert(&root,2);
	insert(&root,3);
	insert(&root,4);
	insert(&root,5);
	insert(&root,6);
	insert(&root,7);
	struct node * temp = root;
	while(temp!=NULL){
		printf(""%d\n"",temp->item);
		temp=temp->next;
	}
	findMiddle(root);
	reverse(root);
	
	
	return 0;
}
"
088-13105,ChristopherBryan240596/ADS,bubbleSort.c,26,3,24,64274420.728906944,401237092.0,0.1601906236525111,1160.0,1150.0,100211165.0,50457918.0,777878.0,1221.0,1347.0,1067.0,1500000000,0.0428496138192713,1082014363648.0,5.757194551694139e-06,0.0051869499995563,"/*
	ORDENAMIENTO BURBUJA

	+ Todavía hasta 10,000 elementos los ordena en menos de 1 segundo
	+ Recuerda nunca usar esto en la vida real por complejidad O(n^2)
*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ITEMS 10000

void bubbleSort(int Array[], int arraySize){
	int i, j, temp;
	for(i=0; i<arraySize-1; i++)
		for(j=0; j<arraySize-i-1; j++)
			if(Array[j] > Array[j+1]){
				temp = Array[j];
				Array[j] = Array[j+1];
				Array[j+1] = temp;
			}
}

int main(){
	int numbers[ITEMS], i;
	// Semilla para generar valores distintos cada ejecución
	srand(time(NULL));
	// Llenamos el arreglo con números aleatorios
	for(i=0; i<ITEMS; i++)
		numbers[i] = rand();
	// Y ejecutamos el ordenamiento
	bubbleSort(numbers, ITEMS);
	return 0;
}
"
347-19818,bi3mer/WorkSpace,GeneralProblems/C/findMinMax.c,28,2,19,1673102.9609217,174816.0,9.668977667948012,1345.0,1324.0,39594.0,13509.0,1627.0,638.0,1345.0,595.0,1500000000,0.0011154019739478,1082014363648.0,0.0152674812374153,0.079185733386061,"#include <stdio.h>
/*
Find the min and max of an array of integers.

- Colan
*/

int min(int array[],int length){
	int min = array[0];
	for(int i = 1; i < 10;i++)
		if(min > array[i])
			min = array[i];
	return min;
}

int max(int array[], int length){
	int max = array[0];
	for(int i = 1; i < 10;i++)
		if(max < array[i])
			max = array[i];
	return max;
}

int main(){
	int array[10] = {10,40,20,10,1000,-20,-40,-60,7,123412};
	int length = sizeof(array) / sizeof(int);
	/*
	I've learned here that in attempting to build a function all that is passed to the funciton is a pointer to the first element.
	Meaning that a sizeof function really isn't in the cards. I tired a macro with similar results.
	*/
	printf(""Max of array: %i\n"",max(array,length));
	printf(""Min of array: %i\n"",min(array,length));
}"
000-29394,chaohu/Daily-Learning,Foundation-of-CS/ics14_lab1-3/lab1/src/bddcheck/cbit/test/run34.c,28,1,20,1402966.4453118,170603.0,8.223571683968043,1144.0,1136.0,38902.0,12866.0,1590.0,586.0,1331.0,546.0,1500000000,0.0009353109635412,1082014363648.0,0.0133643605329331,0.078291608715809,"#include <stdio.h>
#include <stdlib.h>

int test_trueThreeFourths(int x)
{
    long long int x3 = (long long int) x * 3LL;
    return (int) (x3/4LL);
}

int trueThreeFourths(int x) {
  int xs1 = x >> 1;
  int xs2 = x >> 2;
  /* Compute value from low-order 2 bits */
  int bias = (x >> 31) & 0x3;
  int xl2 = x & 0x3;
  int xl1 = (x & 0x1) << 1;
  int incr = (xl2 + xl1 + bias) >> 2;
  return xs1 + xs2 + incr;
}

int main(int argc, char *argv[])
{
    int i;
    for (i = 1; i < argc; i++) {
	int x = atoi(argv[i]);
	int v1 = trueThreeFourths(x);
	int v2 = test_trueThreeFourths(x);
	printf(""x = %d (0x%x)\n"", x, x);
	printf(""\tref: %d (0x%x)\n"", v2, v2);
	printf(""\tGot: %d (0x%x)\n"", v1, v1);
    }
    return 0;
}

"
212-6960,Eddyding/C,niukewang/link/linklist.c,79,4,43,2060584.37470335,182043.0,11.319215789676065,1348.0,1329.0,41248.0,14664.0,1626.0,637.0,1347.0,594.0,1500000000,0.0013737229164689,1082014363648.0,0.0147053168756832,0.0751895836314208,"#include<stdio.h>
#include<stdlib.h>

typedef int ElemType;

typedef struct node{
	ElemType data;
struct node* link;
}LNode,*LinkList;


LinkList create(int n)
{
	LinkList p,r,list = NULL;
	ElemType a;
	int i;
	for(i=1;i<=n;++i){
	   p = (LinkList)malloc(sizeof(LNode));
	   p->data = i;
		p->link= NULL;
		if(NULL == list)
			list=p; // ç¬¬ä¸ä¸ªèç¹
		else
			r->link = p; // ç¬¬2ä¸ªåä»¥åçèç¹
		r=p;
	}
	return list;
}

void print_list(LinkList L)
{
	if(!L) return;
	while(L!= NULL)
	{ 
		printf(""%d "",L->data);
		L=L->link;
	}
	printf(""\n"");
}

LinkList swap_node(LinkList L)
{
   LinkList h = L,p,r,temp,prior;

	if(!L) return (LinkList)0;
	p=L->link;
	r = p->link;
  while(!p && !r)
	{ 
        temp= r->link;
		if(p== h)
		{ r->link = p;h = r;}
		else { prior->link = r; p->link = temp;r->link = p;}
		prior = p;
		p->link = temp;
		p = temp;
		r = temp->link;
   }
 return h;
}




// Á´±í·´×ª 
LinkList LinkListReverse(LinkList L)
{
	 if(!L) return (LinkList)-1; 
	 
	 LinkList pcur,ptemp;
	 pcur=L->link;
	 L->link=NULL; 
	 // µ¥¸ö½ÚµãÍ¬Ñù¿ÉÒÔÓÃ 
	 while(pcur != NULL )
	 {
	 	ptemp = pcur->link; // ÄÃµ½ÏÂÒ»¸ö½Úµã 
	 	pcur->link = L; // Í·½Úµã´æÔÚpcur->link  
	 	L = pcur; // pcur³ÉÎªÐÂµÄÍ· 
	 	pcur = ptemp; // pcur±ä³ÉÏÂÒ»¸ö½Úµã 
	  } 
	 return L;  // ÐÂµÄÍ· 
}


int main(void)
{
	LinkList L;
    L =	create(4);
	print_list( L);
	L = swap_node(L);
print_list( L);
	
		L = LinkListReverse(L);
		print_list( L);
	return 0;
}






"
272-14706,ktereyp/Algorithms,Bubble_Sort/bubble_sort_v1.c,26,4,18,1113371114.8286238,9772090849.0,0.1138827238915695,1367.0,1342.0,2169887625.0,2163892405.0,61313629.0,4816.0,1415.0,4610.0,1500000000,0.7422474098857492,1082014363648.0,2.772180531126783e-07,0.0141503420975429,"#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv)
{
    int big_array[65535];

    int i;
    for(i = 0; i < 65535; i++)
        big_array[i] = 2 * rand();

    i = 0;
    while(++i < 65535)
    {
        int j = i - 1;
        while(j > -1 && big_array[j] > big_array[j + 1])
        {
            int tmp = big_array[j];
            big_array[j] = big_array[j+1];
            big_array[j+1] = tmp;
            j--;
        }
    }

    i = 0;
    for(i = 0; i < 65535; i++)
    {
        printf(""%d : "", i);
        printf(""%d\n"", big_array[i]);
    } 

    return 0;
}
"
286-25579,rrrichter/ufrgs,complexidade/assignment1/t.c,90,6,55,2704354.35231765,177491.0,15.23656974156436,1375.0,1349.0,40280.0,13763.0,1656.0,630.0,1371.0,591.0,1500000000,0.0018029029015451,1082014363648.0,0.0153472570440191,0.078604074533242,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void Multiplica(char Multiplicando[],char Multiplicador[],char Produto[])
{
    char Buffer[20001];

    int digito,digito2,j,resto=0,i=0;
    long int Parcial,Quociente = 0;
    long int Auxiliar1 = atol(Multiplicando);
    int Tamanho_string = strlen(Multiplicador);

    Tamanho_string--;
    while(Tamanho_string!=-1)
    {
        digito = Multiplicador[Tamanho_string]-48;
        digito2 = Multiplicando[Tamanho_string]-48;
        Parcial = digito2*digito;
        Parcial = Parcial+Quociente;
        Quociente = Parcial/10;
        resto = Parcial%10;
        Buffer[i] = resto+48;
        i++;
        Tamanho_string--;
    }
    while(Quociente>=10)
    {
        resto = Quociente%10;
        Quociente = Quociente/10;
        Buffer[i] = resto+48;
        i++;
    }
    if(Quociente>0)
    {
        Buffer[i] = Quociente+48;
        i++;
    }
    Buffer[i] = '\0'; // Obtem a ""string"" de forma inversa
    Tamanho_string = strlen(Buffer); // eh preciso inverter os caracteres
    for(i=0,j=Tamanho_string-1; i<Tamanho_string; i++,j--)
    {
        Produto[i] = Buffer[j];
    }
    Produto[i]='\0';
}

void matcher(char s1[],char s2[],char *Chave,int size) {
	char subs[2000];
	char subs2[2000];
	int subssize = 2;
	int biggestMatch = 0;
	int i,j=0,k,l;


	for (j=0;j<size;j++) {
		for (k=0;k<size;k++) {
			if (s1[j] == s2[k]) {
				i=0;
				while (s1[j+i] == s2[k+i]) {
					subs[i] = s1[j+i];
					i++;
				}
				subs[i] = '\0';
				if (strlen(subs) > biggestMatch) {
					biggestMatch = strlen(subs);
					strcpy(subs2,subs);
				}		
			}
		}
	}

	printf(""maior match:%s\n"",subs2);
}

int MultiplicaEZ(char m1[],char m2[]) {
	char subm1[6];
	strncpy(subm1,m1,6);
	subm1[5] = '\0';

	char subm2[6];
	strncpy(subm2,m2,6);
	subm2[5] = '\0';

	int im1 = atoi(subm1);
	int im2 = atoi(subm2);

	return (im1*im2);
}

int main() {
	int Tamanho = 743;
    char Texto[] = ""12345678901065703304011031338370763392959061742177117741574752405286675751751314504012625336320365104661051291909178480948331328953939507131293079240283777803550434266953656933331862862836053872629918246535772390084354593076702934450791518879868380519997944757051401202663606740768021543612770901240982825779317596912107867285544985437368652710797055348487148149587590243274151793944598475566943017826205603956290299910129298589726700292721565513320871031576930809285943446191042007026945145706963385419521277601571208503379491200480304910489078359571596307622501134540377100878475810202910188059443398551447401411271192011985935673099472044705074971205559203895085818347347252899195454541511061949049056468259567711373961417054550528811252031"";
    char Padrao[] = ""10657033040110313383707633929590617421771177415747524052866757517513145040126253363203651046610512919091784809483313289539395071312930792402837778035504342669536569333318628628360538726299182465357723900843545930767029344507915188798683805199979447570514012026636067407680215436127709012409828257793175969121078672855449854373686527107970553484871481495875902432741517939445984755669430178262056039562902999101292985897267002927215655133208710315769308092859434461910420070269451457069633854195212776015712085033794912004803049104890783595715963076225011345403771008784758102029101880594433985514474014112711920119859356730994720447050749712055592038950858183473472528991954545415110619490490564682595677113739614170545505288112520310000071232"";
    char *Chave = (char *)calloc(2000,sizeof(char));

    char m1[] = ""335328584367495293659342105680805357709"";
    char m2[] = ""339728353662883315388043909290053954799"";
    int prod;
    prod = MultiplicaEZ(m1,m2);
    printf(""%d\n"",prod);
    //printf(""fim = %d\n"",')' - 48);

    //matcher(Texto,Padrao,Chave,Tamanho);
    //printf(""%s\n"",Chave);



	return 0;
}
"
163-14816,EvtimPavlov/c-programming-2014-2015-homework,A/03_Antonio_Mindov/homework_3/task_1.c,17,3,15,2311922.72622135,223879.0,10.326658596831324,1335.0,1316.0,49661.0,20663.0,1618.0,643.0,1340.0,600.0,1500000000,0.0015412818174809,1082014363648.0,0.0118412178006869,0.0597377851089244,"#include <stdio.h>


int main ()
{
	int i;
	
	for (i = 97; i <= 122 ;i ++)
	{
		printf(""%c - %d\n"",i,i);
	}
	
	for (i = 65; i <= 90; i ++)
	{
		printf(""%c - %d\n"",i,i);
	}
	
	for (i = 48; i <= 57; i ++)
	{
		printf(""%c - %d\n"",i,i);
	}
	
	return 0;
}
"
285-18854,pirix/glibc-pirix,manual/examples/dir2.c,36,2,25,17901779.96736015,1820143.0,9.835369528657914,1460.0,1436.0,498320.0,305170.0,6419.0,2487.0,2052.0,1984.0,1500000000,0.0119345199782401,1082014363648.0,0.0015910837774834,0.0161072321995295,"/* Simple Program to List a Directory, Mark II
   Copyright (C) 1991-2012 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2
   of the License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, if not, see <http://www.gnu.org/licenses/>.
*/

/*@group*/
#include <stdio.h>
#include <dirent.h>
/*@end group*/

static int
one (const struct dirent *unused)
{
  return 1;
}

int
main (void)
{
  struct dirent **eps;
  int n;

  n = scandir (""./"", &eps, one, alphasort);
  if (n >= 0)
    {
      int cnt;
      for (cnt = 0; cnt < n; ++cnt)
	puts (eps[cnt]->d_name);
    }
  else
    perror (""Couldn't open the directory"");

  return 0;
}
"
360-12147,ch3nkula/My-C-Source-Codes,planet.c,18,2,18,1639367.89613205,171873.0,9.28942882244448,1150.0,1141.0,39166.0,12972.0,1597.0,587.0,1337.0,546.0,1500000000,0.0010929119307547,1082014363648.0,0.0133296096536396,0.078004526449039,"/* Program to check the planet names*/
/*Author: Alangi Derick*/

#include<stdio.h>
#include<string.h>

#define NUM_PLANETS 9

int main(int argc, char *argv[]) {
	
	char *planets[] = {""Mecury"", ""Vernus"", ""Earth"",
			    ""Mars"", ""Jupiter"", ""Saturn"", 
			    ""Uranus"", ""Neptune"", ""Pluto""};

	int i, j;

	for(i=1; i<argc; i++) {
		for(j=0; j<NUM_PLANETS; j++)
		 if(strcmp(argv[i], planets[j]) == 0) {
		printf(""%s is planet %d\n"", argv[i], j+1);
		break;
	}
	if(j == NUM_PLANETS)
		printf(""%s is not a planet\n"", argv[i]);
	}
	return 0;
}
"
083-7620,qq2588258/floweers,libs/external/emscripten/tests/unistd/access.c,20,1,21,2431039.3491758998,208346.0,11.668277768711665,1369.0,1348.0,46756.0,18293.0,1641.0,646.0,1359.0,604.0,1500000000,0.0016206928994506,1082014363648.0,0.0130408071189271,0.0653353625728297,"#include <stdio.h>
#include <errno.h>
#include <unistd.h>

int main() {
  char* files[] = {""/readable"", ""/writeable"",
                   ""/allaccess"", ""/forbidden"", ""/nonexistent""};
  for (int i = 0; i < sizeof files / sizeof files[0]; i++) {
    printf(""F_OK(%s): %d\n"", files[i], access(files[i], F_OK));
    printf(""errno: %d\n"", errno);
    errno = 0;
    printf(""R_OK(%s): %d\n"", files[i], access(files[i], R_OK));
    printf(""errno: %d\n"", errno);
    errno = 0;
    printf(""X_OK(%s): %d\n"", files[i], access(files[i], X_OK));
    printf(""errno: %d\n"", errno);
    errno = 0;
    printf(""W_OK(%s): %d\n"", files[i], access(files[i], W_OK));
    printf(""errno: %d\n"", errno);
    errno = 0;
    printf(""\n"");
  }
  return 0;
}
"
167-28025,Legend/Elune,drd/tests/memory_allocation.c,28,3,24,9879556.4845203,76973019.0,0.1283508965654575,1259.0,1242.0,17039208.0,10113243.0,1597.0,637.0,1329.0,594.0,1500000000,0.0065863709896802,1082014363648.0,3.2491904728330845e-05,0.0001530985176991,"/**
 * @brief Repeatedly allocate and free memory. Tests whether drd really frees
 *        memory allocated by a client. See also
 *        http://bugs.kde.org/show_bug.cgi?id=161036.
 */

#include <assert.h>
#include <stdlib.h>

int main()
{
  int i;
  void* p;

  for (i = 0; i < 100000; i++)
    free(malloc(40960));

  for (i = 0; i < 100000; i++)
  {
    p = realloc(NULL, 40960);
    p = realloc(p, 50000);
    p = realloc(p, 40000);
    p = realloc(p, 0);
    /*
     * glibc returns a NULL pointer when the size argument passed to realloc()
     * is zero, while Darwin's C library returns a non-NULL pointer. Both are
     * allowed by POSIX.
     */
#if defined(__APPLE__)
    if (p)
      free(p);
#else
    assert(! p);
#endif
  }

  return 0;
}
"
367-34193,BharathTalloju/mrnd-submissions-tool,LinkedList/numberToLinkedList.c,54,3,37,2207432.873547,177161.0,12.460033528824065,1341.0,1323.0,40082.0,13924.0,1617.0,636.0,1340.0,593.0,1500000000,0.001471621915698,1082014363648.0,0.0150371695802123,0.0775099063067066,"/*
OVERVIEW:  Given a number convert that to single linked list (each digit as a node).
E.g.: Input: 234, Output: 2->3->4.

INPUTS:  A number.

OUTPUT: Create linked list from given number, each digit as a node.

ERROR CASES: 

NOTES: For negative numbers ignore negative sign.
*/

#include <stdio.h>
#include <malloc.h>

struct node {
	int data;
	struct node *next;
};

struct node * numberToLinkedList(int N) {
	struct node* head = NULL;
	int digit_to_be_inserted;
	struct node* walker = NULL;
	struct node* new = NULL;
	
	if(N<0){
		N = -N;
	}
	
	reverse_number(&N);
	
	while(N){
		digit_to_be_inserted = N % 10;
		N = N / 10 ;

		new = (struct node*) malloc(sizeof(struct node));
		new->data = digit_to_be_inserted;
		new->next = NULL;

		if(head == NULL){
			head = new;
			walker = head;
		}
		else{
			walker->next = new;
			walker = new;
		}
	}
	
	return head;
}

void reverse_number(int* N){
	int result = 0;
	while(*N){
		result = (result*10) + ((*N)%10);
		*N = (*N) / 10;
	}
	*N = result;
}

/* test driver	*/
int main(){
	struct node *head = numberToLinkedList(-25478);
	
	while(head != NULL){
		printf(""%d ,"",head->data);
		head = head->next;
	}
} 
	
"
035-4268,Gurgel100/gcc,gcc/testsuite/gcc.dg/vect/pr91293-1.c,17,1,15,1648397.9998155,170410.0,9.673123642978698,1147.0,1138.0,38668.0,12782.0,1577.0,586.0,1323.0,546.0,1500000000,0.001098931999877,1082014363648.0,0.0134088375095358,0.0783673469387755,"/* { dg-additional-options ""-msse4.1"" { target { sse4_runtime } } } */

long long a;
unsigned b, c;
int d = 62;
void e(long long *f, int p2) { *f = p2; }
int main()
{
  for (int g = 2; g <= d; g++)
    {
      b += g + 4;
      c += 5 - g;
    }
  e(&a, b);
  if (a != 2196)
    __builtin_abort ();
  return 0;
}
"
344-11547,Ektorus/bohrium,ve/cpu/tools/asm.c,14,1,19,2432912.7045348003,174644.0,13.93069329607659,1331.0,1313.0,39448.0,13573.0,1617.0,643.0,1340.0,601.0,1500000000,0.0016219418030232,1082014363648.0,0.0151393692311215,0.0792327568321985,"#include <inttypes.h>
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
    const int size = 125;
    //__asm__(""# begin malloc""::);
    int* array_a = (int*)malloc(sizeof(int)*size);
    //__asm__(""# end malloc""::);

    //__asm__(""# begin loop""::);
    for(int i=0; i<size; ++i) {
        array_a[i] = 7;
    }
    //__asm__(""# end here""::);

    printf(""hej=%d %d\n"", *array_a, *(array_a+size-1));
    return 0;
}
"
035-13714,weezybusy/KnR2,1/1-5.c,13,1,18,2287879.5862197,214444.0,10.668887914793606,1495.0,1466.0,48201.0,18931.0,1635.0,638.0,1354.0,596.0,1500000000,0.0015252530574798,1082014363648.0,0.0138078006379287,0.062905916701424,"/* 
 * Exercise 1-5
 *
 * Modify the temperature conversion program to print the table in
 * reverse order, that is, from 300 degrees to 0.
 * */

#include <stdio.h>

int main(void)
{
        printf(""%3c %6c\n"", 'F', 'C');
        for (int fahr = 300; fahr >= 0; fahr -= 20)
                printf(""%3d %6.1f\n"", fahr, (5.0 / 9.0) * (fahr - 32.0));

        return 0;
}
"
108-14480,metbosch/PCA-Lab,lab4_session/matriu4x4/matriu4x4_original.c,47,8,20,564239086.699672,6580189516.0,0.0857481512695082,1371.0,1346.0,1460042826.0,640015515.0,1648.0,641.0,1363.0,597.0,1500000000,0.3761593911331147,1082014363648.0,4.129060406837073e-07,2.023277123804438e-06,"#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#define N_ITER 10000000

void multiplica(int A[4][4], int B[4][4], int C[4][4], unsigned int n_iter)
{
   int iter;
   int i,j,k;

   for (iter=0; iter<n_iter; iter++)
   {
      for (i = 0; i < 4; i++) 
      {
        for (j = 0; j < 4; j++) 
	{
           for (k = 0; k < 4; k++) 
	   {
              C[i][j] = C[i][j] + A[i][k] * B[k][j];
	   }
	}
      }
   }
}

void print_matriu(int C[][4])
{
   int i,j,k;

   for (i = 0; i < 4; i++) 
   {
     for (j = 0; j < 4; j++) 
     {
       printf(""%d "", C[i][j]);
     }
     printf(""\n"");
   }
}

int main(int argc, char *argv[])
{
    int A[4][4], B[4][4], C[4][4] = {{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0}};
    unsigned int n_iter=N_ITER, i,j;

    for (i=0; i<4; i++) {
        for (j=0; j<4; j++) {
            A[i][j] = rand();
            B[i][j] = rand();
        }
    }

    if (argc > 1) {
	n_iter = atoi(argv[1]); 
    }

    multiplica(A, B, C, n_iter);

    print_matriu(C);
         
    return 0;
}
"
192-1700,deborasetton/cpar-openmp-mpi-examples,openmp/pi_serial.c,18,1,18,218057623.5987246,1188174922.0,0.1835231656235882,1430.0,1405.0,39545.0,13564.0,1624.0,638.0,1345.0,594.0,1500000000,0.1453717490658164,1082014363648.0,2.3860123181424965e-06,0.0791014705605453,"/**
 * Serial calculation of Pi.
 */

#include <stdio.h>

static long num_steps = 99000000;
double step;

int main(void) {
  int i;
  double x, pi, sum = 0.0;

  printf(""num_steps = %ld\n"", num_steps);

  step = 1.0 / (double) num_steps;

  for (i = 0; i < num_steps; ++i) {
    x = (i + 0.5) * step;
    sum = sum + 4.0 / (1.0 + x * x);
  }

  pi = step * sum;
  printf(""Pi is: %f\n"", pi);
  return 0;
}
"
173-10217,iTech-/napnac.ga,content/articles/algorithme/structure_donnees/pile/pile_liste_chainee.c,60,1,33,1193071.36628775,173380.0,6.881249279040258,1243.0,1227.0,39338.0,13301.0,1603.0,631.0,1336.0,588.0,1500000000,0.0007953809108585,1082014363648.0,0.0142461644941746,0.0789908622884173,"#include <stdio.h>
#include <stdlib.h>

typedef struct Noeud Noeud;
struct Noeud
{
   Noeud *suivant;
   int donnee;
};

typedef Noeud *Pile;

void creerPile(Pile *pile)
{
   *pile = NULL;
}

void supprimerPile(Pile *pile)
{
   Noeud *iPile;

   for(iPile = *pile; iPile != NULL; ) {
      Noeud *temp;

      temp = iPile->suivant;
      free(iPile);
      iPile = temp;
   }
}

void empiler(Pile *pile, int donnee)
{
   Noeud *nouveau;

   nouveau = malloc(sizeof(Noeud));
   nouveau->suivant = *pile;
   nouveau->donnee = donnee;

   *pile = nouveau;
}

int depiler(Pile *pile)
{
   Noeud *temp;
   int donnee;

   temp = (*pile)->suivant;
   donnee = (*pile)->donnee;
   free(*pile);
   *pile = temp;

   return donnee;
}

int estVide(Pile *pile)
{
   if(*pile == NULL)
      return 1;
   else
      return 0;
}

int main(void)
{
   Pile pile;

   creerPile(&pile);

   empiler(&pile, 42);
   // 42
   empiler(&pile, 9);
   // 9
   // 42

   int retour = depiler(&pile);
   // retour = 9

   supprimerPile(&pile);

   return 0;
}
"
078-24829,SnipyJulmy/mcs_notes_and_resume,sys-oriented-prog/exercices/s08/exercices/ex1/to_upper.c,28,2,17,2303962.3629301502,175166.0,12.989244488085587,1237.0,1221.0,39724.0,13465.0,1616.0,633.0,1345.0,591.0,1500000000,0.0015359749086201,1082014363648.0,0.0140324035486338,0.0786816823027317,"#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <ctype.h>

char* to_upper_a(char* string)
{
    for (int i = 0; i < strlen(string); i++)
    {
        string[i] = (char) toupper(string[i]);
    }
    return string;
}

char* to_upper_b(char* string)
{
    char* start = string;
    while (*string != '\0')
    {
        if (*string >= 'a' && *string <= 'z')
            *string += ('A' - 'a');
        string++;
    }
    return start;
}

int main(void)
{
    char* a = malloc(4 * sizeof(char));
    strcpy(a, ""asd"");
    assert(strcmp(to_upper_a(a), ""ASD"") == 0);
    strcpy(a, ""asd"");
    assert(strcmp(to_upper_b(a), ""ASD"") == 0);
    return EXIT_SUCCESS;
}

"
296-27161,ccilab/binutils,gdb/testsuite/gdb.dwarf2/dw2-bad-mips-linkage-name.c,33,1,24,1865209.54594005,169080.0,11.031517624792995,1142.0,1132.0,38460.0,12696.0,1566.0,584.0,1317.0,544.0,1500000000,0.0012434730306267,1082014363648.0,0.0134492547906316,0.0784072249589491,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2015-2016 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* Dummy main function.  */

int
main (void)
{
  asm (""main_label: .globl main_label"");
  return 0;
}

/* dummy f function, DWARF will describe arguments and type differently.  */
int
f (char *x)
{
  asm (""f_label: .globl f_label"");
  return 0;
}

/* dummy g function, DWARF will describe arguments and type differently.  */
int
g (char *x)
{
  asm (""g_label: .globl g_label"");
  return 0;
}
"
050-12051,algobook/Algo_Ds_Notes,Queue_Using_Linked_List/Queue_Linked_List.c,94,2,30,1632333.0346493998,185313.0,8.80851856048955,1357.0,1335.0,42031.0,15159.0,1633.0,645.0,1353.0,600.0,1500000000,0.0010882220230996,1082014363648.0,0.0145267736208468,0.0739814652911348,"#include <stdio.h>
#include <stdlib.h>

//A structure having data and link representing a node in linked list
typedef struct node
{
	int data;
	struct node *link;
}node;

node *front=NULL,*rear=NULL;

//A fuction to check for empty queue
int isEmpty()
{
	if (front == NULL)
		return 1;
	else
		return 0;
}

//Fuction to insert node in queue
void enqueue(int elt)
{
	node *newNode;
	newNode = (node *)malloc(sizeof(node));
	newNode->data = elt;
	newNode->link = NULL;
	if (newNode == NULL)
	{
		printf(""Memory is not allocated\n"");
		return;
	}
	if (front == NULL)
	{
		front = newNode;
		rear = newNode;
	}
	else
	{
		rear->link = newNode;
		rear = newNode;
	}
	printf(""%d inserted in the queue\n"", elt);
}

//Function to delete a node from queue
void dequeue()
{
	int data;
	if (isEmpty())
	{
		printf(""Queue is empty\n"");
		return;
	}
	data = front->data;
	printf(""Element deleted is %d\n"", data);
	front = front->link;
}

//Fucntion to display the queue
void display()
{
	node *ptr;
	if (isEmpty())
	{
		printf(""Queue is empty\n"");
		return;
	}
	printf(""The queue is\n"");
	for (ptr = front; ptr != NULL; ptr = ptr->link)
		printf(""%d\t"", ptr->data);
	printf(""\n"");
}


int main()
{
	dequeue();
	enqueue(15);
	enqueue(49);
	enqueue(54);
	enqueue(2);
	enqueue(97);
	display();
	dequeue();
	dequeue();
	display();
	return 0;
}

/* Output
Queue is empty
15 inserted in the queue
49 inserted in the queue
54 inserted in the queue
2 inserted in the queue
97 inserted in the queue
The queue is
15	49	54	2	97
Element deleted is 15
Element deleted is 49
The queue is
54	2	97
*/
"
123-28487,arkamar/bbcl,bbcl.c,130,5,68,1752572.83262895,181399.0,9.661420404743136,1313.0,1293.0,41522.0,14240.0,1666.0,636.0,1376.0,594.0,1500000000,0.0011683818884193,1082014363648.0,0.014366121092178,0.0766113123632581,"/* See LICENSE file for copyright and license details. */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define COLOR_ONLINE		""\x1b[1;32m""
#define COLOR_AWAY		""\x1b[1;33m""
#define COLOR_OFFLINE	""\x1b[1;31m""
#define COLOR_RESET		""\x1b[0m""
#define CLEAR_LINE		""\x1b[0K""
#define CLEAR_PAGE		""\x1b[0J""
#define GO_TOP				""\x1b[1H""

struct node {
	struct node * next;
	struct node * prev;
	size_t len;
	char name[];
};

static struct node * front = NULL;

static char *
endname(char * name, const char end) {
	char * ob = strchr(name, end);
	if (ob)
		ob[0] = '\0';
	return ob;
}

static struct node *
find(const char * name, struct node ** ret) {
	struct node * n = front;
	while (n) {
		int comparison = strcasecmp(name, n->name);
		if (ret && comparison > 0)
			*ret = n;
		if (comparison < 0)
			return NULL;
		if (comparison == 0)
			break;
		n = n->next;
	}
	return n;
}

static int
add(const char * name) {
	size_t len = strlen(name) + 1;
	struct node * la = NULL;
	if (find(name, &la))
		return 1;
	struct node * new = malloc(sizeof(struct node) + len);
	if (new == NULL) {
		perror(""Cannont allocate memmory"");
		return -1;
	}
	memcpy(new->name, name, len);

	new->prev = la;
	if (la != NULL) { /* I am in middle */
		new->next = la->next;
		la->next = new;
	} else { /* front */
		new->next = front;
		front = new;
	}

	if (new->next)
		new->next->prev = new;

	return 0;
}

static int
away(const char * name) {
	return 0;
}

static int
delete(const char * name) {
	struct node * n = find(name, NULL);
	if (n) {
		struct node * next = n->next;
		struct node * prev = n->prev;
		if (next != NULL)
			next->prev = prev;

		if (prev == NULL)
			front = next;
		else
			prev->next = next;

		free(n);
	}
	return 0;
}

static void
print() {
	struct node * n;
	n = front;
	while (n) {
		printf(""%s"" CLEAR_LINE ""\n"", n->name);
		n = n->next;
	}
}

static void
clear() {
	struct node * n;
	while (front) {
		n = front->next;
		free(front);
		front = n;
	}
}

int
main(int argc, char *argv[]) {
	char * buff = NULL;
	size_t size = 0;
	ssize_t len;
	char * name;
	int position = 0;
	while ((len = getline(&buff, &size, stdin)) > 0) {
		position = strchr(buff, ' ') - buff + 2;
		if (position > 0 && len < position + 3)
			continue;
		switch (buff[position]) {
		case '!':
			name = buff + position + 3;
			if (!endname(name, '('))
				continue;
			delete(name);
			break;
		case 'v':
			name = buff + position + 2;
			endname(name, '\n');
			if (buff[position - 1] == '+')
				add(name);
			else
				away(name);
			break;
		default:
			continue;
		}
		printf(GO_TOP);
		print();
		printf(CLEAR_PAGE);
		fflush(stdout);
	}
	clear();
	free(buff);
	return 0;
}
"
144-16083,foxtrot9/HPC_project,code/qsort.c,71,4,37,1675845379.5919194,3454637345.0,0.4851002324239623,1437.0,1413.0,576455709.0,410000064.0,12972394.0,633393.0,1368.0,625616.0,1500000000,1.1172302530612797,1082014363648.0,8.249780556922683e-07,0.0144281896761731,"#include <stdio.h>
#include <stdlib.h>
#define MAX 10000000

void randomSequence(unsigned int *seedp,int *arr,int size)
{
    int i=0;
    for(i=0; i<size; ++i)
    {
        rand_r(seedp);
        arr[i] = *seedp;
    }
}

void randomGenerator(unsigned int *seedp)
{
    rand_r(seedp);
}

int partition(int arr[], int low, int high,unsigned int *seedp)
{
    randomGenerator(seedp);
    unsigned int randomNumber = *seedp;
    int l = (high - low + 1);
    int pivotIndex = low + (randomNumber%l); //generates a random number as a pivot
    int pivot;
    int i = low - 1;
    int j;
    pivot = arr[pivotIndex];
    int temp;
    temp = arr[pivotIndex];
    arr[pivotIndex] = arr[high];
    arr[high] = temp;
    for (j = low; j < high; j++)
    {
        if (arr[j] < pivot)
        {
            i++;
            temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
 
    }
    temp = arr[i+1];
    arr[i+1] = arr[high];
    arr[high] = temp;
    return i + 1;
}
 
void quick_sort(int arr[], int p, int q,unsigned int *seedp)
{
    int j;
    if (p < q)
    {
        j = partition(arr, p, q,seedp);
        quick_sort(arr, p, j-1,seedp);
        quick_sort(arr, j+1, q,seedp);
    }
}

int main()
{
    int i;
    int *arr = (int *) malloc(sizeof(int)*MAX);
    unsigned int seed = 5;
    struct timeval start, end;
    time_t t1 = time(NULL);
    randomSequence(&seed,arr,MAX);
    double t2 = time(NULL);
    fprintf(stderr,""Time taken for generation of input = %e\n"",t2-t1);
    t1 = time(NULL);
    gettimeofday(&start, NULL);
    quick_sort(arr, 0, MAX-1,&seed);
    gettimeofday(&end, NULL);
    t2 = time(NULL);
    double delta = ((end.tv_sec  - start.tv_sec) * 1000000u + end.tv_usec - start.tv_usec) / 1.e6;
    fprintf(stderr,""Time taken for output = %e .\n"",delta);
    return 0;
}
"
327-31932,mickael-guene/gcc,gcc/testsuite/c-c++-common/ubsan/pr71403-2.c,20,3,20,1757417.9219080498,169985.0,10.335158984616289,1146.0,1137.0,38667.0,12782.0,1577.0,586.0,1324.0,546.0,1500000000,0.0011716119479387,1082014363648.0,0.0134305968173662,0.0783883068669945,"/* { dg-do run } */
/* { dg-additional-options ""-fsanitize=unreachable"" } */

char a, c;
short b;

int
main ()
{
  unsigned d = 0;
  int e = 1;
  for (a = 0; a < 2; a++)
    {
      if (e)
        c--;
      for (; d < 2; d++)
        for (b = 0; b; b++)
          ;
      e = 0;
    }
  __builtin_exit (0);
}
"
245-319,8l/ucc-c-compiler,test2/initialisation/compound/undefined.c,16,2,18,2171432.9486712,170518.0,12.734327167806333,1146.0,1138.0,38744.0,12798.0,1582.0,587.0,1326.0,546.0,1500000000,0.0014476219657808,1082014363648.0,0.0133944803481157,0.0784020798572038,"// 9 * 9 =
// RUN: %ucc -o %t %s

typedef struct
{
	int x;
} int_1;

#define MAX_INTS 10

int main(void){
	int_1 *ints[MAX_INTS];

	for(int i = 0; i < MAX_INTS; i++)
		ints[i] = &(int_1){ i };
	// undefined once scope is left

	int sum = 0;
	for(int i = 0; i < MAX_INTS; i++)
		sum += ints[i]->x;


	return sum;
}
"
342-12788,Gurgel100/gcc,gcc/testsuite/gcc.dg/pr97501.c,12,2,11,1282876.4738514,169083.0,7.587255963047734,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0008552509825676,1082014363648.0,0.0134490161636592,0.0785049652044725,"// { dg-do compile }
// { dg-options ""-O2"" }

static int c = 0;

int main() {
  int b = 0;
  if (c) {
  for (;; b--)
    do
      b++;
    while (b);
  }
}
"
162-10368,tehp/c-notes,lab05/lab05.c,75,3,29,2072464.3254652498,177949.0,11.646393067676694,1353.0,1333.0,40299.0,13982.0,1627.0,636.0,1347.0,594.0,1500000000,0.0013816428836435,1082014363648.0,0.015094212386695,0.0774488310826992,"#include<stdio.h>
#include<ctype.h>
#include<string.h>
#include<stdlib.h>

#define CHECK(PRED) printf(""%s ... %s\n"",(PRED) ? ""passed"" : ""FAILED"", #PRED)
#define LINESIZE 512

void min_max (const int a[], size_t n, int *pmin, int *pmax);
size_t num_digits (unsigned long n);

void min_max (const int a[], size_t n, int *pmin, int *pmax) {

  size_t i;

  if (n >= 1) {

    *pmin = a[0];
    *pmax = a[0];

    for (i = 1; i < n; i++) {
      if (a[i] < *pmin) {
        *pmin = a[i];
      }

      if (a[i] > *pmax) {
        *pmax = a[i];
      }
    }
  }
}

size_t num_digits (unsigned long n) {

  size_t i;
  if (n == 0) {
    printf(""%d\n"", 1);
    return 1;
  }
  for (i = 0; n != 0; i++) {
    n = (n/10);
  }

  printf(""%lu\n"", i);

  return i;

}

int is_reversible(unsigned long n) {

  int reverse;
  int rem;
  size_t i;
  int actual;

  actual = n;
  i = n;

  reverse = 0;

  while(i!=0) {
    rem = i%10;
    reverse = rem + (reverse*10);
    i = (i/10);
  }

  if (reverse == actual) {
    printf(""worked\n"");
    return 1;
  } else {
    printf(""failed\n"");
    return 0;
  }

}

int main(void) {
  int a[] = {2, 3, 4, 5};
  size_t n = 4;

  int b[] = {1};
  size_t k = 1;

  int pmin = 0;
  int pmax = 0;

  unsigned long p = 12321;
  unsigned long q = 123;
  unsigned long r = 0;

  printf(""min max tests\n"");

  min_max(a, n, &pmin, &pmax);
  printf(""%d - %d\n"", pmin, pmax);

  min_max(b, k, &pmin, &pmax);
  printf(""%d - %d\n"", pmin, pmax);

  printf(""num digits tests\n"");
  num_digits(p);
  num_digits(q);
  num_digits(r);

  printf(""is reversible tests\n"");
  is_reversible(p);
  is_reversible(q);
  is_reversible(r);

  return 0;
}
"
060-30487,trammell/test,C/condense/condense.c,41,1,22,1565717.85919365,175144.0,8.939598273420728,1296.0,1280.0,39727.0,13514.0,1630.0,635.0,1351.0,592.0,1500000000,0.0010438119061291,1082014363648.0,0.0147078975014844,0.0790368325162938,"/*
http://www.solipsys.co.uk/Writings/TestsForProgrammers_Part_1.html

Write a C routine with the following prototype:

    void condense_by_removing(char *z_terminated, char char_to_remove);

Your routine should modify the given zero-terminated string in place, removing
all instances of the given char.
*/

#include <assert.h>
#include <stdio.h>
#include <string.h>

void condense_by_removing(char *, char);

int main(int argc, char **argv) {
    char s1[] = ""aaaa"";
    char s2[] = ""aabbaa"";
    char s3[] = ""aaaabbbccd"";

    condense_by_removing(s1,'z');
    assert(!strcmp(s1,""aaaa""));

    condense_by_removing(s1,'a');
    assert(!strcmp(s1,""""));

    condense_by_removing(s2,'a');
    assert(!strcmp(s2,""bb""));

    condense_by_removing(s2,'b');
    assert(!strcmp(s2,""""));

    condense_by_removing(s3,'d');
    assert(!strcmp(s3,""aaaabbbcc""));

    condense_by_removing(s3,'a');
    assert(!strcmp(s3,""bbbcc""));

    printf(""Done.\n"");
    return 0;
}

/*
Condense string 'z_term' by removing all instances of charater 'remove'.
Tracks current source position in 'i', rebuilt position in 'j'.

*/

void condense_by_removing(char *z_term, char remove) {
    int i=0, j=0;
    char ch;

    while ((ch = z_term[i++])) {
        if (ch != remove) {
            z_term[j++] = ch;
        }
    }
    z_term[j] = '\0';
}

"
346-10639,Gurgel100/gcc,gcc/testsuite/gcc.dg/pr97467.c,14,1,13,1646552.9333799002,169086.0,9.73795583312634,1142.0,1132.0,38461.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010977019555866,1082014363648.0,0.0134487775451545,0.078503430615556,"/* { dg-do compile } */
/* { dg-options ""-Os"" } */

int a;
long b;
unsigned int c = 1;

int main () {
  int e;
  for (; c <= 0; c++) {
    int f = 0;
    b = e;
    a = f || b << c;
  }
  return 0;
}
"
150-23350,EvtimPavlov/c-programming-2014-2015-homework,B/01_Asen_Popov/homework_3/task_3.c,20,1,20,1912938.1980745501,184675.0,10.358402599160687,1344.0,1322.0,41139.0,14603.0,1618.0,637.0,1340.0,594.0,1500000000,0.0012752921320497,1082014363648.0,0.0144361716529037,0.0751497972803272,"#include <stdio.h>

int main() {
	int a,b;
	a=3;
	b=5;
	printf(""(%d, %d)\n"" ,a,b);
	a=5;
	b=7;
	printf(""(%d, %d)\n"" ,a,b);
	int i=1;	
	while (i<9) {
		a=a+1;
		b=a+2;
		if ((a%2!=0)&&(a%3!=0)&&(a%5!=0)&&(a%7!=0)&&(a%9!=0)&&
    		(b%2!=0)&&(b%3!=0)&&(b%5!=0)&&(b%7!=0)&&(b%9!=0)) {
			printf(""(%d, %d)\n"" ,a,b);
			i++;
		}
	}
	return 0;
}
"
280-10868,ILyoan/gdb,gdb/testsuite/gdb.python/py-breakpoint.c,34,2,29,2010260.8250454,169062.0,11.89066732914552,1139.0,1129.0,38453.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0013401738833636,1082014363648.0,0.0134151967917095,0.0785548104557273,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2010-2012 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see  <http://www.gnu.org/licenses/>.
*/


int result = 0;

int multiply (int i)
{
  return i * i;
}

int add (int i)
{
  return i + i; 
}


int main (int argc, char *argv[])
{
  int foo = 5;
  int bar = 42;
  int i;

  for (i = 0; i < 10; i++)
    {
      result += multiply (foo);  /* Break at multiply. */
      result += add (bar); /* Break at add. */
    }

  return 0; /* Break at end. */
}
"
381-7188,zhangrxiang/learn-c,basic/data-structure/4章栈与队列/04斐波那契函数_Fibonacci.c,25,2,22,552968911.3609493,4042522607.0,0.1367424852597738,1368.0,1348.0,846039247.0,597273153.0,1645.0,639.0,1361.0,599.0,1500000000,0.3686459409072995,1082014363648.0,6.718577146104257e-07,2.9404583512204287e-06,"#include ""stdio.h""

int Fbi(int i)  /* 斐波那契的递归函数 */
{
    if (i < 2)
        return i == 0 ? 0 : 1;
    return Fbi(i - 1) + Fbi(i - 2);  /* 这里Fbi就是函数自己，等于在调用自己 */
}

int main() {
    int i;
    int a[40];
    printf(""迭代显示斐波那契数列：\n"");
    a[0] = 0;
    a[1] = 1;
    printf(""%d "", a[0]);
    printf(""%d "", a[1]);
    for (i = 2; i < 40; i++) {
        a[i] = a[i - 1] + a[i - 2];
        printf(""%ld "", a[i]);
    }
    printf(""\n"");
    printf(""递归显示斐波那契数列：\n"");
    for (i = 0; i < 40; i++)
        printf(""%ld "", Fbi(i));
    printf(""\n"");
    return 0;
}

"
015-21469,kimushu/nios2-gdb-7.0,gdb/testsuite/gdb.base/sigchld.c,26,2,21,1897879.7597809501,172539.0,10.999710210445174,1155.0,1145.0,39332.0,13032.0,1605.0,587.0,1341.0,546.0,1500000000,0.0012652531731873,1082014363648.0,0.0133303195219631,0.0778970284928576,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2008, 2009 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/* Check that GDB isn't messing the SIGCHLD mask while creating an
   inferior.  */

#include <signal.h>
#include <stdlib.h>

int
main ()
{
  sigset_t mask;

  sigemptyset (&mask);
  sigprocmask (SIG_BLOCK, NULL, &mask);

  if (!sigismember (&mask, SIGCHLD))
    return 0; /* good, not blocked */
  else
    return 1; /* bad, blocked */
}
"
326-9827,wuzhouhui/leetcode,47_permutation_II.c,72,2,35,1528562.97790995,178542.0,8.557728713692017,1263.0,1246.0,40707.0,14009.0,1616.0,643.0,1347.0,597.0,1500000000,0.0010190419852733,1082014363648.0,0.0140527158875782,0.0768148256451494,"/*
 * accepted, but too slow.
 */
#include <stdlib.h>
#include <string.h>

#define STEP	8

static int **res, *ans, maxp, p;
static char *occupy;

static void init(int n)
{
	ans = malloc(n * sizeof(int));
	occupy = calloc(n, sizeof(char));
	res = 0;
	maxp = p = 0;
}

static void deinit(void)
{
	free(ans);
	free(occupy);
}

static void add_ans(int n)
{
	int	i;

	for (i = 0; i <= (p - 1); i++) {
		if (!memcmp(res[i], ans, n * sizeof(int)))
			return;
	}

	if (!res) {
		maxp = STEP;
		res = malloc(maxp * sizeof(int *));
		p = 0;
	}

	if (p >= maxp) {
		maxp += STEP;
		res = realloc(res, maxp * sizeof(int *));
	}
	res[p] = malloc(n * sizeof(int));
	memcpy(res[p], ans, n * sizeof(int));
	p++;
}

static void do_perm(const int *nums, int n, int start)
{
	int	i;

	if (n == start) {
		add_ans(n);
		return;
	}

	for (i = 0; i < n; i++) {
		if (occupy[i])
			continue;
		occupy[i] = 1;
		ans[start] = nums[i];
		do_perm(nums, n, start + 1);
		occupy[i] = 0;
	}
}

int **permuteUnique(int *nums, int numsSize, int *returnSize)
{
	if (!numsSize) {
		*returnSize = 0;
		return(0);
	}

	init(numsSize);
	do_perm(nums, numsSize, 0);
	deinit();
	*returnSize = p;
	return(res);
}

int main(void)
{
	int	**res, ret;
	int	x[] = {1, 1, 2};

	res = permuteUnique(x, 3, &ret);
	return(0);
}
"
006-14941,koturn/Mamemaki,mamemaki.c,65,4,49,357424282.35244006,3800175689.0,0.0940546730601433,1411.0,1390.0,39804.0,13646.0,1636.0,636.0,1354.0,593.0,1500000000,0.2382828549016267,1082014363648.0,7.370711854475e-07,0.078933582787652,"/*!
 * @file mamemaki.c
 * @brief Mamemaki as Monte Carlo method: ""Oni ha soto, Fuku ha uchi"".
 * @author koturn
 * @date 2015-02-03
 */
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#if defined(__cplusplus) && __cplusplus >= 201103L
#  include <cstdint>
#elif (defined(_MSC_VER) && _MSC_VER >= 1600) || \
      (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L)
#  include <stdint.h>
#else
#  ifndef UINT32_T
#    define UINT32_T  unsigned int
#  endif
typedef UINT32_T uint32_t;
#endif
#define XOR128_MAX  0xffffffffU


static void
xor128_seed(unsigned int s);

static uint32_t
xor128(void);


#define SQUARE(x)  ((x) * (x))
#define N_TRIAL    100000000
#define TOLERANCE  0.00025
#ifndef M_PI
#  define M_PI  acos(-1)
#endif


static uint32_t seed128[4];




/*!
 * @brief Entry point of this program
 * @return Exit-status
 */
int
main(void)
{
  size_t i;
  unsigned int n_hit = 0;
  double x, y, pi;

  xor128_seed((uint32_t) time(NULL));
  for (i = 0; i < N_TRIAL; i++) {
    x = xor128() / (XOR128_MAX + 1.0);
    y = xor128() / (XOR128_MAX + 1.0);
    if (SQUARE(x) + SQUARE(y) < 1.0) {
      n_hit++;
    }
  }
  pi = n_hit * 4.0 / N_TRIAL;
  printf(""Calculated PI = %f\n"", pi);
  if (fabs(pi - M_PI) < TOLERANCE) {
    printf(""鬼を追い払うことができました\n"");
  } else {
    printf(""鬼を追い払うことができませんでした...\n"");
  }
  return EXIT_SUCCESS;
}


/*!
 * @brief Set random seed for xor128
 * @param [in] s  Value for random seed
 */
static void
xor128_seed(uint32_t s)
{
  uint32_t i;
  for (i = 1; i <= 4; i++) {
    seed128[i - 1] = s = 1812433253U * (s ^ (s >> 30)) + i;
  }
}


/*!
 * @brief Generate a random number with Xorshift
 * @return Random number
 */
static uint32_t
xor128(void)
{
  uint32_t t = (seed128[0] ^ (seed128[0] << 11));
  seed128[0] = seed128[1];
  seed128[1] = seed128[2];
  seed128[2] = seed128[3];
  return seed128[3] = (seed128[3] ^ (seed128[3] >> 19)) ^ (t ^ (t >> 8));
}
"
172-9368,swigger/gdb-ios,gdb/testsuite/gdb.base/watch-non-mem.c,20,1,16,1469673.1232105999,169062.0,8.693100755935692,1139.0,1129.0,38453.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0009797820821404,1082014363648.0,0.0134151967917095,0.0785548104557273,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2010-2016 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int global = 0;

int main()
{
  global++;
  global++;
  global++;

  return 0;
}
"
118-21689,rhuitl/uClinux,user/gdb/gdb/testsuite/gdb.base/step-line.c,56,1,31,1353333.0056815501,169083.0,8.003956636681393,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0009022220037877,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* Test step/next in presence of #line directives.
   Copyright 2001, 2007
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */



void dummy (int, int);
int f1 (int);
int f2 (int);

int
main (int argc, char **argv)
{
  int i;
  i = f1 (4);
  i = f1 (i);
  dummy (0, i);
  return 0;
}

int
f1 (int i)
{
#line 40 ""step-line.c""
  dummy (1, i);
#line 24 ""step-line.inp""
  i = f2 (i);
#line 44 ""step-line.c""
  dummy (2, i);
#line 25 ""step-line.inp""
  i = f2 (i);
#line 48 ""step-line.c""
  dummy (3, i);
#line 26 ""step-line.inp""
  return i;
#line 52 ""step-line.c""
}

int
f2 (int i)
{
#line 31 ""step-line.inp""
  int j;
#line 60 ""step-line.c""
  dummy (4, i);
#line 32 ""step-line.inp""
  j = i;
#line 64 ""step-line.c""
  dummy (5, i);
  dummy (6, j);
#line 33 ""step-line.inp""
  j = j + 1;
#line 69 ""step-line.c""
  dummy (7, i);
  dummy (8, j);
#line 34 ""step-line.inp""
  j = j - i;
#line 74 ""step-line.c""
  dummy (9, i);
  dummy (10, j);
#line 35 ""step-line.inp""
  return i;
#line 79 ""step-line.c""
}

void
dummy (int num, int i)
{
}
"
372-28831,Tinkerforge/brickd,src/tests/putenv_test.c,54,2,30,2457337.22113065,184649.0,13.308152223949223,1339.0,1321.0,41681.0,13905.0,1692.0,649.0,1352.0,605.0,1500000000,0.0016382248140871,1082014363648.0,0.014405710293584,0.0773216277479941,"/*
 * brickd
 * Copyright (C) 2014 Matthias Bolte <matthias@tinkerforge.com>
 *
 * putenv_test.c: Tests for the WDK putenv replacment
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int test1(void) {
	const char *s;

	if (putenv(""foobar=blubb"") < 0) {
		printf(""test1: putenv 1 failed\n"");

		return -1;
	}

	s = getenv(""foobar"");

	if (s == NULL) {
		printf(""test1: getenv 1 failed\n"");

		return -1;
	}

	if (strcmp(s, ""blubb"") != 0) {
		printf(""test1: value mismatch\n"");

		return -1;
	}

	if (putenv(""foobar"") < 0) {
		printf(""test1: putenv 2 failed\n"");

		return -1;
	}

	s = getenv(""foobar"");

	if (s != NULL) {
		printf(""test1: getenv 2 failed\n"");

		return -1;
	}

	return 0;
}

int main(void) {
#ifdef _WIN32
	fixes_init();
#endif

	if (test1() < 0) {
		return EXIT_FAILURE;
	}

	printf(""success\n"");

	return EXIT_SUCCESS;
}
"
144-22561,ISSAE/nsy103,BaseProgLinux/Environnement/exemple_environ.c,10,1,12,1727224.2112084501,259963.0,6.644114739405223,1363.0,1342.0,56886.0,25316.0,1730.0,701.0,1370.0,656.0,1500000000,0.0011514828074723,1082014363648.0,0.0104053269119066,0.0542200919685652,"#include <stdio.h>

//Variable globale de l'environnement
//Tableaux de string
//une string est tableau de char
extern char ** environ;

int main(void) {
    int i = 0;

    for (i = 0; environ [i] != NULL; i++)
        fprintf(stdout, ""%d : %s\n"", i, environ [i]);

    return (0);
}
"
154-10054,phaziz/NothingButC,2017-03-01-Aufgabe2.c,28,2,23,4159101.0522096003,188866.0,22.012786843582223,1442.0,1418.0,42805.0,15499.0,1650.0,644.0,1366.0,600.0,1500000000,0.0027727340348064,1082014363648.0,0.0151430114472694,0.0730653128430296,"# include <stdio.h>
# include <stdlib.h>

int cmpfunc (const void *a, const void *b)
{
     return ( *(int*)a - *(int*)b );
}

int main (void)
{
        system(""cls"");
        setbuf(stdin, NULL);

        int prozente[] = {38, 33, 30, 31, 25};
        int size = sizeof(prozente)/sizeof(int);
        int rueckgabe[size][2];

        printf(""\n\n\t\tVor der Sortierung:\n\n"");

        for(int i = 0; i < size; i++)
        {
            printf(""\t\t%d --> %d\n"", i, prozente[i]);
        }

        qsort(prozente, 5, sizeof(int), cmpfunc);

        printf(""\n\n\t\tNach der Sortierung:\n"");

        int i = 0;

        for(int j = size ; j > 0; j--)
        {
            rueckgabe[j][0] = prozente[i];
            printf(""\n\t\t%d --> %d"", (j - 1), rueckgabe[j][0]);
            i++;
        }

        printf(""\n\n"");

        return EXIT_SUCCESS;
}"
112-19691,bryanapperson/the-c-programming-language,chapter_1/ex5.c,29,2,20,2559889.8064344,301099.0,8.501818338818794,1463.0,1436.0,68399.0,31095.0,1644.0,654.0,1361.0,611.0,1500000000,0.0017065932042896,1082014363648.0,0.0096280625309283,0.0429171608338191,"//
// Created by Bryan Apperson on 12/4/16.
//
#include <stdio.h>

int main() {
    float fahr, celsius;
    int lower, upper, step;
    float ratio;

    lower = 0;
    upper = 300;
    step = 20;

    ratio = 5.0 / 9.0;

    fahr = upper;

    printf(""This is a simple program that converts\n"");
    printf(""Celsius to Fahrenheit in decimal format\n"");

    while (fahr >= lower) {
        celsius = ratio * (fahr - 32);
        printf(""Celsius: %6.2f Fahrenheit: %3.1f\n"", celsius, fahr);
        fahr = fahr - step;
    }

    celsius = upper;
    ratio = 9.0 / 5.0;

    printf(""Now let's print the reverse\n"");

    while (celsius >= lower) {
        fahr = celsius * ratio + 32;
        printf(""Fahrenheit: %6.2f Celsius: %3.1f\n"", fahr, celsius);
        celsius = celsius - step;
    }

    return 0;
}
"
335-17561,bablon/libstring,stpcpy.c,17,1,15,1826073.04304835,171078.0,10.67392066776558,1147.0,1140.0,38917.0,12878.0,1584.0,586.0,1329.0,546.0,1500000000,0.0012173820286989,1082014363648.0,0.0133681712435263,0.0780963413456897,"#include <assert.h>
#include <stdio.h>

char *stpcpy(char *dst, const char *src)
{
	assert(dst != NULL && src != NULL);

	while ((*dst++ = *src++) != 0)
		;

	return (dst - 1);
}

int main(int argc, char *argv[])
{
	char *p;
	char buf[32] = ""abcdefghijklmnopqrstuvwxyz"";
	const char *src = ""helloworld"";

	p = stpcpy(buf, src);
	assert(*p == '\0');
	assert((p-buf) == 10);

	return 0;
}
"
131-24721,curoverse/l7g,lib/asmukk/examples/mktest.c,54,4,39,1998544.67064135,2212263.0,0.9033934934499198,1365.0,1345.0,667578.0,268559.0,1664.0,855.0,1374.0,811.0,1500000000,0.0013323631137609,1082014363648.0,0.0012249899763274,0.0050249055426716,"/*
    Copyright (C) 2015 Curoverse, Inc.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/




#include <stdio.h>
#include <stdlib.h>

char rc(void) {
  int k;
  k = rand()%4;
  if (k==0) { return 'a'; }
  else if (k==1) { return 'c'; }
  else if (k==2) { return 'g'; }
  else if (k==3) { return 't'; }
  return '\0';
}

int main(int argc, char **argv) {
  int i, j, k;
  int n, z;
  double p, P=1.0/100.0;
  long int seed = -1;
  int pair, n_pair = 1;

  char *a, *b;

  n = 10000;

  if (argc>1) { n = atoi(argv[1]); }
  if (argc>2) { seed = atoi(argv[2]); }
  if (argc>3) { P = atof(argv[3]); }
  if (argc>4) { n_pair = atoi(argv[4]); }

  if (seed>=0) { srand((unsigned long int)seed); }

  a = (char *)malloc(sizeof(char)*(n+1));
  a[n] = '\0';

  for (pair=0; pair<n_pair; pair++) {

    for (i=0; i<n; i++) { a[i] = rc(); }

    printf(""%s\n"", a);

    for (i=0; i<n; i++) {
      p = (double)rand()/(RAND_MAX+1.0);

      if (p<P) {

        k = rand()%3;
        if (k==0) { printf(""%c"", rc()); }                 // sub
        else if (k==1) { continue; }                      // del
        else if (k==2) { printf(""%c%c"", a[i], rc()); }    // ins
      } else {
        printf(""%c"", a[i]);
      }
    }

    printf(""\n"");

  }

}
"
159-25362,hzq1001/or1k-src,gdb/testsuite/gdb.python/py-value.c,75,1,39,1346433.30238755,172475.0,7.806540078272214,1289.0,1271.0,39022.0,13223.0,1605.0,635.0,1333.0,592.0,1500000000,0.0008976222015917,1082014363648.0,0.0148427308305551,0.0797205474208058,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2008-2013 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <stdio.h>

struct s
{
  int a;
  int b;
};

union u
{
  int a;
  float b;
};

enum e
  {
    ONE = 1,
    TWO = 2
  };

typedef struct s *PTR;

enum e evalue = TWO;

#ifdef __cplusplus

struct Base {
  virtual int x() { return 5; }
};

struct Derived : public Base {
};

Base *base = new Derived ();

void ptr_ref(int*& rptr_int)
{
  return; /* break to inspect pointer by reference. */
}
#endif

void func1 ()
{
  printf (""void function called\n"");
}

int func2 (int arg1, int arg2)
{
  return arg1 + arg2;
}

char **save_argv;

int
main (int argc, char *argv[])
{
  char *cp = argv[0]; /* Prevent gcc from optimizing argv[] out.  */
  struct s s;
  union u u;
  PTR x = &s;
  char st[17] = ""divide et impera"";
  char nullst[17] = ""divide\0et\0impera"";
  void (*fp1) (void)  = &func1;
  int  (*fp2) (int, int) = &func2;
  const char *sptr = ""pointer"";
  const char *embed = ""embedded x\201\202\203\204"";
  int a[3] = {1,2,3};
  int *p = a;
  int i = 2;
  int *ptr_i = &i;
  const char *sn = 0;
  s.a = 3;
  s.b = 5;
  u.a = 7;
  (*fp1) ();
  (*fp2) (10,20);

#ifdef __cplusplus
  ptr_ref(ptr_i);
#endif

  save_argv = argv;      /* break to inspect struct and union */
  return 0;
}
"
390-29714,nolink/algorithm,training/005clock_sync.c,107,3,66,113770535.797812,530350203.0,0.214519640713704,1347.0,1326.0,137431692.0,23204850.0,1628.0,638.0,1347.0,594.0,1500000000,0.075847023865208,1082014363648.0,5.040065950535707e-06,2.618955779065513e-05,"
#include <stdio.h>

int  connections[10][5] = {{0,1,2,-1,-1},{3,7,9,11,-1},{4,10,14,15,-1},{0,4,5,6,7},{6,7,8,10,12},{0,2,14,15,-1},{3,14,15,-1,-1},{4,5,7,14,15},{1,2,3,4,5},{3,4,5,9,13}};

int all_twelve(int* current_locations){

	int i=0;
	for(i=0;i<16;i++){
		if(current_locations[i] != 12){
			return -1;
		}
	}

	return 0;
}

void set(int* current_locations, int* affected, int value){
	int i=0;
	for(i=0;i<5;i++){
		if(-1 != affected[i]){
			current_locations[affected[i]] = current_locations[affected[i]] + value;
			if(current_locations[affected[i]] > 12){
				current_locations[affected[i]] = current_locations[affected[i]] - 12;
			}
			if(current_locations[affected[i]] <= 0){
				current_locations[affected[i]] = current_locations[affected[i]] + 12;
			}
		}
	}
}


int min_switch(int* current_locations, int switch_idx){


	if(switch_idx >= 10){
		return all_twelve(current_locations);
	}
	int i=0;
	int* affected = connections[switch_idx];

	//当前不动，后面的开关动的最小次数
	int no_switch = min_switch(current_locations, switch_idx+1);

	set(current_locations, affected, 3);
	//当前动一次，后面的开关动的最小次数
	int switch_once = min_switch(current_locations, switch_idx+1);
	if(switch_once != -1){
		switch_once += 1;
	}
	set(current_locations, affected, -3);

	set(current_locations, affected, 6);
	//当前动两次，后面的开关动的最小次数
	int switch_twice = min_switch(current_locations, switch_idx+1);
	if(switch_twice != -1){
		switch_twice += 2;
	}
	set(current_locations, affected, -6);

	set(current_locations, affected, 9);
	//当前动三次，后面的开关动的最小次数
	int switch_third = min_switch(current_locations, switch_idx+1);
	if(switch_third != -1){
		switch_third += 3;
	}
	set(current_locations, affected, -9);

	if(switch_once != -1){
		if(no_switch == -1){
			no_switch = switch_once;
		}
		else if(no_switch > switch_once){
			no_switch = switch_once;
		}
	}

	if(switch_twice != -1){
		if(no_switch == -1){
			no_switch = switch_twice;
		}
		else if(no_switch > switch_twice){
			no_switch = switch_twice;
		}
	}

	if(switch_third != -1){
		if(no_switch == -1){
			no_switch = switch_third;
		}
		else if(no_switch > switch_third){
			no_switch = switch_third;
		}
	}

	return no_switch;

}


int min_switch_v2(int* current_locations, int switch_idx){

	if(switch_idx >= 10){
		return all_twelve(current_locations);
	}
	int i=0, tmp=0, ret=-1;

	for(i=0;i<4;i++){
		set(current_locations, connections[switch_idx], i*3);
		tmp = min_switch_v2(current_locations, switch_idx+1);
		set(current_locations, connections[switch_idx], -i*3);
		if(tmp != -1){
			tmp += i;
			if(ret == -1 || ret > tmp){
				ret = tmp;
			}
		}
	}

	return ret;
}


int main(int argc, char const *argv[])
{
	//2
	int case1[] = {12,6,6,6,6,6,12,12,12,12,12,12,12,12,12,12};
	//9
	int case2[] = {12,9,3,12,6,6,9,3,12,9,12,9,12,12,6,6};

	printf(""%d\n"", min_switch_v2(case1, 0));
	printf(""%d\n"", min_switch_v2(case2, 0));

	return 0;
}
"
318-22490,kmongo/practice,likedlist.c,103,5,51,1615999.4993358,184678.0,8.750360086204095,1361.0,1343.0,41908.0,15050.0,1633.0,640.0,1354.0,597.0,1500000000,0.0010773329995572,1082014363648.0,0.0146417006898493,0.0741599073001158,"#include <stdio.h>
#include <stdlib.h>
typedef struct Node{
	int val;
	struct Node* next;
}Node;

Node *head = NULL;

void insertToTail(int val){
	Node* temp = (Node*)malloc(sizeof(Node));
	temp->val = val;
	temp->next = NULL;
	if(head == NULL){
		temp->next = head;
		head = temp;
		return;
	}

	Node *temp2 = head;
	while(temp2->next != NULL)
		temp2 = temp2->next;
	temp->next = NULL;
	temp2->next = temp;
}

void insertToFront(int val){
	Node* temp = (Node*)malloc(sizeof(Node));
	temp->val = val;
	temp->next = head;
	head = temp;
}

void deleteN(int n){
	Node *temp = head;
	if(n == 1){
		head = head->next;
		free(temp);
		return;
	}
	int i;
	for(i = 0;i < n-2;i++){
		temp = temp->next;
	}

	Node *temp2 = temp->next;
	temp->next = temp2->next;
	free(temp2);
}
void clear(){
	while(head != NULL){
		Node *temp = head;
		head = head->next;
		free(temp);
	}
}
void Print(){
	Node *temp = head;
	if(temp == NULL){
		printf(""no member in this list\n"");
		return;
	}
	while(temp != NULL){
		printf(""%d "", temp->val);
		temp = temp->next;
	}
	printf(""\n"");
}

void reverseByIter(){
	Node *current,*next,*prev;
	current = head;
	prev = NULL;
	while(current != NULL){
		next = current->next;
		current->next = prev;
		prev = current;
		current = next;
	}
	head = prev;
}

void reverseByRecu(Node *p){
	if(p == NULL || p->next == NULL){
		head = p;
		return;
	}
	reverseByRecu(p->next);
	p->next->next = p;
	p->next = NULL;
}

Node *reverseByRecu_2(Node *p){
	if(p == NULL || p->next == NULL){
		return p;
	}

	Node* temp = reverseByRecu_2(p->next);
	p->next->next = p;
	p->next = NULL;
	return temp;
}

int main(){
	insertToFront(2);
	insertToFront(100);
	insertToFront(234);
	insertToFront(32);
	insertToFront(50);
	insertToFront(99);
	Print();
	reverseByRecu(head);
	Print();
	reverseByRecu_2(head);
	Print();
}
"
395-30201,kimushu/nios2-gdb-7.0,gdb/testsuite/gdb.base/step-break.c,24,2,25,1087427992.6065354,9663845478.0,0.1125253911060104,1139.0,1129.0,3221263925.0,2147496345.0,1567.0,588.0,1316.0,547.0,1500000000,0.7249519950710237,1082014363648.0,2.3468918301344558e-07,7.484036905972708e-07,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2008, 2009 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

int
main ()
{
    volatile int i = 1;

    while (i > 0) /* place1 */
      {
	i++; /* place2 */
	i++; /* place3, set breakpoint here  */
      }

    return 0;
}
"
152-35022,yigezhe/algorithm-summary,sorting/array_sort/bubble_sort/BubbleSortOptimizing.c,67,5,37,2125937.72448585,227689.0,9.33702111213102,1357.0,1340.0,51373.0,21621.0,1630.0,637.0,1351.0,594.0,1500000000,0.0014172918163239,1082014363648.0,0.0118451045065857,0.0577033728799627,"/*
 * 作者：何伟伟
 * 作者邮箱：<1830973318@qq.com>
 * 文件名: BubbleSortOptimizing.c
 * 创建日期: 2014年12月18日 星期四 07时12分16秒
 * 程序想法： 
procedure bubbleSort( A : list of sortable items )
    n = length(A)
    repeat
       swapped = false
       for i = 1 to n-1 inclusive do
          if A[i-1] > A[i] then
             swap(A[i-1], A[i])
             swapped = true
          end if
       end for
       n = n - 1
    until not swapped
end procedure
 */
#include<stdio.h>
void swap(int *Aj, int *Aj1) {
    int originAj = (*Aj);
    *Aj = (*Aj1);
    *Aj1 = originAj;
}
void printarray(int array[], int size) {
    int i;
    for (i = 0; i < size; i++) {
	printf(""%d "", array[i]);
    }
    printf(""\n"");
}

void bubbleSort(int A[], int n) {
    int swapped;
    do {
	swapped = 0;
	int i;
	//这里依然是每一次都从头开始比较，调换次序
	for (i = 1; i <= n - 1; i++) {
	    printarray(A, n);
	    if (A[i - 1] > A[i]) {
		swap(&A[i - 1], &A[i]);
		swapped = 1;
	    }
	    printarray(A, n);
	}
	//这里调换一次就让ｎ减一，这是一个我没有见过的处理办法！
	n = n - 1;
	printf(""a round end n=%d\n"", n);
    } while (swapped);
}
void test_bubbleSort() {
    int array[5] = { 4, 2, 8, 7, 1 };
    //printarray(array, 5);
    bubbleSort(array, 5);
    //printarray(array, 5);
}
void input() {
}

void solve() {
}

int main() {
    input();
    solve();
    test_bubbleSort();
    return 0;
}
"
264-15031,bobblestiltskin/project_euler,c/pe024.c,55,1,31,464726080.535911,3783941354.0,0.1228153495319737,1378.0,1357.0,642931919.0,507254882.0,1642.0,637.0,1358.0,594.0,1500000000,0.3098173870239407,1082014363648.0,7.227913289694183e-07,3.678532909890348e-06,"#include <stdio.h>
#include <string.h>

#define OFFSET 48

int main()
{
/*
  9! is 362880 so after all the 10 digit numbers which 
  start with 0 or 1 we will have passed 725760 of the 
  combinations. The millionth combination will start
  with a 2, since we need to count 274240 more combinations
  after 2000000000.

  8! is 40320, so there are that many 10 digit combinations starting 20.
  The combination starting 22 is invalid (since the numerals must be
  distinct), so we could count 6 sets of combinations of 40320 up to
  2700000000 and then we would have seen 725760+241920 leaving 32320 to
  find.

  7! is 5040, so 6 sets are 30240. As before we count 6 sets from 
  2700000000 (excluding 2 and 7) and get to 2780000000, leaving 2080 to find.
*/

//  unsigned long long start = 2780000000; 
/* unsure why the compiler complains about initialising start to 2780000000; */
  unsigned long long start = 2000000000; 
  start                   += 700000000;
  start                   += 80000000;

  unsigned long long end   = 9876543210ull;

  unsigned long long count = 725760 + 241920 + 30240;
  unsigned long long i;
  for (i = start; i <= end; ++i)
  {
    char string[11];
    snprintf(string, 11, ""%010llu"", i);

    if (strchr(string, OFFSET + 0) == NULL)
      continue;
    if (strchr(string, OFFSET + 1) == NULL)
      continue;
    if (strchr(string, OFFSET + 2) == NULL)
      continue;
    if (strchr(string, OFFSET + 3) == NULL)
      continue;
    if (strchr(string, OFFSET + 4) == NULL)
      continue;
    if (strchr(string, OFFSET + 5) == NULL)
      continue;
    if (strchr(string, OFFSET + 6) == NULL)
      continue;
    if (strchr(string, OFFSET + 7) == NULL)
      continue;
    if (strchr(string, OFFSET + 8) == NULL)
      continue;
    if (strchr(string, OFFSET + 9) == NULL)
      continue;
    
    count++;
    if (count == 1000000)
      break;
  }
  printf(""%llu\n"", i);
  return(0);
}
"
198-11580,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.stabs/gdb11479.c,60,2,29,1535000.9780376002,169057.0,9.079777826413576,1139.0,1129.0,38452.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010233339853584,1082014363648.0,0.0134155935572026,0.0785172440760147,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2010-2015 Free Software Foundation, Inc.

   Contributed by Pierre Muller.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

   Qualifiers of forward types are not resolved correctly with stabs.  */

struct dummy;

enum dummy_enum;

/* This function prevents the compiler from dropping local variables
   we need for the test.  */
void *hack (const struct dummy *t, const enum dummy_enum *e);

const void *
test (const struct dummy *t)
{
  const struct dummy *tt;
  enum dummy_enum *e;
  tt = t;
  return hack (t, e);
}

void *
test2 (struct dummy *t)
{
  struct dummy *tt;
  const enum dummy_enum *e;
  tt = t;
  return hack (t, e);
}


struct dummy {
 int x;
 int y;
 double b;
} tag_dummy;

enum dummy_enum {
  enum1,
  enum2
} tag_dummy_enum;

void *
hack (const struct dummy *t, const enum dummy_enum *e)
{
  return (void *) t;
}

int
main ()
{
  struct dummy tt;
  tt.x = 5;
  tt.y = 25;
  tt.b = 2.5;
  test2 (&tt);
  test (&tt);
  return 0;
}
"
079-16869,acarno/slicer,valgrind/drd/tests/bug-235681.c,66,2,39,1503131299.5124607,186864.0,8043.9854600137,1455.0,1427.0,42922.0,15005.0,1678.0,670.0,1383.0,625.0,1500000000,1.0020875330083072,1082014363648.0,0.015422981419642,0.0751980941529856,"/*
 * pthread_cond_wait() test program.
 * See also https://bugs.kde.org/show_bug.cgi?id=235681.
 */

#include <string.h>
#include <stdio.h>
#include <assert.h>
#include <pthread.h>
#include <errno.h>
#include <unistd.h>

pthread_mutex_t mutex;
pthread_cond_t cond_var;
int status;
int silent;

static void *run_fn(void *v)
{
    int rc;

    if (!silent)
        fprintf(stderr, ""run_fn starting\n"");

    rc = pthread_mutex_lock(&mutex);
    assert(!rc);

    while (!status) {
        if (!silent)
            fprintf(stderr, ""run_fn(): status==0\n"");
        rc = pthread_cond_wait(&cond_var, &mutex);
        assert(!rc);
        if (!silent)
            fprintf(stderr, ""run_fn(): woke up\n"");
    }
    if (!silent)
        fprintf(stderr, ""run_fn(): status==1\n"");

    rc = pthread_mutex_unlock(&mutex);
    assert(!rc);

    if (!silent)
        fprintf(stderr, ""run_fn done\n"");

    return NULL;
}

int main(int argc, char **argv)
{
    int rc;
    pthread_t other_thread;

    if (argc > 1)
        silent = 1;

    rc = pthread_mutex_init(&mutex, NULL);
    assert(!rc);
    rc = pthread_cond_init(&cond_var, NULL);
    assert(!rc);

    status = 0;

    rc = pthread_create(&other_thread, NULL, run_fn, NULL);
    assert(!rc);

    /* yield the processor, and give the other thread a chance to get into the while loop */
    if (!silent)
        fprintf(stderr, ""main(): sleeping...\n"");
    sleep(1);

    rc = pthread_mutex_lock(&mutex);
    assert(!rc);
    /**** BEGIN CS *****/

    if (!silent)
        fprintf(stderr, ""main(): status=1\n"");
    status = 1;
    rc = pthread_cond_broadcast(&cond_var);
    assert(!rc);

    /**** END CS *****/
    rc = pthread_mutex_unlock(&mutex);
    assert(!rc);

    if (!silent)
        fprintf(stderr, ""joining...\n"");

    rc = pthread_join(other_thread, NULL);
    assert(!rc);

    fprintf(stderr, ""Done.\n"");

    return 0;
}
"
101-4102,yantrabuddhi/nativeclient,tests/minsfi/sandbox_invoke_args.c,11,1,13,1982238.0272671499,170089.0,11.64987741711692,1157.0,1148.0,38683.0,12793.0,1580.0,585.0,1325.0,544.0,1500000000,0.0013214920181781,1082014363648.0,0.0135517288008042,0.0783666174527935,"/*
 * Copyright (c) 2014 The Native Client Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

#include <stdlib.h>

int main(int argc, char **argv) {
  int i, sum = 0;
  for (i = 0; i < argc; ++i)
    sum += strtol(argv[i], 0, 0);
  return sum;
}
"
066-11533,ensc/dietlibc,test/stdlib/testsort.c,26,3,19,1871643.00587025,828322.0,2.259559688140602,1387.0,1364.0,208295.0,77069.0,1667.0,902.0,1365.0,795.0,1500000000,0.0012477620039135,1082014363648.0,0.0033211722011488,0.0165718170477004,"#define _BSD_SOURCE

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

static int
compare (const void *a, const void *b)
{
  return strcmp (*(char **) a, *(char **) b);
}

int
main (void)
{
  char bufs[500][20];
  char *lines[500];
  size_t lens[500];
  size_t i, j;

  srandom (1);

  for (i = 0; i < 500; ++i)
    {
      lens[i] = random() % 19;
      lines[i] = bufs[i];
      for (j = 0; j < lens[i]; ++j)
	lines[i][j] = random() % 26 + 'a';
      lines[i][j] = '\0';
    }

  qsort (lines, 500, sizeof (char *), compare);

  for (i = 0; i < 500 && lines[i] != NULL; ++i)
    puts (lines[i]);

  return 0;
}
"
173-5894,3nr1c/metodesnumerics,p3e1.c,22,1,18,2107639.33137045,628374.0,3.354115542654534,1527.0,1495.0,128943.0,70035.0,1640.0,685.0,1358.0,643.0,1500000000,0.0014050928875803,1082014363648.0,0.0048092378106032,0.0217410970056991,"#include <stdio.h>
#include <math.h>

#define X_1 1
#define X_2 1-sqrt(3) 

int main()
{
	double x1 = X_1;
	double x2 = X_2;
	double x3 = 0;

	double z = X_2;

	int i = 0;

	for (i = 3; i <= 50; i++) {
		x3 = 2 * (x1 + x2);

		z *= X_2;

		printf(""%2d %+.8le %+.8le %+.8le %+.8le\n"",
			i,
			z,
			x3,
			fabs(x3 - z),
			fabs((x3 - z) / x3)
		);

		x1 = x2;
		x2 = x3;
	}


	return 0;
}
"
187-13269,limuyuan/C_Primer_Plus,ch06/exercise16.c,19,1,16,2812760.9984949,316792.0,8.878885830450264,1492.0,1463.0,71347.0,33155.0,1647.0,653.0,1362.0,608.0,1500000000,0.0018751739989966,1082014363648.0,0.0093278870678552,0.0408604620007272,"//Programming Exercise 6.16.16
#include <stdio.h>
int main(void)
{
	double money, daphne, deirdre;
	int years = 1;

	money = 100.0;
	daphne = money;
	deirdre = money;
	printf(""          Daphne   Deirdre\n"");

	while (deirdre <= daphne)
	{
		daphne += money * 0.10;
		deirdre *= 1.05;
		printf(""Year%2d : $%-8.2f $%-8.2f\n"", years, daphne, deirdre);
		years++;
	}
	printf(""Deirdre's investment beyond Daphne's investment takes %d years!\n"", years-1);
	printf(""Daphne will have $%.2f, and Deirdre will have $%.2f since then!\n"", daphne, deirdre);
}"
160-19396,hironics/clib_examples,string/search.c,41,2,31,2442438.0389973,185828.0,13.143541339303011,1392.0,1368.0,42170.0,14900.0,1663.0,641.0,1378.0,598.0,1500000000,0.0016282920259982,1082014363648.0,0.0148524441957078,0.0749956194147538,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define HW ""Hello World""
#define HR ""Hey Hiro!""
#define SS ""Hello World&Class""
#define ARR 20
#define printme(x, y) printf(#y x, y)

int main(int argc, char * argv[])
{
    char str[ARR] = HW;
    char *array[20] ;
    int loop;
    /*
    search char in strings
    strchr
    strrchr
    memchr
    */
    printf(""find o at :%d\n"", strchr(str, 'o')-str);
    printf(""find o backward forward at :%d\n"", strrchr(str, 'o')-str);
    printf(""find o at :%d\n"", (char *)memchr(str, 'o', strlen(str))-str);

    /*
    search multiple chars
    strspn: the length of longest string contains any member of str2
    strspn: the length of char in str1 have been scanned before it matches any char in str2 

    */
    printf(""find Wo at :%d\n"", strstr(str, ""Wo"")-str);
    printf(""find longest string that have Hel at :%d\n"", strspn(str, ""Hel""));
    printf(""find longest string that have Hel at :%d\n"", strcspn(HW, ""Wd""));

    /*
    strtok: used to break string into multiple substr
    fist time call: it return the addr os string
    second time call, it accepts NULL, will return any
    */
    strcpy(str, SS);
    array[0] = strtok(str, "" &"");

    for(loop = 1; loop<20; loop++){
        if((array[loop]=strtok(NULL, "" &""))==NULL){
            break;
        }    
    }

    for(loop=0;loop<10;loop++){
        if(array[loop] == NULL)
            break;
        printf(""item #%d is %s.\n"", loop, array[loop]);    
    }
    return EXIT_SUCCESS;
}
"
372-28707,jbruchon/dev86,tests/MSDOS/swab.c,20,1,18,1864805.81760405,178209.0,10.461160771902652,1369.0,1341.0,40365.0,13893.0,1643.0,637.0,1361.0,595.0,1500000000,0.0012432038784027,1082014363648.0,0.0152068638508717,0.0780714364701979,"/*
 * bcc libc-test: swab
 *
 * This is a test-project for dev86/bcc to test the libc functions.
 *
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[]) {
    char src[32], dst[32];
    int n;

    n = 8;
    sprintf(src, ""abcdefgh"");
    swab(src, dst, n);
    printf(""'%s' => '%s' (%u)\r\n"", src, dst, n);


    n = 2;
    bzero(dst, strlen(dst));
    sprintf(src, ""123456789"");
    swab(src, dst, n);
    printf(""'%s' => '%s' (%u)\r\n"", src, dst, n);
    return 0;
}
"
022-22876,evaautomation/binutils,gdb/testsuite/gdb.trace/ftrace.c,53,2,29,1429081.66162665,169165.0,8.447852688203824,1142.0,1132.0,38480.0,12717.0,1568.0,585.0,1317.0,546.0,1500000000,0.0009527211077511,1082014363648.0,0.0134424969704135,0.0784420962165751,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2011-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#ifdef SYMBOL_PREFIX
#define SYMBOL(str)     SYMBOL_PREFIX #str
#else
#define SYMBOL(str)     #str
#endif

int globvar;

static void
begin (void)
{}

/* Called from asm.  */
static void __attribute__((used))
func (void)
{}

static void
marker (int anarg)
{
  /* `set_point' is the label at which to set a fast tracepoint.  The
     insn at the label must be large enough to fit a fast tracepoint
     jump.  */
  asm (""    .global "" SYMBOL(set_point) ""\n""
       SYMBOL(set_point) "":\n""
#if (defined __x86_64__ || defined __i386__)
       ""    call "" SYMBOL(func) ""\n""
#elif (defined __aarch64__)
       ""    nop\n""
#endif
       );

  ++anarg;

  /* Set up a known 4-byte instruction so we can try to set a shorter
     fast tracepoint at it.  */
  asm (""    .global "" SYMBOL(four_byter) ""\n""
       SYMBOL(four_byter) "":\n""
#if (defined __i386__)
       ""    cmpl $0x1,0x8(%ebp) \n""
#endif
       );
}

static void
end (void)
{}

int
main ()
{
  begin ();

  for (globvar = 1; globvar < 11; ++globvar)
    {
      marker (globvar * 100);
    }

  end ();
  return 0;
}
"
191-31545,tykowale/learningC,ProgrammingInC/chapter8/ex12.c,33,4,19,2830144.7164266002,196203.0,23.84285663318094,1362.0,1339.0,44358.0,16698.0,1644.0,639.0,1359.0,596.0,1500000000,0.0018867631442844,1082014363648.0,0.0137663542351544,0.0694116876310272,"/*Program to sort an array of integers into ascending order*/

#include <stdio.h>

void sort (int a[], int n)
{
    int i, j, temp;

    for ( i = 0; i < n - 1; ++i ) {
        for ( j = i + 1; j < n; ++j ) {
            if ( a[i]  > a[j] ) {
                temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }
        }
    }
}

int main (void)
{
    int i;
    int array[16] = {
        34, -5, 6, 0, 12, 100, 56, 22,
        44, -3, -9, 12, 17, 22, 6, 11 };
    void sort (int a[], int n);

    printf (""The array before the sort: \n"");

    for ( i = 0; i < 16; ++i ) {
        printf (""%i "", array[i]);
    }

    sort(array, 16);

    printf (""\n\nThe array after the sort:\n"");

    for ( i = 0; i < 16; ++i ) {
        printf (""%i "", array[i]);
    }

    printf (""\n"");

    return 0;
}

"
272-7484,realincubus/pluto_clang,orio-0.1.0/testsuite/gemver/pluto/gemver_profiling.c,33,2,27,220314748.58522415,200390132.0,1.0994291275779986,1155.0,1147.0,38687.0,25122785.0,1631.0,3156848.0,1330.0,3130559.0,1500000000,0.1468764990568161,1082014363648.0,1.148759161454118e-05,0.25,"#include <stdio.h> 
#include <stdlib.h> 

#define N 5000
#define alpha 1
#define beta 1

double A[N][N];
double B[N][N];
double x[N];
double u1[N];
double u2[N];
double v2[N];
double v1[N];
double w[N];
double y[N];
double z[N];

void init_array()  
{  
  int i, j;
  for (i=0; i<N; i++) {
    u1[i] = i;
    u2[i] = (i+1)/N/2.0;
    v1[i] = (i+1)/N/4.0;
    v2[i] = (i+1)/N/6.0;
    y[i] = (i+1)/N/8.0;
    z[i] = (i+1)/N/9.0;
    x[i] = 0.0;
    w[i] = 0.0;
    for (j=0; j<N; j++) {
      A[i][j] = ((double) i*j)/N;
    }
  }
}  

int main() 
{ 
  init_array(); 
 
  /*@ profiled code @*/ 
 
  return w[0];   //needed to avoid dead code elimination 
} 
"
291-12759,fatedier/fatest,algorithm/bubble_sort/bubble_sort.c,37,4,29,1803662.9771812502,212069.0,8.505071462590006,1374.0,1345.0,48189.0,18216.0,1644.0,642.0,1363.0,598.0,1500000000,0.0012024419847875,1082014363648.0,0.0128212987282441,0.0639560274075747,"#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <time.h>

#define NUMBER 20
#define RANDMIN 0
#define RANDMAX 1000

#ifndef true
typedef char bool;
#define true 1
#define false 0
#endif

void swap(int *a, int *b)
{
    if (a == b)
        return;
    *a = (*a) ^ (*b);
    *b = (*a) ^ (*b);
    *a = (*a) ^ (*b);
}

void bubble_sort(int a[], int length)
{
    for (int i=0; i<length; i++) {
        for (int k = 0; k < length - i; k++) {
            if (a[k] > a[k + 1]) {
                swap(&a[k], &a[k+1]);
            }
        }
    }
    return;
}

int main(int argc, char **argv)
{
    int a[NUMBER];
    srand(time(NULL));
    int i;
    for (i=0; i<NUMBER; i++) {
        a[i] = rand() % (RANDMAX - RANDMIN) + RANDMIN;
        printf(""%d "", a[i]);
    }
    printf(""\n"");

    bubble_sort(a, NUMBER);

    for (i=0; i<NUMBER; i++) {
        printf(""%d "", a[i]);
    }
    printf(""\n"");
    return 0;
}
"
098-5416,alexhilton/miscellaneous,linux/advanced-prog-in-unix/chap04/eg0408.c,16,3,17,1924443.0586695,174156.0,11.045826730058108,1297.0,1279.0,39549.0,13453.0,1627.0,633.0,1346.0,591.0,1500000000,0.001282962039113,1082014363648.0,0.0147913365029054,0.079185691105996,"/**
 * eg0408.c
 * show you how to use function chdir to change current working directory for a
 * process.
 * Note that current working process is an attribute of a process. As a result,
 * chdir will only affect the current process's current working directory.
 * If you change current working directory for your program, for instance, the
 * shell which runs your program will not be affected.
 */
#include <stdio.h>
#include <unistd.h>

int main( int argc, char **argv ) {
  if ( chdir( ""/tmp/"" ) < 0 ) {
    fprintf( stderr, ""chdir error"" );
  }
  printf( ""chdir to /tmp succeed\n"" );
  return 0;
}
"
359-18013,guoxiaoyong/simple-useful,brainfuck/rot13.c,20,1,21,1741534.564644,173881.0,10.015665886439576,1280.0,1262.0,39476.0,13420.0,1615.0,633.0,1336.0,592.0,1500000000,0.001161023043096,1082014363648.0,0.0146191935864182,0.0789473684210526,"#include <stdio.h>

//  A-M (65-77) -> N-Z (78-90)
//  a-m (97-109) -> n-z (110-122)
int rot13(int x) {

    int q = (x-1)/32;
    int r = (x-1)%32;

    if ( q != 2 && q != 3) return x;

    q = r/13;

    switch (q) {

       case 0: return x+13;
       case 1: return x-13;
       case 2: return x;
    }

}

int main (void) {


   int c;
   while ((c = fgetc(stdin)) != EOF) {

       putchar(rot13(c));
   }

   return 0;
}

"
044-26825,iains/darwin-gcc-4-8,gcc/testsuite/gcc.dg/tree-ssa/predcom-6.c,12,1,15,1338738.0167841,169100.0,7.876735659373152,1143.0,1133.0,38466.0,12698.0,1569.0,586.0,1318.0,547.0,1500000000,0.0008924920111894,1082014363648.0,0.0134594914251921,0.0785708701430693,"/* { dg-do run } */
/* { dg-options ""-O3"" } */

int a, c, e[5][2]; 
unsigned int d;

int
main ()
{
  for (d = 0; d < 2; d++)
    if (a ? 0 : e[c + 3][d] & e[c + 4][d])
      break;
  return 0;
}
"
210-29565,sabonis/The-C-Programming-Language-Anwser,exercises/5-3.c,15,2,16,1651111.6409673,173260.0,9.529672168994574,1286.0,1271.0,39282.0,13326.0,1617.0,634.0,1341.0,592.0,1500000000,0.0011007410939782,1082014363648.0,0.0147581669167724,0.0795316301703163,"#include <stdio.h>
#include <string.h>

void strcat2(char *s, char *t);
int main() {
    char s[100] = ""fuck"";
    char *t = ""sabonis"";
    strcat2(s, t);
    printf(""%s\n"", s);
}

void strcat2(char *s, char *t) {
    while(*s)
        s++;
        ;
    while(*s++ = *t++)
        ;
    *s = '\0';
}

"
304-13860,abdulkareemsn/grampathy,simple_threads.c,64,5,40,3290797.35092805,270544.0,12.163629575965462,2432.0,1802.0,64167.0,25636.0,2203.0,899.0,1642.0,807.0,1500000000,0.0021938649006187,1082014363648.0,0.0156499497309125,0.0618130797412113,"#include <pthread.h>
#include <stdio.h>
#include <string.h>

void print_message_function( void * ptr);
void do_one_thing(int *);
void do_another_thing(int *);
void do_wrap_up(int , int );

typedef struct str_thdata
{
	int thread_no;
	char message[100];
} thdata;

int main()
{
	int r1 = 0, r2 = 0;

	pthread_t thread1, thread2;
	pthread_t thread3, thread4;

	thdata data1, data2;
	data1.thread_no = 1;
	strcpy(data1.message, ""Hello!"");
	data2.thread_no = 2;
	strcpy(data2.message, ""Hi!!"");

	pthread_create(&thread1, NULL, (void *) do_one_thing, (void *) &r1);
	pthread_create(&thread2, NULL, (void *) do_another_thing, (void *) &r2);

	pthread_join(thread1, NULL);
	pthread_join(thread2, NULL);

	pthread_create(&thread3, NULL, (void *) &print_message_function, (void *) &data1);
	pthread_create(&thread4, NULL, (void *) &print_message_function, (void *) &data2);

	pthread_join(thread3, NULL);
	pthread_join(thread4, NULL);

	do_wrap_up(r1,r2);

	return 0;
}

void do_one_thing(int *pnum_times)
{
	int i,j,x;
	for(i = 0; i<4; i++)
	{
		printf(""doing one thing\n"");
		for(j=0;j<10000;j++) x = x+i;
		(*pnum_times)++;
	}
}


void do_another_thing(int *pnum_times)
{
	int i,j,x;
	for(i = 0; i<4; i++)
	{
		printf(""doing another thing\n"");
		for(j=0; j<10000; j++)
			x = x+i;
		(*pnum_times)++;
	}
}

void do_wrap_up(int one_times, int another_times)
{
	int total;
	total = one_times + another_times;
	printf(""All done, one thing %d, another %d for a total of %d\n"", one_times, another_times, total);
}

void print_message_function(void *ptr)
{
	thdata * data;
	data = (thdata *) ptr;
	printf(""Thread %d says %s \n"", data->thread_no, data->message);

	pthread_exit(0);
}
"
032-22957,kimushu/nios2-gdb-7.0,gdb/testsuite/gdb.threads/manythreads.c,48,5,30,17105249893.502335,542758838.0,31.51537790896369,1603.0,1536.0,140612126.0,92464691.0,5208967.0,8026837.0,1632.0,9830.0,1500000000,11.403499929001557,1082014363648.0,5.7834157276311365e-06,0.0568364806526425,"/* Manythreads test program.
   Copyright 2004, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.

   Written by Jeff Johnston <jjohnstn@redhat.com> 
   Contributed by Red Hat

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <pthread.h>
#include <stdio.h>
#include <limits.h>

void *
thread_function (void *arg)
{
  int x = * (int *) arg;

  printf (""Thread <%d> executing\n"", x);

  return NULL;
}

int 
main (int argc, char **argv)
{
  pthread_attr_t attr;
  pthread_t threads[256];
  int args[256];
  int i, j;

  pthread_attr_init (&attr);

#ifdef PTHREAD_STACK_MIN
  pthread_attr_setstacksize (&attr, 2*PTHREAD_STACK_MIN);
#endif

  /* Create a ton of quick-executing threads, then wait for them to
     complete.  */
  for (i = 0; i < 1000; ++i) 
    {
      for (j = 0; j < 256; ++j)
	{
	  args[j] = i * 1000 + j;
	  pthread_create (&threads[j], &attr, thread_function, &args[j]);
	}

      for (j = 0; j < 256; ++j)
	{
	  pthread_join (threads[j], NULL);
	}
    }

  pthread_attr_destroy (&attr);

  return 0;
}
"
332-27733,alpine9000/BitOS,tests/gcc.dg/torture/pr63464.c,85,4,41,1657742.7741139499,176595.0,9.387253319742914,1155.0,1146.0,39444.0,13360.0,1577.0,586.0,1323.0,546.0,1500000000,0.0011051618494093,1082014363648.0,0.0130298139811432,0.0763578516779031,"/* PR tree-optimization/63464 */
/* { dg-do run { target int32plus } } */

int cnt;

__attribute__((noinline, noclone)) void
bar (int x, int y)
{
  cnt++;
  switch (y)
    {
    case 1:
      if ((unsigned) x < 24U && ((1U << x) & 0x860c0cU) != 0)
        __builtin_abort ();
      break;
    case 2:
      if ((unsigned) x >= 24U || ((1U << x) & 0x860c0cU) == 0)
        __builtin_abort ();
      break;
    case 3:
      if ((unsigned) x - 43U < 40U && ((1ULL << (x - 43U)) & 0x8f0000004fULL) != 0)
        __builtin_abort ();
      break;
    case 4:
      if ((unsigned) x - 43U >= 40U || ((1ULL << (x - 43U)) & 0x8f0000004fULL) == 0)
        __builtin_abort ();
      break;
    default:
      __builtin_abort ();
    }
}

__attribute__((noinline, noclone)) void
f1 (int x)
{
  if (x != 2 && x != 3 && x != 10 && x != 11 && x != 17 && x != 18 && x != 23)
    bar (x, 1);
}

__attribute__((noinline, noclone)) void
f2 (int x)
{
  if (x == 2 || x == 3 || x == 10 || x == 11 || x == 17 || x == 18 || x == 23)
    bar (x, 2);
}

__attribute__((noinline, noclone)) void
f3 (int x)
{
  if (x != 43 && x != 76 && x != 44 && x != 78 && x != 49
      && x != 77 && x != 46 && x != 75 && x != 45 && x != 82)
    bar (x, 3);
}

__attribute__((noinline, noclone)) void
f4 (int x)
{
  if (x == 43 || x == 76 || x == 44 || x == 78 || x == 49
      || x == 77 || x == 46 || x == 75 || x == 45 || x == 82)
    bar (x, 4);
}

int
main ()
{
  int i;
  f1 (-__INT_MAX__ - 1);
  for (i = -3; i < 92; i++)
    f1 (i);
  f1 (__INT_MAX__);
  if (cnt != 97 - 7)
    __builtin_abort ();
  f2 (-__INT_MAX__ - 1);
  for (i = -3; i < 92; i++)
    f2 (i);
  f2 (__INT_MAX__);
  if (cnt != 97)
    __builtin_abort ();
  f3 (-__INT_MAX__ - 1);
  for (i = -3; i < 92; i++)
    f3 (i);
  f3 (__INT_MAX__);
  if (cnt != 97 * 2 - 10)
    __builtin_abort ();
  f4 (-__INT_MAX__ - 1);
  for (i = -3; i < 92; i++)
    f4 (i);
  f4 (__INT_MAX__);
  if (cnt != 97 * 2)
    __builtin_abort ();
  return 0;
}
"
072-1840,evelynmitchell/C21,21st_century_examples/pointer_arithmetic1.c,10,1,15,1583628.2400414,173549.0,9.124961826342991,1290.0,1275.0,39364.0,13360.0,1620.0,633.0,1342.0,591.0,1500000000,0.0010557521600276,1082014363648.0,0.0147796875810289,0.0793945831120552,"/* Compile with:
export CFLAGS=""-g -Wall -std=gnu11 -O3""  #the usual.
make pointer_arithmetic1
*/
#include <stdio.h>

int main(){
    char *list[] = {""first"", ""second"", ""third"", NULL};
    for (char **p=list; *p != NULL; p++){
        printf(""%s\n"", p[0]);
    }
}
"
371-23398,danadorneanu/portofolio,kr/knr_strcpy.c,23,2,23,2355184.5224574,174410.0,13.503721116908434,1327.0,1307.0,39455.0,13445.0,1623.0,638.0,1343.0,595.0,1500000000,0.0015701230149716,1082014363648.0,0.0151023450490224,0.0793761814744801,"#include <stdio.h>

/* this function copies the string source to dest */
void strcpy(char *dest, char *source);

int main(void)
{
   int ret = 0;
   char source[] = ""Pouvez vous me dire quelle e la correct pronontiation?"", dest[] = {};
   
   strcpy(dest, source);
   printf(""\n%s\n"", dest);

   return ret;
}
/*
void strcpy (char *dest, char *source)
{
   int i = 0;

   while ((dest[i] = source[i]) != '\0')
      i++;
}
*/
void strcpy (char *dest, char *source)
{
   while (*dest++ = *source++)
      ;
}
"
139-16160,davidbrazdil/nacl,tests/hello_world/printf.c,21,2,19,2380639.66389735,171896.0,13.849298412993903,1141.0,1132.0,39273.0,13024.0,1604.0,587.0,1344.0,546.0,1500000000,0.0015870931092649,1082014363648.0,0.0132231116489039,0.0780350689332084,"/*
 * Copyright 2009 The Native Client Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can
 * be found in the LICENSE file.
 */

/*
   It can't get much simpler than this (uh, except for noop.c).
*/

#include <stdio.h>
#include <stdlib.h>

int main(int argc, char* argv[]) {
  int i;

  for (i = 1; i < argc; ++i) {
    long x;
    printf(""%s\n"", argv[i]);

    x = strtol(argv[i], 0, 0);
    printf(""%ld\n"", x);
    printf(""%lx\n"", x);
    printf(""0x%08lx\n"", x);
    printf(""\n"");
  }
  return 0;
}
"
109-5313,dalmemail/RandomKey,randomkey.c,93,5,56,2489327.8023228003,182156.0,13.665907244340016,1335.0,1313.0,41815.0,14422.0,1705.0,639.0,1401.0,596.0,1500000000,0.0016595518682152,1082014363648.0,0.0145369902720744,0.0771911730711097,"/*
 * Copyright (C) 2015 Dan Rulos [dalmemail@amaya.tk]
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <fcntl.h>

/* VERSION 0.3 */
#define VERSION ""0.3""

int filekey(int n_bytes, char *path)
{
	int fd;
	if ((fd = open(path, O_WRONLY)) < 0) {
		printf(""Error: Al abrir %s\n"", path);
		return -1;
	}
	char key[n_bytes];
	srand(time(NULL));
	int i;
	for (i = 0; i < n_bytes; i++) {
		key[i] = rand() % 126 + 33;
	}
	write(fd, key, n_bytes);
	close(fd);
	return 0;
}

void makekey(int n_bytes)
{
	char key[n_bytes];
	srand(time(NULL));
	int i;
	for (i = 0; i < n_bytes; i++) {
		key[i] = rand() % 126 + 33;
	}
	i = 0;
	printf(""Key: "");
	while (i < n_bytes) {
		printf(""%c"", key[i++]);
	}
	putchar('\n');
}

int checkarg(char *arg)
{
	int i, ret = 0;
	for (i = 0; i < strlen(arg); i++) {
		if (arg[i] != '0'&&arg[i] != '1'&&arg[i] != '2'&&arg[i] != '3'&&arg[i] != '4'&&arg[i] != '5'
			&&arg[i] != '6'&&arg[i] != '7'&&arg[i] != '8'&&arg[i] != '9') {
			ret = -1;
		}
	}
	if (ret == 0 && atoi(arg) == 0) {
		ret = -1;
	}
	return ret;
}

int main(int argc, char **argv)
{
	int ret = EXIT_SUCCESS;
	if (argc != 2 && argc != 3) {
		printf(""Uso: %s numero_de_bytes\n"", argv[0]);
	}
	else {
		if ((strcmp(argv[1], ""--help"")) == 0) {
			printf(""RandomKey %s\n"", VERSION);
			printf(""Uso: %s numero_de_bytes\n"", argv[0]);
			printf(""Uso: %s numero_de_bytes archivo.txt\n"", argv[0]);
			printf(""Contacto: dalmemail@amaya.tk\n"");
		}
		else {
			if (checkarg(argv[1]) < 0) {
				printf(""%s error: %s no es valido\n"", argv[0], argv[1]);
				ret = EXIT_FAILURE;
			}
			else {
				if (argv[2]) {
					ret = filekey(atoi(argv[1]), argv[2]);
				}
				else {
					makekey(atoi(argv[1]));
				}
			}
		}
	}
	return ret;
}
"
150-20200,parduck/algorithm,hashtable/main.c,81,4,50,2177269.54724625,1877870.0,1.1594354241773923,1475.0,1450.0,362001.0,230509.0,2408.0,1471.0,1375.0,1405.0,1500000000,0.0014515130314975,1082014363648.0,0.001557615809401,0.0112386288839006,"#include <stdio.h>
#include <malloc.h>
#include <time.h>
#define M_S 100

typedef struct node{
    int key;
    int val;

    struct node *head;
    struct node *next;
    struct node *link;
}node;

node *lnode[M_S];

void printA()
{
    int i;
    for(i=0;i<M_S;i++){
        node *tmp = lnode[i];
        if(tmp!=NULL)puts("""");
        while(tmp!=NULL){
           printf(""[%d,%d,%d] "",i,tmp->key,tmp->val);
           tmp = tmp->link;
        }

    }
}

void insert(int id,int val)
{
    //hash f
    int hval = (id*13)%M_S;

    node *tmp = (node *)malloc(sizeof(node));
    tmp->key = id;
    tmp->val = val;
    tmp->link =NULL;
    tmp->head=NULL;
    tmp->next=NULL;

    if(lnode[hval]==NULL){
        lnode[hval] = tmp;
    }else{
        tmp->link = lnode[hval];
        lnode[hval]=tmp;
    }
}

node *getN(int id)
{
    int val = (id*13)%M_S;

    node *tmp = lnode[val];
    while(tmp!=NULL){
        if(tmp->key==id){
            return tmp;
        }else{
            tmp = tmp->link;
        }
    }

    return NULL;
}

int main()
{
    printf(""this is hash table(separate chaining hash)\n"");

    time_t t = clock();
    /*
    insert(100101,111);
    insert(10011,222);
    insert(105101,333);
    insert(100601,444);
    insert(1001221,555);
    insert(100111,444);
    insert(100188,333);
    insert(14,333);
    insert(15,333);
    insert(6,333);
    insert(7878,33);
    insert(99888,33);
*/
    int i;
    for(i=1;i<1000;i++){

        insert(i,i+3);
    }


    printA();

    node * tmp = getN(111);
    printf(""key:%d,val:%d\n"",tmp->key,tmp->val);
    tmp = getN(12);
    printf(""key:%d,val:%d\n"",tmp->key,tmp->val);

    t=clock()- t;
    printf(""time:%f"",t/1000.);
    return 0;
}
"
164-9034,h4ck3rm1k3/gcc,gcc/testsuite/c-c++-common/torture/vector-subscript-2.c,55,2,30,1951009.50077175,170020.0,18.74278320197624,1149.0,1140.0,38671.0,12781.0,1576.0,585.0,1323.0,544.0,1500000000,0.0013006730005145,1082014363648.0,0.0134631219856487,0.0782865583456425,"/* { dg-do run } */
#define vector __attribute__((vector_size(sizeof(int)*4) ))

/* Check to make sure that we extract and insert the vector at the same
   location for vector subscripting (with constant indexes) and
   that vectors layout are the same as arrays. */

struct TV4
{
    vector int v;
};

typedef struct TV4 MYV4;

static inline MYV4 myfunc2( int x, int y, int z, int w )
{
    MYV4 temp;
    temp.v[0] = x;
    temp.v[1] = y;
    temp.v[2] = z;
    temp.v[3] = w;
    return temp;
}
MYV4 val3;
__attribute__((noinline)) void modify (void) 
{
    val3 = myfunc2( 1, 2, 3, 4 );
}
int main( int argc, char* argv[] )
{
  int a[4];
  int i;
  
  /* Set up the vector.  */
  modify();
  
  /* Check the vector via the global variable.  */
  if (val3.v[0] != 1)
    __builtin_abort ();
  if (val3.v[1] != 2)
    __builtin_abort ();
  if (val3.v[2] != 3)
    __builtin_abort ();
  if (val3.v[3] != 4)
    __builtin_abort ();
    
  vector int a1 = val3.v;
  
   /* Check the vector via a local variable.  */
  if (a1[0] != 1)
    __builtin_abort ();
  if (a1[1] != 2)
    __builtin_abort ();
  if (a1[2] != 3)
    __builtin_abort ();
  if (a1[3] != 4)
    __builtin_abort ();
    
  __builtin_memcpy(a, &val3, sizeof(a));  
   /* Check the vector via copying it to an array.  */
  for(i = 0; i < 4; i++)
    if (a[i] != i+1)
      __builtin_abort ();
  
  
  return 0;
}

"
044-32477,epicsdeb/rtems-gdb,gdb/testsuite/gdb.reverse/break-reverse.c,29,1,25,1294083.0783918002,169062.0,7.654487702736274,1140.0,1130.0,38452.0,12697.0,1567.0,588.0,1316.0,547.0,1500000000,0.0008627220522612,1082014363648.0,0.0134270267712436,0.0785548104557273,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2008, 2009, 2010, 2011 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int xyz;

int bar ()
{
  xyz = 2; /* break in bar */
  return 1;
}

int foo ()
{
  xyz = 1; /* break in foo */
  return bar ();
}

int main ()
{
  xyz = 0;	/* break in main */
  foo ();
  return (xyz == 2 ? 0 : 1);
}		/* end of main */
"
073-7196,AndrewLaing/CHowToProgramExercises,Chapter14/ex14_03.c,15,1,19,1737736.51476945,170003.0,10.221796085951423,1146.0,1137.0,38670.0,12779.0,1577.0,586.0,1324.0,546.0,1500000000,0.0011584910098463,1082014363648.0,0.0134291747792686,0.0783883068669945,"/*
 * Filename:    ex14_03.c
 * Author:      Andrew Laing
 * Email:       parisianconnections@gmail.com
 * Date:        27/10/2017
 * Description: Command line args
 */
 
#include <stdio.h>

int main( int argc, char *argv[])
{
    int i;
 
    /* argv[0] is the name of the program */
    
    for(i=1; i<argc; i++)
        printf(""%s\n"", argv[i]);
    
    return 0;
}

"
368-28469,ChristopherBryan240596/ADS,insertionSort.c,27,3,20,16900619.957596052,202435631.0,0.0834863848647276,1161.0,1151.0,25423422.0,25285647.0,65970.0,1215.0,1347.0,1067.0,1500000000,0.0112670799717307,1082014363648.0,1.1420914334986809e-05,0.0013725158314383,"/*
	ORDENAMIENTO POR INSERCIÓN

	+ Recuerda nunca usar esto en la vida real por complejidad O(n^2)
*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ITEMS 10000

void insertionSort(int Array[], int arraySize){
   int i, j, key;
   for(i=1; i<arraySize; i++){
       key = Array[i];
       j = i-1;
       while(j >= 0 && Array[j] > key){
           Array[j+1] = Array[j];
           j--;
       }
       Array[j+1] = key;
   }
}


int main(){
	int numbers[ITEMS], i;
	// Semilla para generar valores distintos cada ejecución
	srand(time(NULL));
	// Llenamos el arreglo con números aleatorios
	for(i=0; i<ITEMS; i++)
		numbers[i] = rand();
	// Y ejecutamos el ordenamiento
	insertionSort(numbers, ITEMS);
	return 0;
}
"
165-3605,ivanmurashko/tests,memtest.c,39,2,34,31399755199.55624,1902485122.0,16.504599608111942,1430.0,1415.0,463634148.0,265734478.0,5874251.0,5402022.0,3067140.0,4970943.0,1500000000,20.933170133037493,1082014363648.0,1.4954124829155957e-06,0.0264809251611543,"// to compile memtest

#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>

char** myalloc_data_( size_t size  )
{
    int i = 0;    
    char** tmp = NULL;    
    char** buffer = (char**) calloc( size, sizeof( char*) );
    for ( i = 0, tmp = buffer; i < size; ++i, ++tmp )
    {
        int elem_size = 256 + rand() % 10;        
        *tmp = (char*) malloc( elem_size );
    }    
    return buffer;    
}

void myfree_data_( char** buffer, size_t size )    
{
    int i = 0;    
    char** tmp = NULL;    
    for ( i = 0, tmp = buffer; i < size; ++i, ++tmp )
    {
        free( *tmp );        
    }    
    free( buffer );    
}

int main()
{
    char** buffer;
    size_t size1 = 3*1024*1024, size2 = 1*1024*1024;    

    printf(""First ... "");    
    
    buffer = myalloc_data_( size1 );
    printf(""done\n"");    
    sleep( 10 );
    myfree_data_( buffer, size1 );

    printf(""Second ... "");    
    buffer = myalloc_data_( size2 );
    printf(""done\n"");   
    sleep( 10 );
    myfree_data_( buffer, size2 ); 
    return 0;    
}
"
186-24756,swigger/gdb-ios,gdb/testsuite/gdb.dwarf2/dw2-bad-mips-linkage-name.c,33,1,24,2024779.3290763502,169080.0,11.971126094156611,1142.0,1132.0,38460.0,12696.0,1566.0,584.0,1317.0,544.0,1500000000,0.0013498528860509,1082014363648.0,0.0134492547906316,0.0784072249589491,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2015-2016 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* Dummy main function.  */

int
main (void)
{
  asm (""main_label: .globl main_label"");
  return 0;
}

/* dummy f function, DWARF will describe arguments and type differently.  */
int
f (char *x)
{
  asm ("".global f_end_lbl\nf_end_lbl:"");
  return 0;
}

/* dummy g function, DWARF will describe arguments and type differently.  */
int
g (char *x)
{
  asm ("".global g_end_lbl\ng_end_lbl:"");
  return 0;
}
"
046-15023,ChristopherBryan240596/ADS,quickSort.c,32,4,26,13460017.74072645,27243021.0,0.4940721148363098,1165.0,1155.0,5215828.0,1832577.0,36146.0,7009.0,1436.0,6616.0,1500000000,0.0089733451604843,1082014363648.0,8.515942486701457e-05,0.0072650479080018,"/*
	ORDENAMIENTO RÁPIDO

	+ El caso promedio de este algoritmo es O(nlogn)
	+ Su peor caso lo llevaría hasta O(n^2)
*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ITEMS 100000

void quickSort(int Array[], unsigned int arraySize){
	if(arraySize >= 2){
		int pivot = Array[arraySize/2];
		int i, j, temp;
		for(i=0, j=arraySize-1; ; i++, j--){
			while(Array[i] < pivot) i++;
			while(Array[j] > pivot) j--;
			if(i >= j) break;
			temp = Array[i];
			Array[i] = Array[j];
			Array[j] = temp;
		}
		quickSort(Array, i);
		quickSort(Array+i, arraySize-i);
	}
}

int main(){
	int numbers[ITEMS], i;
	// Semilla para generar valores distintos cada ejecución
	srand(time(NULL));
	// Llenamos el arreglo con números aleatorios
	for(i=0; i<ITEMS; i++)
		numbers[i] = rand();
	// Y ejecutamos el ordenamiento
	quickSort(numbers, ITEMS);
	return 0;
}
"
091-10749,chenxilinsidney/funnycprogram,more_programming_pearls/get_prime_number_v1.c,26,2,19,206435414.96247044,729223997.0,0.283089167182193,1338.0,1318.0,10945520.0,7855912.0,1621.0,697.0,1341.0,653.0,1500000000,0.1376236099749803,1082014363648.0,3.64222791752148e-06,0.0002293442329286,"/**
 * @file get_prime_number_v1.c
 * @brief get the prime number and anlyse with gprop
 * @author chenxilinsidney
 * @version 1.0
 * @date 2014-12-26
 */
#include <stdio.h>
#include <stdlib.h>

int is_prime_number(int count)
{
    int i;
    for(i = 2; i * i <= count; i++) {
        if(0 == count % i)
            return 0;
    }
    return 1;
}

int main(void)
{
    int i;
    int count = 1000000;
    for(i = 2; i <= count; i++) {
        if(is_prime_number(i))
            printf(""%d\n"", i);
    }
    return EXIT_SUCCESS;
}
"
069-6597,evelynmitchell/C21,21st_century_examples/vectorize.c,15,1,19,1602573.0874389,173942.0,9.213260742086442,1242.0,1226.0,39467.0,13393.0,1605.0,634.0,1337.0,592.0,1500000000,0.0010683820582926,1082014363648.0,0.0141886375918409,0.0788497919031403,"/* Compile with:
export CFLAGS=""-g -Wall -std=gnu11 -O3""  #the usual.
make vectorize
*/
#include <stdio.h>
#include <stdlib.h> //malloc, free

#define Fn_apply(type, fn, ...) {                                      \
    void *stopper_for_apply = (int[]){0};                              \
    type **list_for_apply = (type*[]){__VA_ARGS__, stopper_for_apply}; \
    for (int i=0; list_for_apply[i] != stopper_for_apply; i++)         \
         fn(list_for_apply[i]);                                        \
}

#define Free_all(...) Fn_apply(void, free, __VA_ARGS__);

int main(){
    double *x= malloc(10);
    double *y= malloc(100);
    double *z= malloc(1000);

    Free_all(x, y, z);
}
"
262-23715,Gurgel100/gcc,gcc/testsuite/gcc.c-torture/execute/pr82210.c,24,3,18,1855532.9879744998,171768.0,10.802547622374366,1154.0,1145.0,39153.0,12972.0,1597.0,586.0,1338.0,545.0,1500000000,0.001237021991983,1082014363648.0,0.0133843323552698,0.0780047961630695,"/* PR c/82210 */
/* { dg-require-effective-target alloca } */

void
foo (int size)
{
  int i;
  struct S {
    __attribute__((aligned (16))) struct T { short c; } a[size];
    int b[size];
  } s;

  for (i = 0; i < size; i++)
    s.a[i].c = 0x1234;
  for (i = 0; i < size; i++)
    s.b[i] = 0;
  for (i = 0; i < size; i++)
    if (s.a[i].c != 0x1234 || s.b[i] != 0)
      __builtin_abort ();
}

int
main ()
{
  foo (15);
  return 0;
}
"
208-5849,Prabudh/Miscellaneous,ctci_2.2_linkedList_nth_nodeFromTheEnd.c,55,3,29,3099770.98368105,178441.0,17.365308421270896,1351.0,1330.0,40428.0,14095.0,1623.0,638.0,1345.0,595.0,1500000000,0.0020665139891207,1082014363648.0,0.0150245739488122,0.0770500522715184,"#include<stdio.h>
#include<string.h>
#include<stdlib.h>

typedef struct linkedList {
int data;
struct linkedList *next;
}linkedList;

insertLl(linkedList** x, int data)
{
linkedList *temp = (linkedList*)malloc(sizeof(linkedList));
temp->data = data;
temp->next = *x;
*x = temp;
}

displayList(linkedList *x)
{
while(x!=NULL)
{
printf(""%d "",x->data);
x= x->next;
}
}
int movethefastPointerTo_N_position(linkedList **x, int n)
{
    for(int i =0; i<n; i++)
    {
        if(*x==NULL)
           return 0;
        else
           *x = (*x)->next;
    }
    return 1;
}
findTheNthFromTheLastElement(linkedList *x, int n)
{
linkedList *slow = x, *fast = x;
if(movethefastPointerTo_N_position(&fast,n))
{
while(fast!=NULL)
{
fast=fast->next;
slow=slow->next;
}
printf(""%d\n"",slow->data);
}
}
int main()
{
linkedList *aList= NULL;
insertLl(&aList, 1);
insertLl(&aList,2);
insertLl(&aList, 3);
insertLl(&aList, 3);
insertLl(&aList, 4);
displayList(aList);
printf(""\n"");
findTheNthFromTheLastElement(aList,5);
}
"
153-652,krystism/leetcode,algorithms/IntersectionofTwoLinkedLists/solve.c,75,4,45,2021209.33681725,177016.0,11.418227730826592,1356.0,1335.0,40132.0,13809.0,1636.0,641.0,1353.0,598.0,1500000000,0.0013474728912115,1082014363648.0,0.0152020156370045,0.0783819358187649,"#include <stdio.h>
#include <string.h>
#include <stdlib.h>
struct ListNode {
	int val;
	struct ListNode *next;
};
int getLength(struct ListNode *head)
{
	int len = 0;
	struct ListNode *p = head;
	while (p) {
		++len;
		p = p->next;
	}
	return len;
}
struct ListNode *getIntersectionNode(struct ListNode *ha, struct ListNode *hb)
{
	if (ha == NULL || hb == NULL)
		return NULL;
	int len1 = getLength(ha), len2 = getLength(hb);
	struct ListNode *p, *q;
	int diff;
	if (len1 >= len2) {
		p = ha;
		q = hb;
		diff = len1 - len2;
	} else {
		p = hb;
		q = ha;
		diff = len2 - len1;
	}
	while (diff--)
		p = p -> next;
	while (p && q) {
		if (p == q)
			return p;
		p = p->next;
		q = q->next;
	}
	return NULL;
}
void print(struct ListNode *ha, struct ListNode *hb)
{
	struct ListNode *p = getIntersectionNode(ha, hb);
	if (p == NULL)
		printf(""NULL\n"");
	else
		printf(""%d\n"", p -> val);
}
struct ListNode * mk_list(struct ListNode **ha, int a[], int n)
{
	struct ListNode *p = malloc(sizeof(*p));
	p->val = a[0];
	p->next = NULL;
	*ha = p;
	for (int i = 1; i < n; ++i) {
		struct ListNode *q = malloc(sizeof(*q));
		q->val = a[i];
		q->next = NULL;
		p->next = q;
		p = q;
	}
	return p;
}
int main(int argc, char **argv)
{
	struct ListNode *ha = NULL, *hb = NULL;
	print(ha, hb);
	int a[] = {1,2,3,4,5};
	int b[] = {6,7};
	struct ListNode *last1 = mk_list(&ha, a, 5);
	struct ListNode *last2 = mk_list(&hb, b, 2);
	last2->next = ha;
	print(ha, hb);
	return 0;
}
"
086-3159,artcz/euler,problems/05/5.c,25,2,19,1237614483.1068814,3562385064.0,0.3474117650859317,1423.0,1401.0,39643.0,13585.0,1631.0,629.0,1350.0,590.0,1500000000,0.8250763220712543,1082014363648.0,7.927273299391983e-07,0.0789058390320883,"
// 2520 is the smallest number that can be divided by each of the numbers from
// 1 to 10 without any remainder.
//
// What is the smallest positive number that is evenly divisible by all of the
// numbers from 1 to 20?


#include <stdio.h>
#include <time.h>

#define FALSE 0
#define TRUE 1


int solve() {
    for(int i=2520;;i++) {
        int found=FALSE;
        for(int j=2;j<=20;j++) {
            if(i%j != 0) {
                found = FALSE;
                break;
            }
            found = TRUE;
        }
        if(found) return i;
    }
}


int main() {
    clock_t begin = clock();
    int result = solve();
    clock_t end = clock();
    double time = (double)(end - begin) / CLOCKS_PER_SEC;
    printf(""%d [in %f seconds]"", result, time);
}
"
308-30843,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.threads/tls-var-main.c,19,1,17,1737032.78414895,170260.0,10.20223188065312,1144.0,1136.0,38665.0,12780.0,1573.0,589.0,1320.0,547.0,1500000000,0.0011580218560993,1082014363648.0,0.0133912839187125,0.0783166488482845,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2011-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <pthread.h>

int
main (void)
{
  /* Ensure we link against pthreads even with --as-needed.  */
  pthread_testcancel();
  return 0;
}
"
192-35443,epicsdeb/rtems-gdb,gdb/testsuite/gdb.python/py-value.c,73,1,36,1733012.9630863501,172473.0,16.228429957152713,1289.0,1271.0,39021.0,13221.0,1606.0,634.0,1333.0,592.0,1500000000,0.0011553419753909,1082014363648.0,0.0148429029471279,0.0797251253780483,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2008, 2009, 2010, 2011 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <stdio.h>

struct s
{
  int a;
  int b;
};

union u
{
  int a;
  float b;
};

enum e
  {
    ONE = 1,
    TWO = 2
  };

typedef struct s *PTR;

enum e evalue = TWO;

#ifdef __cplusplus

struct Base {
  virtual int x() { return 5; }
};

struct Derived : public Base {
};

Base *base = new Derived ();

void ptr_ref(int*& rptr_int)
{
  return; /* break to inspect pointer by reference. */
}
#endif

void func1 ()
{
  printf (""void function called\n"");
}

int func2 (int arg1, int arg2)
{
  return arg1 + arg2;
}

int
main (int argc, char *argv[])
{
  char *cp = argv[0]; /* Prevent gcc from optimizing argv[] out.  */
  struct s s;
  union u u;
  PTR x = &s;
  char st[17] = ""divide et impera"";
  char nullst[17] = ""divide\0et\0impera"";
  void (*fp1) (void)  = &func1;
  int  (*fp2) (int, int) = &func2;
  const char *sptr = ""pointer"";
  const char *embed = ""embedded x\201\202\203\204"";
  int a[3] = {1,2,3};
  int *p = a;
  int i = 2;
  int *ptr_i = &i;
  const char *sn = 0;
  s.a = 3;
  s.b = 5;
  u.a = 7;
  (*fp1) ();
  (*fp2) (10,20);

#ifdef __cplusplus
  ptr_ref(ptr_i);
#endif

  return 0;      /* break to inspect struct and union */
}
"
056-1765,samjcus/pragma_pragma_pragma,divcon_sum/src/divcon_sum_serial.c,30,1,23,1014593766.303733,2481516621.0,0.4088603547580268,1424.0,1416.0,320540904.0,320514513.0,12520423.0,12514714.0,12501479.0,12500660.0,1500000000,0.6763958442024887,1082014363648.0,1.1444614055639646e-06,0.0780545248867306,"#include <stdio.h>
#include <stdlib.h>
#include <time.h>

double sum(const double *a, size_t n)
{
  size_t half;
  // edge cases
  if (n == 0) return 0;
  if (n == 1) return *a;
    
  // recursive case
  half = n / 2;
  return sum(a, half) + sum(a + half, n - half);
}

int main (int argc, char *argv[])
{
  int N,i;
  double *list,res,kgo;
  clock_t t_start,t_end;
  
  N=100000000;
  list=malloc(N*sizeof(double));

  for(i=0;i<N;i++)
    {
      list[i] = (double) i;
    }
  t_start=clock();
  res=sum(list, N);
  t_end=clock();
  kgo=0.5* N*(N-1);
  printf(""error=%g\n"",res-kgo);
  printf(""Took %g s\n"",(double)(t_end - t_start)/CLOCKS_PER_SEC);
  free(list);

  return EXIT_SUCCESS;
}
"
304-9724,hanlin-he/UTD,leetcode/c/069.c,11,1,19,1882563.2287188002,544224.0,3.459169386135121,1334.0,1316.0,39243.0,13349.0,1617.0,636.0,1340.0,593.0,1500000000,0.0012550421524792,1082014363648.0,0.0048693185159052,0.0795938545786431,"/* 069. Sqrt(x) */
/* Spaghetti Code. Sum of odd number is the power 2 of some number. */

#include <stdio.h>

int mySqrt(int x) {
    int i, sum;
    for (i = 1, sum = 0; sum < sum + i * 2 - 1 && (sum += i * 2 - 1) < x; i++);
    return sum == x ? i : i-1;
}

int main() {
    printf(""%d == %d\n"", 46340, mySqrt(2147483647));
    return 0;
}
"
260-12393,aababilov/linux-research,scala/scala_vs_c/PiCalculator.cool.c,13,1,15,232167034.52635545,1150175498.0,0.2058310304920093,1431.0,1407.0,39742.0,13658.0,1631.0,637.0,1350.0,593.0,1500000000,0.1547780230175703,1082014363648.0,2.4674495369923105e-06,0.0788576779026217,"#include <stdio.h>
#include <time.h>

int main() {
   clock_t clock_start;
   int nrOfElements = 1000 * 1000 * 100;
   int start = 0;
   double acc = 0;
   register int i;
   clock_start = clock();
   for (i = start; i < (nrOfElements); ++i)
        acc += (i % 2 == 0 ? 4.0 : -4.0) / (2 * i + 1);
   printf(""%d ms\n"", (int)((clock() - clock_start) / (CLOCKS_PER_SEC / 1000)));
   printf(""%.8lf\n"", acc);
   return 0;
}
"
369-15663,mistotebe/examples,c_questions/leaks.c,31,3,20,1571953.29666135,173942.0,9.037225052028838,1236.0,1219.0,39419.0,13477.0,1593.0,635.0,1328.0,595.0,1500000000,0.0010479688644409,1082014363648.0,0.014113900035644,0.078474742891712,"#include <stdlib.h>

struct list {
    struct list *next;
};

int main()
{
    int *i;
    struct list *head, *current;
    char *a;

    i = malloc( sizeof(int) );

    i = malloc( sizeof(int) );
    i[1] = 1;

    a = malloc(1);
    a[4] = 'a';

    current = head = malloc( sizeof(struct list) );

    for ( *i = 0; *i < 5; (*i)++ )
    {
        current->next = malloc( sizeof(struct list) );
        current = current->next;
    }
    current->next = NULL;

    for ( *i = 0; *i < 2; (*i)++ )
        head = head->next;

    i = NULL;

    while (head)
    {
        current = head->next;
        free(head);
        head = current;
    }

    return 0;
}
"
240-7910,SanDisk-Open-Source/SSD_Dashboard,uefi/gcc/gcc-4.6.3/gcc/testsuite/gcc.dg/20041219-1.c,38,1,31,1566021.0046916998,169057.0,9.26327215081304,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010440140031278,1082014363648.0,0.0134155935572026,0.0785563462891999,"/* PR18191 Struct member is not getting default-initialized.
   Origin: Grigory Zagorodnev  <grigory.zagorodnev@intel.com>  */

/* { dg-do run } */

extern int printf (__const char *__restrict __format, ...);

typedef struct S {
  const char* s;
  int         i;
} S;

void
foo (void)
{
  S dummy[2];
  unsigned i;

  /* Put some garbage on the stack.  */
  for (i = 0; i < sizeof(dummy); i++)
    ((char *)&dummy)[i] = -1;
}

int
bar (void)
{
  /* Allocate object on the stack.  */
  S obj[2] = { {""m0""}, {""m1""} };

  /* Assume fields those not explicitly initialized
     are default initialized to 0 [8.5.1/7 and 8.5/5].  */
  if (obj[0].i == 0)
    return 0;
  else
    {
      printf(""Failed: obj[0].i == '%d', expecting '0'\n"", obj[0].i);
      return 1;
    }
}

int
main (void)
{
  foo();
  return bar();
}

"
103-9569,mandliya/short-fun-projects,learning-pthreads/mutex.c,32,2,22,1531235084.9853828,9395428888.0,0.1629766030112493,1511.0,1474.0,2684397425.0,671103929.0,1671.0,668.0,1377.0,624.0,1500000000,1.0208233899902552,1082014363648.0,3.177076890883068e-07,1.2933983754250036e-06,"#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

pthread_mutex_t lock;
long shared_data;   // could be more complicated then just an int.

void * increment( void * arg )
{
  long i = 0;
  for ( i = 0; i < 1024 * 1024 * 128; ++i ) {
    pthread_mutex_lock(&lock);
    ++shared_data;
    pthread_mutex_unlock(&lock);
  }
  return NULL;
}

int main()
{
  pthread_t thread_id;
  void * exit_status;
  int i;

  //initialize the mutex
  pthread_mutex_init(&lock, NULL);
  //create the thread
  pthread_create(&thread_id, NULL, increment, NULL);

  // Lets access shared data
  for ( i = 0; i < 10; ++i ) {
    //sleep(1);
    pthread_mutex_lock(&lock);
    printf(""Shared integer's value is %ld\n"", shared_data);
    pthread_mutex_unlock(&lock);
  }
  pthread_join(thread_id, &exit_status);
  pthread_mutex_destroy(&lock);
  return 0;
}
"
334-6471,techvedaLPE/Linuxpro,signals/sigwait.c,28,2,21,7502356690.471061,201242.0,37280.27295494976,1729.0,1668.0,45473.0,16692.0,1788.0,687.0,1426.0,641.0,1500000000,5.001571126980707,1082014363648.0,0.0168801741187227,0.0730636210086061,"#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <signal.h>
#include <time.h>

void timestamp(char *str)
{
	time_t t;
	time(&t);
	printf(""\n %s: \n"",__func__);
	printf(""The time %s is %s\n"", str, ctime(&t));
}

int main()
{
	int result = 0;
	sigset_t waitset;
	siginfo_t info;
	
	/* let's disable async handlers and enable signal queue */
	sigemptyset(&waitset);
	sigaddset(&waitset, SIGALRM);
	sigprocmask(SIG_BLOCK, &waitset, NULL);

	/* schedule an alarm event */
	alarm(5);
	timestamp(""before sigwaitinfo()"");

	/* wait for alarm to arrive */
	result = sigwaitinfo(&waitset, &info);
	if (result < 0)
		printf(""sigwaitinfo failed : \n"");

	/* got alarm  */
	printf(""sigwaitinfo() returned for signal %d\n"", info.si_signo);
	timestamp(""after sigwaitinfo()"");
	return 0;
}
"
227-17609,gjwang/testcpp,test_perfect_hash.c,65,7,42,1815378.08384745,202206.0,8.977864158333581,1358.0,1339.0,45551.0,17625.0,1632.0,639.0,1352.0,595.0,1500000000,0.0012102520558983,1082014363648.0,0.0133378831488679,0.0667658604533367,"//http://stackoverflow.com/questions/4130936/perfect-hash-function
//10, 100, 32, 45, 58, 126, 3, 29, 200, 400, 0
#include <stdio.h>
int hash (int n) {
  switch (n) {
    case 10:   return 0;
    case 100:  return 1;
    case 32:   return 2;
    case 45:   return 3;
    case 58:   return 4;
    case 126:  return 5;
    case 3:    return 6;
    case 29:   return 7;
    case 200:  return 8;
    case 400:  return 9;
    case 0:    return 10;

    default:   return -1;
  }
}

int perfect_hash(int n){
	return (n ^ 28) % 13;
}

#define HASH(x)    ((((x) << 2) ^ ((x) >> 2)) & 0xF)

int search_table(int n,  int num_table[], int num){
	int i = 0;
	for(i = 0; i<num; i++){
		if(num_table[i] == n){
			return i;
		}
	}

	return -1;
}

int main(){
	int num_table[] = {10, 100, 32, 45, 58, 126, 3, 29, 200, 400, 0};
	int i = 0;
	int num = sizeof(num_table)/sizeof(num_table[0]);

	for(i = 0; i<num; i++){
		int val = hash(num_table[i]);
		printf(""%d, "", val);
	}
	printf(""\n"");

	for(i = 0; i<num; i++){
		int val = perfect_hash(num_table[i]);
		printf(""%d, "", val);
	}
	printf(""\n"");

	for(i = 0; i<num; i++){		
		int val = HASH(num_table[i]);
		printf(""%d, "", val);
	}
	printf(""\n"");

	for(i = 0; i<num; i++){
		int val = search_table(num_table[i], num_table, num);
		printf(""%d, "", val);
	}
	printf(""\n"");


#define TEST_TIMES (10000000)
	int times = 0;
	for(times = 0; times < TEST_TIMES; times++){
		for(i = 0; i<num; i++){
			int val = hash(num_table[i]);
			//int val = perfect_hash(num_table[i]);
			//int val = HASH(num_table[i]);
			//int val = search_table(num_table[i], num_table, num);
			//printf(""val = %d\n"", val);
		}
	}
}
"
374-17335,zxombie/aarch64-freebsd-binutils,gdb/testsuite/gdb.base/step-break.c,24,2,26,1083382124.779746,9663845478.0,0.1121067308522625,1139.0,1129.0,3221263925.0,2147496345.0,1567.0,588.0,1316.0,547.0,1500000000,0.722254749853164,1082014363648.0,2.3468918301344558e-07,7.484036905972708e-07,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2008-2014 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

int
main ()
{
    volatile int i = 1;

    while (i > 0) /* place1 */
      {
	i++; /* place2 */
	i++; /* place3, set breakpoint here  */
      }

    return 0;
}
"
312-5913,jjones-cavium/gcc,gcc/testsuite/c-c++-common/tsan/thread_leak5.c,15,1,25,1502491156.4541981,181222.0,8290.887177053559,1357.0,1336.0,41442.0,14727.0,1641.0,754.0,1355.0,708.0,1500000000,1.0016607709694654,1082014363648.0,0.0148602266832945,0.0793676227100357,"
/* { dg-do run { target { x86_64*-*-linux* } } } */
/* { dg-shouldfail ""tsan"" } */

#include <pthread.h>
#include <unistd.h>

void *Thread(void *x) {
  return 0;
}

int main() {
int i;
  for (i = 0; i < 5; i++) {
    pthread_t t;
    pthread_create(&t, 0, Thread, 0);
  }
  sleep(1);
  return 0;
}
/* { dg-output ""WARNING: ThreadSanitizer: thread leak.*"" } */
"
170-33980,alpine9000/BitOS,tests/gcc.c-torture/pr39339.c,76,1,28,1314377.76144585,170774.0,7.696587302516776,1143.0,1135.0,38917.0,12879.0,1588.0,586.0,1332.0,546.0,1500000000,0.0008762518409639,1082014363648.0,0.0133392671015494,0.078229979148969,"/* { dg-do run } */
struct C
{
  unsigned int c;
  struct D
  {
    unsigned int columns : 4;
    unsigned int fore : 12;
    unsigned int back : 6;
    unsigned int fragment : 1;
    unsigned int standout : 1;
    unsigned int underline : 1;
    unsigned int strikethrough : 1;
    unsigned int reverse : 1;
    unsigned int blink : 1;
    unsigned int half : 1;
    unsigned int bold : 1;
    unsigned int invisible : 1;
    unsigned int pad : 1;
  } attr;
};

struct A
{
  struct C *data;
  unsigned int len;
};

struct B
{
  struct A *cells;
  unsigned char soft_wrapped : 1;
};

struct E
{
  long row, col;
  struct C defaults;
};

__attribute__ ((noinline))
void foo (struct E *screen, unsigned int c, int columns, struct B *row)
{
  struct D attr;
  long col;
  int i;
  col = screen->col;
  attr = screen->defaults.attr;
  attr.columns = columns;
  row->cells->data[col].c = c;
  row->cells->data[col].attr = attr;
  col++;
  attr.fragment = 1;
  for (i = 1; i < columns; i++)
    {
      row->cells->data[col].c = c;
      row->cells->data[col].attr = attr;
      col++;
    }
}

int
main (void)
{
  struct E e = {.row = 5,.col = 0,.defaults =
      {6, {-1, -1, -1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0}} };
  struct C c[4];
  struct A a = { c, 4 };
  struct B b = { &a, 1 };
  struct D d;
  __builtin_memset (&c, 0, sizeof c);
  foo (&e, 65, 2, &b);
  d = e.defaults.attr;
  d.columns = 2;
  if (__builtin_memcmp (&d, &c[0].attr, sizeof d))
    __builtin_abort ();
  d.fragment = 1;
  if (__builtin_memcmp (&d, &c[1].attr, sizeof d))
    __builtin_abort ();
  return 0;
}

"
089-31870,tripleee/glibc-en-150,setjmp/tst-setjmp.c,96,3,30,2091603.00437355,200144.0,10.450490646734352,1373.0,1354.0,45461.0,17213.0,1659.0,648.0,1363.0,603.0,1500000000,0.0013944020029157,1082014363648.0,0.0136251898632984,0.0681781919137122,"/* Copyright (C) 1991-2015 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#include <stdio.h>
#include <setjmp.h>
#include <stdlib.h>

static jmp_buf env;
static int last_value = -1, lose = 0;

static void
jump (int val)
{
  longjmp (env, val);
}

int
main (void)
{
  int value;

  value = setjmp (env);
  if (value != last_value + 1)
    {
      fputs(""Shouldn't have "", stdout);
      lose = 1;
    }
  last_value = value;
  switch (value)
    {
    case 0:
      puts(""Saved environment."");
      jump (0);
    default:
      printf (""Jumped to %d.\n"", value);
      if (value < 10)
	jump (value + 1);
    }

  if (!lose && value == 10)
    {
      /* Do a second test, this time without `setjmp' being a macro.
         This is not required by ISO C but we have this for compatibility.  */
#undef setjmp
      extern int setjmp (jmp_buf);

      last_value = -1;
      lose = 0;

      value = setjmp (env);
      if (value != last_value + 1)
	{
	  fputs(""Shouldn't have "", stdout);
	  lose = 1;
	}
      last_value = value;
      switch (value)
	{
	case 0:
	  puts(""Saved environment."");
	  jump (0);
	default:
	  printf (""Jumped to %d.\n"", value);
	  if (value < 10)
	    jump (value + 1);
	}
    }

  if (!lose && value == 10)
    {
      /* And again for the `_setjmp' function.  */
#ifndef _setjmp
      extern int _setjmp (jmp_buf);
#endif
      last_value = -1;
      lose = 0;

      value = _setjmp (env);
      if (value != last_value + 1)
	{
	  fputs(""Shouldn't have "", stdout);
	  lose = 1;
	}
      last_value = value;
      switch (value)
	{
	case 0:
	  puts(""Saved environment."");
	  jump (0);
	default:
	  printf (""Jumped to %d.\n"", value);
	  if (value < 10)
	    jump (value + 1);
	}
    }

  if (lose || value != 10)
    puts (""Test FAILED!"");
  else
    puts (""Test succeeded!"");

  return lose ? EXIT_FAILURE : EXIT_SUCCESS;
}
"
313-461,bhagatyj/algorithms,problems/strings/pallindrome/isPall_ignorePuncCap.c,25,1,19,1421176.479198,172673.0,8.227053447846508,1158.0,1148.0,39417.0,13069.0,1606.0,586.0,1344.0,544.0,1500000000,0.000947450986132,1082014363648.0,0.0133547225101781,0.0777350150516328,"#include <stdio.h>
#include <ctype.h>
#include <assert.h>
#include <string.h>

int 
isPall ( char *s) {
    int len = strlen(s);
    char *end = s+len - 1;

    if ( len <= 1 ) {
        return 1;
    }

    while ( end > (s+2) ) {
        if ( ! isalpha( *end ) ) { end--; continue; }
        if ( ! isalpha( *s ) ) { s++; continue; }
        if ( tolower(*end) != tolower(*s) ) {
            return 0;
        }
        end--;
        s++;
    }
    return 1;
}

int main(int argc, char **argv) {
    assert( isPall(""Hello"") == 0 );
    assert( isPall(""H"") == 1 );
    assert( isPall(""rooR"") == 1 );
    assert( isPall(""rot21#!3or"") == 1 );
    assert( isPall("""") == 1 );
}
"
261-9858,goblint/analyzer,tests/regression/52-apron-mukherjee/09-mukherjee_fib_Bench.c,33,2,27,1921517.7744627,180628.0,10.637979715215804,1377.0,1350.0,41250.0,14300.0,1637.0,680.0,1358.0,638.0,1500000000,0.0012810118496418,1082014363648.0,0.0150973271032176,0.0776417641764176,"// SKIP PARAM: --set ana.activated[+] apron --set ana.path_sens[+] threadflag --set ana.activated[+] threadJoins --enable ana.apron.threshold_widening

#include <pthread.h>
#include <assert.h>

int i, j, NUM;

pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

void* W1_Fib_Bench_False_Unreach_Call(void* arg){
    for(int k = 0; k < NUM; k++) {
        pthread_mutex_lock(&lock);
        i += j;
        pthread_mutex_unlock(&lock);
    }
    return 0;
}

void* W2_Fib_Bench_False_Unreach_Call(void* arg){
    for(int k = 0; k < NUM; k++) {
        pthread_mutex_lock(&lock);
        j += i;
        pthread_mutex_unlock(&lock);
    }
    return 0;
}


int main() {
    i = 1;
    j = 1;

    NUM = 5;

    pthread_t t1;
    pthread_t t2;
    pthread_create(&t1, 0, W1_Fib_Bench_False_Unreach_Call, 0);
    pthread_create(&t2, 0, W2_Fib_Bench_False_Unreach_Call, 0);
    pthread_join(t1, 0);
    pthread_join(t2, 0);

    assert(i < 144); //TODO
    assert(j < 144); //TODO

    return 0;
}
"
064-18053,wuzhouhui/leetcode,133_clone_graph.c,68,3,33,1653273.1242477,173639.0,9.521322974677348,1245.0,1227.0,39398.0,13359.0,1602.0,636.0,1335.0,592.0,1500000000,0.0011021820828318,1082014363648.0,0.0142364330593933,0.07894686960972,"#include <stdlib.h>

#define NEIGHBORS_MAX_SIZE	100

struct UndirectedGraphNode {
	int	label;
	struct UndirectedGraphNode *neighbors[NEIGHBORS_MAX_SIZE];
	int	neighborsCount;
};

struct link_node {
	struct UndirectedGraphNode *val;
	struct link_node *next;
};

static struct link_node *head;

static struct UndirectedGraphNode *is_accessed(int label)
{
	struct link_node *t = head;

	while (t) {
		if (t->val->label == label)
			return(t->val);
		t = t->next;
	}
	return(0);
}

static void add_accessed(struct UndirectedGraphNode *graph)
{
	struct link_node *t = malloc(sizeof(struct link_node));
	t->val = graph;
	t->next = head;
	head = t;
}

static struct UndirectedGraphNode *do_clone(struct UndirectedGraphNode *graph)
{
	if (!graph)
		return(0);

	struct UndirectedGraphNode *new_graph;
	int	i;

	if (new_graph = is_accessed(graph->label))
		return(new_graph);


	new_graph = malloc(sizeof(struct UndirectedGraphNode));
	new_graph->label = graph->label;
	new_graph->neighborsCount = graph->neighborsCount;
	add_accessed(new_graph);
	for (i = 0; i < graph->neighborsCount; i++)
		new_graph->neighbors[i] = do_clone(graph->neighbors[i]);

	return(new_graph);
}

struct UndirectedGraphNode *cloneGraph(struct UndirectedGraphNode *graph)
{
	if (!graph)
		return(0);

	head = 0;

	struct link_node *t;
	struct UndirectedGraphNode *new_graph = do_clone(graph);

	while (head) {
		t = head;
		head = head->next;
		free(t);
	}

	return(new_graph);
}

int main(void)
{
	struct UndirectedGraphNode graph;
	struct UndirectedGraphNode *new_graph;

	graph.label = 0;
	graph.neighborsCount = 2;
	graph.neighbors[0] = &graph;
	graph.neighbors[1] = &graph;

	new_graph = cloneGraph(&graph);
	return(0);
}
"
306-27484,begeekmyfriend/leetcode,0045_jump_game_ii/jump_game.c,31,4,25,1839858.13055175,174459.0,10.543268045787263,1350.0,1329.0,39576.0,13489.0,1627.0,636.0,1346.0,593.0,1500000000,0.0012265720870345,1082014363648.0,0.015356043540316,0.079185904079902,"#include <stdio.h>
#include <stdlib.h>

static inline int max(int a, int b)
{
    return a > b ? a : b;
}

static int jump(int* nums, int numsSize)
{
    int i, lo = 0, hi = 0;
    int steps = 0;
    while (hi < numsSize - 1) {
        int right = 0;
        for (i = lo; i <= hi; i++) {
            /* Assume right > hi for the purpose of the problem */
            right = max(i + nums[i], right);
        }
        /* [lo, hi] is the next location range */
        lo = hi + 1;
        hi = right;
        steps++;
    }
    return steps;
}

int main(int argc, char **argv)
{
    int i, count = argc - 1;
    int *nums = malloc(count * sizeof(int));
    for (i = 0; i < count; i++) {
        nums[i] = atoi(argv[i + 1]);
    }
    printf(""%d\n"", jump(nums, count));
    return 0;
}
"
374-15627,jabberx/doommy,tools/composer/composer.c,121,6,67,3924502.75830915,184804.0,21.23602302980455,1448.0,1424.0,42408.0,14868.0,1710.0,664.0,1413.0,620.0,1500000000,0.0026163351722061,1082014363648.0,0.0155407891604077,0.0769432222920595,"/*
  composer - raw indexed slices to Doommy Voxel Engine level converter

  COPYRIGHT (C) 2012 jabberx@ymail.com

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <memory.h>
#include <stdio.h>
#include <malloc.h>

unsigned char pal[]={8,8,8,16,16,16,24,24,24,32,32,32,41,41,41,49,49,49,57,
57,57,65,65,65,74,74,74,82,82,82,90,90,90,98,98,98,106,106,106,115,115,115,
123,123,123,131,131,131,139,139,139,148,148,148,156,156,156,164,164,164,172,
172,172,180,180,180,189,189,189,197,197,197,205,205,205,213,213,213,222,222,
222,230,230,230,238,238,238,246,246,246,255,255,255,7,0,1,11,2,2,19,4,5,26,
7,8,33,10,12,41,12,14,48,15,17,56,17,20,63,20,23,71,22,26,77,26,29,86,29,33,
92,31,35,101,34,39,108,35,40,116,39,44,123,40,46,131,44,50,138,45,52,146,49,
56,152,51,58,160,55,62,168,57,70,175,60,73,183,62,79,190,65,74,195,70,79,200,
75,84,204,81,90,209,86,95,214,91,100,219,96,105,3,8,1,6,11,2,10,18,5,14,25,8,
20,31,12,24,39,14,28,45,18,33,52,21,38,59,24,43,66,27,46,72,31,53,80,35,57,86,
37,61,93,42,65,99,44,71,108,47,75,114,49,79,122,53,83,127,56,90,136,59,92,140,
63,97,149,66,106,155,70,113,162,73,115,169,76,118,176,79,120,182,83,127,188,87,
132,193,92,135,199,96,140,205,100,147,211,104,1,3,8,2,5,11,5,9,18,8,13,25,12,
18,31,14,21,39,18,26,45,21,30,52,24,35,59,27,39,66,31,43,72,35,49,80,37,52,86,
42,56,93,44,59,99,47,66,108,49,67,114,53,74,122,56,78,127,59,81,136,63,86,140,
66,92,149,70,98,155,73,102,162,76,107,169,79,106,176,83,111,182,87,118,188,92,
120,193,96,125,199,100,130,205,104,137,211,1,8,6,2,11,10,5,18,16,8,25,23,12,31,
29,14,39,36,18,45,41,21,52,48,24,59,54,27,66,61,31,72,68,35,80,75,37,86,80,42,
93,88,44,99,94,47,108,100,49,114,106,53,122,113,56,127,118,59,136,126,63,140,
132,66,149,138,70,155,140,73,162,147,76,169,153,79,176,166,83,182,172,87,188,
175,92,193,183,96,199,188,100,205,194,104,211,197,8,1,6,11,2,9,18,5,15,25,8,21,
31,12,26,39,14,33,45,18,38,52,21,45,59,24,50,66,27,56,72,31,62,80,35,70,86,37,
74,93,42,82,99,44,86,108,47,93,114,49,98,122,53,105,127,56,109,136,59,117,140,
63,123,149,66,130,155,70,140,162,73,147,169,76,151,176,79,152,182,83,158,188,
87,165,193,92,168,199,96,176,205,100,179,211,104,185,7,5,0,10,9,1,18,15,3,25,
22,6,32,30,9,41,35,10,48,42,13,55,48,16,63,56,18,70,64,21,77,69,24,86,76,27,
93,83,28,101,92,32,107,98,34,117,104,36,123,108,38,132,118,41,137,125,44,147,
129,46,152,134,49,161,142,52,169,148,54,176,155,57,184,162,59,191,168,62,197,
177,66,201,185,72,205,186,78,210,194,83,215,195,88,220,200,93,8,3,1,11,5,2,18,
9,5,25,13,8,31,18,12,39,22,14,45,26,18,52,30,21,59,35,24,66,38,27,72,43,31,80,
48,35,86,51,37,93,56,42,99,59,44,108,66,47,114,69,49,122,73,53,127,76,56,136,
81,59,140,86,63,149,90,66,155,90,70,162,94,73,169,98,76,176,109,79,182,111,
83,188,118,87,193,120,92,199,127,96,205,130,100,93,100,114};

unsigned char *level, *slice;

int xsize, ysize, zsize, slices;

int load_slice(const char *filename) {
  long len;
  FILE *fl = fopen(filename, ""rb"");
  if (!fl) return -1;
  fseek(fl, 0, SEEK_END);
  len = ftell(fl);
  if (len!=xsize*zsize) return -1;
  fseek(fl, 0, SEEK_SET);
  fread(slice, 1, len, fl);
  fclose(fl);
  return 0; }

void save_level(const char *filename) {
  FILE *fl = fopen(filename, ""wb"");
  int i;
  for(i=0; i<255*3; i++) {
    level[xsize*ysize*zsize+i] = pal[i]; }
  fwrite(level, 1, xsize*ysize*zsize+255*3, fl);
  fclose(fl); }
  
void save_palette() {
  FILE *fl = fopen(""color_table.act"", ""wb"");
  int i;
  unsigned char empty[] = {0xFF,0,0xFF};
  fwrite(empty, 1, 3, fl);
  fwrite(pal, 1, 255*3, fl);
  fclose(fl); }
  
void read_palette() {
  FILE *fl = fopen(""color_table.act"", ""rb"");
  if (!fl) return;
  int i;
  unsigned char empty[] = {0xFF,0,0xFF};
  fread(empty, 1, 3, fl);
  fread(pal, 1, 255*3, fl);
  fclose(fl); }

int main(int argc, char **argv) {
    int i;
    
    if (argc!=6){
        printf(""usage:   %s slice_w slice_h slices_count world_h filename\n"", 
                                                                       argv[0]);
        printf(""example: %s 256 256 32 128 level.dat\n\n"",argv[0]);
        printf(""slices must be in raw indexed format without header,\n"");
        printf(""named 0.raw, 1.raw, etc.\n"");
        printf(""Use color_table.act as palette\n"");
        printf(""(first color (magenta,FF00FF) is for empty).\n"");
        printf(""Palette will be saved now as color_table.act\n"");
		printf(""You can alter this palette and it will be added to level.\n"");
        save_palette();
        return 0; }
	
	read_palette();
    xsize = atoi(argv[1]);
    zsize = atoi(argv[2]);
    slices = atoi(argv[3]);
    ysize = atoi(argv[4]);
    
    if (xsize<32 || zsize<32 || ysize<32 ) {
        printf(""Size error. Values greater than 32 expected.\n"");
        return -1; }

    level = (unsigned char*)malloc(xsize*ysize*zsize+255*3);
    slice = (unsigned char*)malloc(xsize*zsize); 
    
    memset(level,0,xsize*ysize*zsize+255*3);
    memset(slice,0,xsize*zsize);
    
    for (i=0;i<slices;i++){
        int x,z; char buffer[256];
        memset(slice,0,xsize*zsize);
        sprintf(buffer,""%d.raw"",i);
        
        if (load_slice(buffer)!=0){
            printf(""error reading %d.raw\n"",i);
            return -1; }
            
        for (x=0;x<xsize;x++) {
            for (z=0;z<zsize;z++) {
                level[x*ysize+z*ysize*xsize+i] = slice[x+z*xsize]; } } }

    save_level(argv[5]);
    printf(""Done!\n"");
    
    return 0; }

"
005-14858,atstarbuckswifi/D3DC,src/D3DC.c,12,1,13,1746768.0154367997,174178.0,10.028637370965336,1373.0,1352.0,39401.0,13455.0,1622.0,637.0,1344.0,594.0,1500000000,0.0011645120102912,1082014363648.0,0.01564491497204,0.0794044195550174,"/*
  D3DC.c

  > mingw32-make -f makefile.mingw32
*/

#include <stdio.h>

int main(int ac, char **av)
{
  int i;
  printf(""sizeof(size_t): %08x\n"", sizeof(size_t));
  for(i = 0; i < ac; ++i)
    printf(""%d %s\n"", i, av[i]);
  return 0;
}
"
019-13062,chbrown/sandbox,c/k_and_r/fahr_for.c,12,2,18,2537344.5823788,407047.0,6.233540598505824,1476.0,1448.0,92640.0,45519.0,1636.0,655.0,1354.0,612.0,1500000000,0.0016915630549192,1082014363648.0,0.0071834456463258,0.0308123249299719,"#include <stdio.h>

int main() {
  printf(""%3s = %6s\n"", ""Fahrenheit"", ""Celsius"");
  for (float fahrenheit = -50; fahrenheit <= 250; fahrenheit += 10) {
    float celsius = (5.0/9.0) * (fahrenheit - 32);
    printf(""%3.0f°F = %6.2f°C\n"", fahrenheit, celsius);
  }

  printf(""%3s = %6s\n"", ""Celsius"", ""Fahrenheit"");
  for (float celsius = -50; celsius <= 250; celsius += 10) {
    float fahrenheit = (celsius*9.0/5.0) + 32;
    printf(""%3.0f°C = %6.2f°F\n"", celsius, fahrenheit);
  }
}
"
163-31466,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.dwarf2/dw2-case-insensitive.c,41,2,23,1300291.6239201,169100.0,7.689479597871082,1142.0,1132.0,38461.0,12696.0,1567.0,584.0,1317.0,544.0,1500000000,0.0008668610826134,1082014363648.0,0.0134476641040804,0.0784252399476122,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2011-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* Target-specific way of forcing an instruction label.  */
#ifdef __mips__
#define START_INSNS asm ("".insn"");
#else
#define START_INSNS
#endif

/* Use DW_LANG_Fortran90 for case insensitive DWARF.  */
asm ("".globl cu_text_start"");
asm (""cu_text_start:"");
START_INSNS

asm ("".globl FUNC_lang_start"");
asm ("".p2align 4"");
asm (""FUNC_lang_start:"");
START_INSNS

void
FUNC_lang (void)
{
}

asm ("".globl FUNC_lang_end"");
asm (""FUNC_lang_end:"");

/* Symbol is present only in ELF .symtab.  */

void
FUNC_symtab (void)
{
}

int
main (void)
{
  FUNC_lang ();
  FUNC_symtab ();
  return 0;
}

asm ("".globl cu_text_end"");
asm (""cu_text_end:"");
"
276-28236,ColinIanKing/stress-ng,test/test-sem-posix.c,46,1,32,1546398.2708751,174906.0,8.83912501572273,1172.0,1162.0,40032.0,13332.0,1610.0,590.0,1350.0,547.0,1500000000,0.0010309321805834,1082014363648.0,0.0133443106582964,0.0767746046023536,"/*
 * Copyright (C) 2013-2021 Canonical, Ltd.
 * Copyright (C)      2022 Colin Ian King
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 */

#include <time.h>
#include <semaphore.h>

#if defined(__FreeBSD_kernel__)
#error POSIX semaphores not yet implemented
#endif

int main(void)
{
	sem_t sem;
	int ret;
	struct timespec timeout;

	timeout.tv_sec = 0;
	timeout.tv_nsec = 1000000;

	/*
	 * This is not meant to be functionally
	 * correct, it is just used to check we
	 * can build minimal POSIX semaphore
	 * based code
	 */
	ret = sem_init(&sem, 1, 1);
	(void)ret;
	ret = sem_wait(&sem);
	(void)ret;
	ret = sem_post(&sem);
	(void)ret;
	ret = sem_trywait(&sem);
	(void)ret;
	ret = sem_timedwait(&sem, &timeout);
	(void)ret;
	ret = sem_destroy(&sem);
	(void)ret;

	return 0;
}
"
065-3827,AndrewLaing/CHowToProgramExercises,Chapter9/ex09_07.c,29,2,26,2227024.52447265,197051.0,11.301764517815185,1381.0,1358.0,44970.0,16092.0,1643.0,639.0,1360.0,597.0,1500000000,0.0014846830163151,1082014363648.0,0.0138999548340277,0.0694212439815269,"/*
 * Filename:    ex09_07.c
 * Author:      Andrew Laing
 * Email:       parisianconnections@gmail.com
 * Date:        16/07/2017.
 */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int getRandomNumber( int max );

int main()
{   
    srand( time(NULL) );
    int i, sum=0, x[10];
    
    for(i=0; i<10; i++) 
    {
        x[i] = getRandomNumber(1000) ;
    }
    
    
    printf(""%s\t%s\n"", ""Value"", ""Total characters"");
    
    for(i=0; i<10; i++) 
    {
        sum += printf(""%d"", x[i]);
        printf(""\t%d\n"", sum);
        x[i] = getRandomNumber(1000) ;
    }
    return 0;
}


/* Returns a random number in the range 0 to max-1*/
int getRandomNumber( int max )
{
    return (rand()%max)+1;
}


"
212-28059,ensemblr/llvm-project-boilerplate,include/llvm/projects/test-suite/SingleSource/Benchmarks/BenchmarkGame/puzzle.c,59,5,45,265839971.9512089,3105190507.0,0.0856114851571005,1378.0,1355.0,505041580.0,7514178.0,33697246.0,156973.0,1343.0,63095.0,1500000000,0.1772266479674726,1082014363648.0,8.801392358501114e-07,0.0661755457247248,"#include ""stdlib.h""
#include ""stdio.h""

#define ARRAY_SIZE 500000
#define NLOOPS1 5
#define NLOOPS2 200

// RNG implemented localy to avoid library incongruences
#ifdef RAND_MAX
#undef RAND_MAX
#endif
#define RAND_MAX 32767
static unsigned long long int next = 1;
 
int rand( void ) {
    next = next * 1103515245 + 12345;
    return (unsigned int)(next / 65536) % RAND_MAX+1;
}
 
void srand( unsigned int seed ) {
    next = seed;
}
// End of RNG implementation

int randInt(int min, int max) {
    int k, n;
    n = (max - min) + 1;
    k = (int)(n * (rand() / (RAND_MAX + 1.0)));
    return (k == n) ? k + min - 1 : k + min;
}

void shuffle(int* items, int len) {
    size_t j, k, i;
    int aux;

    for(i = len-1; i > 0; --i) {
        k = (int)((i + 1) * (rand() / (RAND_MAX + 1.0)));
        j = (k == (i + 1)) ? k - 1 : k;

        aux = items[i];
        items[i] = items[j];
        items[j] = aux;
    }
}

int *createRandomArray(int size) {
    int i, len;
    int *result;

    len = size + 1;
    result = (int*)malloc(len * sizeof(int));
    for (i = 0; i < len; i++)
        result[i] = i;
    result[0] = randInt(1, size);
    shuffle(result, len);
    return result;
}

int findDuplicate(int *data, int len) {
    int i;
    int result = 0;

    for (i = 0; i < len; i++)
        result = result ^ (i + 1) ^ data[i];
    result ^= len;
    return result;
}

int main() {
    int i, j, duplicate;
    int *rndArr;

    srand(1);

	for (i = 0; i < NLOOPS1; i++) {
		rndArr = createRandomArray(ARRAY_SIZE);
		for (j = 0; j < NLOOPS2; j++)
			duplicate = findDuplicate(rndArr, ARRAY_SIZE+1);
		free(rndArr);
		printf(""Found duplicate: %d\n"", duplicate);
	}

    return 0;
}
"
086-1349,alexhilton/miscellaneous,linux/advanced-prog-in-unix/chap12/liftoff.c,22,3,18,15006000390.043482,256361.0,58534.646026501694,1551.0,1508.0,57789.0,26025.0,1747.0,1053.0,1378.0,998.0,1500000000,10.004000260028988,1082014363648.0,0.011932392212544,0.0617557925883503,"/*
 * liftoff.c
 * Emulator rockets lifting off using thread.
 * The counting down before lanuching is by thread.
 */
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

static void *liftoff( void *arg ) {
  int a = *(int *) arg;
  while ( a ) {
    printf( "" %d "", a-- );
  }
  printf( ""Lift off...\n"" );

  return (void *) 0;
}

int main( void ) {
  pthread_t tid;
  for ( int i = 1; i <= 10; i++ ) {
    pthread_create( &tid, NULL, liftoff, (void *) &i );
  }
  printf( ""Waiting for lift off:\n"" );
  sleep( 10 );
  return 0;
}
"
373-30652,Gurgel100/gcc,gcc/testsuite/gcc.c-torture/execute/pr87290.c,56,2,45,1498411.52597205,207964.0,7.2051460829759,1152.0,1143.0,42751.0,16684.0,1577.0,586.0,1323.0,546.0,1500000000,0.0009989410173147,1082014363648.0,0.011035563847589,0.067838815512745,"/* PR middle-end/87290 */

int c;

__attribute__((noipa)) void
f0 (void)
{
  c++;
}

__attribute__((noipa)) int
f1 (int x)
{
  return x % 16 == 13;
}

__attribute__((noipa)) int
f2 (int x)
{
  return x % 16 == -13;
}

__attribute__((noipa)) void
f3 (int x)
{
  if (x % 16 == 13)
    f0 ();
}

__attribute__((noipa)) void
f4 (int x)
{
  if (x % 16 == -13)
    f0 ();
}

int
main ()
{
  int i, j;
  for (i = -30; i < 30; i++)
    {
      if (f1 (13 + i * 16) != (i >= 0) || f2 (-13 + i * 16) != (i <= 0))
	__builtin_abort ();
      f3 (13 + i * 16);
      if (c != (i >= 0))
	__builtin_abort ();
      f4 (-13 + i * 16);
      if (c != 1 + (i == 0))
	__builtin_abort ();
      for (j = 1; j < 16; j++)
	{
	  if (f1 (13 + i * 16 + j) || f2 (-13 + i * 16 + j))
	    __builtin_abort ();
	  f3 (13 + i * 16 + j);
	  f4 (-13 + i * 16 + j);
	}
      if (c != 1 + (i == 0))
	__builtin_abort ();
      c = 0;
    }
  return 0;
}
"
322-871,CajetanP/coding-exercises,CodeWars/Fundamentals/FindTheSmallest/FindTheSmallest.c,75,5,42,1889358.1582233,211314.0,8.940997756892587,1428.0,1404.0,46863.0,18356.0,1661.0,643.0,1378.0,597.0,1500000000,0.0012595721054822,1082014363648.0,0.0134018569522132,0.0656097149603643,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

int smallest_idx_between(char* str, int start, int end) {

    int smallest = start;

    for (int i = start ; i < end ; ++i) {
        if (str[i]-'0' < str[smallest]-'0')
            smallest = i;
    }

    return smallest;
}

long long* smallest(long long n) {
    long long* result = malloc(3 * sizeof *result);
    char temp[100];
    sprintf(temp, ""%lld"", n);

    int min_idx = 0;
    int tmp = -1;
    do {
        tmp++;
        min_idx = smallest_idx_between(temp, tmp, strlen(temp));
    } while (min_idx == 0);

    char temp_char = temp[min_idx];
    for (size_t i = min_idx+1 ; i < strlen(temp) ; ++i)
        temp[i-1] = temp[i];
    temp[strlen(temp)-1] = '\0';

    if (tmp > 0) {
        temp[strlen(temp)+1] = '\0';
        int i;
        for (i = strlen(temp) ; i >= tmp+1 ; --i) {
            temp[i] = temp[i-1];
        }

        temp[i] = temp_char;
        result[0] = atoi(temp);
    } else {
        result[0] = atoi(temp);
        sprintf(temp, ""%c%lld"", temp_char, result[0]);
        result[0] = atoi(temp);
    }

    if (temp_char != '0' || min_idx > 1) {
        result[1] = min_idx;
        result[2] = tmp;
    } else {
        result[1] = 0;
        result[2] = min_idx;
   }

    printf(""n: %lld ; m_i: %d ; tmp: %d ; %c\n"", n, min_idx, tmp, temp_char);

    return result;
}

char* array2StringLongLong(long long* arr, int size) {
    char* result = malloc(size * 7);
    strcpy(result, """");

    char temp[50];
    strcpy(temp, """");
    for (int i = 0 ; i < size ; ++i) {
        sprintf(temp, ""%lld"", arr[i]);
        strcat(result, temp);
        strcat(result, "", "");
        strcpy(temp, """");
    }
    result[strlen(result)-2] = '\0';

    return result;
}


void dotest(long long n, char *expr) {
    long long* act = smallest(n);
    char* sact = array2StringLongLong(act, 3);
    if(strcmp(sact, expr) != 0)
        printf(""step. Error. Expected \n%s\n but got \n%s\n"", expr, sact);
    assert(strcmp(sact, expr) == 0);
    free(act); act = NULL;
    free(sact); sact = NULL;
}

int main() {
    dotest(261235, ""126235, 2, 0"");
    dotest(209917, ""29917, 0, 1"");
    dotest(285365, ""238565, 3, 1"");
    dotest(296837, ""239687, 4, 1"");
    dotest(269045, ""26945, 3, 0"");
}
"
207-16091,senfo/ScratchPad,c/palindrome.c,37,3,23,122942713.43853314,839583294.0,0.1464330148998891,1390.0,1368.0,161478675.0,124999279.0,1641.0,641.0,1365.0,595.0,1500000000,0.0819618089590221,1082014363648.0,3.2849629330523576e-06,1.4807422144602444e-05,"/* Finds the largest palindrome made from the product of two 3-digit numbers. */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>

#define ARRAY_SIZE 8
#define START 999
#define FINISH 99

#define max(a, b) (((a) > (b)) ? (a) : (b))

void reverse(char *);

int main(void)
{
  int x, y, largest = 0;
  char buffer[ARRAY_SIZE];
  char *reversed;
  size_t length;

  for (x = START; x > FINISH; x--)
  for (y = START; y > FINISH; y--)
  {
    sprintf(buffer, ""%d"", x * y);
    length = strlen(buffer);
    reversed = malloc((length + 1) * sizeof(char));
    strncpy(reversed, buffer, length);
    reverse(reversed);

    if (strcmp(buffer, reversed) == 0)
    {
      largest = max(largest, x * y);
    }

    strncpy(reversed, ""\0"", length);
    free(reversed);
  }

  printf(""%d\n"", largest);

  return 0;
}


void reverse(char *s)
{
  int length = strlen(s);
  int c, i, j;

  for (i = 0, j = length - 1; i < j; i++, j--)
  {
    c = s[i];
    s[i] = s[j];
    s[j] = c;
  }
}
"
080-17205,jesajx/experiments,old_crap/src/bubblesort.c,42,3,25,1965080.9699668502,188549.0,10.42211838832346,1351.0,1331.0,42545.0,15534.0,1630.0,638.0,1350.0,594.0,1500000000,0.0013100539799779,1082014363648.0,0.0142244191165161,0.0725219098124967,"
#include <stdio.h>

void printarray(int size, int* v) {
    if (size > 0) {
        printf(""%d"", v[0]);
        for (int i = 1; i < size; ++i) {
            printf("", %d"", v[i]);
        }
    }
}

// Returns index with min value.
// If more than one index has the same value, the first is returned.
int mini(int size, int* v) {
    int min = 0;
    for (int i = 0; i < size; ++i) {
        if (v[i] < v[min]) {
            min = i;
        }
    }
    return min;
}

// Swaps contents at index i and j.
void swapi(int* v, int j, int i) {
    int temp = v[j];
    v[j] = v[i];
    v[i] = temp;
}

// Sorts v.
void bubblesort(int size, int* v) {
    for (; size > 1; --size, ++v) {
        int max = mini(size, v);
        swapi(v, max, 0);
    }
}


int main(int argc, char** argv) {
    int v[] = {1,7,14,12,12,3,5,4,732,1000,1};
    int size = sizeof(v)/sizeof(v[0]);

    printarray(size, v);
    printf(""\n"");

    bubblesort(size, v);

    printarray(size, v);
    printf(""\n"");

    return 0;
}

"
016-2344,alfikpl/ao68000,tests/nbcd_abcd_sbcd/nbcd_abcd_sbcd.c,246,5,123,44490432.0174828,283215869.0,0.1570254560841716,1320.0,1300.0,50830870.0,48576169.0,1634.0,638.0,1353.0,594.0,1500000000,0.0296602880116552,1082014363648.0,9.25089405918847e-06,4.244166250641466e-05,"/* 
 * Copyright 2010, Aleksander Osman, alfik@poczta.fm. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice, this list of
 *     conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright notice, this list
 *     of conditions and the following disclaimer in the documentation and/or other materials
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <stdio.h>

/*
struct from_68knotes_t {
	unsigned char operand;
	unsigned int x;
	unsigned char unadjusted;
	unsigned char adjusted;
	unsigned int v;
};
struct from_68knotes_t from_68knotes[] = {
	{ 0x00, 0, 0x00, 0x00, 0 },
	{ 0x00, 1, 0xFF, 0x99, 0 },
	{ 0xFF, 0, 0x01, 0x9B, 0 },
	{ 0xFF, 1, 0x00, 0x9A, 0 },
	{ 0x01, 0, 0xFF, 0x99, 0 },
	{ 0x01, 1, 0xFE, 0x98, 0 },
	{ 0x0F, 0, 0xF1, 0x8B, 0 },
	{ 0x0F, 1, 0xF0, 0x8A, 0 },
	{ 0xF0, 0, 0x10, 0xB0, 0 },
	{ 0xF0, 1, 0x0F, 0xA9, 0 },
	{ 0x9A, 0, 0x66, 0x00, 0 },
	{ 0x9A, 1, 0x65, 0xFF, 0 },
	{ 0x99, 0, 0x67, 0x01, 0 },
	{ 0x99, 1, 0x66, 0x00, 0 },
	{ 0x10, 0, 0xF0, 0x90, 0 },
	{ 0x10, 1, 0xEF, 0x89, 0 },
	{ 0x7F, 0, 0x81, 0x1B, 1 },
	{ 0x7F, 1, 0x80, 0x1A, 1 },
	{ 0x80, 0, 0x80, 0x20, 1 },
	{ 0x80, 1, 0x7F, 0x19, 0 },
	{ 0x81, 0, 0x7F, 0x19, 0 },
	{ 0x81, 1, 0x7E, 0x18, 0 }
};
*/

struct input_t {
	unsigned char src;
	unsigned char dst;
	
	unsigned int x;
	unsigned int z;
	unsigned int v;
};

struct output_t {
	unsigned char result;
	
	unsigned int c;
	unsigned int v;
	unsigned int z;
	unsigned int n;
	unsigned int x;
};

struct output_t uae_nbcd(struct input_t in) {	
	signed char src = in.dst;
	
	unsigned short newv_lo = - (src & 0xF) - in.x;
	unsigned short newv_hi = - (src & 0xF0);
	unsigned short newv;
	int cflg;
	if (newv_lo > 9) { newv_lo -= 6; }
	newv = newv_hi + newv_lo;	cflg = (newv & 0x1F0) > 0x90;
	if (cflg) newv -= 0x60;
	
	struct output_t out;
	out.c = cflg ? 1 : 0;
	out.x = out.c;
	out.z = in.z & ((((signed char)(newv)) == 0) ? 1 : 0);
	out.n = (((signed char)(newv)) < 0) ? 1 : 0;
	out.v = in.v;
	
	out.result = (newv) & 0xff;
	return out;
}
struct output_t verilog_nbcd(struct input_t in) {
	struct output_t out;
	
	unsigned char l = 25 - ((in.dst) & 0x0F);
	unsigned char h = 25 - (((in.dst) & 0xF0) >> 4);
	
	if( ((in.dst) & 0x0F) > 9 ) h -= 1;
	
	l &= 0x0F;
	h &= 0x0F;
	
	if(in.x == 0) {
		if(l == 9) {
			l = 0;
			h = (h==9) ? 0 : h+1;
		}
		else if(l == 0xF) {
			l = 0;
			h += 1;
		}
		else {
			l += 1;
		}
	}
	
	l &= 0x0F;
	h &= 0x0F;
	
	out.result = (h << 4) + l;
	
	out.v = in.v;
	out.z = in.z & ((out.result == 0) ? 1 : 0);
	out.c = out.x = (in.dst == 0 && in.x == 0) ? 0 : 1;
	out.n = (((out.result) & 0x80) == 0) ? 0 : 1;
	
	return out;
}

struct output_t uae_abcd(struct input_t in) {
	signed char src = in.src;
	signed char dst = in.dst;
	
	unsigned short newv_lo = (src & 0xF) + (dst & 0xF) + (in.x ? 1 : 0);
	unsigned short newv_hi = (src & 0xF0) + (dst & 0xF0);
	unsigned short newv, tmp_newv;
	int cflg;
	newv = tmp_newv = newv_hi + newv_lo;	if (newv_lo > 9) { newv += 6; }
	cflg = (newv & 0x3F0) > 0x90;
	if (cflg) newv += 0x60;
	
	struct output_t out;
	out.c = cflg;
	out.x = out.c;
	out.z = in.z & (((signed char)(newv)) == 0);
	out.n = ((signed char)(newv)) < 0;
	out.v = (tmp_newv & 0x80) == 0 && (newv & 0x80) != 0;
	out.result = (newv) & 0xff;
	
	return out;
}
struct output_t verilog_abcd(struct input_t in) {

	unsigned char l = (in.src & 0x0F) + (in.dst & 0x0F) + in.x;
	unsigned char h = ((in.src & 0xF0) >> 4) + ((in.dst & 0xF0) >> 4);
	
	int tmp = (in.src + in.dst + in.x) & 0x80;
	
	l = (l > 0x09) ? (l+6) : l;
	h = (l > 0x1F) ? (h+2) :
		(l > 0x0F) ? (h+1) : h;
	h = (h > 0x09) ? (h+6) : h;
	
	struct output_t out;
	out.c = (h > 0x09) ? 1 : 0;
	out.x = out.c;
	
	l &= 0x0F;
	h &= 0x0F;
	
	out.result = (h << 4) + l;
	
	out.z = in.z & (out.result == 0);
	out.n = ((out.result & 0x80) == 0x80) ? 1 : 0;
	out.v = (tmp == 0) && ((out.result & 0x80) != 0);
	
	return out;
}

struct output_t uae_sbcd(struct input_t in) {
	signed char src = in.src;
	signed char dst = in.dst;
	
	unsigned short newv_lo = (dst & 0xF) - (src & 0xF) - (in.x ? 1 : 0);
	unsigned short newv_hi = (dst & 0xF0) - (src & 0xF0);
	unsigned short newv, tmp_newv;
	int bcd = 0;
	newv = tmp_newv = newv_hi + newv_lo;
	if (newv_lo & 0xF0) { newv -= 6; bcd = 6; };
	if ((((dst & 0xFF) - (src & 0xFF) - (in.x ? 1 : 0)) & 0x100) > 0xFF) { newv -= 0x60; }
	
	struct output_t out;
	out.c = (((dst & 0xFF) - (src & 0xFF) - bcd - (in.x ? 1 : 0)) & 0x300) > 0xFF;
	out.x = out.c;
	out.z = in.z & (((signed char)(newv)) == 0);
	out.n = ((signed char)(newv)) < 0;
	out.v = (tmp_newv & 0x80) != 0 && (newv & 0x80) == 0;
	out.result = (newv) & 0xff;
	
	return out;
}

struct output_t verilog_sbcd(struct input_t in) {
	
	unsigned char l = 32 + (in.dst & 0x0F) - (in.src & 0x0F) - in.x;
	unsigned char h = 32 + ((in.dst & 0xF0) >> 4) - ((in.src & 0xF0) >> 4);
	
	int tmp = in.dst - in.src - in.x;
	
	l = (l < 32) ? (l-6) : l;
	h = (l < 16) ? (h-2) :
		(l < 32) ? (h-1) : h;
	h = (h < 32 && (tmp & 0x100) > 0xFF) ? (h-6) : h;
	
	struct output_t out;
	out.c = (h < 32) ? 1 : 0;
	out.x = out.c;
	
	l &= 0x0F;
	h &= 0x0F;
	
	out.result = (h << 4) + l;
	
	out.z = in.z & (out.result == 0);
	out.n = ((out.result & 0x80) == 0x80) ? 1 : 0;
	out.v = ((tmp & 0x80) != 0) && ((out.result & 0x80) == 0);
	
	return out;
}

int test_failed = 0;
void compare(struct input_t in, struct output_t uae, struct output_t verilog) {
	if( uae.result == verilog.result &&
		uae.c == verilog.c &&
		uae.v == verilog.v &&
		uae.z == verilog.z &&
		uae.n == verilog.n &&
		uae.x == verilog.x
	) return;

	//printf(""%hhx + %hhx + %x: | "", in.dst, in.src, in.x);
	//printf(""%hhx - %hhx - %x: | "", in.dst, in.src, in.x);

	printf(""[Mismatch: in.dst: %hhx, in.src: %hhx, in.x: %x] "", in.dst, in.src, in.x);

	if( uae.result != verilog.result ) 		printf(""result: %hhx != %hhx | "", uae.result, verilog.result);
	if( uae.c != verilog.c ) 			printf(""c: %x != %x | "", uae.c, verilog.c);
	if( uae.v != verilog.v ) 			printf(""v: %x != %x | "", uae.v, verilog.v);
	if( uae.z != verilog.z ) 			printf(""z: %x != %x | "", uae.z, verilog.z);
	if( uae.n != verilog.n ) 			printf(""n: %x != %x | "", uae.n, verilog.n);
	if( uae.x != verilog.x ) 			printf(""x: %x != %x | "", uae.x, verilog.x);
	printf(""\n"");
	
	test_failed = 1;
}

int main(int argc, char **argv) {
	struct input_t in;
	
	int i,j,k,l,m;
	for(i=0; i<256; i++) {
		for(j=0; j<256; j++) {
			for(k=0; k<2; k++) {
				for(l=0; l<2; l++) {
					for(m=0; m<2; m++) {
						in.src = i;
						in.dst = j;
						in.x = k;
						in.z = l;
						in.v = m;
						
						struct output_t uae0 = uae_nbcd(in);
						struct output_t verilog0 = verilog_nbcd(in);
						
						compare(in, uae0, verilog0);
						
						struct output_t uae1 = uae_abcd(in);
						struct output_t verilog1 = verilog_abcd(in);
						
						compare(in, uae1, verilog1);
						
						struct output_t uae2 = uae_sbcd(in);
						struct output_t verilog2 = verilog_sbcd(in);
						
						compare(in, uae2, verilog2);
					}
				}
			}
		}
	}
	if(test_failed) printf(""Test FAILED.\n"");
	else            printf(""Test OK.\n"");
	
	return 0;
}

"
107-9192,ilee/projects,daily/pe/pe12.c,60,5,46,292904819.8275267,881464590.0,0.3322933471439845,1342.0,1322.0,64066419.0,42021953.0,1622.0,699.0,1342.0,656.0,1500000000,0.1952698798850178,1082014363648.0,3.0222427879944674e-06,4.071134204981485e-05,"/* Project Euler
** 12
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <inttypes.h>

static long long euler = 0;

/*
int numberdivisors(unsigned long long number) {
	int total = 0;
	unsigned long long i;

	for (i=1; i < number; i++) {
		if (number % i == 0) {
			total++;
			printf(""divisor = %llu | divisors = %d\n"", i, total);
		}
	}

	total++;
	return total;
}
*/
// Copied from stackoverflow
int numberdivisors(unsigned long long x) {
    unsigned long long limit = x;
    int numberOfDivisors = 0;
    unsigned long long i = 1;

    for (i = 1; i < limit; ++i) {
        if (x % i == 0) {
            limit = x / i;
            printf(""limit = %llu | i = %llu\n"", limit, i);
            if (limit != i) {
                numberOfDivisors++;
            }
            numberOfDivisors++;
        }
    }

    return numberOfDivisors;
}

/* Completely unnecessary for this problem

unsigned long long numbertriangle(unsigned long long number) {
	unsigned long long i;
	unsigned long long total = 0;

	for (i=1; i <= number; i++) {
		total+=i;
		printf(""triangle = %llu\n"", total);
	}
	return total;
}
*/

int main(int argc, char** argv) {

	unsigned long long triangle = 0;
	int divisors = 0;
	unsigned long long i = 1;

	do {
		triangle+=i;
		divisors = numberdivisors(triangle);
		i++;
		printf(""%llu\n"", i);
	} while (divisors <= 500);

	euler = triangle;

	printf(""%llu\n"", euler);

return 0;
}

"
235-778,phil-opp/binutils-gdb,gdb/testsuite/gdb.base/step-break.c,24,2,26,1081510108.7791846,9663845478.0,0.1119130174899926,1139.0,1129.0,3221263925.0,2147496345.0,1567.0,588.0,1316.0,547.0,1500000000,0.721006739186123,1082014363648.0,2.3468918301344558e-07,7.484036905972708e-07,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2008-2016 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

int
main ()
{
    volatile int i = 1;

    while (i > 0) /* place1 */
      {
	i++; /* place2 */
	i++; /* place3, set breakpoint here  */
      }

    return 0;
}
"
387-27335,NicoleRobin/glibc,stdio-common/xbug.c,51,2,38,5436279.22888845,187828.0,28.942857294972,1522.0,1484.0,42889.0,14974.0,1739.0,657.0,1389.0,611.0,1500000000,0.0036241861525923,1082014363648.0,0.0160040036629256,0.0759725558647149,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct _Buffer {
  char *buff;
  int  room, used;
} Buffer;

void InitBuffer (Buffer *b);
void AppendToBuffer (Buffer *b, const char *str, int len);
void ReadFile (Buffer *buffer, FILE *input);

#define INIT_BUFFER_SIZE 10000

void
InitBuffer (Buffer *b)
{
  b->room = INIT_BUFFER_SIZE;
  b->used = 0;
  b->buff = (char *)malloc(INIT_BUFFER_SIZE*sizeof(char));
}

void
AppendToBuffer (Buffer *b, const char *str, int len)
{
  while (b->used + len > b->room) {
    b->buff = (char *)realloc(b->buff, 2*b->room*(sizeof(char)));
    b->room *= 2;
  }
  strncpy(b->buff + b->used, str, len);
  b->used += len;
}

void
ReadFile (Buffer *buffer, FILE *input)
{
  char       buf[BUFSIZ + 1];
  int        bytes;

  buffer->used = 0;
  while (!feof(input) && (bytes = fread(buf, 1, BUFSIZ, input)) > 0) {
    AppendToBuffer(buffer, buf, bytes);
  }
  AppendToBuffer(buffer, """", 1);
}

int
main(int argc, char *argv[])
{
  char filename[] = ""xbug.c"";
  FILE *input;
  Buffer buffer;

  InitBuffer(&buffer);

  if (!freopen (filename, ""r"", stdin))
    fprintf(stderr, ""cannot open file\n"");

  unsetenv (""LD_LIBRARY_PATH"");

  if (!(input = popen(""/bin/cat"", ""r"")))
    fprintf(stderr, ""cannot run \n"");

  ReadFile(&buffer, input);
  pclose(input);

  return 0;
}
"
118-6729,totalspectrum/binutils-propeller,gdb/testsuite/gdb.threads/tls-var-main.c,19,1,17,1510429.42889025,170260.0,8.871308586867144,1144.0,1136.0,38665.0,12780.0,1573.0,589.0,1320.0,547.0,1500000000,0.0010069529525935,1082014363648.0,0.0133912839187125,0.0783166488482845,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2011-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <pthread.h>

int
main (void)
{
  /* Ensure we link against pthreads even with --as-needed.  */
  pthread_testcancel();
  return 0;
}
"
090-35038,mrrusof/snippets,c/float/bits-of-float/main.c,46,3,25,1817687.9966631,182995.0,9.932987240088528,1464.0,1439.0,42244.0,14809.0,1648.0,641.0,1365.0,598.0,1500000000,0.0012117919977754,1082014363648.0,0.0158638214158856,0.0745271940125847,"#include <stdlib.h>
#include <stdio.h>

char * bits_of_double(double d) {
  unsigned long byte_count = sizeof(d);
  unsigned char * bytes = (unsigned char *) &d;
  char * bits_of_double = (char *) malloc(byte_count * 8 + 1);
  bits_of_double[byte_count * 8] = 0;
  unsigned char byte;
  int i, j, k;
  for (i = byte_count, j = 0; i > 0; i--) {
    byte = bytes[i-1];
    for (k = j+8; j < k; j++) {
      if (byte & 0x80) {
	bits_of_double[j] = '1';
      } else {
	bits_of_double[j] = '0';
      }
      byte = byte << 1;
    }
  }
  return bits_of_double;
}

void print_bits_of_double(char * bits) {
  int i = -1;
  while(bits[++i] != 0) {
    if (i == 1 || i == 12) {
      printf("" "");
    }
    printf(""%c"", bits[i]);
  }
}

int main(void) {
  /*
     For d = 0.25, bits are
     0 01111111101 0000000000000000000000000000000000000000000000000000
     1 23456781234 5678123456781234567812345678123456781234567812345678
     1        2        3       4       5       6       7       8
  */
  double d = 5432.0;
  char * bits = bits_of_double(d);
  printf(""For d = %f, bits are\n"", d);
  print_bits_of_double(bits);
  printf(""\n"");
  printf(""1 23456781234 5678123456781234567812345678123456781234567812345678\n"");
  printf(""1        2        3       4       5       6       7       8\n"");
  free(bits);
  return 0;
}
"
353-29823,batermj/algorithm-challenger,books/cs/general-purpose-algorithms/introduction-to-algorithms/3rd-edition/chapter8/C/bucket_sort.c,64,5,41,2077382.756397,267541.0,7.764723911475251,1515.0,1485.0,59376.0,25706.0,1667.0,666.0,1381.0,619.0,1500000000,0.001384921837598,1082014363648.0,0.0112132346070321,0.0509273406831057,"#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>

#define DATASETSIZE 10

struct node{
	double dValue;
	struct node * pNext;
};

void insert_sort(struct node ** pBucket, double dValue);
int main(void){
	double srcdata[DATASETSIZE];
	struct node bArray[DATASETSIZE];
	struct node *pNext = NULL;

	int idx, jdx;

	srand(time(NULL));
	for( idx=0; idx<DATASETSIZE; idx++ ){
		srcdata[idx] = rand()*1.0/RAND_MAX;
		printf(""the data is %f,%f\n"",srcdata[idx],floor((float)(srcdata[idx]*DATASETSIZE)) );
		bArray[idx].dValue = -1;
		bArray[idx].pNext = NULL;
	}

	for( idx=0; idx<DATASETSIZE; idx++ ){
		jdx = (int)(floor((float)(srcdata[idx]*DATASETSIZE)));
		insert_sort(&(bArray[jdx].pNext),srcdata[idx]);
		if(bArray[jdx].pNext == NULL ){
			printf(""the insertion failed.\n"");
		}
	}

	for( idx=0; idx<DATASETSIZE; idx++ ){
		printf(""\nthe %dth bucket:\n"",idx);
		pNext = bArray[idx].pNext;
		while( pNext != NULL ){
			printf(""%f, "", pNext->dValue);
			pNext = pNext->pNext;
		}
		printf(""\n"");
	}
}


void insert_sort(struct node ** pBucket, double dValue){
	struct node *pNext = NULL, *pNext2=NULL, *myBucket=*pBucket;
	printf(""the dValue is %f\n"",dValue);
	if( myBucket == NULL ){
		printf(""the myBucket is empty\n"");
		myBucket = (struct node *)malloc(sizeof(struct node));
		myBucket->dValue = dValue;
		myBucket->pNext = NULL;
		*pBucket = myBucket;
	}else{
		printf(""the myBucket is not empty\n"");
		pNext = myBucket;
		while( pNext != NULL ){
			if( pNext->dValue <= dValue ){
				myBucket = pNext;
				pNext = pNext->pNext;
			}else break;
		}

		pNext2 = (struct node *)malloc(sizeof(struct node));
		pNext2->dValue = dValue;
		pNext2->pNext = NULL;

		if(pNext == myBucket){
			pNext2->pNext = myBucket;
			*pBucket = pNext2;
		}else{
			myBucket->pNext = pNext2;
			pNext2->pNext = pNext;
		}
	}
}
"
027-2954,tperdue321/learn-c-the-hard-way,ex13.c,13,2,14,1380214.46764455,178083.0,7.750397286658468,1356.0,1335.0,40251.0,13960.0,1627.0,637.0,1345.0,596.0,1500000000,0.0009201429784297,1082014363648.0,0.0151109314196189,0.0775672833926693,"#include <stdio.h>

int main(int argc, char *argv[]) {
  // print each argument passed to the program
  for(int i = 0; i < argc; i++)
    printf(""arg %d: %s\n"", i, argv[i]);

  // array of states
  char *states[] = {
    ""California"", ""Oregon"",
    ""Washington"", ""Texas""
  };

  for(int i = 0, numStates = 4; i < numStates; i++)
    printf(""State %d: %s\n"", i, states[i]);

  return 0;
}"
186-29489,myhongkongzhen/LinuxC,linuxC/7-01sigmask.c,39,1,27,15003052185.17315,185621.0,80826.26526632224,1393.0,1370.0,42207.0,15038.0,1657.0,640.0,1372.0,595.0,1500000000,10.002034790115433,1082014363648.0,0.0148851692427042,0.0744868547471395,"/*
 * =====================================================================================
 *
 *       Filename:  7-01sigmask.c
 *
 *    Description:  
 *
 *        Version:  1.0
 *        Created:  2014年08月22日 23时41分16秒
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  Z_Z.W (ZZW), myhongkongzhen@gmail.com
 *   Organization:  
 *
 * =====================================================================================
 */
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void handle(int s){
	printf(""signal ...\n"");
}

int main(){

	int num = 0;
	int i = 0;

	sigset_t sigs;
	sigemptyset(&sigs);
	sigaddset(&sigs,SIGINT);
	//	sigfillset(&sigs);

	signal(SIGINT,handle);

	sigprocmask(SIG_BLOCK,&sigs,0);

	for(; i < 10 ; i ++){
		num += i;
		sleep(1);
		printf(""%d "",num);
	}
	printf(""%d\n"",num);
	sigprocmask(SIG_UNBLOCK,&sigs,0);
	printf(""over!\n"");

	return 0;
}

"
007-17686,mssola/programs,lang/c/clock.c,28,2,23,36008503989.083694,1085390402.0,33.17562410967404,1289.0,1269.0,271344081.0,81405171.0,1631.0,634.0,1348.0,592.0,1500000000,24.005669326055795,1082014363648.0,2.3567556846702244e-06,1.1920648948675871e-05,"/*
 * Copyright (C) 2014-2016 Miquel Sabaté Solà <mikisabate@gmail.com>
 * This file is licensed under the MIT license.
 * See the LICENSE file.
 */

/*
 * This file is not that interesting. It's more a rendition of a program
 * that I did in the EC1 course.
 */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void wait(int seconds)
{
	clock_t endwait;

	endwait = clock() + seconds * CLOCKS_PER_SEC;
	while (clock() < endwait);
}

int main(int argc, char *argv[])
{
	int n, sec;
	char *a = ""Aquest programa funciona"";

	sec = (argc == 2) ? atoi(argv[1]) : 1;
	for (; *a; ++a) {
		wait(sec);
		printf(""%c"",*a);
		fflush(stdout);
	}
	printf(""\n"");
	return 0;
}
"
092-33390,LingboTang/Lingbo379,Midterm2/mutex.c,51,2,31,18415593165.20579,410792.0,44829.483449044776,3455.0,1903.0,96217.0,45455.0,2606.0,1470.0,1695.0,1295.0,1500000000,12.277062110137194,1082014363648.0,0.0130430972365576,0.0498757693827997,"#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

int thd_var[10];
pthread_mutex_t mutex;

void *runner(void *param); /* the thread */

int main()
{
	pthread_t tid[10]; 
	pthread_attr_t attr; 

	int i;

	if (pthread_mutex_init(&mutex, NULL) != 0)
	{
		fprintf(stderr,""Unable to initialize mutex\n"");
		return 1;
	}

	pthread_attr_init(&attr);

	for (i = 0; i < 10; i++)
	{
		thd_var[i] = i;
		pthread_create(&tid[i], &attr, runner, (void *) &thd_var[i]);
	}

	for (i = 0; i < 10; i++)
		pthread_join(tid[i],NULL);

	pthread_mutex_destroy(&mutex);

	printf(""\n\nMain Thread Finished.\n\n"");

}

/* The thread will begin control in this function */
void *runner(void *param)
{
	int * p;
	FILE * f;

	p = (int *) param;

	if (pthread_mutex_lock(&mutex) != 0)
	{
		fprintf(stderr,""Unable to acquire lock\n"");
		_exit(2);
	}

	fprintf(stdout, ""\nMutex acquired by Thread %d\n"", (*p) );
	sleep(1);
		
	f = fopen(""1.txt"", ""a"");
	fprintf(f, ""\nText 1 written by Thread %d"", (*p) );
	fprintf(f, ""\nText 2 written by Thread %d"", (*p) );
	fprintf(f, ""\nText 3 written by Thread %d\n"", (*p) );
	fclose(f);

	if (pthread_mutex_unlock(&mutex) != 0)
	{
		fprintf(stderr,""Unable to release mutex\n"");
		_exit(3);
	} 

	fprintf(stdout, ""Mutex released by Thread %d\n"", (*p) );
	sleep(1);

	pthread_exit( (void *) 0 ); 
}
"
248-32978,CajetanP/coding-exercises,CodeWars/Algorithms/SrotTheInnerCtonnetInDsinnieedcgOredr/SrotTheInnerCtonnetInDsinnieedcgOredr.c,55,4,30,1730432.73389325,192431.0,8.992480421553699,1436.0,1407.0,43519.0,15428.0,1669.0,644.0,1382.0,600.0,1500000000,0.0011536218225955,1082014363648.0,0.0147741268298766,0.0728620625307479,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

int cmp_char(const void* a, const void* b) {
    if (*(char*)a > *(char*)b)
        return -1;
    else if (*(char*)a < *(char*)b)
        return 1;

    return 0;
}

char* sortTheInnerContent(const char* words, int length) {
    char* result = malloc(length);
    strcpy(result, """");

    char buff[length];
    strcpy(buff, words);

    char other_buff[length];
    strcpy(other_buff, "" "");

    char* word = strtok(buff, "" "");
    while (word != NULL) {
        if (strlen(word) <= 3) {
            strcat(result, word);
            strcat(result, "" "");
            word = strtok(NULL, "" "");
            continue;
        }

        strncat(result, &word[0], 1);
        strcpy(other_buff, word+1);
        other_buff[strlen(other_buff)-1] = '\0';

        qsort(other_buff, strlen(other_buff), sizeof(char), cmp_char);
        strcat(result, other_buff);

        strncat(result, &word[strlen(word)-1], 1);
        strcat(result, "" "");

        word = strtok(NULL, "" "");
    }

    return result;
}

void assertString(char* actual, char* expected, int length) {
  printf(""\nYour result:     %s\nExpected result: %s\n"", actual, expected);

  for(int i=0;i<length;i++) {
    if(actual[i] != expected[i])
        assert(actual[i] == expected[i]);
  }
}

int main() {
    char* words1 = ""sort the inner content in descending order"";
    char* expected1 = ""srot the inner ctonnet in dsnnieedcg oredr"";
    assertString(sortTheInnerContent(words1, strlen(words1)),
                 expected1, strlen(words1));

    char* words2 = ""wait for me"";
    char* expected2 = ""wiat for me"";
    assertString(sortTheInnerContent(words2, strlen(words2)),
                 expected2, strlen(words2));

    char* words3 = ""this kata is easy"";
    char* expected3 = ""tihs ktaa is esay"";
    assertString(sortTheInnerContent(words3, strlen(words3)),
                 expected3, strlen(words3));

    return 0;
}
"
185-30297,ODyckhoff/C-Util,misc/progbar.c,30,3,20,2672899.5144366003,5042915.0,0.5297251688755412,2159.0,1494.0,695366.0,100029.0,1689.0,648.0,1390.0,604.0,1500000000,0.0017819330096244,1082014363648.0,0.0007243826239387,0.0054450933184141,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int main ( int argc, char **argv ) {
    unsigned int a = 1;
    double pc = 0;
    int items = 100;
    int i,j = 0;
    char *str = malloc( 256 );
    char tmp[100];

    if( argc == 2 ) items = atoi( argv[1] );

    if( str == NULL ) return EXIT_FAILURE;

    for ( i = 0; i <= items; i++ ) {
        memset( str, 0, 256 );
        strcpy( str, ""["" );
        pc = (((double)i)/items)*100;
        while( (int)pc-- ) {
            strcat( str, ""="" );
        }
        strcat( str, "">"" );
        pc = 100 - (((double)i)/items)*100;
        while( (int)pc-- ) {
            strcat( str, "" "" );
        }
        sprintf( tmp, ""] %g%%"", (((double)i)/items)*100 );
        strcat( str, tmp );
        printf( ""\r%s"", str );
        fflush( stdout );
    }

    printf( ""\n"" );
    free( str );

    return EXIT_SUCCESS;
}

"
070-10036,AllenCompSci/Hacktoberfest,HelloWorld/HelloWorld.c,41,1,36,1875544.43255055,175084.0,10.712252404560097,1325.0,1306.0,39646.0,13609.0,1618.0,640.0,1340.0,596.0,1500000000,0.0012503629550337,1082014363648.0,0.0150270727193804,0.0787531687165524,"#include <stdio.h>
#include <stdlib.h>

void add_entry(char *, char *);
void populate_census();

struct census_entry {
   char * fullName;
   char * githubUsername;
   struct census_entry * next;
};

typedef struct census_entry CensusEntry_t;

static CensusEntry_t * head = NULL;
static CensusEntry_t * tail = NULL;

void populate_census() {
   /*
    * ADD YOURSELF HERE!
    *
    * Add yourself using the following format:
    *    add_entry(""Your Name"", ""github_username"");
    */
   add_entry(""Allen Comp Sci"", ""AllenCompSci"");
   add_entry(""Maxwell Cody"", ""MaxwellCody"");
}

int main(int argc, char * argv[]) {
   populate_census();

   for(CensusEntry_t * current = head; current != NULL; current = current->next) {
      printf(""Hello World from %s @ https://github.com/%s\n"", current->fullName, current->githubUsername);
   }

   return EXIT_SUCCESS;
}

void add_entry(char * fullName, char * githubUsername) {
   CensusEntry_t * entry = malloc(sizeof(CensusEntry_t));
   entry->fullName = fullName;
   entry->githubUsername = githubUsername;
   entry->next = NULL;

   // If one of these conditions is true, then they both should be
   // we're checking both just to be sure.
   if(head == NULL || tail == NULL) {
      head = entry;
   } else {
      tail->next = entry;
   }
   tail = entry;
}
"
315-11257,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.compile/compile-tls.c,28,1,22,1595193.17094225,170187.0,9.37317773978036,1138.0,1131.0,38716.0,12802.0,1576.0,592.0,1321.0,550.0,1500000000,0.0010634621139615,1082014363648.0,0.0133323931910192,0.0783997826002562,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <pthread.h>

__thread int global_scope;

static __thread int static_scope;

int foo ()
{
  /* Ensure we link against pthreads even with --as-needed.  */
  pthread_testcancel();
  return 27;
}

int
main (void)
{
  static __thread int local_scope;

  /* break-here */
  foo ();

  return 0;
}
"
232-1887,JasonVann/ComputerArchitecture,CS61C/L4/HeapPointer.c,20,2,15,1573293.00418485,169989.0,9.25526357587844,1146.0,1138.0,38662.0,12779.0,1570.0,589.0,1318.0,547.0,1500000000,0.0010488620027899,1082014363648.0,0.0134361635164628,0.0782255399389592,"#include <stdio.h>
#include <stdlib.h>

typedef struct { 
    int year_planted;
    // ... kind, cost, ...
} Tree;

Tree* plant_tree(int year) {
    Tree* tn = malloc(sizeof(Tree));
    tn->year_planted = year;
    return tn;
}

int main(void) {
    const int ORCHARD = 100;
    // lets grow some apple trees ...
    Tree* apples[ORCHARD];
    for (int i=0;  i<ORCHARD;  i++)
        apples[i]= plant_tree(2014);
    
    // apples don't sell ... let's try pears
    Tree* pears[ORCHARD];
    for (int i=0;  i<ORCHARD;  i++)
        pears[i]= plant_tree(2016);
}

"
203-27037,lmokto/ilovec,estructuras_uniones/enum2.c,37,1,24,1924682.9906478,176738.0,10.89002930892055,1338.0,1319.0,39972.0,13863.0,1618.0,636.0,1340.0,593.0,1500000000,0.0012831219937652,1082014363648.0,0.0150335524901266,0.0777746818983932,"/*
 *      Enum2.c
 *      
 *      Julio César Brizuela <brizuelaalvarado@gmail.com> 2009
 * 
 *      para el wikilibro ""Programación en C (fundamentos)""
 *      bajo licencia FDL, adaptado del Dominio Público
  
  A los enumeradores se pueden asignar valores o expresiones constantes durante la declaracion:


        enum Hexaedro
        {
                VERTICE = 8,
                LADOS = 12,
                CARAS = 6
        };

 */
 
#include <stdio.h>
 
enum DiasSemanas
{
        Domingo = 2,
        Lunes,
        Marte,
        Miercoles,
        Jueves,
        Viernes,
        Sabado
};
/* Podemos inicializar nuestra primer constante Domingo 
 * en 2, asi pues las demas los siguientes valores enteros.
 */
 
int main(int argc, char** argv)
{
 
        enum DiasSemanas dia;
 
        for (dia = Domingo; dia <= Sabado; dia++)
        {
                printf(""%d "", dia); /* Salida: 2 3 4 5 6 7 8 */
        }
 
        return 0;
}"
298-20140,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.btrace/multi-thread-step.c,35,1,24,1718402.95661235,178407.0,9.544053764706542,1384.0,1357.0,40698.0,13990.0,1647.0,661.0,1365.0,616.0,1500000000,0.0011456019710749,1082014363648.0,0.0153637469381806,0.0784267115272089,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2013-2015 Free Software Foundation, Inc.

   Contributed by Intel Corp. <markus.t.metzger@intel.com>

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <pthread.h>

static pthread_barrier_t barrier;
static int global;

static void *
test (void *arg)
{
  pthread_barrier_wait (&barrier);

  global = 42; /* bp.1 */

  pthread_barrier_wait (&barrier);

  global = 42; /* bp.2 */

  return arg;
}

int
main (void)
{
  pthread_t th;

  pthread_barrier_init (&barrier, NULL, 2);
  pthread_create (&th, NULL, test, NULL);

  test (NULL);

  pthread_join (th, NULL);
  pthread_barrier_destroy (&barrier);

  return 0; /* bp.3 */
}
"
303-4055,ColinIanKing/stress-ng,test/test-atomic_add_fetch.c,25,1,26,1771639.21762245,170439.0,10.394563450853385,1145.0,1137.0,38727.0,12788.0,1581.0,586.0,1326.0,544.0,1500000000,0.0011810928117483,1082014363648.0,0.0133889544059751,0.0783655246044841,"/*
 * Copyright (C) 2017-2021 Canonical, Ltd.
 * Copyright (C)      2022 Colin Ian King
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 */

int main(int argc, char **argv)
{
	int var;

	__atomic_add_fetch(&var, 1, 0);

	return 0;
}

"
329-33038,CajetanP/coding-exercises,CodeWars/Algorithms/EqualSidesOfAnArray/EqualSidesOfAnArray.c,63,2,28,1770348.0552880499,172203.0,10.280587446211738,1156.0,1148.0,39095.0,12903.0,1587.0,585.0,1330.0,544.0,1500000000,0.0011802320368587,1082014363648.0,0.0133795578474242,0.0778106850263471,"#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

int sum_subarr(const int* arr, int from, int to) {
    int sum = 0;

    for (int i = from ; i < to ; ++i)
        sum += arr[i];

    return sum;
}

int find_even_index(const int *values, int length) {

    for (int i = 0 ; i < length ; ++i) {
        if (sum_subarr(values, 0, i) == sum_subarr(values, i+1, length))
            return i;
    }

    return -1;
}

int main() {
    {
        int arr[] = { 1,2,3,4,3,2,1 };
        int expected = 3;
        int result = find_even_index(arr, (int)(sizeof(arr)/sizeof(arr[0])));
        assert(expected == result);
    }

    {
        int arr[] = { 1,100,50,-51,1,1 };
        int expected = 1;
        int result = find_even_index(arr, (int)(sizeof(arr)/sizeof(arr[0])));
        assert(expected == result);
    }

    {
        int arr[] = { 1,2,3,4,5,6 };
        int expected = -1;
        int result = find_even_index(arr, (int)(sizeof(arr)/sizeof(arr[0])));
        assert(expected == result);
    }

    {
        int arr[] = { 20,10,30,10,10,15,35 };
        int expected = 3;
        int result = find_even_index(arr, (int)(sizeof(arr)/sizeof(arr[0])));
        assert(expected == result);
    }

    {
        int arr[] = { 20,10,-80,10,10,15,35 };
        int expected = 0;
        int result = find_even_index(arr, (int)(sizeof(arr)/sizeof(arr[0])));
        assert(expected == result);
    }

    {
        int arr[] = { 10,-80,10,10,15,35,20 };
        int expected = 6;
        int result = find_even_index(arr, (int)(sizeof(arr)/sizeof(arr[0])));
        assert(expected == result);
    }

    {
        int arr[] = { 0,0,0,0,0 };
        int expected = 0;
        int result = find_even_index(arr, (int)(sizeof(arr)/sizeof(arr[0])));
        assert(expected == result);
    }

    {
        int arr[] = { -1,-2,-3,-4,-3,-2,-1 };
        int expected = 3;
        int result = find_even_index(arr, (int)(sizeof(arr)/sizeof(arr[0])));
        assert(expected == result);
    }
}
"
268-32854,duythanhphan/glibc,wctype/test_wcfuncs.c,72,4,53,2201329.45105425,184315.0,11.943298158044652,1299.0,1282.0,42826.0,13995.0,1646.0,638.0,1366.0,593.0,1500000000,0.0014675529673695,1082014363648.0,0.0140032010416949,0.0746730962144277,"/* Copyright (C) 1999-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#include <stdio.h>
#include <stdlib.h>
#include <wctype.h>

int
main (int argc, char *argv[])
{
  int result = 0;
  wint_t ch;


  for (ch = 0; ch < 128; ++ch)
    {
      if (iswlower (ch))
	{
	  /* Get corresponding upper case character.  */
	  wint_t up = towupper (ch);
	  /* This should have no effect.  */
	  wint_t low  = towlower (ch);

	  if ((ch != low) || (up == ch) || (up == low))
	    {
	      printf (""iswlower/towupper/towlower for character \\%x failed\n"", ch);
	      result++;
	    }
	}
      if (iswupper (ch))
	{
	  /* Get corresponding lower case character.  */
	  wint_t low = towlower (ch);
	  /* This should have no effect.  */
	  wint_t up  = towupper (ch);

	  if ((ch != up) || (low == ch) || (up == low))
	    {
	      printf (""iswupper/towlower/towupper for character \\%x failed\n"", ch);
	      result++;
	    }
	}
    }

  /* Finally some specific tests.  */
  ch = L'A';
  if (!iswupper (ch) || iswlower (ch))
    {
      printf (""!iswupper/iswlower (L'A') failed\n"");
      result++;

    }
  ch = L'a';
  if (iswupper (ch) || !iswlower (ch))
    {
      printf (""iswupper/!iswlower (L'a') failed\n"");
      result++;
    }
  if (towlower (L'A') != L'a')
    {
      printf (""towlower(L'A') failed\n"");
      result++;
    }
  if (towupper (L'a') != L'A')
    {
      printf (""towupper(L'a') failed\n"");
      result++;
    }

  if (result == 0)
    puts (""All test successful!"");
  return result != 0;
}
"
039-32001,mattstock/binutils-bexkat1,gdb/testsuite/gdb.base/float128.c,23,1,17,1406957.97745125,169061.0,8.322185483346248,1139.0,1129.0,38454.0,12698.0,1569.0,586.0,1318.0,547.0,1500000000,0.0009379719849675,1082014363648.0,0.0134152761429306,0.0785893024710666,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2016-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <stdio.h>
#include <stdlib.h>

long double ld;
__float128 f128;

// Test largest IEEE-128 value.  This has to be supported since the
// __float128 data type by definition is encoded as IEEE-128.
__float128 large128 = 1.18973149535723176508575932662800702e+4932q;

int main()
{
  ld = 1.375l;
  f128 = 2.375q;

  return 0;
}
"
158-6935,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.base/watchpoint-delete.c,25,1,19,1519592.94453255,169068.0,8.988052144699175,1140.0,1130.0,38454.0,12699.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010130619630217,1082014363648.0,0.0134265502637991,0.0785486677223232,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2010-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

void
func (void)
{
  volatile int x = 0;

  x++;	/* break-here */
  x++;
}

int
main (void)
{
  func ();

  return 0;
}
"
275-15430,mcallinder/BuzzFizz,simpleVersion.c,109,7,73,370725677.81433463,919596001.0,0.4029760488269022,1368.0,1346.0,77862.0,39352.0,1628.0,682.0,1348.0,639.0,1500000000,0.2471504518762231,1082014363648.0,2.951296000688024e-06,0.0366594434111966,"#include <stdio.h>

#define DEBUG 1

#define UINT64_MAX 18446744073709551615ULL

void fibonacciBuzzFizz( int );
int isPrime( unsigned long long );

/*
 *  This program is a simple FizzBuzz variation which prints ""Buzz"", ""Fizz"",
 *  or ""BuzzFizz"" based on Fibonacci numbers.
 *
 *  The Fibonacci terms are calculated from 0. So, f(0) = 0, f(7) = 13, etc.
 *  The output will match the list found at:
 *      http://www.miniwebtool.com/list-of-fibonacci-numbers/?number=100
 *
 *  A more elaborate version of this program, which includes user input, unit
 *  tests, and Doxygen documentation, can be found at:
 *      https://github.com/mcallinder/BuzzFizz
 */
int main(int argc, char *argv[])
{
    fibonacciBuzzFizz( 100 );
    
    return 0;
}

/*
 *  The function fibonacciBuzzFizz calculates the nth Fibonacci term in a 
 *  typically iterative fashion. As it iterates, each term is checked for 
 *  primality and then for divisibility by 3 or 5. If the term is prime, 
 *  ""BuzzFizz"" will be printed. If the term is divisible by 3, ""Buzz"" will be
 *  printed. If the term is divisible by 5, ""Fizz"" will be printed. It should
 *  be noted that ""BuzzFizz"" will only print once. If a number is prime it will
 *  effectively ignore the divisibility. If none of these checks return true, 
 *  the Fibonacci term itself will be printed.
 *  
 *  Iteration was chosen over recursion since it is faster for higher numbers.
 *  Still, this function will only work for Fibonacci terms less than f(94).
 *  Larger numbers will cause overflow in the unsigned long long variable which
 *  stores them. In these cases, a message stating such will be printed.
 */
void fibonacciBuzzFizz( int n )
{
    int i;
    int prime;
    unsigned long long first = 0;
    unsigned long long second = 1;
    unsigned long long fibonacci = 0;
    
    for ( i = 0; i <= n; i++ )
    {
        if ( second > UINT64_MAX - first )
        {
            printf( ""f(%d) too big for unsigned long long. Stopping.\n"", i );
            return;
        }
        else
        {
            if ( i < 2 )
            {
               fibonacci = i;
            }
            else
            {
                fibonacci = first + second;
                first = second;
                second = fibonacci;
            }
            
            prime = isPrime( fibonacci );
            
#if DEBUG
            printf( ""f(%d) = %llu%s : "", 
                   i, fibonacci, (prime ? "", prime"" : """" ));
#endif
            
            if ( prime || fibonacci % 3 == 0)
            {
                printf( ""Buzz"" );
            }
            
            if ( prime || fibonacci % 5 == 0)
            {
                printf( ""Fizz"" );
            }
            
            if ( !prime && fibonacci % 3 && fibonacci % 5 )
            {
                printf( ""%llu"", fibonacci );
            }
            
            printf( ""\n"" );

        }
    }
}

/*
 *  The function isPrime takes advantage of the fact that all primes greater than
 *  3 follow the form 6k−1 or 6k+1, where k is a natural number. It is sufficient 
 *  only to check up to the number's square root as every composite number N has 
 *  a prime factor at most equal to sqrt(N). If no factors are detected up to this
 *  point then N itself must be prime.
 */
int isPrime( unsigned long long num ) 
{
    unsigned long i;
    
    if ( num == 2 || num == 3 )
    {
        return 1;
    }
    else if ( num <= 1 || num % 2 == 0 || num % 3 == 0 )
    {
        return 0;
    }
    else
    {
        for ( i = 5; i * i <= num; i += 6 )
        {
            if ( num % i == 0 || num % ( i + 2 ) == 0 )
            {
                return 0;
            }
        }
    }
    
    return 1;
}
"
195-3921,Stevendeo/Pilat,tests/pilat/test_tableau.c,20,3,13,2168181.11948655,179473.0,12.080819956205112,1341.0,1321.0,40617.0,14257.0,1626.0,637.0,1344.0,594.0,1500000000,0.0014454540796577,1082014363648.0,0.014832314609997,0.076557203775923,"#include <stdio.h>

int main(){
  int N = 10, t[N];
  int i=0;
  
  while (i<N){
    t[i] = 0;
    i++;
  } 

  i=0;
  while (i<N){
    t[i] = t[N-i-1];
    t[N-i-1]++;
    i++;
  } 
  
  i=0;
  while(i<10){
    printf(""%i\n"", t[i]);
    i++;
  } 
  return 0;
}

"
226-8784,luoxn28/ThinkInTechnology,Linux/thread/three_thread_print_abc.c,49,1,41,3246748561.738059,3190384992.0,1.0176666982641072,1541.0,1505.0,245443149.0,16009.0,1672.0,788.0,1377.0,745.0,1500000000,2.164499041158706,1082014363648.0,9.547437088746186e-07,1.866705661884492e-05,"/**
 * Three three print a/b/c in order.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

typedef struct ThreadInfo_t
{
	char info; /* 'A' or 'B' or 'C' */
	int  n;    /* remainder num */
	int  num;  /* share num */
	pthread_mutex_t mutex;
}ThreadInfo;

void *func(void *arg)
{
	int cnt = 3;
	ThreadInfo *info = (ThreadInfo *)arg;
	int  result = info->n;
	char show   = info->info;

	while (cnt > 0) {
		if (info->num % 3 == result) {
			printf(""---%c\n"", show);

			pthread_mutex_lock(&info->mutex);
			info->num++;
			cnt--;
			pthread_mutex_unlock(&info->mutex);
		}
	}

	return NULL;
}

int main(int argc, char **argv)
{
	pthread_t t1, t2, t3;
	ThreadInfo info;

	memset(&info, 0, sizeof(ThreadInfo));
	pthread_mutex_init(&(info.mutex), NULL);

	info.n = 0;
	info.info = 'A';
	pthread_create(&t1, NULL, func, &info);
	sleep(1);

	info.n = 1;
	info.info = 'B';
	pthread_create(&t2, NULL, func, &info);
	sleep(1);

	info.n = 2;
	info.info = 'C';
	pthread_create(&t3, NULL, func, &info);

	pthread_join(t1, NULL);
	pthread_join(t2, NULL);
	pthread_join(t3, NULL);

	return 0;
}
"
347-25221,robert-abela/llp2,week09/intro/thread_multiple_params_example.c,22,1,19,7518612745.217979,181619.0,41397.72130118545,1497.0,1462.0,41423.0,14597.0,1660.0,668.0,1367.0,628.0,1500000000,5.012408496811986,1082014363648.0,0.016292348267527,0.0771688682613352,"#include <stdio.h>
#include <unistd.h> /* sleep */
#include <pthread.h>

struct thread_arg {
	char *msg;
	int reps;
};

void* print_msg(void *ptr) {
	sleep(5); // seconds
	struct thread_arg* pargs = (struct thread_arg*)ptr;
	for (int i = 0; i < pargs->reps; i++)
		printf(""Message from thread: %s \n"", pargs->msg);
	return NULL;
}

int main(void) {
	pthread_t t1;
	
	struct thread_arg args;
	args.msg = ""My msg"";
	args.reps = 5;

	int r1 = pthread_create(&t1, NULL, print_msg, &args);
	printf(""Thread 1 %s\n"", r1 == 0 ? ""created"" : ""failed"");
	
	// Wait till threads are complete.
	pthread_join(t1, NULL);

	return 0;
}
"
158-27124,a1lu/challenges,multiply/multiply.c,30,2,26,2309254.4870451,200142.0,11.538077964645105,1372.0,1352.0,45836.0,15825.0,1644.0,649.0,1361.0,605.0,1500000000,0.0015395029913634,1082014363648.0,0.0136103366609707,0.0690712119492061,"#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

#define DIGITS 100

int main()
{
    char n1[DIGITS+1]={};
    char n2[DIGITS+1]={};
    char m[DIGITS +2]={};
    time_t t;
    int e=0;
    int k=DIGITS;
    int r=0;
    time(&t);
    srand((unsigned int) t);
    memset(m,0x20,DIGITS+1);
    for(int i=0; i<DIGITS; i++)
    {
        n1[i]=(rand()%9)+0x30;
        n2[i]=(rand()%9)+0x30;
    }
    for(int i=DIGITS-1; i>=0; i--)
    {
        int a=n1[i]-0x30, b=n2[i]-0x30;
        int multi=a*b+r;
        e=multi % 10;
        r=multi/10;
        m[k]=e+0x30;
        --k;
        
    }
    if(r)
        m[k]=r+0x30;
    printf(""%101s\n%101s\n%101s\n"",n1,n2,m);
}
"
130-27133,ColinIanKing/stress-ng,test/test-clearenv.c,23,1,24,1835807.9250901497,169943.0,10.802486716134233,1141.0,1133.0,38669.0,12781.0,1574.0,589.0,1319.0,547.0,1500000000,0.0012238719500601,1082014363648.0,0.0133809571444543,0.0783090379008746,"/*
 * Copyright (C) 2013-2021 Canonical, Ltd.
 * Copyright (C)      2022 Colin Ian King
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 */

#include <stdlib.h>

int main(void)
{
	return clearenv();
}
"
052-10151,dk00/old-stuff,csie/13parllel-programming/omp3-3.c,33,8,24,462920740.4796034,950293780.0,0.4871343470226649,1349.0,1326.0,50039313.0,50013402.0,3126699.0,3125673.0,1340.0,3125593.0,1500000000,0.3086138269864023,1082014363648.0,2.814918982212006e-06,0.0937436330438409,"#include<stdio.h>

#ifndef N
#define N 5000
#endif
#define M 1000000000

int a[N][N], b[N][N];

int main() {
  int i, j, sum;
  #pragma omp parallel sections
  {
    #pragma omp section
    {
      int i, j;
      for (i = 0; i < N; i++)
        for (j = 0; j < N; j++)
          a[i][j] = i + j;
    }
    #pragma omp section
    {
      int i, j;
      for (i = 0; i < N; i++)
        for (j = 0; j < N; j++)
          b[i][j] = i - j;
    }
  }
  sum = 0;
  for (i = 0; i < N; i++)
    for (j = 0; j < N; j++) {
      sum += a[i][j];
      sum %= M;
    }
  printf(""%d\n"", sum);
  sum = 0;
  for (i = 0; i < N; i++)
    for (j = 0; j < N; j++) {
      sum += b[i][j];
      sum %= M;
    }
  printf(""%d\n"", sum);
  return 0;
}

"
014-5010,ColinIanKing/stress-ng,test/test-atomic_store.c,24,1,25,1792322.96068215,170400.0,10.518321596244132,1142.0,1134.0,38716.0,12789.0,1581.0,590.0,1325.0,547.0,1500000000,0.0011948819737881,1082014363648.0,0.013356807511737,0.0784972332783224,"/*
 * Copyright (C) 2021-2022 Colin Ian King
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 */

int main(int argc, char **argv)
{
	int val = 1, var;

	__atomic_store(&var, &val, 0);

	return 0;
}

"
387-11443,florianm93/studium,its/ue06.05/main.c,31,2,30,24798775194.212795,193264.0,128315.54347421144,1361.0,1339.0,43806.0,15323.0,1636.0,642.0,1354.0,599.0,1500000000,16.532516796141863,1082014363648.0,0.0139705273615365,0.0715554127416327,"/*
 Berechnung von Pi als Monte-Carlo Algorithmus mit Pseudozufallszahlen
 Florian Macherey
 IT-Systeme, SoSe 2015
 
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

int main(void) {
    double pi;
    unsigned long i,j,k;
    unsigned long n[] = {100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000};
    double x = 0.0;
    double y = 0.0;
    srand(time(0));
    clock_t begin, end;
    double time_spent;

    for(j=0; j<sizeof(n)/sizeof(n[0]); ++j) {
        i=0;
        begin = clock();
        for (k=0; k<n[j]; ++k) {
            x = ((double)rand()+1) / (double)RAND_MAX;
            y = ((double)rand()+1) / (double)RAND_MAX;
            if ((x*x + y*y) <= 1.0) {
                ++i;
            }
            
        }
        pi = i/((double)n[j]) * 4;
        
        end = clock();
        time_spent = (double)(end - begin) / CLOCKS_PER_SEC;
        printf(""Iterationen %10ld Werte: Pi: %f, berechneter Wert: %f, Differenz: %e, Laufzeit: %2.8f\n"", n[j], M_PI, pi, fabs(M_PI-pi), time_spent);
    }

    return 0;
}
"
095-25686,chrysanth/problem_solving,valladolid/Codes/136.c,27,1,26,2037672823.4114125,11036371256.0,0.1846325006412053,1342.0,1335.0,630679311.0,859976872.0,13885781.0,13437587.0,6546211.0,13437547.0,1500000000,1.3584485489409417,1082014363648.0,2.425616117747607e-07,0.0317357728358209,"/* @JUDGE_ID: andrea 136 C ""Dynamic Programming"" */
/* @BEGIN_OF_SOURCE_CODE */
#include <stdio.h>
#include <stdlib.h>

#define TARGET_NUM	1500
#define MAX_ARRAY	1 << 30 

int main()
{
	char* 			check;
	unsigned long	i, j;
	int				count;

	check = (char*)malloc(MAX_ARRAY * sizeof(char));

	i = 1; 
	check[1] = 1;
	count = 1;

	while (count < TARGET_NUM) {
		i++;
		if (!(i%2)) 
			check[i] = check[i/2];
		else if (!(i%3)) 
			check[i] = check[i/3];
		else if (!(i%5))
			check[i] = check[i/5];
		else 
			check[i] = 0;	
		count += check[i];
	} 	

	printf(""The %d'th ugly number is %d.\n"",TARGET_NUM, i);

	return 0;
}
/* @END_OF_SOURCE_CODE */
"
208-29823,SanDisk-Open-Source/SSD_Dashboard,uefi/gcc/gcc-4.6.3/gcc/testsuite/gcc.c-torture/execute/20020402-3.c,65,2,30,1527994.4054780998,170446.0,8.964680896002253,1146.0,1138.0,38723.0,12805.0,1581.0,590.0,1325.0,547.0,1500000000,0.0010186629369854,1082014363648.0,0.0134001384602748,0.078462195311287,"/* extracted from gdb sources */

typedef unsigned long long CORE_ADDR;

struct blockvector;

struct symtab {
  struct blockvector *blockvector;
};

struct sec {
  void *unused;
};

struct symbol {
  int len;
  char *name;
};

struct block {
	CORE_ADDR startaddr, endaddr;
	struct symbol *function;
	struct block *superblock;
	unsigned char gcc_compile_flag;
	int nsyms;
	struct symbol syms[1];
};

struct blockvector {
	int nblocks;
	struct block *block[2];
};

struct blockvector *blockvector_for_pc_sect(register CORE_ADDR pc,
					    struct symtab *symtab)
{
  register struct block *b;
  register int bot, top, half;
  struct blockvector *bl;

  bl = symtab->blockvector;
  b = bl->block[0];

  bot = 0;
  top = bl->nblocks;

  while (top - bot > 1)
    {
      half = (top - bot + 1) >> 1;
      b = bl->block[bot + half];
      if (b->startaddr <= pc)
	bot += half;
      else
	top = bot + half;
    }

  while (bot >= 0)
    {
      b = bl->block[bot];
      if (b->endaddr > pc)
	{
	  return bl;
	}
      bot--;
    }
  return 0;
}

int main(void)
{
  struct block a = { 0, 0x10000, 0, 0, 1, 20 };
  struct block b = { 0x10000, 0x20000, 0, 0, 1, 20 };
  struct blockvector bv = { 2, { &a, &b } };
  struct symtab s = { &bv };

  struct blockvector *ret;

  ret = blockvector_for_pc_sect(0x500, &s);

  return 0;
}
"
019-33804,ChalkPE/Coin,sspark/2016/06/p1081.c,7,2,18,1852563.0002841,195476.0,9.477189015531318,1359.0,1336.0,43672.0,16115.0,1628.0,638.0,1349.0,596.0,1500000000,0.0012350420001894,1082014363648.0,0.0137868587448075,0.0704333718032348,"/**
 * @author ChalkPE <chalk@chalk.pe>
 * @since 2016-06-09
 */

#include <stdio.h>

int main(){
    int i, j; for(i = 2; i <= 4; printf(""\n""), i++) for(j = 1; j <= 5; j++) printf(""%d * %d = %2d   "", i, j, i * j);
}"
346-28768,wginolas/playground,euler/p24.c,70,11,41,407193200.7791474,1492490055.0,0.2728280825965035,1320.0,1300.0,272333570.0,103497973.0,1606.0,697.0,1334.0,656.0,1500000000,0.2714621338527649,1082014363648.0,1.755455583253451e-06,1.1422670821432357e-05,"/*
A permutation is an ordered arrangement of objects. For example, 3124 is one possible permutation of the digits 1, 2, 3 and 4. If all of the permutations are listed numerically or alphabetically, we call it lexicographic order. The lexicographic permutations of 0, 1 and 2 are:

012   021   102   120   201   210

What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9?
*/

#include <string.h>
#include <stdio.h>
#include <stdlib.h>

void set_space(char* s, int p, char c) {
  while (*s!=0 && (p>0 || *s!=' ')) {
    if (*s==' ') {
      p--;
    }
    s++;
  }

  if (*s!=0) {
    *s = c;
  }
}

void clear(char* s, char c) {
  while (*s!=0 && *s!=c) {
    s++;
  }

  if (*s==c) {
    *s = ' ';
  }
}

int main() {
  char* s;
  int i0, i1, i2, i3, i4, i5, i6, i7, i8;
  
  s = malloc(11);
  strcpy(s, ""          "");
  
  for(i0=0; i0<10; i0++) {
    set_space(s, i0, '0');
    for(i1=0; i1<9; i1++) {
      set_space(s, i1, '1');
      for(i2=0; i2<8; i2++) {
        set_space(s, i2, '2');
        for(i3=0; i3<7; i3++) {
          set_space(s, i3, '3');
          for(i4=0; i4<6; i4++) {
            set_space(s, i4, '4');
            for(i5=0; i5<5; i5++) {
              set_space(s, i5, '5');
              for(i6=0; i6<4; i6++) {
                set_space(s, i6, '6');
                for(i7=0; i7<3; i7++) {
                  set_space(s, i7, '7');
                  for(i8=0; i8<2; i8++) {
                    set_space(s, i8, '8');
                    set_space(s, 0, '9');
                    printf(""%s\n"", s);
                    clear(s, '8');
                    clear(s, '9');
                  }
                  clear(s, '7');
                }
                clear(s, '6');
              }
              clear(s, '5');
            }
            clear(s, '4');
          }
          clear(s, '3');
        }
        clear(s, '2');
      }
      clear(s, '1');
    }
    clear(s, '0');
  }
  return 0;
}
"
182-31737,goblint/analyzer,tests/regression/31-ikind-aware-ints/14-enums-large.c,19,2,21,2164472.8258251,169061.0,12.802905460159351,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0014429818838834,1082014363648.0,0.0134152761429306,0.0785563462891999,"//PARAM: --disable ana.int.interval --disable ana.int.def_exc --enable ana.int.enums
#include <assert.h>

int main(){
    int a = 0;

    // maximum value for ulonglong
    unsigned long long x = 18446744073709551615ull;
    if(x > 18446744073709551612ull){
        a = 1;
    }
    assert(a);

    unsigned long long y = x + 4;
    assert(y == 3);

    // maximum value for long long
    signed long long s = 9223372036854775807;
    assert(s > 9223372036854775806);

    signed long long t = s + 2;
    // Signed overflow -- The following assertion must be UNKNOWN!
    assert(t == -9223372036854775807); // UNKNOWN!

    return 0;
}
"
392-34148,Gurgel100/gcc,gcc/testsuite/c-c++-common/ubsan/pr71403-1.c,26,2,19,1701932.8661262,169995.0,10.011659166446073,1146.0,1137.0,38670.0,12782.0,1577.0,586.0,1324.0,546.0,1500000000,0.0011346219107508,1082014363648.0,0.0134298067590223,0.0783837362979087,"/* { dg-do run } */
/* { dg-additional-options ""-fsanitize=unreachable"" } */

char a = -97;
int b, c, d, e;

int
main ()
{
  int g = d, h = 0, i = 1; 
  for (; h < 3; h++)
    {
      if (g > -1)
        {
          int j;
          g = j = 0;
          for (; j < 5; j++)
          L1:
            if (!i)
              goto L1;
          a = e;
        }
      else
        i = 0;
    }
  b = c / ~(a | 114);
  __builtin_exit (0);
}
"
154-571,SCST-CS510-Fall2015/CExercises,Structs/structs.c,66,2,47,1677650.84188425,195443.0,8.58383262639235,1418.0,1397.0,43823.0,16279.0,1643.0,642.0,1357.0,599.0,1500000000,0.0011184338945895,1082014363648.0,0.0144031763736741,0.0705633755948221,"#include <stdio.h>

/* These type declarations would be better in a header file.
   They are included in the source only for simplicity here. */

struct vec3 {
    long double x;
    long double y;
    long double z;
};
// alias the type ""VEC3"" to mean ""struct vec3""
typedef struct vec3 VEC3;

// declare and alias a new struct type ""struct vec2"" as ""VEC2""
typedef struct vec2 {
    long double x;
    long double y;
} VEC2;

void printVec3(VEC3 v);
VEC3 modifyVec3(VEC3 v, long double x, long double y, long double z);
void setVec2(VEC2 *wp, long double x, long double y);
void printVec2(VEC2 *wp);

int main(void)
{
    // declare a new struct type called ""struct vec3""
    
    VEC3 v, vprime;
    VEC2 w;
    
    v.x = 0.0;
    v.y = 0.0;
    v.z = 0.0;
    w.x = 0.0;
    w.y = 0.0;
    
    puts(""-----Pass by value test-----"");
    puts(""Original 3 vector:"");
    printVec3(v);
    vprime = modifyVec3(v, 1.0, 2.0, 3.0);
    puts(""Original 3 vector after modification:"");
    printVec3(v);
    puts(""New 3 vector after modification:"");
    printVec3(vprime);
    
    puts(""-----Pass by reference test-----"");
    puts(""Original 2 vector:"");
    printVec2(&w);
    setVec2(&w, 1.0, 2.0);
    puts(""Original 2 vector after modification:"");
    printVec2(&w);

    return 0;
}

void printVec3(VEC3 v)
{
    printf(""3Vector : [%Lf, %Lf, %Lf]\n"", v.x, v.y, v.z);
}

VEC3 modifyVec3(VEC3 v, long double x, long double y, long double z)
{
    v.x = x;
    v.y = y;
    v.z = z;
    return v;
}

void setVec2(VEC2 *wp, long double x, long double y)
{
    // Dereference the pointer, then set its field
    (*wp).x = x;
    // Syntactic sugar for doing the same thing directly
    wp->y = y;
}

void printVec2(VEC2 *wp)
{
    printf(""2Vector : [%Lf, %Lf]\n"", wp->x, wp->y);
}
"
207-7027,cxsjabc/basic,c/_topics/printf/unix2dos.c,99,1,37,1990563.0033462,176808.0,11.258331070992265,1141.0,1131.0,40578.0,13577.0,1623.0,587.0,1364.0,546.0,1500000000,0.0013270420022308,1082014363648.0,0.012850097280666,0.0760779244760409,"/*
   Xi Chen(511272827@qq.com)
   cxsjabcabc
*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>

char *realloc_more(char **pbuf, int new_size) {
	char *temp;
	temp = realloc(*pbuf, new_size);
	if (!temp) {
		printf(""realloc fatal error!\n"");
		return NULL;
	} else {
		*pbuf= temp;
		return temp;
	}
}

void unix2dos(int argc, char *argv[])
{
	char *file;
	FILE *fp;
	char *src;
	char *dest;
	long src_len, dest_len;
	size_t ret;
	int i, j = 0;

	if (argc < 2)
		return;
	
	file = argv[1];
	fp = fopen(file, ""r+"");
	if (!fp) {
		printf(""open file %s error!\n"", file);
		goto error_exit;
	}
	fseek(fp, 0, SEEK_END);
	src_len = ftell(fp);

	src = (char *)malloc(src_len);
	if (!src) {
		printf(""malloc error!\n"");
		goto error_alloc_src;
	}

	dest = (char *)malloc(src_len);
	if (!dest) {
		printf(""malloc dest buf error!\n"");
		goto error_alloc_dest;
	}
	dest_len = src_len;

	fseek(fp, 0, SEEK_SET);
	ret = fread(src, 1, src_len, fp);
	if (ret != src_len) {
		printf(""load file error! ret:%zu\n"", ret);
		goto error_load_file;
	}

	for (i = 0; i < src_len; ++i) {
		if (src[i] != '\n') {
			if (j == dest_len) {
				char *temp = realloc_more(&dest, dest_len * 2);
				if (!temp)
					goto error_load_file;
				else {
					dest = temp;
					dest_len *= 2;
				}
			}
			dest[j++] = src[i];
		}
		else {
			if (j == dest_len) {
				char *temp = realloc_more(&dest, dest_len * 2);
				if (!temp)
					goto error_load_file;
				else {
					dest = temp;
					dest_len *= 2;
				}
			}
			dest[j++] = '\r';
			dest[j++] = '\n';
		}
	}

	fseek(fp, 0, SEEK_SET);
	ret = fwrite(dest, 1, j, fp);
	if (ret != j) {
		printf(""fwrite dest error!ret:%zu\n"", ret);
		goto error_load_file;
	}
	printf(""unix2dos ok, len:%d!\n"", j);

error_load_file:
	free(dest);
error_alloc_dest:
	free(src);
error_alloc_src:
	fclose(fp);
error_exit:
	return;
}

int main(int argc, char *argv[])
{
	unix2dos(argc, argv);
	return 0;
}
"
223-32251,TextusData/Mover,thirdparty/postgresql-9.0.1/src/test/locale/test-ctype.c,55,2,40,2181112.30060455,1870088.0,1.166315168056263,1566.0,1536.0,373208.0,225556.0,1902.0,794.0,1510.0,740.0,1500000000,0.0014540748670697,1082014363648.0,0.0016587454708013,0.0082603496536197,"/*
 * $PostgreSQL: pgsql/src/test/locale/test-ctype.c,v 1.6 2009/06/11 14:49:15 momjian Exp $
 */

/*

   test-ctype.c

Written by Oleg BroytMann, phd2@earthling.net
   with help from Oleg Bartunov, oleg@sai.msu.su
Copyright (C) 1998 PhiloSoft Design

This is copyrighted but free software. You can use it, modify and distribute
in original or modified form providing that the author's names and the above
copyright notice will remain.

Disclaimer, legal notice and absence of warranty.
   This software provided ""as is"" without any kind of warranty. In no event
the author shall be liable for any damage, etc.

*/

#include <stdio.h>
#include <locale.h>
#include <ctype.h>

char	   *flag(int b);
void		describe_char(int c);

#undef LONG_FLAG

char *
flag(int b)
{
#ifdef LONG_FLAG
	return b ? ""yes"" : ""no"";
#else
	return b ? ""+"" : "" "";
#endif
}

void
describe_char(int c)
{
	unsigned char cp = c,
				up = toupper(c),
				lo = tolower(c);

	if (!isprint(cp))
		cp = ' ';
	if (!isprint(up))
		up = ' ';
	if (!isprint(lo))
		lo = ' ';

	printf(""chr#%-4d%2c%6s%6s%6s%6s%6s%6s%6s%6s%6s%6s%6s%4c%4c\n"", c, cp, flag(isalnum(c)), flag(isalpha(c)), flag(iscntrl(c)), flag(isdigit(c)), flag(islower(c)), flag(isgraph(c)), flag(isprint(c)), flag(ispunct(c)), flag(isspace(c)), flag(isupper(c)), flag(isxdigit(c)), lo, up);
}

int
main()
{
	short		c;
	char	   *cur_locale;

	cur_locale = setlocale(LC_ALL, """");
	if (cur_locale)
		fprintf(stderr, ""Successfulle set locale to %s\n"", cur_locale);
	else
	{
		fprintf(stderr, ""Cannot setup locale. Either your libc does not provide\nlocale support, or your locale data is corrupt, or you have not set\nLANG or LC_CTYPE environment variable to proper value. Program aborted.\n"");
		return 1;
	}

	printf(""char#  char alnum alpha cntrl digit lower graph print punct space upper xdigit lo up\n"");
	for (c = 0; c <= 255; c++)
		describe_char(c);

	return 0;
}
"
156-4171,wtok/project-euler,solutions/c/eul05.c,18,2,17,1256044091.7732193,3795214170.0,0.5349274299321032,1338.0,1319.0,39181.0,13306.0,1618.0,636.0,1340.0,593.0,1500000000,0.8373627278488129,1082014363648.0,7.000922427521396e-07,0.0797721340522415,"/* wtok 2015-09-26 */
/* Find the smallest positive integer that is evenly divisible by all the
 * integers from 1 to 20. */
#include <stdio.h>

int main(void)
{
        const int d_max = 20;

        for (int n = 1;; ++n) {
                for (int d = 1; d <= d_max; ++d) {
                        if (n % d != 0) {
                                break;
                        } else if (d == d_max) {
                                printf(""%d\n"", n);
                                return 0;
                        }
                }
        }

        return 1;
}
"
039-17276,mattstock/binutils-bexkat1,gdb/testsuite/gdb.dwarf2/implref-array.c,20,2,16,1552937.9015787002,169061.0,9.185660796990437,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010352919343858,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* Copyright (C) 2016-2020 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* Test program for synthetic C++ references to arrays.  */

int array[5] = {0, 1, 2, 3, 4};

int
main (void)
{
  asm (""main_label: .globl main_label"");
  return 0;
}
"
265-30827,krichter722/gcc,gcc/testsuite/gcc.dg/ubsan/pr78248.c,28,2,28,1832867.9725527,175506.0,10.443329572778138,1144.0,1134.0,39742.0,13340.0,1569.0,585.0,1318.0,546.0,1500000000,0.0012219119817018,1082014363648.0,0.012979613232596,0.0756942089597226,"/* PR rtl-optimization/78232 */
/* PR rtl-optimization/78248 */
/* { dg-do run } */
/* { dg-options ""-fsanitize=undefined"" } */

static struct S
{
  int f0:15;
} a;

int b[1], c = 2, d, e, f, g;

int main ()
{
  struct S h = { -2 };
  for (; e < 640; e++)
    for (; f < 1; f++)
      {
        if (c < 2)
          {
            d = b[e];
            h = a;
          }
        g = c;
        c = 1;
        if (!h.f0)
          break;
        c = g;
      }
  return 0; 
}
"
303-18780,android-808/maemo-launcher,client/app-console.c,27,1,24,3002568745.636381,173208.0,17335.046562514435,1299.0,1281.0,39268.0,13338.0,1611.0,637.0,1336.0,594.0,1500000000,2.001712497090921,1082014363648.0,0.0148953858944159,0.0794205984108276,"/*
 * Copyright © 2009 Nokia Corporation
 *
 * Author: Guillem Jover <guillem.jover@nokia.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 *
 */

#include <stdio.h>
#include <unistd.h>

int
main(int argc, char *argv[])
{
  puts(""console app startup"");

  sleep(2);

  puts(""console app shutdown"");

  return 0;
}

"
360-29180,zyfjeff/utils_code,str.c,9,1,14,2049677.7724474499,173195.0,11.799324460867808,1284.0,1269.0,39269.0,13310.0,1616.0,634.0,1340.0,592.0,1500000000,0.0013664518482983,1082014363648.0,0.0147406102947544,0.0795374579204625,"/*
 *	字符串相关的实用函数
 */

#include <stdio.h>
static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;} //跳过前面的空白字符 ascii码小于等于32的略过

int main()
{
	char str[] = ""  zhangyifei"";
	printf(""%s\n"",skip(str));
}
"
053-14432,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.python/py-block.c,31,1,22,1650604.5358255499,169057.0,9.763594527289612,1139.0,1129.0,38452.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0011004030238837,1082014363648.0,0.0134155935572026,0.0785172440760147,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2010-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see  <http://www.gnu.org/licenses/>.  */

int block_func (void)
{
  int i = 0;
  {
    double i = 1.0;
    double f = 2.0;
    {
      const char *i = ""stuff"";
      const char *f = ""foo"";
      const char *b = ""bar"";
      return 0; /* Block break here.  */
    }
  }
}


int main (int argc, char *argv[])
{
  block_func ();
  return 0; /* Break at end. */
}
"
255-8775,ro4/C-data-structure,pointer_linklist.c,161,7,63,2064647.8515117,198427.0,10.40507088249079,1364.0,1341.0,44804.0,17124.0,1626.0,649.0,1348.0,604.0,1500000000,0.0013764319010078,1082014363648.0,0.0136322173897705,0.0682566851827929,"/**
Description: C语言指针实现链表
Author: FAN
Date: 2014/4/19
Blog: thefrp.sinaapp.com
ps: 在vs2012正常运行
*/

#include<stdio.h>
#include<stdlib.h>

typedef int ListItem;
typedef struct node *link;
typedef struct node
{
	ListItem element;
	link next;
}Node;


typedef struct llist *List;
typedef struct llist
{
	link first;
}Llist;

link NewNode();//生成新节点

List ListInit();
int ListEmpty(List L);
int ListLength(List L);
ListItem ListRetrieve(int k,List L);
int ListLocate(ListItem x,List L);
void ListInsert(int k,ListItem x,List L);
ListItem ListDelete(int k,List L);
void PrintList(List L);

void Error(char *ch);
void ItemShow(ListItem li);

int main()
{
	int size = 15;
	int i ;
	List L = ListInit();
	for(i=0;i<size;i++)
		ListInsert(i,i+3,L);
	printf(""打印全部元素：\n"");
	PrintList(L);
	printf(""显示第五个元素："");
	ItemShow(ListRetrieve(5,L));
	printf(""删除第五个元素：%d\n"",ListDelete(5,L));
	printf(""打印全部元素：\n"");
	PrintList(L);

	return 0;
}

void Error(char *ch)
{
	printf(""%s\n"",ch );
}

void ItemShow(ListItem li)
{
	printf(""%d\n"",li);
}
link NewNode()
{
	link p;
	if((p=(link)malloc(sizeof (Node)))==0)
		Error(""Exhausted memory"");
	else
		return p;
}

List ListInit()
{
	List L = (List)malloc(sizeof *L);
	L->first = 0;
	return L;
}

int ListEmpty(List L)
{
	return L->first == 0;
}

int ListLength(List L)
{
	int len = 0;
	link p;
	p = L->first;
	while (p)
	{
		len ++;
		p = p->next;
	}
	return len;
}

ListItem ListRetrieve(int k,List L)
{
	if (k<1)
		Error(""out of bounds"");
	int i;
	link p;
	p = L->first;
	i = 1;
	while(i<k && p)
	{
		p = p->next;
		i ++;
	}
	return p->element;
}

int ListLocate(ListItem x,List L)
{
	int i = 1;
	link p;
	p = L->first;
	while(p&&p->element!=x)
	{
		p = p->next;
		i++;
	}
	return i;
}


void ListInsert(int k,ListItem x,List L)
{
	if(k<0)
		Error(""out of bounds"");
	link p,y;
	int i;
	p = L->first;
	for(i = 1;i <k&&p;i++)
		p = p->next;
	y = NewNode();
	y->element = x;
	if(k)
	{
		y->next = p->next;
		p->next = y;
	}
	else
	{
		y->next = L->first;
		L->first = y;
	}
}

ListItem ListDelete(int k, List L)
{
	if (k<1||!L->first)
		Error(""out of bounds"");
	link p,q;
	ListItem x;
	int i;
	p=L->first;
	if(k==1)
		L->first = p->next;
	else
	{
		q = L->first;
		for(i = 1;i<k-1&&q;i++)
			q = q->next;
		p = q->next;
		q->next = p->next;
	}
	x = p->element;
	free(p);
	return x;
}

void PrintList(List L)
{
	link p;
	for(p=L->first;p;p=p->next)
		ItemShow(p->element);
}
"
249-5257,zxombie/aarch64-freebsd-binutils,gdb/testsuite/gdb.stabs/gdb11479.c,60,2,29,1780936.4944695,169057.0,10.531122639109888,1139.0,1129.0,38452.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.001187290996313,1082014363648.0,0.0134155935572026,0.0785172440760147,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2010-2014 Free Software Foundation, Inc.

   Contributed by Pierre Muller.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

   Qualifiers of forward types are not resolved correctly with stabs.  */

struct dummy;

enum dummy_enum;

/* This function prevents the compiler from dropping local variables
   we need for the test.  */
void *hack (const struct dummy *t, const enum dummy_enum *e);

const void *
test (const struct dummy *t)
{
  const struct dummy *tt;
  enum dummy_enum *e;
  tt = t;
  return hack (t, e);
}

void *
test2 (struct dummy *t)
{
  struct dummy *tt;
  const enum dummy_enum *e;
  tt = t;
  return hack (t, e);
}


struct dummy {
 int x;
 int y;
 double b;
} tag_dummy;

enum dummy_enum {
  enum1,
  enum2
};

void *
hack (const struct dummy *t, const enum dummy_enum *e)
{
  return (void *) t;
}

int
main ()
{
  struct dummy tt;
  tt.x = 5;
  tt.y = 25;
  tt.b = 2.5;
  test2 (&tt);
  test (&tt);
  return 0;
}
"
029-20701,alpine9000/BitOS,tests/gcc.c-torture/20061031-1.c,25,1,20,1621923.0601563,169079.0,9.592693356360044,1140.0,1130.0,38457.0,12699.0,1568.0,588.0,1317.0,547.0,1500000000,0.0010812820401042,1082014363648.0,0.0134256767546531,0.0785831574008913,"/* { dg-do run } */
/* PR rtl-optimization/29631 */
/* Origin: Falk Hueffner <falk@debian.org> */

const signed char nunmap[] = { 17, -1, 1 };

__attribute__((noinline))
void ff(int i) {
    asm volatile("""");
}

__attribute__((noinline))
void f(short delta)
{
    short p0 = 2, s;
    for (s = 0; s < 2; s++)
    {
        p0 += delta;
        ff(s);
        if (nunmap[p0] == 17)
            asm volatile("""");
    }
}

int main(void)
{
    f(-1);
    return 0;
}
"
147-5839,Lekssays/brackets,web/tests/test-fill-syslog.c,18,1,17,613589113.2289543,140400171.0,4.370287504849264,101837.0,1750.0,10730977.0,88833913.0,51785.0,20952.0,1399.0,904.0,1500000000,0.4090594088193029,1082014363648.0,0.0007377982466987,0.0007536793341508,"/*
 * Floods syslog and should fail with WRONG-ANSWER.
 * It must be checked manually that syslog is not flooded.
 * This should normally not happen if USE_CHROOT is enabled.
 *
 * @EXPECTED_RESULTS@: CHECK-MANUALLY
 */

#include <stdio.h>
#include <syslog.h>

const int maxmesg = 10000;

int main()
{
	int i;

	openlog(""domjudge_test-fill-syslog"", LOG_PID, LOG_USER);

	for(i=0; i<maxmesg; i++) {
		syslog(LOG_NOTICE,""Fill syslog with nonsense, should not be possible (%06d)."",i);
	}

	printf(""%d lines written to syslog.\n"",maxmesg);

	return 0;
}
"
062-19820,yigezhe/algorithm-summary,two_pointers/example_problem_1_i2.c,35,4,21,1778958.0160750502,181113.0,9.822365042818571,1355.0,1337.0,40973.0,14414.0,1631.0,643.0,1352.0,599.0,1500000000,0.0011859720107167,1082014363648.0,0.0148636486613329,0.0762814378825356,"//看看两个都从大到小排列会出现什么！
//测试结果是，两个都从小到大排列才会得到正确的结果！
#include<stdio.h>
#define MAX 100
int main() {
	int A[MAX];
	int B[MAX];

	int An=4;
	A[0]=6;
	A[1]=4;
	A[2]=3;
	A[3]=2;
	int Bn=5;
	B[0]=2;
	B[1]=3;
	B[2]=4;
	B[3]=6;
	B[4]=9;

	int i;
	for(i=0;i<An;i++) {
		printf("" %d"",A[i]);
	}
	printf(""\n"");
	for(i=0;i<Bn;i++) {
		printf("" %d"",B[i]);
	}
	printf(""\n"");


	int X=8;

	i=0;
	int j=Bn-1;
	while(i<An) {
		while(A[i]+B[j]>X && j > 0) j--;
		if (A[i]+B[j]==X) printf(""%d+%d=%d\n"",i,j,X);
		i++;
	}

	return 0;
}
"
118-34818,bigown/SOpt,C/Function/Factorial.c,19,1,16,1738743.0416419501,174921.0,10.500037159632065,1341.0,1322.0,39577.0,13585.0,1618.0,636.0,1340.0,593.0,1500000000,0.0011591620277613,1082014363648.0,0.015224015412672,0.078759264136037,"#include <stdio.h>

int fatorial(int num) {
    if (num >= 0) {
        int fat = 1;
        while (num > 0) {
            fat *= num;
            num--;
        }
        return fat;
    } else {
        return -1;
    }
}

int main(void) {
	printf(""%d\n"", fatorial(0));
	printf(""%d\n"", fatorial(1));
	printf(""%d\n"", fatorial(5));
	printf(""%d\n"", fatorial(-5));
}

//http://pt.stackoverflow.com/q/185600/101
"
204-13924,SanDisk-Open-Source/SSD_Dashboard,uefi/userspace/glibc/time/tst-strptime2.c,46,1,25,1785018.1320681,203815.0,8.758030566935702,1670.0,1629.0,45510.0,16602.0,1758.0,684.0,1403.0,636.0,1500000000,0.0011900120880454,1082014363648.0,0.0161862473321394,0.0721438691396187,"#include <limits.h>
#include <stdio.h>
#include <time.h>


static const struct
{
  const char *fmt;
  long int gmtoff;
} tests[] =
  {
    { ""1113472456 +1000"", 36000 },
    { ""1113472456 -1000"", -36000 },
    { ""1113472456 +10"", 36000 },
    { ""1113472456 -10"", -36000 },
    { ""1113472456 +1030"", 37800 },
    { ""1113472456 -1030"", -37800 },
    { ""1113472456 +0030"", 1800 },
    { ""1113472456 -0030"", -1800 },
    { ""1113472456 -1330"", LONG_MAX },
    { ""1113472456 +1330"", LONG_MAX },
    { ""1113472456 -1060"", LONG_MAX },
    { ""1113472456 +1060"", LONG_MAX },
    { ""1113472456  1030"", LONG_MAX },
  };
#define ntests (sizeof (tests) / sizeof (tests[0]))


int
main (void)
{
  int result = 0;

  for (int i = 0; i < ntests; ++i)
    {
      struct tm tm;

      if (strptime (tests[i].fmt, ""%s %z"", &tm) == NULL)
	{
	  if (tests[i].gmtoff != LONG_MAX)
	    {
	      printf (""round %d: strptime unexpectedly failed\n"", i);
	      result = 1;
	    }
	  continue;
	}

      if (tm.tm_gmtoff != tests[i].gmtoff)
	{
	  printf (""round %d: tm_gmtoff is %ld\n"", i, (long int) tm.tm_gmtoff);
	  result = 1;
	}
    }

  if (result == 0)
    puts (""all OK"");

  return 0;
}
"
340-34948,danieljiang0415/android_root,obfuscator/obfuscate.c,100,5,67,2102899.36512705,182952.0,11.494266255629892,1342.0,1320.0,42020.0,14464.0,1688.0,637.0,1397.0,596.0,1500000000,0.0014019329100847,1082014363648.0,0.0145502645502645,0.0764464273068479,"/*
* Simple string obfuscation - Quequero 2013
*
* Obfuscated string format:
* 1-byte key. 1-byte module. 1-byte length, <string>
*/

#include <string.h>
#include <stdio.h>
#include <time.h>
#include <stdlib.h>

// <search string> <replace string> <string to search>
unsigned char *str_replace(unsigned char *search , unsigned char *replace , unsigned char *subject) {
    unsigned char *p = NULL , *old = NULL , *new_subject = NULL ;
    int c = 0 , search_size;

    search_size = strlen(search);

    for (p = strstr(subject , search) ; p != NULL ; p = strstr(p + search_size , search)) {
        c++;
    }

    c = (strlen(replace) - search_size )*c + strlen(subject);
    new_subject = malloc(c);
    strcpy(new_subject , """");
    old = subject;

    for (p = strstr(subject , search) ; p != NULL ; p = strstr(p + search_size , search)) {
        strncpy(new_subject + strlen(new_subject) , old , p - old);
        strcpy(new_subject + strlen(new_subject) , replace);
        old = p + search_size;
    }

    strcpy(new_subject + strlen(new_subject) , old);
    return new_subject;
}

int obfuscate(unsigned char *s, unsigned char *d) {
    unsigned int seed;
    unsigned char key, mod;
    unsigned char *rep = NULL;
    unsigned char nl[] = ""\n"";
    unsigned char tb[] = ""\t"";
    unsigned char cr[] = ""\r"";
    int i, j, len;

    srandom(time(0));
    seed = random();

    key = (unsigned char)(seed & 0x000000ff);
    mod = (unsigned char)((seed & 0x0000ff00) >> 8);

    rep = str_replace(""\\n"", nl, s);
    rep = str_replace(""\\t"", tb, rep);
    rep = str_replace(""\\r"", cr, rep);

    len = strlen(rep);

    if (len > 255) {
        printf(""String too long\n"");
        return 0;
    }

    d[0] = key;
    d[1] = mod;
    d[2] = (unsigned char)len ^ key ^ mod;

    for (i = 0, j = 3; i < len; i++, j++) {
        d[j] = rep[i] ^ key;
        d[j] += mod;
        d[j] ^= mod;
    }

    return len;
}

unsigned char* deobfuscate(unsigned char *s) {
    unsigned char key, mod, len;
    int i, j;
    static unsigned char d[256]; // E' zozza ma cosi' non serve la free()

    key = s[0];
    mod = s[1];
    len = s[2] ^ key ^ mod;

    // zero terminate the string
    memset(d, 0x00, len + 1);

    for (i = 0, j = 3; i < len; i++, j++) {
        d[i] = s[j] ^ mod;
        d[i] -= mod;
        d[i] ^= key;
    }

    d[len] = 0;
    return d;
}

int main(int argc, char *argv[]) {
    unsigned char *buf, *test;
    int i, obf_len;

    if (argc < 2) {
        printf(""Usage: %s <string>\n"", argv[0]);
        return 0;
    }

    if (strlen(argv[1]) > 255) {
        printf(""String too long\n"");
        return 0;
    }

    obf_len = strlen(argv[1]) + 3;

    buf = (unsigned char *)malloc(obf_len);
    memset(buf, 0x00, obf_len);

    obf_len = obfuscate(argv[1], buf);
    obf_len += 3;

    printf(""unsigned char obf_string[] = \"""");

    for (i = 0; i < obf_len; i++) {
        printf(""\\x"");
        printf(""%02x"", buf[i]);
    }

    printf(""\""; // \""%s\""\n"", argv[1]);

    test = deobfuscate(buf);

    printf(""Deobfuscated string: \""%s\""\n"", test);

    free(buf);
    return 0;
}

"
003-15874,csampez/analisis-numerico-computo-cientifico,MNO/entrega_tareas_de_C/tarea4/107882/Tarea41.c,16,1,16,1662813.12704085,175932.0,9.45145283404952,1358.0,1334.0,39860.0,13686.0,1628.0,637.0,1346.0,595.0,1500000000,0.0011085420846939,1082014363648.0,0.0153013664370324,0.0785492847271504,"#include<stdio.h>
#include<string.h>
#define MAX_LONG 200
#define CADENA_PRUEBA ""Hola a todos""

int longitud_string(char * s){
    int i=0;
    while(*(s++) != '\0')
        i++;
    return i;
}

int main(void){
    char string1[] = CADENA_PRUEBA; //definición y declaracion de variable e inicializacion.
    char string2[MAX_LONG]; //definición y declaracion.
    
    printf(""cadena: %s\n"", string1);
    printf(""longitud cadena: %d\n"", longitud_string(string1));
    strcpy(string2, ""leer libros y revistas""); //inicializacion de string2
    printf(""cadena2: %s\n"", string2);
    printf(""longitud cadena: %d\n"", longitud_string(string2));
return 0;
}
"
081-21331,ColinIanKing/stress-ng,test/test-atomic_fetch_or.c,24,1,25,1767918.0018603,170439.0,10.372731593121292,1145.0,1137.0,38727.0,12788.0,1581.0,586.0,1326.0,544.0,1500000000,0.0011786120012402,1082014363648.0,0.0133889544059751,0.0783655246044841,"/*
 * Copyright (C) 2021-2022 Colin Ian King
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 */
int main(int argc, char **argv)
{
	int var;

	__atomic_fetch_or(&var, 1, 0);

	return 0;
}

"
323-11081,massivethreads/massivethreads,tests/pth_lock.c,52,1,40,90945217.1763405,72436572.0,1.255515197488915,1576.0,1530.0,23107318.0,5059739.0,6294.0,5939.0,3771.0,4813.0,1500000000,0.060630144784227,1082014363648.0,4.287889272286381e-05,0.000739054846944,"
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

#include <pthread.h>

typedef struct {
  long ninc_per_thread;
  long a;
  long b;
  long r;
  long * p;
  pthread_mutex_t * m;
} arg_t;

void * f(void * arg_) {
  arg_t * arg = (arg_t *)arg_;
  long a = arg->a, b = arg->b;
  long ninc_per_thread = arg->ninc_per_thread;
  if (b - a == 1) {
    int i;
    for (i = 0; i < ninc_per_thread; i++) {
      pthread_mutex_lock(arg->m);
      arg->p[0]++;
      pthread_mutex_unlock(arg->m);
    }
    arg->r = a;
  } else {
    long c = (a + b) / 2;
    arg_t cargs[2] = { { ninc_per_thread, a, c, 0, arg->p, arg->m }, 
		       { ninc_per_thread, c, b, 0, arg->p, arg->m } };
    pthread_t tid;
    pthread_create(&tid, 0, f, cargs);
    f(cargs + 1);
    pthread_join(tid, 0);
    arg->r = cargs[0].r + cargs[1].r;
  }
  return 0;
}

pthread_mutex_t m[1];

int main(int argc, char ** argv) {
  long nthreads        = (argc > 1 ? atol(argv[1]) : 100);
  long ninc_per_thread = (argc > 2 ? atol(argv[2]) : 10000);

  pthread_mutex_init(m, 0);
  long p[1] = { 0 };
  arg_t arg[1] = { { ninc_per_thread, 0, nthreads, 0, p, m } };
  pthread_t tid;
  pthread_create(&tid, 0, f, arg);
  pthread_join(tid, 0);

  if (arg->r == (nthreads - 1) * nthreads / 2
      && arg->p[0] == nthreads * ninc_per_thread) {
    printf(""OK\n"");
    return 0;
  } else {
    printf(""NG: p = %ld != nthreads * ninc_per_thread = %ld\n"",
	   arg->p[0], nthreads * ninc_per_thread);
    return 1;
  }
}

"
218-8070,kevinselwyn/arecibo,arecibo.c,102,4,37,5210796374.827623,1183036.0,4404.596625969117,1367.0,1346.0,261406.0,179464.0,1662.0,675.0,1382.0,633.0,1500000000,3.4738642498850822,1082014363648.0,0.0022932522763466,0.009871390659378,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define MESSAGE_WIDTH  23
#define MESSAGE_HEIGHT 73
#define MESSAGE_BITS   MESSAGE_WIDTH * MESSAGE_HEIGHT
#define MESSAGE_BYTES  (MESSAGE_BITS + 1) / 8
#define COLOR_POINTS   65
#define SLEEP          2000
#define CHARACTER      ""\u25A0""
#define START_COLOR    ""\e[1;%dm""

enum {
	NRM = 0x00,
	RED = 0x1F,
	GRN, YEL, BLU, PUR, CYA, WHT
};

static int message[MESSAGE_BYTES] = {
	0x02, 0xA8, 0x00, 0x50, 0x50, 0x12, 0x22, 0x25, 0x95, 0x55,
	0x52, 0x40, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x0D, 0x00,
	0x00, 0x1A, 0x00, 0x00, 0x54, 0x00, 0x00, 0xF8, 0x00, 0x00,
	0x00, 0x06, 0x1C, 0x61, 0x88, 0x00, 0x32, 0x1A, 0x31, 0x86,
	0xBE, 0xFB, 0xEF, 0x80, 0x00, 0x00, 0x10, 0x00, 0x04, 0x00,
	0x00, 0x00, 0x20, 0x00, 0x0F, 0xC0, 0x01, 0xF0, 0x00, 0x00,
	0x18, 0x61, 0xC6, 0x20, 0x20, 0x08, 0x68, 0x63, 0x9A, 0xFB,
	0xEF, 0xBE, 0x00, 0x00, 0x00, 0x40, 0xC0, 0x10, 0x01, 0x80,
	0x00, 0x83, 0x00, 0x3F, 0x06, 0x07, 0xC0, 0x0C, 0x00, 0x10,
	0x08, 0x04, 0x10, 0x30, 0x10, 0x18, 0x60, 0x40, 0x0C, 0x43,
	0x00, 0x01, 0x98, 0x00, 0x31, 0x0C, 0x01, 0x86, 0x04, 0x04,
	0x08, 0x04, 0x10, 0x18, 0x04, 0x40, 0x30, 0x08, 0x80, 0x20,
	0x20, 0x80, 0x80, 0x80, 0x80, 0x06, 0x00, 0xC0, 0x30, 0x04,
	0x75, 0x80, 0x08, 0x08, 0x00, 0x10, 0x7C, 0x00, 0x21, 0x74,
	0xB6, 0x04, 0xE4, 0xFE, 0xE1, 0xC1, 0xB8, 0x02, 0x83, 0xB2,
	0x05, 0x07, 0xE4, 0x0A, 0x0C, 0x08, 0x36, 0x00, 0x00, 0x00,
	0x00, 0x38, 0x20, 0x00, 0x75, 0x15, 0x54, 0xE0, 0x0A, 0xA0,
	0x00, 0x14, 0x00, 0x0F, 0x80, 0x00, 0x7F, 0xC0, 0x03, 0x80,
	0xE0, 0x0C, 0x00, 0x60, 0x34, 0x01, 0x60, 0xCC, 0x06, 0x61,
	0x14, 0x14, 0x42, 0x24, 0x48, 0x80, 0x45, 0x10, 0x00, 0x84,
	0x20, 0x01, 0x00, 0x40, 0x00, 0x94, 0x00, 0x79, 0xF4, 0xF0
};

static int color_points[COLOR_POINTS] = {
	0x0000, 0x007F, 0x00FD, 0x0260, 0x026B,
	0x0277, 0x0288, 0x028E, 0x029A, 0x02A5,
	0x02AD, 0x02BC, 0x02CB, 0x02D4, 0x02DD,
	0x02EA, 0x02F3, 0x0301, 0x0309, 0x0319,
	0x031E, 0x032F, 0x0333, 0x0347, 0x034C,
	0x035D, 0x0365, 0x0374, 0x037D, 0x038B,
	0x0395, 0x03A2, 0x03AC, 0x03BA, 0x03C2,
	0x03D0, 0x03D8, 0x0415, 0x0417, 0x042C,
	0x043B, 0x0441, 0x0452, 0x0457, 0x0460,
	0x046D, 0x0478, 0x0487, 0x048F, 0x049E,
	0x04A6, 0x04AE, 0x04B5, 0x04BD, 0x04C5,
	0x04CC, 0x04D4, 0x04DC, 0x04E2, 0x050A,
	0x056C, 0x0668, 0x0679, 0x067F, 0x0688
};

static int colors[COLOR_POINTS] = {
	WHT, PUR, GRN, WHT, GRN, WHT, GRN, WHT, GRN, WHT, GRN, WHT, BLU,
	WHT, BLU, WHT, BLU, WHT, BLU, WHT, BLU, WHT, BLU, WHT, BLU, WHT,
	BLU, WHT, BLU, WHT, BLU, WHT, BLU, WHT, BLU, WHT, BLU, RED, BLU,
	RED, BLU, RED, BLU, RED, WHT, RED, WHT, RED, WHT, RED, WHT, BLU,
	RED, WHT, BLU, RED, WHT, BLU, RED, YEL, PUR, WHT, BLU, WHT, BLU
};

static void usage(char *exec) {
	printf(""%s [options] [<rate>]\n\n"", exec);
	printf(""Options:\n"");
    printf(""    -c,--color  Show message part colorings\n"");
    printf(""    -h,--help   Print this help message\n"");
}

int main(int argc, char *argv[]) {
	int rc = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, byte = 0, bit = 0;
	int bit_counter = 0, color_counter = 0, show_colors = 0, sleep = SLEEP;

	if (argc > 1) {
		for (i = 1, l = argc; i < l; i++) {
			if (strcmp(argv[i], ""-h"") == 0 || strcmp(argv[i], ""--help"") == 0) {
				usage(argv[0]);

				rc = 1;
				goto end_transmission;
			} else if (strcmp(argv[i], ""-c"") == 0 || strcmp(argv[i], ""--color"") == 0) {
				show_colors = 1;
			} else if (i == argc - 1) {
				sleep = atoi(argv[argc - 1]);
			}
		}
	}

	for (i = 0, j = MESSAGE_BYTES; i < j; i++) {
		byte = message[i];

		for (k = 0, l = 8; k < l; k++) {
			bit = (byte >> (7 - k)) & 0x01;

			if (show_colors != 0) {
				for (m = 0, n = COLOR_POINTS; m < n; m++) {
					if (bit_counter == color_points[m]) {
						printf(START_COLOR, colors[color_counter]);
						color_counter++;
						break;
					}
				}
			}

			printf(""%s"", bit == 1 ? CHARACTER : "" "");

			if ((bit_counter + 1) % MESSAGE_WIDTH == 0) {
				printf(""\n"");
			}

			if (bit_counter == MESSAGE_BITS) {
				goto end_transmission;
			}

			bit_counter++;

			if (sleep > 0) {
				usleep(sleep);
			}
		}
	}

end_transmission:
	printf(START_COLOR, NRM);

	return rc;
}"
257-2882,hy0kl/study,c-study/kmp.c,105,3,69,1695918.1521087,186327.0,9.09906240104762,1363.0,1342.0,41952.0,14984.0,1633.0,640.0,1354.0,598.0,1500000000,0.0011306121014058,1082014363648.0,0.0145174880720453,0.0742061261767598,"/**
 * @file kmp.c
 * @author yangyongjie(com@baidu.com)
 * @date 2012/02/07 16:07:57
 * @brief
 *
 **/
#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include <stdlib.h>

#define STR_BUF_LEN 1024
/**
“KMP算法中，如果当前字符匹配成功，即S[i]==T[j]，令i++，j++，继续匹配下一个字符；
如果匹配失败，即S[i] != T[j]，需要保持i不变，并且让j = next[j]，
这里next[j] <=j -1，即模式串T相对于原始串S向右移动了至少1位(移动的实际位数j - next[j]  >=1),
同时移动之后，i之前的部分（即S[i-j+1 ~ i-1]），和j=next[j]之前的部分（即T[0 ~ j-2]）仍然相等。
显然，相对于BF算法来说，KMP移动更多的位数，起到了一个加速的作用！
(失配的特殊情形，令j=next[j]导致j==0的时候，需要将i++，否则此时没有移动模式串)。”
*/

char haystack[STR_BUF_LEN] = ""aaaaaaaaaaaaaaaaaaaaaaaaaab"";
char pattern[STR_BUF_LEN]  = ""aaaaaaaab"";
int  next_map[STR_BUF_LEN] = {0};

void get_nextval(const char *ptrn, int plen, int *nextval)
{
    int i = 0;
    int j = -1;

    nextval[i] = -1;
    while (i < plen - 1)
    {
        if(-1 == j || ptrn[i] == ptrn[j])
        {
            ++i;
            ++j;
            if(ptrn[i] != ptrn[j])
            {
                nextval[i] = j;
            }
            else
            {
                nextval[i] = nextval[j];
            }
        }
        else
        {
            j = nextval[j];
        }
    }
}

int
kmp_search(const char *src, int slen, const char *patn, int plen,
    int const* nextval, int pos)
{
    int i = pos;
    int j = 0;

    while (i < slen && j < plen)
    {
        if (-1 == j || src[i] == patn[j])
        {
            ++i;
            ++j;
        }
        else
        {
            j = nextval[j];
        }
    }

    if(j >= plen)
    {
        return i - plen;
    }

    return -1;
}

int main(int argc, char *argv[])
{
    int haystack_len = 0;
    int pattern_len  = 0;
    int i;
    int pos;

    if (argc > 1 && argv[1][0])
    {
        snprintf(haystack, STR_BUF_LEN, ""%s"", argv[1]);
    }

    if (argc > 2 && argv[2][0])
    {
        snprintf(pattern, STR_BUF_LEN, ""%s"", argv[2]);
    }
    printf(""haystack: %s\n"", haystack);
    printf(""pattern: %s\n"", pattern);

    haystack_len = strlen(haystack);
    pattern_len  = strlen(pattern);

    get_nextval(pattern, pattern_len, next_map);
    for (i = 0; i < pattern_len; i++)
    {
       printf(""next_map[%d] = %d\n"", i, next_map[i]);
    }

    if (-1 != 
        (pos = kmp_search(haystack, haystack_len, pattern, pattern_len, next_map, 0)))
    {
        printf(""OK, the pattern:[%s] is substr of haystack:[%s], position is:%d.\n"",
            pattern, haystack, pos);
    }
    else
    {
        printf(""Sorry, the pattern:[%s] is NOT substr of haystack:[%s].\n"",
            pattern, haystack);
    }

    return 0;
}

/* vim: set expandtab ts=4 sw=4 sts=4 tw=100: */
"
059-21072,bentglasstube/aq-embedded,src/aq.c,63,2,42,2131308.0796971,410036.0,5.19785579802749,1380.0,1358.0,45755.0,132240.0,2386.0,59169.0,1556.0,3583.0,1500000000,0.0014208720531314,1082014363648.0,0.0066774624667102,0.3746959184246748,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

static const char *quest_base        = ""|V wants you to |D."";

typedef struct {
  const int count;
  const char * const * data;
} list;

static const list data[] = {
  { 24, (const char * const []){ ""B"",""D"",""F"",""G"",""H"",""J"",""K"",""L"",""M"",""N"",""P"",""R"",""S"",""T"",""V"",""W"",""Wh"",""Y"",""Z"",""Th"",""Ch"",""Sh"",""Zh"",""|B|F"" } },
  { 25, (const char * const []){ ""A"",""A"",""A"",""E"",""E"",""E"",""I"",""I"",""I"",""O"",""O"",""O"",""U"",""U"",""U"",""Ae"",""Ee"",""Ie"",""Oe"",""Ue"",""Oo"",""Au"",""Oi"",""Ai"",""Ea"" } },
  {  4, (const char * const []){ ""powerful"",""magical"",""sacred"",""valuable"" } },
  { 26, (const char * const []){ ""expose the corruption of |W |Q"",""assassinate |W |Q"",""steal |N from |R"",""recover |N from |R"",""transport |N to |U"",""hunt down and capture |R"",""hunt down and kill |R"",""explore |U"",""slay |R and retrieve |N"",""slay |R and destroy |N"",""rescue |W |Q from |R"",""investigate a star which fell into |U"",""thwart the monstrous plan of |R"",""find and explore |U"",""discover who is assassinating his peers and why"",""escort |I safely to |U"",""recover and destroy |N from |U"",""deliver |N to |Q in |U"",""travel to |U and retrieve |N"",""search |U for treasure"",""collect |S |J from |U"",""kill |S of the nearby |E"",""travel to |U and defeat |R"",""make peace with the people of |U"",""aid the people of |U against |R"",""find out what killed all the |E in |U"" } },
  {  9, (const char * const []){ ""bears"",""rabbits"",""deer"",""fish"",""birds"",""wolves"",""foxes"",""pigs"",""boars"" } },
  { 21, (const char * const []){ ""b"",""d"",""f"",""g"",""h"",""j"",""k"",""l"",""m"",""n"",""p"",""r"",""s"",""t"",""v"",""w"",""z"",""th"",""ch"",""sh"",""ng"" } },
  { 10, (const char * const []){ """","""","""","""","""",""y"",""|F"",""|F|X"",""|F|X"",""|F|X|G"" } },
  {  6, (const char * const []){ ""murderer"",""scoundrel"",""thief"",""scalawag"",""vandal"",""cur"" } },
  {  8, (const char * const []){ ""a caravan of |C goods"",""a locked chest"",""his daughter"",""his son"",""his family"",""her daughter"",""her son"",""her family"" } },
  {  5, (const char * const []){ ""berries"",""hides"",""feathers"",""gemstones"",""ingots"" } },
  {  5, (const char * const []){ ""Tundra"",""Savannah"",""Woodlands"",""Caldera"",""|L"" } },
  {  5, (const char * const []){ ""Sea"",""Swamp"",""Forest"",""Mountains"",""Cavern"" } },
  {  4, (const char * const []){ ""warlocks"",""cultists"",""theives"",""traitors"" } },
  {  5, (const char * const []){ ""the Relic of |Q"",""the Sword of |Q"",""the Amulet of |Q"",""a |C device"",""a |C artifact"" } },
  { 19, (const char * const []){ ""shady"",""wealthy"",""cryptic"",""mysterious"",""dying"",""disgruntled"",""hoary"",""skittish"",""frantic"",""mysterious"",""worried"",""vacant"",""crippled"",""stocky"",""peg-legged"",""one-eyed"",""lecherous"",""destitute"",""ghostly"" } },
  {  7, (const char * const []){ ""Demon"",""Dragon"",""Vampire"",""Goblin"",""Orc"",""Troll"",""Kobold"" } },
  {  1, (const char * const []){ ""|A|X|F|X|G"" } },
  {  6, (const char * const []){ ""|Q, the |P |W"",""a rival"",""the |H |Q"",""the |M of |Q"",""the |P of |U"",""the pirates of the |Q Sea"" } },
  { 11, (const char * const []){ ""12"",""20"",""25"",""40"",""50"",""75"",""100"",""200"",""250"",""500"",""100"" } },
  { 14, (const char * const []){ ""aristocrat"",""dwarf"",""elf"",""ex-adventurer"",""farmer"",""gnome"",""mercenary"",""merchant"",""peasant"",""pirate"",""sage"",""traveler"",""vagabond"",""wizard"" } },
  {  7, (const char * const []){ ""|Q |Q"",""the |Q |K"",""the |L of |Q"",""Lake |Q"",""the town of |Q"",""the lost city of |Q"",""the ancient ruins of |Q"" } },
  {  3, (const char * const []){ ""|W |Q"",""A |O |T named |Q"",""A |O |T named |Q"" } },
  { 10, (const char * const []){ ""Lord"",""Lady"",""King"",""Queen"",""Prince"",""Princess"",""Count"",""Countess"",""Duke"",""Dutchess"" } },
  { 24, (const char * const []){ ""a"",""a"",""a"",""e"",""e"",""e"",""i"",""i"",""i"",""o"",""o"",""o"",""u"",""u"",""u"",""ae"",""ee"",""ie"",""oe"",""ue"",""oo"",""au"",""oi"",""ai"",""ea"" } }
};

static const size_t buffer_size = 65536;

static inline int rand_int(const int bound) {
  return random() % bound;
}

void generate_quest(char* buffer, const size_t len) {
  char before[len], after[len], replace[len];
  char *start;
  int group;

  strncpy(buffer, quest_base, len);

  while (start = strchr(buffer, '|')) {
    if (start == buffer) {
      before[0] = 0;
    } else {
      strncpy(before, buffer, start - buffer);
      before[start - buffer] = 0;
    }

    group = start[1] - 'A';

    strncpy(after, start + 2, len);

    strncpy(replace, data[group].data[rand_int(data[group].count)], len);

    buffer[0] = 0;
    strncat(buffer, before, len);
    strncat(buffer, replace, len - strlen(buffer));
    strncat(buffer, after, len - strlen(buffer));
  }
};

int main(int argc, char** argv) {
  srandom(time(NULL));

  char quest[buffer_size];
  generate_quest(quest, buffer_size);
  printf(""%s\n"", quest);
  return 0;
}
"
230-28646,aawantar/sharpner,C++/random/questions/reverse_string.c,32,1,24,2594299.61442945,175973.0,14.74259687565706,1337.0,1314.0,39919.0,13643.0,1635.0,640.0,1350.0,595.0,1500000000,0.0017295330762863,1082014363648.0,0.0150648110789723,0.0787871998805123,"#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Routines
char* rstrdup(const char* str);
void reverse_string(char* str);

int 
main() {
	char str[] = ""Atul Patil"";
	char* rstr = rstrdup(str);
    reverse_string(str);
	printf(""%s ==> %s\n"", str, rstr);
	return 0;
}

char *
rstrdup(const char *str) {
	if (!str) return NULL;
	char* rstr = strdup(str);
    reverse_string(rstr);
    return rstr;
}

void
reverse_string(char *str) {
	if (!str) return;
	int len = strlen(str);
	char* start = str;
	char* end = str + len - 1;
	while(start < end) {
		char tmp = *start;
        *start = *end;
        *end = tmp;
		start++; end--;
	} 
   return;
}

"
161-15802,Nextra/adventofcode2015,C/Day03/day03.c,122,4,62,1800092.98492215,180045.0,9.994979033019522,1406.0,1383.0,41085.0,14252.0,1637.0,641.0,1357.0,597.0,1500000000,0.0012000619899481,1082014363648.0,0.015490571801494,0.0764768599671106,"#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int max(int a, int b) {
	return a > b ? a : b;
}

int min(int a, int b) {
	return a < b ? a : b;
}

char *read_instructions(FILE *in) {
	int i = 0, len = 64;
	char *ret = malloc(sizeof(char) * len);
	if (ret == NULL) {
		return NULL;
	}

	ret[0] = 0;
	int c;
	while ((c = fgetc(in)) != EOF) {
		switch (c) {
		case '^':
		case 'v':
		case '<':
		case '>':
			ret[i++] = c;
		}

		if (i == len) {
			len *= 2;
			char *tmp = realloc(ret, sizeof(char) * len);

			if (tmp == NULL) {
				free(ret);
				return NULL;
			}

			ret = tmp;
		}
	}

	ret[i] = 0;
	return ret;
}

int main(int argc, char **argv) {
	int santas = 1;
	if (argc > 1) {
		santas = max(1, atoi(argv[1]));
	}

	int *x_pos = calloc(santas, sizeof(int));
	int *y_pos = calloc(santas, sizeof(int));
	char *instructions = read_instructions(stdin);
	if (x_pos == NULL || y_pos == NULL || instructions == NULL) {
		free(x_pos);
		free(y_pos);
		free(instructions);
		return 1;
	}

	size_t inslen = strlen(instructions);
	int turn = 0;
	int x_lo = 0, x_hi = 0, y_lo = 0, y_hi = 0;
	for (size_t i = 0; i < inslen; ++i) {
		switch (instructions[i]) {
		case '^':
			y_hi = max(y_hi, ++y_pos[turn]);
			break;
		case 'v':
			y_lo = min(y_lo, --y_pos[turn]);
			break;
		case '>':
			x_hi = max(x_hi, ++x_pos[turn]);
			break;
		case '<':
			x_lo = min(x_lo, --x_pos[turn]);
			break;
		default:
			continue;
		}

		++turn;
		turn %= santas;
	}

	int x_off = abs(x_lo);
	int y_off = abs(y_lo);
	int cols = x_off + abs(x_hi) + 1;
	int rows = y_off + abs(y_hi) + 1;

	int *map = calloc((cols + 1) * (rows + 1), sizeof(int));
	if (map == NULL) {
		free(x_pos);
		free(y_pos);
		free(instructions);
		return 1;
	}

	map[y_off * cols + x_off] = 1;

	turn = 0;
	for (int i = 0; i < santas; ++i) {
		x_pos[i] = x_off;
		y_pos[i] = y_off;
	}

	int houses = 1, *loc;
	for (size_t i = 0; i < inslen; ++i) {
		switch (instructions[i]) {
		case '^':
			++y_pos[turn];
			break;
		case 'v':
			--y_pos[turn];
			break;
		case '>':
			++x_pos[turn];
			break;
		case '<':
			--x_pos[turn];
			break;
		default:
			continue;
		}

		loc = &map[y_pos[turn] * cols + x_pos[turn]];

		if (*loc == 0) {
			++houses;
		}

		++(*loc);

		++turn;
		turn %= santas;
	}

	printf(""Houses visited: %d\n"", houses);

	free(instructions);
	free(x_pos);
	free(y_pos);
	free(map);
	return 0;
}"
282-22961,SanDisk-Open-Source/SSD_Dashboard,uefi/gcc/gcc-4.6.3/gcc/testsuite/gcc.dg/pr46685.c,36,1,33,6730885.477736549,13169086.0,0.5111125403843516,1143.0,1133.0,2038460.0,2012696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0044872569851577,1082014363648.0,0.0001728290027113,0.0009913219831574,"/* { dg-do compile } */
/* { dg-require-effective-target freorder } */
/* { dg-require-effective-target fpic } */
/* { dg-options ""-O2 -freorder-blocks-and-partition -fpic"" } */

__attribute__((noinline, noclone))
void bar (void *x)
{
  asm volatile ("""" : : ""r"" (x) : ""memory"");
}

__attribute__((noinline, noclone))
void baz (void)
{
  asm volatile ("""" : : : ""memory"");
}

__attribute__((noinline, noclone))
int foo (int x)
{
  __label__ lab;
  if (__builtin_expect (x, 0))
    {
      lab:
      baz ();
      return 2;
    }
  bar (&&lab);
  return 1;
}

int
main (void)
{
  int x, i;
  asm volatile ("""" : ""=r"" (x) : ""0"" (0));
  for (i = 0; i < 1000000; i++)
    foo (x);
  return 0;
}
"
344-10479,thuctran289/ExercisesInC,exercises/ex13/mem_errors.c,40,1,33,1483819.6802883,169878.0,8.734615429896749,1137.0,1130.0,38650.0,12779.0,1569.0,589.0,1318.0,547.0,1500000000,0.0009892131201922,1082014363648.0,0.0133448710250885,0.0782243481304322,"/* Example code for Exercises in C.

Copyright 2014 Allen Downey
License: Creative Commons Attribution-ShareAlike 3.0

*/

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>


void free_anything(int *p) {
    free(p);
}


int read_element(int *array, int index) {
    int x = array[index];
    return x;
}


int main ()
{
    int *never_allocated = malloc(sizeof(int));
    int *free_twice = malloc (sizeof (int));
    int *use_after_free = malloc (sizeof (int));
    int *never_free = malloc (sizeof (int));
    int *array1 = malloc(sizeof(int)*100);
    int *array2 = malloc (100 * sizeof (int));

    // valgrind does not bounds-check static arrays
    read_element(array1, 0);
    read_element(array1, 99);

    // but it does bounds-check dynamic arrays
    read_element(array2, 0);
    read_element(array2, 99);

    // and it catches use after free
    *use_after_free = 17;
    free(use_after_free);
    
    // never_free is definitely lost
    *never_free = 17;
    free(never_free);

    // the following line would generate a warning
    // free(&never_allocated);

    // but this one doesn't
    free_anything(never_allocated);
    
    free(free_twice);
    free(array1);
    free(array2);

    return 0;
}
"
314-3805,smarr/Truffle,sulong/tests/com.oracle.truffle.llvm.tests.libc.native/libc/getc/getc.c,40,1,34,1937204.8554941998,270553.0,7.160164551862297,1385.0,1362.0,73339.0,34107.0,1673.0,669.0,1381.0,628.0,1500000000,0.0012914699036628,1082014363648.0,0.0101532786551987,0.0404947601585912,"/*
 * Copyright (c) 2017, 2021, Oracle and/or its affiliates.
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of
 * conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
 * conditions and the following disclaimer in the documentation and/or other materials provided
 * with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
 * endorse or promote products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS"" AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    int c;
    FILE *file = fopen(__FILE__, ""r"");
    if (file == NULL) {
        return 1;
    }
    while ((c = getc(file)) != EOF) {
        putchar(c);
    }
    fclose(file);
}
"
161-3857,bablon/libstring,strncpy.c,25,2,20,1771458.3082123501,169909.0,10.425922111247786,1145.0,1137.0,38675.0,12782.0,1578.0,586.0,1325.0,546.0,1500000000,0.0011809722054749,1082014363648.0,0.0134307187965322,0.0784149872709252,"#include <stdio.h>

char *strncpy(char *dst, const char *src, size_t n)
{
	char *d = dst;

	while (n != 0 && *src != '\0') {
		*dst++ = *src++;
		n--;
	}

	while (n != 0) {
		*dst++ = '\0';	
		n--;
	}

	return d;

}

int main(int argc, char *argv[])
{
	char buf[64] = ""abcdefghijklmnopqrstuvwxyz"";
	const char *src = ""helloworld"";

	strncpy(buf, src, 0);
	strncpy(buf, src, 5);
	strncpy(buf, src, 10);
	strncpy(buf, src, 11);
	strncpy(buf, src, 12);
	strncpy(buf, src, 20);

	return 0;
}
"
065-10095,senfo/ScratchPad,c/smallest.c,33,1,27,670575456.2281072,6498964991.0,0.1031818846429603,1343.0,1324.0,39179.0,13312.0,1618.0,636.0,1340.0,593.0,1500000000,0.4470503041520715,1082014363648.0,4.1037303689023686e-07,0.0797660551332609,"/* Finds the smallest number that is evenly divisible by all of the numbers from 1 to 20 */
#include <stdio.h>
#include <limits.h>

int main(void)
{
  unsigned int x;

  for (x = 20; x < UINT_MAX; x++)
  {
    if (x % 1 == 0 &&
        x % 2 == 0 &&
        x % 3 == 0 &&
        x % 4 == 0 &&
        x % 5 == 0 &&
        x % 6 == 0 &&
        x % 7 == 0 &&
        x % 8 == 0 &&
        x % 9 == 0 &&
        x % 10 == 0 &&
        x % 11 == 0 &&
        x % 12 == 0 &&
        x % 13 == 0 &&
        x % 14 == 0 &&
        x % 15 == 0 &&
        x % 16 == 0 &&
        x % 17 == 0 &&
        x % 18 == 0 &&
        x % 19 == 0 &&
        x % 20 == 0)
    {
      break;
    }
  }

  printf(""%d\n"", x);
  return 0;
}
"
347-5887,flaviomahooney/prog1_2016,imprimindo.c,12,1,15,2393599.4831844,250958.0,9.537846970409392,1342.0,1322.0,55257.0,24584.0,1619.0,646.0,1340.0,601.0,1500000000,0.0015957329887896,1082014363648.0,0.0106153220857673,0.0526797009055497,"#include <stdio.h>

int main()
{
    char lt;

   
   printf(""\nTabela ASCII"");
   printf(""\n-----------"");
   printf(""\nDec\tChar"");
   
   for(lt=33; lt<=126; lt++)
   {
       printf(""\n%d\t%c"",lt,lt);
   }
   
   return 0;
}
"
199-28780,dangvanuy/UyDang-ccpp,thread/criticalResource/semaphore_lock.c,114,9,88,24003307478.73522,203171.0,118143.37419218294,1583.0,1550.0,46000.0,17565.0,1698.0,812.0,1390.0,767.0,1500000000,16.002204985823482,1082014363648.0,0.0154205078480688,0.0734209077322425,"/*
 * waitToWork.c
 *
 *  Created on: Dec 3, 2014
 *      Author: udang
 *	How to make
 function udmake(){
 	 gcc -o waitToWork waitToWork.c -lpthread
 }
 */
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>
#include <errno.h>		//for EINTR
#include <semaphore.h> 	//for sem_t

#define LOCK(x)     semaWait( &gResSema, x)
#define UNLOCK(x)   semaRelease( &gResSema, x )

static sem_t gResSema;
int semaCreate( sem_t* sem, int initialCount )
{
   int  rc;
   rc = sem_init( sem, 0, initialCount );
   return rc;
}

void semaDestroy( sem_t* sem )
{
   sem_destroy( sem );
   return;
}

int semaWait( sem_t* sem, char *name )
{
	int  rc;
	do
	{
	   printf(""[Work_%s] - is waiting for Resource\n"", name);
	   rc = sem_wait( sem );
	}while(( -1 == rc ) && ( EINTR == errno ));
	printf(""[Work_%s] - is keeping resource\n"", name);
   return rc;
}

int semaRelease( sem_t* sem, char *name)
{
   int rc;
   rc = sem_post( sem );
   printf(""[Work_%s] - Release Resource\n"", name);
   return rc;
}


int gResource = 0;

typedef struct
{
	pthread_t	threadID;
	char		name[10];
	int 		time; 	//in sec to do a work
	int			target;	//result need
}SWorker;


/*
 * WorkerA will work with gResource in 3 sec
 */
void Work(SWorker *person)
{
	LOCK(person->name);
	printf(""[%s_%s] - Begin transaction, target = %d and work with in %d sec\n"", __FUNCTION__,person->name, person->target, person->time);
	sleep(person->time);
	gResource = person->target;
	printf(""[%s_%s] - End transaction, Resource = %d and target = %d \n"", __FUNCTION__,person->name, gResource, person->target);
	UNLOCK(person->name);
}

void *DoWork(void *param)
{
	SWorker *worker = (SWorker*)param;
	Work(worker);
	return NULL;
}

pthread_t DoAWork(SWorker *person)
{
	pthread_t var_thread;
	pthread_create(&var_thread, NULL, DoWork, (void*)person);
	return var_thread;
}

void ExampleWithSema()
{
	semaCreate(&gResSema, 1);

	SWorker workerA = {0, ""A"", 10, 10};
	workerA.threadID = DoAWork(&workerA);

	SWorker workerB = {0, ""B"", 4, 11};
	workerB.threadID = DoAWork(&workerB);


	SWorker workerC = {0, ""C"", 2, 11};
	workerC.threadID = DoAWork(&workerC);

	pthread_join(workerA.threadID, NULL);
	pthread_join(workerB.threadID, NULL);
	pthread_join(workerC.threadID, NULL);

	semaDestroy(&gResSema);
}

int main()
{
	ExampleWithSema();
	return 0;
}

/*
 * Output when do not use sem
 	[Work_A] - Begin transaction, please wait for me 5 sec
	[Work_B] - Begin transaction, please wait for me 2 sec
	[Work_B] - End transaction with real = 11 and result = 11
	[Work_A] - End transaction with real = 10 and result = 10
 * Output when do use sem
	[Work_A] - is waiting for Resource
	[Work_A] - is keeping resource
	[Work_A] - Begin transaction, target = 10 and work with in 10 sec
	[Work_B] - is waiting for Resource
	[Work_C] - is waiting for Resource
	[Work_A] - End transaction, Resource = 10 and target = 10
	[Work_A] - Release Resource
	[Work_B] - is keeping resource
	[Work_B] - Begin transaction, target = 11 and work with in 4 sec
	[Work_B] - End transaction, Resource = 11 and target = 11
	[Work_B] - Release Resource
	[Work_C] - is keeping resource
	[Work_C] - Begin transaction, target = 11 and work with in 2 sec
	[Work_C] - End transaction, Resource = 11 and target = 11
	[Work_C] - Release Resource
 */
"
303-19909,acarno/slicer,valgrind/massif/tests/peak.c,11,1,16,1992304.34373015,169083.0,11.782994150801676,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0013282028958201,1082014363648.0,0.0134490161636592,0.0785049652044725,"#include <stdlib.h>

int main(void)
{
   int i;
   for (i = 0; i < 20; i++) {
      int* p;           // Sizes are divisible by 16 -- no slop.
      p = malloc(1600); // With --peak-inaccuracy=1000, the first 10 of
      p = malloc(16);   // 'free' calls result in peaks, but after that,
      free(p);          // only every second one does.
   }
   return 0;
}
"
389-20762,jindal25/interview-questions,numeric/even_odd_count/solution.c,44,5,33,3694585.4080840503,6773931.0,0.5454122576684055,1339.0,1320.0,239310.0,113421.0,7234.0,6906.0,1340.0,6845.0,1500000000,0.0024630569387227,1082014363648.0,0.0003925342611254,0.0632918569674908,"/* Write code to determine how many numbers between 1 and 100000 contain an even number of digits
 *
 * Source: Careercup (Microsoft interview)
 */

#include <stdio.h>
#define N 100000

unsigned even_odd_digits(void) {
	static unsigned odd_digits[N+1];

	unsigned res = 0;
	size_t i;
	for (i = 0; i < N+1 && i < 10; i++) {
		odd_digits[i] = i & 1;
		res += !odd_digits[i];
	}

	size_t mult;
	for (mult = 10; mult < N+1; mult *= 10) {
		for (i = mult; i < N+1 && i < mult*10; i++) {
			odd_digits[i] = odd_digits[i%mult] + odd_digits[i/mult];
			res += !(odd_digits[i] & 1U);
		}
	}

	return res-1;
}

unsigned even_odd_digits_naive(void) {
	unsigned res = 0;
	size_t i;
	for (i = 1; i < N+1; i++) {
		size_t j = i;
		unsigned odd_digits = 0;
		while (j != 0) {
			if ((j%10) & 1) {
				odd_digits++;
			}
			j /= 10;
		}
		if (!(odd_digits & 1)) {
			res++;
		}
	}

	return res;
}

int main(void) {
	printf(""Naive: %u\n"", even_odd_digits_naive());
	printf(""Lookup table: %u\n"", even_odd_digits());
	return 0;
}
"
013-25353,Mikescher/Project-Euler_Befunge,compiled/C/Euler_Problem-038.c,149,3,113,7426421.740092299,23721585.0,0.3133471056002371,1429.0,1405.0,6608269.0,4301258.0,1698.0,2843.0,1352.0,2767.0,1500000000,0.0049509478267282,1082014363648.0,0.0001194692513168,0.0007938016011143,"/* transpiled with BefunCompile v1.3.0 (c) 2017 */
#include <stdio.h>
#include <stdlib.h>
#define int64 long long
char* _g = ""v{#}  ){ } !`v{#}  )    v{ } !O<#     p145< {#}  ){ }  )v{ }  *+1<{ }  +v{ }  ,<  v{ }  /<{ }  1vp2\\0:<{ }  ){>v    }  \""      >$""
           ""v   v\\g2:<{ }  =>\""ec\""*31p>241p>01-1>:31g*\\:41g-#^_$>\\10p01-\\>:55+%\\55+/:#^_$>10g55+*+10p:1+#^_$10g\\:1+#v_$:55+>  1-:|  >:55+%:|>""
           "":2g!|>1\\2p55+/:!| >55+> 1-:|>#v_$41g1-:41p1-#^_31g1-:31p|{ }  C^{ }  R\\<{ }  +$>$:^  {    $#}  \""{ }  *<v{+}  ($<{ } !J$${>     }""
           ""  \""     $0>9-!\\$     ^ >.     @     ,,,,, \""RORRE\""<"";
int t=0;int z=0;
int64 g[1014];
int d(){int s,w,i,j,h;h=z;for(;t<434;t++)if(_g[t]==';')g[z++]=_g[++t];else if(_g[t]=='}')return z-h;else if(_g[t]=='{'){t++;s=z;w=d();for(i=1;i<_g[t+1]*9025+_g[t+2]*95+_g[t+3]-291872;i++)for(j=0;j<w;g[z++]=g[s+j++]);t+=3;}else g[z++]=_g[t];return z-h;}
int64 gr(int64 x,int64 y){if(x>=0&&y>=0&&x<169&&y<6){return g[y*169+x];}else{return 0;}}
void gw(int64 x,int64 y,int64 v){if(x>=0&&y>=0&&x<169&&y<6){g[y*169+x]=v;}}
int64 td(int64 a,int64 b){ return (b==0)?0:(a/b); }
int64 tm(int64 a,int64 b){ return (b==0)?0:(a%b); }
int64*s;int q=16384;int y=0;
int64 sp(){if(!y)return 0;return s[--y];}
void sa(int64 v){if(q-y<8)s=(int64*)realloc(s,(q*=2)*sizeof(int64));s[y++]=v;}
int64 sr(){if(!y)return 0;return s[y-1];}
int main(void)
{
    d();
    s=(int64*)calloc(q,sizeof(int64));
    gw(3,1,9999);
    gw(4,1,2);
_1:
    sa(-1);
    sa(gr(3,1));
    sa(1);
    sa(1-gr(4,1));
_2:
    if(sp()!=0)goto _29;else goto _3;
_3:
    sp();
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
_4:
    gw(1,0,sp());
    sa(-1);
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
_5:
    sa(sr()%10);
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    sa(sp()/10LL);

    sa(sr());
    if(sp()!=0)goto _5;else goto _7;
_7:
    sp();
_8:
    sa(sp()+(gr(1,0)*10));

    gw(1,0,sp());
    if(sr()!=-1)goto _8;else goto _10;
_10:
    sp();
    sa(gr(1,0));
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}

    if(sr()!=-1)goto _4;else goto _11;
_11:
    sp();
    sa(sr());
    sa(9);
    sa(9);
_12:
    if(sp()!=0)goto _13;else goto _14;
_13:
    sa(sr());
    sa(0);
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    sa(2);
    {int64 v0=sp();int64 v1=sp();gw(v1,v0,sp());}
    sa(sp()-1LL);

    sa(sr());
    goto _12;
_14:
    sp();
    sa(sr());
_15:
    sa(sr()%10);
    sa(sr());

    if(sp()!=0)goto _16;else goto _28;
_16:
    sa(sr());
    sa(2);
    {int64 v0=sp();sa(gr(sp(),v0));}

    if(sp()!=0)goto _28;else goto _17;
_17:
    sa(1);
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    sa(2);
    {int64 v0=sp();int64 v1=sp();gw(v1,v0,sp());}
    sa(sp()/10LL);

    sa(sr());

    if(sp()!=0)goto _15;else goto _18;
_18:
    sp();
    sa(9);
    sa(9);
_19:
    if(sp()!=0)goto _20;else goto _21;
_20:
    sa(sr());
    sa(2);
    {int64 v0=sp();sa(gr(sp(),v0));}
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    sa(sp()-1LL);

    sa(sr());
    goto _19;
_21:
    sp();
    sa(sp()+sp());

    sa(sp()+sp());

    sa(sp()+sp());

    sa(sp()+sp());

    sa(sp()+sp());

    sa(sp()+sp());

    sa(sp()+sp());

    sa(sp()+sp());

    sa(sp()-9LL);

    sa((sp()!=0)?0:1);
_22:
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    sp();

    if(sp()!=0)goto _27;else goto _23;
_23:
    sp();
    sa(gr(4,1)-2);
    gw(4,1,gr(4,1)-1);

    if(sp()!=0)goto _1;else goto _24;
_24:
    sa(gr(3,1)-1);
    gw(3,1,gr(3,1)-1);

    if(sp()!=0)goto _26;else goto _25;
_25:
    printf(""RORRE"");
    return 0;
_26:
    gw(4,1,5);
    goto _1;
_27:
    printf(""%lld "", (int64)(sp()));
    return 0;
_28:
    sp();
    sp();
    sa(0);
    goto _22;
_29:
    sa(sp()+1LL);

    sa(sr()*gr(3,1));
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    sa(sr()-gr(4,1));
    goto _2;
}
"
098-22616,wcnnbdk1/hello_world,CLearning/understandC_ja/chap12/list1207.c,39,4,28,1815243.2749047,211443.0,8.585022913976816,1514.0,1484.0,47421.0,18298.0,1660.0,645.0,1374.0,601.0,1500000000,0.0012101621832698,1082014363648.0,0.0141787621250171,0.0651257627170224,"#include <stdio.h>
#include <string.h>

#define NUMBER    5
#define NAME_LEN  64

typedef struct {
    char  name[NAME_LEN];
    int   height;
    float weight;
    long  schols;
} Student;

void swap_Student(Student *x, Student *y)
{
    Student temp = *x;
    *x = *y;
    *y = temp;
}

void sort_by_height(Student a[], int n)
{
    int i, j;

    for (i = 0; i < n - 1; i++){
        for (j = n - 1; j > i; j--)
            if (a[j - 1].height > a[j].height)
                swap_Student(&a[j - 1], &a[j]);
    }
}

int main(void)
{
    int i;
    Student std[]={
        {""Sato"",   178, 61.2, 80000},
        {""Sanaka"", 175, 62.5, 73000},
        {""Takao"",  173, 86.2, 0},
        {""Mike"",   165, 72.3, 70000},
        {""Masaki"", 179, 77.5, 70000},
    };
    for (i = 0; i < NUMBER; i++)
        printf(""%-8s %6d%6.1f%7ld\n"", std[i].name, std[i].height, std[i].weight, std[i].schols);
    sort_by_height(std,NUMBER);
    puts(""\n Sort by height."");
    for (i = 0; i < NUMBER; i++)
        printf(""%-8s %6d%6.1f%7ld\n"", std[i].name, std[i].height, std[i].weight, std[i].schols);
    return 0;
}
"
397-22626,TixLo/BasicSample,src/reverse-list/reverse-list.c,51,2,40,2574652.43339535,179483.0,14.34482374375289,1346.0,1326.0,40678.0,14268.0,1625.0,639.0,1346.0,594.0,1500000000,0.0017164349555969,1082014363648.0,0.0148872038020313,0.0765114840024751,"#include <stdio.h>
#include <stdlib.h>

typedef struct _node_t{
	int val;
	struct _node_t *next;
}node_t;

void print(node_t *list)
{
	node_t *n = NULL;
	for (n = list ; n != NULL ; n=n->next)
	{
		printf(""%d "",n->val);
	}
	printf(""\n"");
}

node_t *reverse(node_t *list)
{
	node_t *n = NULL;
	node_t *next = list;
	node_t *prev = NULL;
	do{
		n = next;
		next = n->next;
		n->next = prev;
		prev = n;
	}while(next != NULL);

	return n;
}

int main(int argc, char **argv)
{
	//
	// prepare data
	//
	node_t* n1 = (node_t*)malloc(sizeof(node_t));
	n1->val = 1;
	n1->next = NULL;

	node_t* n2 = (node_t*)malloc(sizeof(node_t));
	n2->val = 2;
	n2->next = NULL;
	n1->next = n2;

	node_t* n3 = (node_t*)malloc(sizeof(node_t));
	n3->val = 3;
	n3->next = NULL;
	n2->next = n3;

	node_t* n4 = (node_t*)malloc(sizeof(node_t));
	n4->val = 4;
	n4->next = NULL;
	n3->next = n4;

	print(n1);

	n1 = reverse(n1);

	print(n1);


	return 0;
}"
280-21035,gnustep/base,config/config.align.c,35,1,24,1923543.05181645,171937.0,11.187487277316691,1223.0,1211.0,38862.0,13143.0,1592.0,636.0,1325.0,593.0,1500000000,0.0012823620345443,1082014363648.0,0.0141563479646614,0.0797231035477357,"/* This program will most likely crash on systems that need shorts and ints
   to be word aligned
  Copyright (C) 2005 Free Software Foundation

  Copying and distribution of this file, with or without modification,
  are permitted in any medium without royalty provided the copyright
  notice and this notice are preserved.

*/
#include <stdlib.h>

int main ()
{
  char  *buf = malloc(30);
  void  *v;
  short *sp;
  short *sq;
  int   *ip;
  int   *iq;
  int   i;

  for (i = 0 ; i < 30; i++)
    {
      buf[i] = i;
    }
  v = buf;

  sp = (short*)(v + 1);
  sq = (short*)(v + 2);
  if (*sp == *sq)
    {
      return 1;
    }

  ip = (int*)(v + 1);
  iq = (int*)(v + 2);
  if (*ip == *iq)
    {
      return 1;
    }

  return 0;
}

"
364-17399,Mikescher/Project-Euler_Befunge,compiled/C/Euler_Problem-012.c,218,3,165,60168626.83463836,264329080.0,0.2276277207184317,1448.0,1426.0,75970850.0,46700013.0,39406.0,313867.0,1358.0,23890.0,1500000000,0.0401124178897589,1082014363648.0,1.0872810513319231e-05,0.0030856634635398,"/* transpiled with BefunCompile v1.3.0 (c) 2017 */
#include <stdio.h>
#include <stdlib.h>
#define int64 long long
char* _g = ""v     // Project Euler - Problem 12{ } ?4{#}0Zz{ } +@v  p03+1g03 p04+1g04   p +3/g01\\%g01:g04 g03 <{ } )6>\""d\""55+*:10p3\""2\""*:20p*0""
           ""0p230p\"" \"":03p13p{ }  ,v{ }  .>130p040p  > 30g:10g%\\10g/3+g\"" \""- 00g30g` !#v_{ }  *|{ } )6v{ }  R<{ }  -_^#`g03g00 <^{ }  8p03+1g0""
           ""3{ }  ,<{ } )6> \""X\"" 30g:10g%\\10g/3+p30g >30g+ : 00g\\`     #v_$>30g1+:30p:10g%\\10g/3+g\"" \""- |{ } )~^p+3/g01\\%g01:\\\"" \"":<  ^{ }  ;<{""
           "" } *(v{ }  \\+1$<{ } )]>:1+2/>:01p31p111p0>::10g%\\10g/3+g::*01g`#v_121p>:31g\\%{ }  )!#v_11g21g*11p31g1-|{ } * v{ }  (<    ^p13/\\g""
           ""13:p12+1g12<{ } )jv{ }  6<{ }  *vp21<*2g11$$<^g11$${ }  B<{ } )M>2 212p222p >:2%|{ }  =>12g22g*\""d\""5*` #v_1+    1v{ } *-|{ }  C<{""
           "" }  70+1$<{ } )]>:1+  >:01p31p111p0>::10g%\\10g/3+g::*01g`#v_121p>:31g\\%{ }  )!#v_11g21g*11p31g1-|{ } ){#   v{ }  (<  v ^p13/\\g13""
           "":p12+1g12<{ } *-^p22<*2g11$$<^g11$${ }  B<{ } *,>$$:1+*2/.@{ } )h^{ } !%$p05-1g04<{ } )B"";
int t=0;int z=0;
int64 g[170000];
int d(){int s,w,i,j,h;h=z;for(;t<856;t++)if(_g[t]==';')g[z++]=_g[++t];else if(_g[t]=='}')return z-h;else if(_g[t]=='{'){t++;s=z;w=d();for(i=1;i<_g[t+1]*9025+_g[t+2]*95+_g[t+3]-291872;i++)for(j=0;j<w;g[z++]=g[s+j++]);t+=3;}else g[z++]=_g[t];return z-h;}
int64 gr(int64 x,int64 y){if(x>=0&&y>=0&&x<1000&&y<170){return g[y*1000+x];}else{return 0;}}
void gw(int64 x,int64 y,int64 v){if(x>=0&&y>=0&&x<1000&&y<170){g[y*1000+x]=v;}}
int64 td(int64 a,int64 b){ return (b==0)?0:(a/b); }
int64 tm(int64 a,int64 b){ return (b==0)?0:(a%b); }
int64*s;int q=16384;int y=0;
int64 sp(){if(!y)return 0;return s[--y];}
void sa(int64 v){if(q-y<8)s=(int64*)realloc(s,(q*=2)*sizeof(int64));s[y++]=v;}
int64 sr(){if(!y)return 0;return s[y-1];}
int main(void)
{
    int64 t0,t1;
    d();
    s=(int64*)calloc(q,sizeof(int64));
    gw(1,0,1000);
    gw(2,0,150);
    gw(0,0,150000);
    gw(3,0,2);
    gw(0,3,32);
    gw(1,3,32);
_1:
    gw(tm(gr(3,0),gr(1,0)),(td(gr(3,0),gr(1,0)))+3,88);
    sa(gr(3,0)+gr(3,0));
    sa((gr(3,0)+gr(3,0))<gr(0,0)?1:0);
_2:
    if(sp()!=0)goto _35;else goto _3;
_3:
    sp();
_4:
    sa(gr(3,0)+1);
    sa(gr(3,0)+1);
    gw(3,0,gr(3,0)+1);
    sa(tm(sp(),gr(1,0)));

    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    sa(td(sp(),gr(1,0)));

    sa(sp()+3LL);

    {int64 v0=sp();t0=gr(sp(),v0);}
    t0-=32;
    if((t0)!=0)goto _6;else goto _4;
_6:
    if(gr(0,0)>gr(3,0))goto _1;else goto _7;
_7:
    gw(3,0,1);
    gw(4,0,0);
_8:
    t0=gr(tm(gr(3,0),gr(1,0)),(td(gr(3,0),gr(1,0)))+3)-32;

    if(gr(0,0)>gr(3,0))goto _32;else goto _9;
_9:
    gw(5,0,gr(4,0)-1);
    gw(1,2,2);
    gw(2,2,2);
    sa(2);
    sa(0);
_10:
    if(sp()!=0)goto _23;else goto _11;
_11:
    sa(sr()+1);
    sa(sr());
    gw(0,1,sp());
    gw(3,1,sp());
    gw(1,1,1);
    sa(0);
    sa(gr(0,3));
    sa((gr(0,3)*gr(0,3))>gr(0,1)?1:0);
_12:
    if(sp()!=0)goto _22;else goto _13;
_13:
    gw(2,1,1);
_14:
    t0=gr(3,1);
    sa(sr());
    sa(t0);
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    {int64 v0=sp();sa(tm(sp(),v0));}

    t1=sp();

    if((t1)!=0)goto _15;else goto _21;
_15:
    gw(1,1,gr(1,1)*gr(2,1));

    if(gr(3,1)!=1)goto _16;else goto _17;
_16:
    sp();
    sa(sp()+1LL);

    sa(sr());
    sa(tm(sr(),gr(1,0)));
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    sa(td(sp(),gr(1,0)));

    sa(sp()+3LL);

    {int64 v0=sp();sa(gr(sp(),v0));}
    sa(sr());
    sa(sr());
    sa(sp()*sp());

    sa((sp()>gr(0,1))?1:0);
    goto _12;
_17:
    gw(2,2,gr(1,1));
    sp();
    sp();
_18:
    if((gr(1,2)*gr(2,2))>500)goto _20;else goto _19;
_19:
    sa(sp()+1LL);

    sa(sr()%2);
    goto _10;
_20:
    t0=1;
    t1=1;
    t0=sr()+1;
    sa(sp()*t0);

    t1=sp();
    t1/=2;
    printf(""%lld "", t1);
    return 0;
_21:
    gw(2,1,gr(2,1)+1);
    t0=gr(3,1);
    sa(sr());
    sa(t0);
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    {int64 v0=sp();sa(td(sp(),v0));}

    t1=sp();
    gw(3,1,t1);
    goto _14;
_22:
    gw(2,2,gr(1,1)*2);
    sp();
    sp();
    goto _18;
_23:
    sa((sr()+1)/2);
    sa(sr());
    gw(0,1,sp());
    gw(3,1,sp());
    gw(1,1,1);
    sa(0);
    sa(gr(0,3));
    sa((gr(0,3)*gr(0,3))>gr(0,1)?1:0);
_24:
    if(sp()!=0)goto _31;else goto _25;
_25:
    gw(2,1,1);
_26:
    t0=gr(3,1);
    sa(sr());
    sa(t0);
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    {int64 v0=sp();sa(tm(sp(),v0));}

    t1=sp();

    if((t1)!=0)goto _27;else goto _30;
_27:
    gw(1,1,gr(1,1)*gr(2,1));

    if(gr(3,1)!=1)goto _28;else goto _29;
_28:
    sp();
    sa(sp()+1LL);

    sa(sr());
    sa(tm(sr(),gr(1,0)));
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    sa(td(sp(),gr(1,0)));

    sa(sp()+3LL);

    {int64 v0=sp();sa(gr(sp(),v0));}
    sa(sr());
    sa(sr());
    sa(sp()*sp());

    sa((sp()>gr(0,1))?1:0);
    goto _24;
_29:
    gw(1,2,gr(1,1));
    sp();
    sp();
    goto _18;
_30:
    gw(2,1,gr(2,1)+1);
    t0=gr(3,1);
    sa(sr());
    sa(t0);
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    {int64 v0=sp();sa(td(sp(),v0));}

    t1=sp();
    gw(3,1,t1);
    goto _26;
_31:
    gw(1,2,gr(1,1)*2);
    sp();
    sp();
    goto _18;
_32:
    if((t0)!=0)goto _33;else goto _34;
_33:
    gw(tm(gr(4,0),gr(1,0)),(td(gr(4,0),gr(1,0)))+3,gr(3,0));
    gw(4,0,gr(4,0)+1);
    gw(3,0,gr(3,0)+1);
    goto _8;
_34:
    gw(3,0,gr(3,0)+1);
    goto _8;
_35:
    sa(sr());
    sa(32);
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    sa(tm(sr(),gr(1,0)));
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    sa(td(sp(),gr(1,0)));

    sa(sp()+3LL);

    {int64 v0=sp();int64 v1=sp();gw(v1,v0,sp());}
    sa(sp()+gr(3,0));

    sa(sr()<gr(0,0)?1:0);
    goto _2;
}
"
205-4705,zeuzoix/Salmon,issort.c,52,3,35,1505761.4073156,172821.0,8.71283582435005,1151.0,1142.0,39539.0,13121.0,1595.0,587.0,1339.0,546.0,1500000000,0.0010038409382104,1082014363648.0,0.0132680634876548,0.0772312951006456,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>


int issort(void *data, int size, int esize,
		int (*compare)(void *key1, void *key2))
{
	int ret = -1;
	int i = 0;
	int j = 0;
	char *ele = (char *)data;
	char *temp = NULL;

	if((NULL==data) || (0==size) || (0==esize) || (NULL==compare)) {
		ret = -1;
		goto LBL_RET;
	}

	temp = malloc(esize);
	if(NULL == temp) {
		ret = -2;
		goto LBL_RET;
	}

	for(i=1 ; i<size ; i++) {
		memcpy(temp, &ele[i], esize);
		j = i-1;
		while((j>=0) && (0 < compare(temp, &ele[j]))) {
			memcpy(&ele[j+1],&ele[j],esize);
			--j;
		}
		++j;
		memcpy(&ele[j], temp, esize);
		
	}
	free(temp);
	ret = 0;
LBL_RET:
	return ret;
}

int compare_char(void *key1, void *key2)
{
	if(*(char *)key1 > *(char *)key2)
		return 1;
	else if(*(char *)key1 < *(char *)key2)
		return -1;
	else
		return 0;
}

int main(int argc, char *argv[])
{
	int i = 1;
	while(i < argc) {
		printf(""%s\n"",argv[i]);
		issort(argv[i], strlen(argv[i]), sizeof(*argv[0]), compare_char);
		printf(""%s\n"",argv[i]);
      i++;
	}

	return 0;
}
"
374-13879,b3h3moth/L-LP,src/C/C_lang/functions/get_hash_string.c,23,2,23,2048134.454526,191535.0,10.693262328034042,1368.0,1345.0,42817.0,15688.0,1631.0,645.0,1349.0,601.0,1500000000,0.001365422969684,1082014363648.0,0.0141645130132873,0.0722331424664558,"#include <stdio.h>
#include <stdlib.h>

#define VEC_SIZE(x) (sizeof(x)/sizeof(x[0]))
enum { 
    A = 127,
    M = 96
};

unsigned int hash(char *str);

/* Lo scopo del programma e' di creare una funzione hash da utilizzare con
le stringhe */

int main(void) {
    char *strings[] = { ""take"", ""a"", ""walk"", ""on"", ""the"", ""wild"", ""side"",
                        ""song"", ""composed"", ""by"", ""Lou"", ""Reed"", ""and"", 
                        ""Velvet"", ""undeground""};
    
    for (int i=0; i<VEC_SIZE(strings); i++)
        printf(""hash of \'%11s\' is: %u\n"", strings[i], hash(strings[i]));

    return(EXIT_SUCCESS);
}

// Tipica funzione hash per le stringhe
unsigned int hash(char *str) {
    unsigned char *p;
    int h = 0;

    for (p = (unsigned char *)str; *p != '\0'; p++)
        h = (A * h + *p) % M;

    return h;
}

"
102-33777,ColinIanKing/stress-ng,test/test-atomic_or_fetch.c,25,1,26,1887589.22740815,170439.0,11.071034211653435,1145.0,1137.0,38727.0,12788.0,1581.0,586.0,1326.0,544.0,1500000000,0.0012583928182721,1082014363648.0,0.0133889544059751,0.0783655246044841,"/*
 * Copyright (C) 2017-2021 Canonical, Ltd.
 * Copyright (C)      2022 Colin Ian King
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 */

int main(int argc, char **argv)
{
	int var;

	__atomic_or_fetch(&var, 1, 0);

	return 0;
}

"
076-31229,jyheo/OperatingSystemExercise,thread.c,20,2,19,3002226778.3060675,188476.0,15928.96059975806,1543.0,1508.0,42991.0,15846.0,1671.0,793.0,1370.0,750.0,1500000000,2.0014845188707118,1082014363648.0,0.0161877374307604,0.0779101585736866,"#include <stdio.h>
#include <pthread.h>
#include <sched.h>
#include <unistd.h>

void *thread_entry(void *ptr)
{
	char *name = (char *)ptr;

	printf(""%s-A\n"", name);

	sleep(1); //sched_yield();

	printf(""%s-B\n"", name);

	sleep(1); //sched_yield();

	printf(""%s-C\n"", name);
}

int main()
{
#define MAX_THREAD	3
    pthread_t thread[MAX_THREAD];
    char *thread_name[MAX_THREAD] = {""thread1"", ""thread2"", ""thread3""};
    int i;

    for (i = 0; i < MAX_THREAD; i++)
        pthread_create(&thread[i], NULL, thread_entry, thread_name[i]);

    for (i = 0; i < MAX_THREAD; i++)
        pthread_join(thread[i], NULL);

    return 0;
}

"
231-19156,frivoal/presto-testo,imported/peter/unicode/tables/big5.c,66,5,49,6325510.4469135,10706437.0,0.5908137319633039,1466.0,1439.0,2351367.0,1758975.0,1656.0,770.0,1366.0,726.0,1500000000,0.004217006964609,1082014363648.0,0.0002713320967563,0.0010991786084953,"#include <stdio.h>

int main(void)
{
	int i, j, pl;
	FILE *b5 = fopen(""big5-table.html"", ""w"");
	if (!b5) return 1;

	fputs(""<html lang=zh-tw>\n <head>\n  <meta http-equiv=\""Content-Type\"" ""
	      ""content=\""text/html;charset=big5\"">\n  <title>Big5</title>\n""
	      ""  <style>.unused { background: #ccc; }""
	      "" table { float: left; }</style>\n""
	      "" </head>\n <body>\n""
		  ""  <table><caption>ASCII/CNS-Roman</caption>\n""
	      ""   <tr><th>  "", b5);

	for (i = 0; i < 16; i ++)
	{
		fprintf(b5, ""<th>%X"", i);
	}

	/* Singlebyte */

	for (i = 32; i < 128; i ++)
	{
		if (0 == (i & 0x0F))
		{
			fprintf(b5, ""\n   <tr><th>%02X"", i);
		}
		fprintf(b5, ""<td%s>%c"",
		        (127 == i) ? "" class=unused"" : """",
		        (char) i);
	}

	fputs(""\n  </table>\n"", b5);

	/* Row-cell multibyte */

	for (i = 0xA1; i <= 0xFE; i ++)
	{
		if (0xA0 == i)
		{
			i = 0xE0;
		}

		fprintf(b5, ""  <table><caption>Multibyte: Big5 (Lead %X)</caption>\n   <tr><th> "", i);
		for (j = 0; j < 16; j ++)
		{
			fprintf(b5, ""<th>%X"", j);
		}
		for (j = 0x40; j < 0x100; j ++)
		{
			if (0x80 == j)
			{
				j = 0xA0;
			}
			if (0 == (j & 0x0F))
			{
				fprintf(b5, ""\n   <tr><th>%02X"", j);
			}
			if (0x7F == j || 0xA0 == j || j > 0xFE)
			{
				fputs(""<td class=unused>&nbsp;"", b5);
			}
			else
			{
				fprintf(b5, ""<td>%c%c"", (char) i, (char) j);
			}
		}
		fputs(""\n  </table>\n"", b5);
	}

	/* End */

	fputs(""\n </body>\n</html>\n"", b5);
	fclose(b5);

	return 0;
}
"
392-34916,luozhao/Classical-algorithm,heap_sort.c,93,3,69,1911931.67120205,179933.0,10.625794045561404,1349.0,1329.0,40576.0,14302.0,1619.0,638.0,1340.0,595.0,1500000000,0.0012746211141347,1082014363648.0,0.0148833176793584,0.0763876234556653,"//堆结构采用数组实现，其实索引为0
#include <stdio.h>
#define MAX_HEAP_LEN 100
static int heap[MAX_HEAP_LEN];
static int heap_size = 0;       // the number of the elements int heaps

static void swap(int *a, int *b)
{
    int temp = 0;
    temp = *b;
    *b = *a;
    *a = temp;
}

/*
* void shift_up(int i)
* 
*/
static void shift_up(int i)
{
  int done = 0;
  if(i == 0) return ;     //  node is root already
 
  while(i!=0 && (!done))
  {
    if(heap[i] > heap[(i-1)/2])
    {// the current is larger than the parent , then swap
        swap(&heap[i], &heap[(i-1)/2]);
    }
    else
    {// the job is already done
        done = 1;
    }
    i = (i-1)/2;
  }
}
/*
*
*/
static void shift_down(int i)
{
  int done = 0;
  if(2*i+1 > heap_size) return; // node i is a leaf
  
  while(2*i + 1 < heap_size && (!done))
  {
    i = 2*i + 1;        // jump to the left child
    if((i+1 <  heap_size)&&(heap[i+1] > heap[i]))
    {// find the bigger one of the two children
      i++;
    }
    if(heap[(i-1)/2] < heap[i])
    {
      swap(&heap[(i-1)/2],&heap[i]);
    }
    else
    {
      done = 1;
    }
  }
}

static void delete(int i)
{
	 int last = heap[heap_size-1];  //  get the last one;
	 heap_size--;                   //  shrink the heap
	 if(i == heap_size) return;
	 heap[i] = last;                //  use the last item to overwrite the current
	 shift_down(i);
}

int delete_max()
{
  int ret = heap[0];
  delete(0);
  return ret;
}

void insert(int new_data)
{
  if(heap_size > MAX_HEAP_LEN) return;
  heap_size++;
  heap[heap_size -1 ] = new_data;
  shift_up(heap_size-1);
}

int main()
{
	
	int i = 0;
	heap_size = 10;
	
	insert(3);
	insert(7);
	insert(13);
	insert(83);
	insert(23);
	insert(11);
	insert(31);
	insert(12);
	insert(35);

	for(i = 0; i < heap_size; i++)
		printf(""%d "",delete_max());

	return 0;
}
"
157-5749,arthurpessoa/psxsdk,tools/lictool.c,76,6,36,1407378.12034785,177859.0,7.912886050185821,1302.0,1287.0,40585.0,13876.0,1657.0,639.0,1379.0,596.0,1500000000,0.0009382520802319,1082014363648.0,0.0145564745107079,0.078423091753732,"/*
 * lictool
 * 
 * Tool for manipulating PS1 license files
 */
 
#include <stdio.h>
#include <string.h>

unsigned char lic_buffer[37632]; // 16 CD sectors..

//0x2E08

void display_usage();

void display_usage()
{
	printf(""""
	""lictool - PS1 license file manipulation tool\n""
	""usage: lictool <input> <output> <options>\n""
	""\n""
	""Options:\n""
	"" -tmd=<file>      TMD file for boot logo\n""
	"" -removelogo      Remove logo from license file\n"");
}

int main(int argc, char *argv[])
{
	int x,y,z,sz;
	FILE *f;
	
	if(argc < 3)
	{
		display_usage();
		return 0;
	}
	
	f = fopen(argv[1], ""rb"");
	
	if(f == NULL)
	{
		printf(""Could not open input license file! Aborting.\n"");
		return -1;
	}
	
	fread(lic_buffer, sizeof(char), 37632, f);
	fclose(f);
	
	for(x = 3; x < argc; x++)
	{
		if(strncmp(argv[x], ""-tmd="", 5) == 0)
		{
			f = fopen(argv[x] + 5, ""rb"");
			
			if(f == NULL)
				printf(""Could not open TMD file %s. Ignoring option.\n"", argv[x] + 5);
			else
			{				
				fseek(f, 0, SEEK_END);
				sz = ftell(f);
				fseek(f, 0, SEEK_SET);
				z = 0x2E08;
				
				for(y = 0; y < sz; y++)
				{
					if((z - ((z / 2352)*2352)) == 2072)
						z+=304;
					
					fread(&lic_buffer[z], sizeof(char), 1, f);
					
					z++;
				}
			
				fclose(f);
			}
		}
		else if(strncmp(argv[x], ""-removelogo"", 11) == 0)
		{
			z = 0x2E08;
			
			for(y = 0; y < 12; y++)
				lic_buffer[z+y] = 0;
			
			lic_buffer[z] = 0x41;
		}
	}
	
	f = fopen(argv[2], ""wb"");
	
	if(f == NULL)
	{
		printf(""Could not open output file path for writing! Aborting.\n"");
		return -1;
	}
	
	fwrite(lic_buffer, sizeof(char), 37632, f);
	fclose(f);
	
	return 0;
}
"
340-19775,alexhilton/miscellaneous,linux/advanced-prog-in-unix/chap06/ex0602.c,21,2,24,1613402.8555824,173053.0,9.319855766730424,1149.0,1140.0,39476.0,13106.0,1604.0,587.0,1345.0,546.0,1500000000,0.0010756019037216,1082014363648.0,0.0132271616210062,0.0776311285230687,"/*
 * eg0606.c
 * implementation of getspnam.
 * using getspent, setspent and endspent.
 */
#include <stdio.h>
#include <string.h>
#include <shadow.h>

int main( int argc, char **argv ) {
  struct spwd *p;
  while ( --argc > 0 ) {
    setspent();
    argv++;
    while ( (p = getspent()) != NULL ) {
      if ( strcmp( p->sp_namp, *argv ) == 0 ) {
	/* match found */
	printf( ""%s, %s\n"", p->sp_namp, p->sp_pwdp );
	break;
      }
    }
    endspent();
  }
  return 0;
}
"
392-8017,YoungHubber/os_2017,Week10/lab10/sem_and_cond/e14-backoff-1.c,91,8,66,15019009207.491762,325530.0,46137.0970632507,2321.0,1780.0,76433.0,33725.0,2212.0,896.0,1639.0,809.0,1500000000,10.012672804994509,1082014363648.0,0.0125979172426504,0.0504366455454892,"/*
 * backoff.c
 *
 * Demonstrates deadlock avoidance using ""mutex backoff"".
 * 
 * uses usleep   (microsleep)
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>		// for usleep
#include <pthread.h>
#include <errno.h> 		// for EBUSY

#define ITERATIONS 10

/*
 * Initialize a static array of 3 mutexes.
 */
pthread_mutex_t mutex[3] = {
    PTHREAD_MUTEX_INITIALIZER,
    PTHREAD_MUTEX_INITIALIZER,
    PTHREAD_MUTEX_INITIALIZER
    };
    

/*
 * This is a thread start routine that locks all mutexes 
 * in order. This ensures a conflict with lock_backward, 
 * which does the opposite.
 */
void *
lock_forward (void *arg)
{
    int i, iterate, backoffs;
    int status;

    for (iterate = 0; iterate < ITERATIONS; iterate++) {
        backoffs = 0;
        status = pthread_mutex_lock (&mutex[0]);
        for (i = 1; i < 3; i++) {  
          status = pthread_mutex_trylock (&mutex[i]);
          if (status == EBUSY) {
            backoffs++;
            printf(""forward locker backing off at %d\n"",i);
            for (; i >= 0; i--) 
              pthread_mutex_unlock (&mutex[i]);
          }
          else
            printf("" forward locker got %d\n"", i);
          usleep (rand() % 10);
        }

        printf (""lock forward got all locks, %d backoffs\n"", backoffs);
        pthread_mutex_unlock (&mutex[2]);
        pthread_mutex_unlock (&mutex[1]);
        pthread_mutex_unlock (&mutex[0]);
        sleep (1);
  }
  return NULL;
}

/*
 * This is a thread start routine that locks all mutexes in
 * reverse order. This ensures a conflict with lock_forward, 
 * which does the opposite.
 */
void *
lock_backward (void *arg)
{
    int i, iterate, backoffs;
    int status;

    for (iterate = 0; iterate < ITERATIONS; iterate++) {
        backoffs = 0;
        status = pthread_mutex_lock (&mutex[2]);
        for (i = 2; i >= 0; i--) {  
          status = pthread_mutex_trylock (&mutex[i]);
          if (status == EBUSY) {
            backoffs++;
            printf(""backward locker backing off at %d\n"",i);
            for (; i <3; i++) 
              status = pthread_mutex_unlock (&mutex[i]);
          }
          else
            printf("" backward locker got %d\n"", i);
          usleep (rand() % 10);            
        }
        /*
         * Report that we got them, and unlock to try again.
         */
        printf (
            ""lock forward got all locks, %d backoffs\n"", backoffs);
        pthread_mutex_unlock (&mutex[2]);
        pthread_mutex_unlock (&mutex[1]);
        pthread_mutex_unlock (&mutex[0]);
        sleep (1);
  }
    return NULL;
}

int main (int argc, char *argv[]){
    pthread_t forward, backward;

    pthread_create (&forward, NULL, lock_forward, NULL);
    pthread_create (&backward, NULL, lock_backward, NULL); 
    pthread_exit (NULL);
}
"
171-172,bfosterscripps/learning,C/1988/exercises/exercise_3-3_expand.c,29,3,25,1966203.0972540001,224682.0,8.751048148049243,1344.0,1326.0,49865.0,20716.0,1627.0,639.0,1346.0,596.0,1500000000,0.001310802064836,1082014363648.0,0.0118834619595695,0.0596194443263767,"/*
Date: 20150731
Author: Brandon Foster

Purpose:
Write a function, `expand(s1, s2)`, that expands shorthand notations like `a-z` in the string, `s1`, into the equivalent complete list, `abcdefghijklmnopqrstuvwxyz`, in `s2`.

Allow for letters of either case and digits, and be prepared to handle cases like `a-b-c` and `a-z0-9`, and `-a-z`. 
Arrange that a leading or trailing `-` is taken literally.

*/

#include <stdio.h>
#define INDEXLENGTH 62

int expand(char originalString[], char newString[]){
	char theIndex[INDEXLENGTH];

	for(int i = 0; i < INDEXLENGTH; i++){
		if(i < 10){
			theIndex[i] = i + 48;
		}	else if (i < 36){
			theIndex[i] = i + 55; // 55 because ASCII 65 is A, minus the first 10 chars
		} else {
			theIndex[i] = i + 61; // ASCII 97 is a, minus the first 36 chars
		}
	}
	for(int i = 0; i < INDEXLENGTH; i++){
		printf(""%d %c\n"", i, theIndex[i]);
	}

	return 0;
}

int main(){
	
	char original[5], new[5];

	expand(original, new);

	return 0;
}
"
329-32428,swigger/gdb-ios,gdb/testsuite/gdb.python/py-bad-printers.c,44,1,29,1837594.6674495,169062.0,10.869349706025009,1140.0,1130.0,38452.0,12697.0,1567.0,589.0,1316.0,548.0,1500000000,0.001225063111633,1082014363648.0,0.0134270267712436,0.078593911904436,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2008-2016 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* This lets us avoid malloc.  */
int array[100];

struct container
{
  const char *name;
  int len;
  int *elements;
};

struct container
make_container (const char *name)
{
  struct container result;

  result.name = name;
  result.len = 0;
  result.elements = 0;

  return result;
}

void
add_item (struct container *c, int val)
{
  if (c->len == 0)
    c->elements = array;
  c->elements[c->len] = val;
  ++c->len;
}

int
main ()
{
  struct container c = make_container (""foo"");

  add_item (&c, 23);

  return 0; /* break here */
}
"
141-33352,GreenteaOS/Kernel,third-party/reactos/boot/freeldr/tools/rrmdir.c,73,2,35,1818363.0891143999,171881.0,10.579197235296514,1147.0,1139.0,39242.0,13025.0,1597.0,586.0,1339.0,546.0,1500000000,0.0012122420594096,1082014363648.0,0.0132998993489681,0.0778311362810186,"/*
 * COPYRIGHT:             See COPYING in the top level directory
 * PROGRAMMER:            Rex Jolliff (rex@lvcablemodem.com)
 *                        Casper S. Hornstrup (chorns@users.sourceforge.net)
 * PURPOSE:               Platform independant remove directory command
 */

#include <dirent.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

void
convertPath (char * pathToConvert)
{
  while (*pathToConvert != 0)
  {
    if (*pathToConvert == '\\')
    {
      *pathToConvert = '/';
    }
    pathToConvert++;
  }
}

void
getDirectory (const char *filename, char * directorySpec)
{
  int  lengthOfDirectory;

  if (strrchr (filename, '/') != 0)
  {
    lengthOfDirectory = strrchr (filename, '/') - filename;
    strncpy (directorySpec, filename, lengthOfDirectory);
    directorySpec [lengthOfDirectory] = '\0';
  }
  else
  {
    strcpy (directorySpec, ""."");
  }
}

void
getFilename (const char *filename, char * fileSpec)
{
  if (strrchr (filename, '/') != 0)
  {
    strcpy (fileSpec, strrchr (filename, '/') + 1);
  }
  else
  {
    strcpy (fileSpec, filename);
  }
}

int
main (int argc, char* argv[])
{
  int  justPrint = 0;
  int  idx;
  int  returnCode;

  for (idx = 1; idx < argc; idx++)
  {
    convertPath (argv [idx]);

    if (justPrint)
    {
      printf (""remove %s\n"", argv [idx]);
    }
    else
    {
      returnCode = rmdir (argv [idx]);
      if (returnCode != 0 && errno != ENOENT)
      {
      /* Continue even if there is errors */
#if 0
        printf (""Rmdir of %s failed.  Rmdir returned %d.\n"",
                argv [idx],
                returnCode);
        return  returnCode;
#endif
      }
    }
  }

  return  0;
}


"
247-31043,mattstock/binutils-bexkat1,gdb/testsuite/gdb.base/testenv.c,32,2,28,1885398.0582207,177980.0,10.59331385548938,1351.0,1330.0,40205.0,13564.0,1691.0,637.0,1354.0,593.0,1500000000,0.0012569320388138,1082014363648.0,0.0150634902798067,0.0795067789990515,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2011-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/*
    This source is used to check that GDB correctly
    passes on environment variables down to inferior.
    One of the tests checks that 'unset' variables also are removed from
    inferior environment list.  */

#include <stdio.h>
#include <string.h>

int main (int argc, char **argv, char **envp)

{
    int i, j;

    j = 0;
    for (i = 0; envp[i]; i++)
      {
	if (strncmp (""TEST_GDB"", envp[i], 8) == 0)
	  {
	    printf (""%s\n"", envp[i]);
	    j++;
	  }
      }
    printf (""Program found %d variables starting with TEST_GDB\n"", j);
    return 0; /* set breakpoint here.  */
}

"
285-597,ColinIanKing/stress-ng,test/test-getdomainname.c,24,1,24,1957204.4257073998,170982.0,11.446842357675076,1153.0,1145.0,38946.0,12876.0,1590.0,586.0,1333.0,545.0,1500000000,0.0013048029504716,1082014363648.0,0.0134400112292522,0.0782293234533595,"/*
 * Copyright (C) 2013-2021 Canonical, Ltd.
 * Copyright (C)      2022 Colin Ian King
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 */

#include <unistd.h>

int main(void)
{
	char name[128];

	return getdomainname(name, sizeof(name));
}
"
034-26697,justanotherdot/Playground,C/qsort.c,51,3,35,1880241.0922943999,186891.0,10.060628922741063,1366.0,1341.0,42295.0,15344.0,1633.0,636.0,1352.0,594.0,1500000000,0.0012534940615296,1082014363648.0,0.0144843785950099,0.073127569874564,"#include <stdio.h>

// A down and dirty integer quicksort implementation.

void swap(int* a, int* b) {
	int t = *a;
	*a = *b;
	*b = t;
}

int partition(int* arr, int lo, int hi) {
	// TODO make this randomized.
	int pivot = arr[hi];
	int i     = (lo-1);

	for (int j = lo; j <= hi-1; j++) {
		if (arr[j] <= pivot) {
			i++;
			swap(&arr[i], &arr[j]);
		}
	}
	swap(&arr[i+1], &arr[hi]);
	return (i+1);
}

void qsort(int* arr, int lo, int hi) {
	if (lo < hi) {
		int wall = partition(arr, lo, hi);

		qsort(arr, lo, wall-1);
		qsort(arr, wall+1, hi);
	}
}

int main(void) {
	int n = 10;
	int test[n];
	test[0] = 9;
	test[1] = 4;
	test[2] = 1;
	test[3] = -18;
	test[4] = 3;
	test[5] = 6;
	test[6] = 7;
	test[7] = 2;
	test[8] = 0;
	test[9] = -2;

	// Print prior to qsort.
	for (int i = 0; i < n; i++) {
		printf(""%d "", test[i]);
	}
	printf(""\n"");

	qsort(test, 0, n-1);

	// Print after qsort.
	for (int i = 0; i < n; i++) {
		printf(""%d "", test[i]);
	}
	printf(""\n"");
}


"
220-14618,Kattis/problemtools,examples/hello/submissions/accepted/hello_alarm.c,26,5,26,1501624692.2314167,391218811.0,3.838324359101434,1298.0,1283.0,130387762.0,13438.0,1622.0,644.0,1340.0,592.0,1500000000,1.0010831281542778,1082014363648.0,6.597331026600354e-06,3.2192955279552645e-05,"#include <signal.h>
#include <stdio.h>
#include <stdlib.h>

/* Based on the libc manual*/   

/* This flag controls termination of the main loop. */
volatile sig_atomic_t keep_going = 1;
     
/* The signal handler just clears the flag and re-enables itself. */
void catch_alarm (int sig)
{
  keep_going = 0;
  signal (sig, catch_alarm);
}

void do_nothing (void)
{
  int i=0;
  for (i=0;i<1000;i+=1);
}

int main (void)
{
  /* Establish a handler for SIGALRM signals. */
  signal (SIGALRM, catch_alarm);
  /* Set an alarm to go off in a little while. */
  alarm (1);
  /* Check the flag once in a while to see when to quit. */
  while (keep_going)
    do_nothing();
  
  printf(""Hello World!\n"");
  return EXIT_SUCCESS;
}
"
360-2648,leeduhem/prelink,testsuite/reloc4lib2.c,14,3,13,23671970.819122948,145030449.0,0.1632206902979387,1365.0,1342.0,29843365.0,19331888.0,1632.0,699.0,1349.0,656.0,1500000000,0.0157813138794153,1082014363648.0,1.866504598630871e-05,8.817443196479335e-05,"#include <stdio.h>

int main (void)
{
  int i, j;

  for (i = 0; i < 256; ++i)
    {
      printf (""extern int "");
      for (j = 0; j < 255; ++j)
	printf (""foo%02x%02x (void), "", i, j);
      printf (""foo%02xff (void);\nint bar%02x (int x) { return x"", i, i);
      for (j = 0; j < 256; ++j)
	printf ("" + foo%02x%02x ()"", i, j);
      printf (""; }\n"");
    }
}
"
394-14057,mattstock/binutils-bexkat1,gdb/testsuite/gdb.stabs/gdb11479.c,60,2,29,1463896.24569555,169057.0,8.659185955032918,1139.0,1129.0,38452.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0009759308304637,1082014363648.0,0.0134155935572026,0.0785172440760147,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2010-2020 Free Software Foundation, Inc.

   Contributed by Pierre Muller.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

   Qualifiers of forward types are not resolved correctly with stabs.  */

struct dummy;

enum dummy_enum;

/* This function prevents the compiler from dropping local variables
   we need for the test.  */
void *hack (const struct dummy *t, const enum dummy_enum *e);

const void *
test (const struct dummy *t)
{
  const struct dummy *tt;
  enum dummy_enum *e;
  tt = t;
  return hack (t, e);
}

void *
test2 (struct dummy *t)
{
  struct dummy *tt;
  const enum dummy_enum *e;
  tt = t;
  return hack (t, e);
}


struct dummy {
 int x;
 int y;
 double b;
} tag_dummy;

enum dummy_enum {
  enum1,
  enum2
} tag_dummy_enum;

void *
hack (const struct dummy *t, const enum dummy_enum *e)
{
  return (void *) t;
}

int
main ()
{
  struct dummy tt;
  tt.x = 5;
  tt.y = 25;
  tt.b = 2.5;
  test2 (&tt);
  test (&tt);
  return 0;
}
"
294-15234,jzeng4/pemu,plugins/glibc-2.13-new/manual/examples/sigh1.c,26,6,21,4185542135.9650793,557608956.0,7.506231903133206,1308.0,1293.0,156451076.0,76797906.0,1624.0,704.0,1341.0,655.0,1500000000,2.7903614239767194,1082014363648.0,4.664559225623342e-06,1.8538130211432177e-05,"#include <signal.h>
#include <stdio.h>
#include <stdlib.h>

/* This flag controls termination of the main loop. */
volatile sig_atomic_t keep_going = 1;

/* The signal handler just clears the flag and re-enables itself. */
void 
catch_alarm (int sig)
{
  keep_going = 0;
  signal (sig, catch_alarm);
}

void 
do_stuff (void)
{
  puts (""Doing stuff while waiting for alarm...."");
}

int
main (void)
{
  /* Establish a handler for SIGALRM signals. */
  signal (SIGALRM, catch_alarm);

  /* Set an alarm to go off in a little while. */
  alarm (2);

  /* Check the flag once in a while to see when to quit. */
  while (keep_going)
    do_stuff ();

  return EXIT_SUCCESS;
}
"
301-2478,tudinfse/fex,src/micro/struct/struct.c,21,1,19,1642626193.7012897,671262627.0,2.4470693390770286,1341.0,1334.0,39427.0,134231167.0,1677.0,33555090.0,1419.0,33555050.0,1500000000,1.095084129134193,1082014363648.0,3.985027457814957e-06,0.4998356974573301,"/* stress narrowing of bounds */
#include <stdio.h>
#include <stdlib.h>

// 128MB size
#define SIZE 128*1024*1024

typedef struct __attribute__((__packed__)) {
  int x;
  int a[2];
  int y;
} s_t;

__attribute__((noinline)) 
void arraywrite(s_t* arr, int idx) {
  int i = SIZE-1, r=0;
  for (; i >= 0; i--) {
    int* innerarr = arr[i].a;
    innerarr[idx] = i;
  }
}

int main(int argc, char **argv) {
  s_t* arr = (s_t*) malloc(SIZE * sizeof(s_t));
  arraywrite(arr, 0);
  printf(""r = %x\n"", arr);
  return 0;
}
"
094-3457,alexhilton/miscellaneous,linux/linux-prog-24-codes/optproc.c,28,2,20,1563003.1703040001,172588.0,9.056266947875866,1172.0,1159.0,39490.0,13059.0,1660.0,588.0,1340.0,547.0,1500000000,0.001042002113536,1082014363648.0,0.0135061533826221,0.0786884621971873,"/*
 * option processing demostration.
 * optpro.c
 */
#include <stdio.h>
#include <unistd.h>

int main( int argc, char **argv ) {
  char optch; /* option character */
  static char optstring[] = ""gW:c"";

  while ( ( optch = getopt( argc, argv, optstring ) ) != -1 ) {
    switch ( optch ) {
    case 'c':
      printf( ""-c processed\n"" );
      break;
    case 'g':
      printf( ""-g processed\n"" );
      break;
    case 'W':
      printf( ""-W processed\n"" );
      break;
    default:
      printf( ""Unknown options!\n"" );
      break;
    }
  }
  for ( ; optind < argc; optind++ ) {
    printf( ""argv[ %d ] = '%s'\n"", optind, argv[ optind ] );
  }
  return 0;
}
"
337-33504,chaicko/ExploringBeagleBone,exploringBB/chp05/overview/cstrings.c,29,1,24,1556028.02988135,183123.0,8.497174030569617,1389.0,1365.0,41656.0,14650.0,1654.0,640.0,1373.0,598.0,1500000000,0.0010373520199209,1082014363648.0,0.0150390720990809,0.0757468120626576,"#include<stdio.h>
#include<string.h>
#include<stdlib.h>

int main(){
   char a[20] = ""hello "";
   char b[] = {'w','o','r','l','d','!','\0'};

   a[0]='H';
   char *c = strcat(a,b);
   printf(""The string c is: %s\n"", c);
   printf(""The length of c is: %d\n"", strlen(c));

   // find and replace the w with a W
   char *p = strchr(c,'w');  //pointer to first 'w' char
   *p = 'W';
   printf(""The string c is now: %s\n"", c);

   if (strcmp(""cat"", ""dog"")<=0){
      printf(""cat comes before dog (lexiographically)\n"");
   }
   //insert ""to the"" into middle of ""Hello World!"" string - messy!
   char *d = "" to the"";
   char *cd = malloc(strlen(c) + strlen(d));
   memcpy(cd, c, 5);
   memcpy(cd+5, d, strlen(d));
   memcpy(cd+5+strlen(d), c+5, 6);
   printf(""The cd string is: %s\n"", cd); 

   //tokenize cd string using spaces
   p = strtok(cd,"" "");
   while(p!=NULL){
      printf(""Token:%s\n"", p);
      p = strtok(NULL, "" "");
   }
   return 0;
}
"
309-30712,kevintvh/sodium,book/von-neumann/linked-list.c,44,5,35,2638383316.6910334,5271106874.0,0.5005368661777583,1261.0,1241.0,2054050838.0,38021290.0,500213449.0,1126507.0,1342.0,625678.0,1500000000,1.7589222111273557,1082014363648.0,4.746631134233383e-07,0.2399377006565617,"#include <stdlib.h>
#include <assert.h>

typedef struct Node {
    struct Node* next;
    unsigned value;
} Node;

void shuffle(Node** nodes, unsigned n, int doit) {
    unsigned i;
    for (i = 0; i < n; i++) {
        unsigned j = (unsigned)(((long long)random() * n) /
                     ((long long)RAND_MAX + 1));
        if (i != j && doit) {
            Node* node = nodes[i];
            nodes[i] = nodes[j];
            nodes[j] = node;
        }
    }
}

int main(int argc, char* argv[])
{
    const unsigned n = 1000000;
    const unsigned iterations = 1000;
    Node* head;
    Node* node;
    unsigned iter;
    {
        Node** nodes = malloc(sizeof(Node*) * n);
        unsigned i;
        for (i = 0; i < n; i++) {
            nodes[i] = malloc(sizeof(Node));
            nodes[i]->value = i;
        }
        shuffle(nodes, n,
            argc == 2 && strcmp(argv[1], ""--no-shuffle"") == 0);
        for (i = 0; i < n; i++)
            nodes[i]->next = (i+1) < n ? nodes[i+1] : NULL;
        head = nodes[0];
        free(nodes);
    }
    for (iter = 0; iter < iterations; iter++) {
        unsigned long long sum = 0;
        for (node = head; node != NULL; node = node->next)
            sum += node->value;
        assert(sum == (unsigned long long)(n - 1) * n / 2);
    }
}
"
070-26520,AndrewLaing/CHowToProgramExercises,Chapter12/ex12_16.c,84,1,65,1978804.59018045,213684.0,9.260421931450178,1413.0,1389.0,48928.0,18728.0,1649.0,648.0,1369.0,605.0,1500000000,0.0013192030601203,1082014363648.0,0.0131128208008086,0.0631281778408419,"/*
 * Filename:    ex12_16.c
 * Author:      Andrew Laing
 * Email:       parisianconnections@gmail.com
 * Date:        08/08/2017
 */
 
#include <stdio.h>
#include <stdlib.h>
#include <time.h>


struct treeNode {
    struct treeNode *leftPtr;
    int data;
    struct treeNode *rightPtr;
};

typedef struct treeNode TreeNode;
typedef TreeNode *TreeNodePtr;

void insertNode( TreeNodePtr *, int );
void inOrder( TreeNodePtr );
void preOrder( TreeNodePtr );
void postOrder( TreeNodePtr );



int main()
{
    int i, item;
    TreeNodePtr rootPtr = NULL;
    
    srand(time(NULL));

    printf(""The numbers being placed in the tree are:\n"");
    
    for(i=1; i<10; i++) {
        item = rand() % 15;
        printf(""%3d"", item);
        insertNode( &rootPtr, item );
    }    
    
    /* Traverse the tree preOrder */
    printf(""\n\nThe preOrder traversal is:\n"");
    preOrder( rootPtr );
    
    /* Traverse the tree inOrder */
    printf(""\n\nThe inOrder traversal is:\n"");
    inOrder( rootPtr );
    
    /* Traverse the tree postOrder */
    printf(""\n\nThe postOrder traversal is:\n"");
    postOrder( rootPtr );
    
    return 0;
}


/* Insert value into the list in its sorted position */
void insertNode( TreeNodePtr *treePtr, int value )
{
    if( *treePtr == NULL )
    {
        *treePtr = malloc( sizeof( TreeNode ) );
        
        if(*treePtr != NULL) {
            ( *treePtr )->data = value;
            ( *treePtr )->leftPtr = NULL;
            ( *treePtr )->rightPtr = NULL;
        }
        else
            printf( ""%c not inserted. No memory available.\n"", value );
    }
    else {
        if( value <= (*treePtr)->data )
            insertNode( &( ( *treePtr )->leftPtr ), value );
        else if( value > (*treePtr)->data )
            insertNode( &( ( *treePtr )->rightPtr ), value );
    }
    
}


void inOrder( TreeNodePtr treePtr )
{
    if( treePtr != NULL ) {
        inOrder( treePtr->leftPtr );
        printf( ""%3d"", treePtr->data );
        inOrder( treePtr->rightPtr );
    }
}


void preOrder( TreeNodePtr treePtr )
{
    if( treePtr != NULL ) {
        printf( ""%3d"", treePtr->data );
        preOrder( treePtr->leftPtr );
        preOrder( treePtr->rightPtr );
    }
}


void postOrder( TreeNodePtr treePtr )
{
    if( treePtr != NULL ) {
        postOrder( treePtr->leftPtr );
        postOrder( treePtr->rightPtr );
        printf( ""%3d"", treePtr->data );
    }
}


"
353-29632,justanotherdot/Playground,C/bstree.c,114,1,62,1736074.45321965,183107.0,9.481199517222173,1390.0,1368.0,41504.0,14730.0,1627.0,641.0,1349.0,598.0,1500000000,0.0011573829688131,1082014363648.0,0.0150622313729131,0.0749546537681829,"#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

typedef struct node Node;
struct node {
	int depth;
	int payload;
	Node* left;
	Node* right;
};

Node* createNode(int val) {
	Node* new    = malloc(sizeof(Node));
	new->payload = val;
	new->left    = NULL;
	new->right   = NULL;
	return new;
}

// Returns a pointer to the node inserted into `root'.
// If the value already exists in the BST, a pointer
// to preexisting node is returned.
Node* insert(Node* root, int val) {
	if (root == NULL) { 
		return createNode(val); 
	} 

	// Check for duplicates.
	int pivot = root->payload;
	if (val == pivot) {
		return root;
	}

	// Insert node in the correct place.
	Node* newNode = NULL;
	if (val <= pivot) {
		if (root->left == NULL) {
			newNode = createNode(val);
			root->left = newNode;
		} else {
			insert(root->left, val);
		}
	} else {
		if (root->right == NULL) {
			newNode = createNode(val);
			root->right = newNode;
		} else {
			insert(root->right, val);
		}
	}
	return newNode;
}

// Prints the tree with in-order traversal.
void printTreeGo(Node* root) {
	if (root == NULL) {
		return;
	}
	if (root->left != NULL) {
		printTreeGo(root->left);
	}
	printf(""%d at depth %d, "", root->payload, root->depth);
	if (root->right != NULL) {
		printTreeGo(root->right);
	}
}

void printTree(Node* root) {
	printTreeGo(root);
	printf(""\n"");
}

void freeTree(Node* root) {
	if (root == NULL) {
		return;
	}

	freeTree(root->left);
	freeTree(root->right);
	free(root);
}

int height(Node* root) {
	if (root == NULL) {
		return -1;
	}

	int leftH  = height(root->left);
	int rightH = height(root->right);
	if (leftH > rightH) {
		return 1 + leftH;
	} else {
		return 1 + rightH;
	}
}

Node* createExampleTree(void) {
	Node* root = insert(NULL, 5);
	insert(root, 10);
	insert(root, 2);
	insert(root, 7);
	insert(root, 13);
	insert(root, 8);
	return root;
}

void calcDepthsGo(Node* root, int depth) {
	if (root == NULL) {
		return;
	}
	root->depth = depth;
	if (root->left)  {
		calcDepthsGo(root->left, depth+1);
	}
	if (root->right) {
		calcDepthsGo(root->right, depth+1);
	}
}

void calcDepths(Node* root) {
	calcDepthsGo(root, 0);
}

int main(void) {
	Node* root = createExampleTree();
	printf(""Trees height: %d\n"", height(root));
	calcDepths(root);
	printTree(root);
	freeTree(root);
	root = NULL;
}
"
105-3761,Irishsmurf/POSIX-Stuff,threads.c,34,2,33,87929503.41012315,2100519482.0,0.0418608366899212,1547.0,1515.0,105746.0,58008.0,1679.0,858.0,1366.0,813.0,1500000000,0.0586196689400821,1082014363648.0,1.457734634807829e-06,0.0287992965057342,"#include <pthread.h>
#include <stdio.h>

/* Each thread will execute this function */
static void * loop(void *in)
{
	int i;
	int name;

	name = *((int *)in);

	/* Count up to 100 million */
	for (i = 0; i < 100000000; i++) {

		/* Every time we get through a million, say so */
		if (i % 1000000 == 0) {
			(void) printf(""Thread %d: %d\n"", name, i);
		}
	}
	return ((void *)NULL);
}

int
main(void)
{
	pthread_t	tid1;
	pthread_t	tid2;
	pthread_t	tid3;
	int		thread1 = 1;
	int		thread2 = 2;
	int 	thread3 = 3;
	/* Create our threads */
	pthread_create(&tid1, NULL, loop, (void *)&thread1);
	pthread_create(&tid2, NULL, loop, (void *)&thread2);
	pthread_create(&tid3, NULL, loop, (void *)&thread3);
	/* Wait for our threads */
	pthread_join(tid1, NULL);
	pthread_join(tid2, NULL);
	pthread_join(tid3, NULL);
	return (0);
}

"
299-8032,dllm/practice,array_adhoc/rand_perm.c,51,2,32,679673287.4354348,2596322273.0,0.2616820492838718,1377.0,1351.0,700042447.0,370014306.0,1646.0,639.0,1365.0,597.0,1500000000,0.4531155249569565,1082014363648.0,1.0507170193659544e-06,3.968948364741548e-06,"
#include <stdio.h>
#include <stdlib.h>
#include <time.h>


volatile int random_range (int min, int max) {

	volatile int r = 0;
	r = rand() % (max + 1 - min) + min;
	return r;
}

void swap (int* arr, int x, int y){

	int tmp = arr[x];

	arr[x] = arr[y];
	arr[y] = tmp;

}

int main () {

	int arr[] = {0,1,2};

	int max = sizeof (arr) /sizeof (int) -1;

	int idx = 0;
	volatile int r_idx = 0;


	int cnt1 ,cnt2, cnt3, cnt4, cnt5, cnt6;

	cnt1  = cnt2 = cnt3 = cnt4 = cnt5 = cnt6 = 0;
	int k = 10000000;

	srand(time(NULL));
	while (k--){
		idx = r_idx = 0;
		while (idx <= max){

			r_idx = random_range (idx, max);

			swap (arr, idx, r_idx);

			idx++;

		}
		if (arr[0] == 0 && arr[1] == 1 && arr[2] == 2){
			cnt1++;
		}
		else if (arr[0] == 1 && arr[1] == 2 && arr[2] == 0){
			cnt2++;
		}
		else if (arr[0] == 2 && arr[1] == 0 && arr[2] == 1){
			cnt3++;
		}
		else if (arr[0] == 0 && arr[1] == 2 && arr[2] == 1){
			cnt4++;
		}
		else if (arr[0] == 1 && arr[1] == 0 && arr[2] == 2){
			cnt5++;
		}
		else if (arr[0] == 2 && arr[1] == 1 && arr[2] == 0){
			cnt6++;
		}else
		{
			printf (""unknown %d %d %d\n"", arr[0], arr[1], arr[2]);
		}
	}

	printf (""%d %d %d %d %d %d"", cnt1, cnt2, cnt3, cnt4, cnt5, cnt6);

	printf (""\n"");
}


"
019-33792,AllenDowney/ExercisesInC,exercises/ex02.5/bigint.c,161,2,95,1895942.8416564001,176094.0,10.766647358797004,1302.0,1284.0,40107.0,13672.0,1629.0,636.0,1354.0,593.0,1500000000,0.0012639618944376,1082014363648.0,0.0146853385123854,0.0783205340374495,"/* Example code for Exercises in C.

This program shows a way to represent a BigInt type (arbitrary length integers)
using C strings, with numbers represented as a string of decimal digits in reverse order.

Follow these steps to get this program working:

1) Read through the whole program so you understand the design.

2) Compile and run the program.  It should run three tests, and they should fail.

3) Fill in the body of reverse_string().  When you get it working, the first test should pass.

4) Fill in the body of itoc().  When you get it working, the second test should pass.

5) Fill in the body of add_digits().  When you get it working, the third test should pass.

6) Uncomment the last test in main.  If your three previous tests pass, this one should, too.

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>

/* reverse_string: Returns a new string with the characters reversed.

It is the caller's responsibility to free the result.

s: string
returns: string
*/
char *reverse_string(char *s) {
    //TODO: Fill this in.
    return """";
}

/* ctoi: Converts a character to integer.

c: one of the characters '0' to '9'
returns: integer 0 to 9
*/
int ctoi(char c) {
    assert(isdigit(c));
    return c - '0';
}

/* itoc: Converts an integer to character.

i: integer 0 to 9
returns: character '0' to '9'
*/
char itoc(int i) {
    //TODO: Fill this in, with an appropriate assertion.
    return '0';
}

/* add_digits: Adds two decimal digits, returns the total and carry.

For example, if a='5', b='6', and carry='1', the sum is 12, so
the output value of total should be '2' and carry should be '1'

a: character '0' to '9'
b: character '0' to '9'
c: character '0' to '9'
total: pointer to char
carry: pointer to char

*/
void add_digits(char a, char b, char c, char *total, char *carry) {
    //TODO: Fill this in.
}

/* Define a type to represent a BigInt.
   Internally, a BigInt is a string of digits, with the digits in
   reverse order.
*/
typedef char * BigInt;

/* add_bigint: Adds two BigInts

Stores the result in z.

x: BigInt
y: BigInt
carry_in: char
z: empty buffer
*/
void add_bigint(BigInt x, BigInt y, char carry_in, BigInt z) {
    char total, carry_out;
    int dx=1, dy=1, dz=1;
    char a, b;

    /* OPTIONAL TODO: Modify this function to allocate and return z
    *  rather than taking an empty buffer as a parameter.
    *  Hint: you might need a helper function.
    */

    if (*x == '\0') {
        a = '0';
        dx = 0;
    }else{
        a = *x;
    }
    if (*y == '\0') {
        b = '0';
        dy = 0;
    }else{
        b = *y;
    }

    // printf(""%c %c %c\n"", a, b, carry_in);
    add_digits(a, b, carry_in, &total, &carry_out);
    // printf(""%c %c\n"", carry_out, total);

    // if total and carry are 0, we're done
    if (total == '0' && carry_out == '0') {
        *z = '\0';
        return;
    }
    // otherwise store the digit we just computed
    *z = total;

    // and make a recursive call to fill in the rest.
    add_bigint(x+dx, y+dy, carry_out, z+dz);
}

/* print_bigint: Prints the digits of BigInt in the normal order.

big: BigInt
*/
void print_bigint(BigInt big) {
    char c = *big;
    if (c == '\0') return;
    print_bigint(big+1);
    printf(""%c"", c);
}

/* make_bigint: Creates and returns a BigInt.

Caller is responsible for freeing.

s: string of digits in the usual order
returns: BigInt
*/
BigInt make_bigint(char *s) {
    char *r = reverse_string(s);
    return (BigInt) r;
}

void test_reverse_string() {
    char *s = ""123"";
    char *t = reverse_string(s);
    if (strcmp(t, ""321"") == 0) {
        printf(""reverse_string passed\n"");
    } else {
        printf(""reverse_string failed\n"");
    }
}

void test_itoc() {
    char c = itoc(3);
    if (c == '3') {
        printf(""itoc passed\n"");
    } else {
        printf(""itoc failed\n"");
    }
}

void test_add_digits() {
    char total, carry;
    add_digits('7', '4', '1', &total, &carry);
    if (total == '2' && carry == '1') {
        printf(""add_digits passed\n"");
    } else {
        printf(""add_digits failed\n"");
    }
}

void test_add_bigint() {
    char *s = ""1"";
    char *t = ""99999999999999999999999999999999999999999999"";
    char *res = ""000000000000000000000000000000000000000000001"";

    BigInt big1 = make_bigint(s);
    BigInt big2 = make_bigint(t);
    BigInt big3 = malloc(100);

    add_bigint(big1, big2, '0', big3);

    if (strcmp(big3, res) == 0) {
        printf(""add_bigint passed\n"");
    } else {
        printf(""add_bigint failed\n"");
    }
}

int main (int argc, char *argv[])
{
    test_reverse_string();
    test_itoc();
    test_add_digits();

    //TODO: When you have the first three functions working,
    //      uncomment the following, and it should work.
    // test_add_bigint();
    return 0;
}
"
036-11431,cornerstonecollege/401,olderFiles/401_2016_1/c_examples/revision/revision1.c,17,2,15,1585278.0779823,235359.0,6.735574165423884,1352.0,1333.0,52786.0,22925.0,1630.0,643.0,1351.0,599.0,1500000000,0.0010568520519882,1082014363648.0,0.0114081042152626,0.0557778922481541,"#include <stdio.h>

int main()
{ 
  // create a matrix 10 x 10 
  int matrix[10][10] = {0}; // initialize all elements with '0'
  matrix[2][3] = 1; // set the element at the row 2 col 3 with '1'

  // step trough the matrix
  for (int row = 0; row < 10; row++)
  {
    for (int col = 0; col < 10; col++)
    {
      // print the elements inside the rows
      printf(""%i "", matrix[row][col]);
    }
    printf(""\n"");
  }  
  
  return 0;
}
"
134-28075,vinoski/otp,erts/lib_src/yielding_c_fun/test/examples/destroy_while_yielded.c,77,2,65,1797692.9666473498,182537.0,9.848370467357302,1348.0,1331.0,41489.0,14685.0,1625.0,638.0,1349.0,595.0,1500000000,0.0011984619777649,1082014363648.0,0.0146764765499597,0.0748922989283298,"/*
 * %CopyrightBegin%
 *
 * Copyright Ericsson AB and Kjell Winblad 2019. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * %CopyrightEnd%
 */

/*
 * Description:
 *
 * Author: Kjell Winblad
 *
 */

#include <stdio.h>
#include <stdlib.h>

#define YCF_YIELD()


void fun(int level){
  void* my_mem = malloc(1000);
  /*special_code_start:ON_DESTROY_STATE*/
  if(0){
    printf(""FREE AT LEVEL %d\n"", level);
    free(my_mem);
  }
  /*special_code_end*/
  /*special_code_start:ON_DESTROY_STATE_OR_RETURN*/
  if(0){
    printf(""I got destroyed or returned %d\n"", level);
  }
  /*special_code_end*/
  printf(""LEVEL %d\n"", level);
  if (level == 10) {
    YCF_YIELD();
    printf(""SHOULD NOT BE PRINTED 1\n"");
    return;
  }else {
    fun(level + 1);
    printf(""SHOULD NOT BE PRINTED 2\n"");
  }
}

void* allocator(size_t size, void* context){
  (void)context;
  return malloc(size);
}

void freer(void* data, void* context){
  (void)context;
  free(data);
}

int main( int argc, const char* argv[] )
{
#ifdef YCF_YIELD_CODE_GENERATED
  void* wb = NULL;
  long nr_of_reductions = 1;
  do {
    fun_ycf_gen_yielding(&nr_of_reductions,&wb,NULL,allocator,freer,NULL,0,NULL,1);
    if(wb != NULL){
      printf(""TRAPPED\n"");
      fun_ycf_gen_destroy(wb);
      printf(""DESTROYED\n"");
      wb = NULL;
      break;
    }
  } while(wb != NULL);
  if(wb != NULL){
    free(wb);
  }
#else
  fun(1);
#endif
  printf(""RETURNED\n"");
  return 0;
}

"
207-29425,ColinIanKing/stress-ng,test/test-builtin-supports.c,22,1,24,1752002.86321335,169610.0,10.329591415600497,1184.0,1171.0,38522.0,12723.0,1568.0,584.0,1318.0,544.0,1500000000,0.0011680019088089,1082014363648.0,0.0138847945286244,0.0783295931310371,"/*
 * Copyright (C)      2022 Colin Ian King
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 */
int main(int argc, char **argv)
{
	return __builtin_cpu_supports(""avx"");
}

"
183-30093,ROCm-Developer-Tools/hcc2,test/smoke/issue_001/issue_001.c,31,6,22,304526163.03227836,2104468926.0,0.1447045186734204,1296.0,1279.0,882921606.0,299533480.0,110324498.0,120651.0,3230.0,118631.0,1500000000,0.2030174420215189,1082014363648.0,1.2235866104682031e-06,0.0935063084501799,"#include <stdio.h>
#include ""assert.h""
#include <unistd.h>

// 920 fails
#define TRIALS 919
// 6000 fails
#define N 64*5000

int main() {
  int fail = 0;
  double A[N], B[N], C[N];
  for (int i = 0; i < N; i++) {
    A[i] = 0.0;
    B[i] = 0.0;
    C[i] = 1.0;
  }
  int nte = 32;
  int tl = 64;
  int blockSize = tl;

  for (int t = 0 ; t < TRIALS ; t++) {
    #pragma omp target
    #pragma omp teams num_teams(nte) thread_limit(tl)
    {
      #pragma omp distribute
      for(int j = 0 ; j < N ; j += blockSize) {
        #pragma omp parallel for
        for(int i = j ; i < j+blockSize; i++) {
          A[i] += B[i] + C[i];
        }
      }
    }
  }
  for(int i = 0 ; i < N ; i++) {
    if (A[i] != TRIALS) {
      printf(""Error at A[%d], h = %lf, d = %lf\n"", i, (double) (2.0+3.0)*TRIALS, A[i]);
      fail = 1;
    }
  }

  if(fail) {printf(""Failed\n"");}
  else {printf(""Succeeded\n"");}
}
"
236-32770,guillermo-carrasco/algorithmics,src/largest_prime_factor.c,48,3,35,1794047.8865056501,1764422.0,1.428718299817164,1340.0,1322.0,341052.0,253367.0,1670.0,4080.0,1340.0,4018.0,1500000000,0.0011960319243371,1082014363648.0,0.0015087093677136,0.0186871550202803,"/*
The prime factors of 13195 are 5, 7, 13 and 29.

What is the largest prime factor of the number 600851475143 ?
*/

#include <stdio.h>
#include <stdlib.h>

long N=600851475143;

struct node {
    struct node* next;
    int val;
};

void next_prime(struct node *primes, int n) {
    char found = 0;
    struct node *aux = primes;
    while (!found) {
        if (n%aux->val == 0) {
            n++;
            aux = primes;
        }
        else {
            if (aux->next == NULL) {
                found = 1;
                aux->next = (struct node*) malloc(sizeof(struct node));
                aux->next->val = n;
                aux->next->next = NULL;
            }
            else (aux = aux->next);
        }
    }
}

int main() {
    /* You can't malloc outside the main (or any function). Malloc allocates memory
     on the heap, i.e runtime, so you can't allocate on compile time. You can
     though declare the variable and it will be saved in the program page on
     compile time */
    struct node *primes = (struct node*) malloc(sizeof(struct node));
    primes->val = 2;
    primes->next = NULL;
    while (N > 1) {
        while (N%primes->val == 0) {
            N /= primes->val;
        }
        if (N>1) {
            next_prime(primes, primes->val);
            primes = primes->next;
        }
    }
    printf(""%d\n"", primes->val);
    return 0;
}
"
090-31154,Gurgel100/gcc,gcc/testsuite/gcc.dg/graphite/pr83385.c,25,3,25,1558158.08102475,169975.0,9.16698337990881,1146.0,1137.0,38666.0,12782.0,1577.0,586.0,1323.0,546.0,1500000000,0.0010387720540165,1082014363648.0,0.0134313869686718,0.0783703934069351,"/* { dg-do run } */
/* { dg-options ""-O1 -floop-nest-optimize"" } */

int xc, n1 = 0;
int bx[2];

int
main (void)
{
  int aj = 1;
  int cs;

  for (cs = aj; cs >= 0; --cs)
    {
      int sq;

      for (sq = 0; sq < 2; ++sq)
	{
	  if (aj != 0)
	    --n1;

	  for (xc = 0; xc < 2; ++xc)
	    bx[xc] = 0;
	}

      --aj;
    }

  if (n1 != -2)
    __builtin_abort ();
  return 0;
}
"
230-8038,vongola12324/FCU_CE_OS,HW1/hw1.c,26,3,29,6003346582.408995,190983.0,31433.93172167156,1520.0,1478.0,43659.0,16082.0,1671.0,778.0,1374.0,733.0,1500000000,4.00223105493933,1082014363648.0,0.0156977322588921,0.0762625332686095,"#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#define MAXTHREADS 4

char *messages[MAXTHREADS+1]={""Hello 0"",""Hello 1"",""Hello 2"",""Hello 3"",""Error !!!""};

void *Hello(void *pthreadid) {
    int *idp, id;
    // sleep(1);
    idp = (int *) pthreadid;
    id = *idp;
    printf(""My Thread's ID [%d] %s\n"", id, messages[id]);
    return NULL;
}

int main(int argc, char *argv[]) {
    pthread_t child[MAXTHREADS];
    int id;
    int i;
    for(id = 0; id < MAXTHREADS; id++) {
        int *id2 = (int*)malloc(sizeof(int));
        *id2 = id;
        printf(""Create thread %d\n"", id);
        pthread_create(&child[id], NULL, Hello, (void *) id2);
        sleep(1);
    }

    /** Wait for all threads to finish **/
    for (i = 0; i < MAXTHREADS; i++) {
        pthread_join(child[i], NULL);
    }
    //sleep(10);
}
"
098-33030,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.mi/mi-var-create-rtti.c,18,1,15,1619540.85342585,169087.0,9.578146161443517,1142.0,1132.0,38460.0,12696.0,1567.0,584.0,1317.0,544.0,1500000000,0.0010796939022839,1082014363648.0,0.0134486980075345,0.0784267730080538,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2012-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int
main (void)
{
  int i = 0;

  return i; /* next-line */
}
"
200-28412,SanDisk-Open-Source/SSD_Dashboard,uefi/gcc/gcc-4.6.3/gcc/testsuite/gcc.c-torture/execute/pr28982b.c,41,5,26,2113434.0204297,698056.0,3.0275995049107807,1184.0,1174.0,301759.0,537515.0,5822.0,8794.0,1402.0,8591.0,1500000000,0.0014089560136198,1082014363648.0,0.0033779524851874,0.0293217709591861,"/* Like pr28982a.c, but with the spill slots outside the range of
   a single sp-based load on ARM.  This test tests for cases where
   the addresses in the base and index reloads require further reloads.  */
#if defined(STACK_SIZE) && STACK_SIZE <= 0x80100
int main (void) { return 0; }
#else
#define NITER 4
#define NVARS 20
#define MULTI(X) \
  X( 0), X( 1), X( 2), X( 3), X( 4), X( 5), X( 6), X( 7), X( 8), X( 9), \
  X(10), X(11), X(12), X(13), X(14), X(15), X(16), X(17), X(18), X(19)

#define DECLAREI(INDEX) inc##INDEX = incs[INDEX]
#define DECLAREF(INDEX) *ptr##INDEX = ptrs[INDEX], result##INDEX = 0
#define LOOP(INDEX) result##INDEX += *ptr##INDEX, ptr##INDEX += inc##INDEX
#define COPYOUT(INDEX) results[INDEX] = result##INDEX

float *ptrs[NVARS];
float results[NVARS];
int incs[NVARS];

struct big { int i[0x10000]; };
void __attribute__((noinline))
bar (struct big b)
{
  incs[0] += b.i[0];
}

void __attribute__((noinline))
foo (int n)
{
  struct big b = {};
  int MULTI (DECLAREI);
  float MULTI (DECLAREF);
  while (n--)
    MULTI (LOOP);
  MULTI (COPYOUT);
  bar (b);
}

float input[NITER * NVARS];

int
main (void)
{
  int i;

  for (i = 0; i < NVARS; i++)
    ptrs[i] = input + i, incs[i] = i;
  for (i = 0; i < NITER * NVARS; i++)
    input[i] = i;
  foo (NITER);
  for (i = 0; i < NVARS; i++)
    if (results[i] != i * NITER * (NITER + 1) / 2)
      return 1;
  return 0;
}
#endif
"
356-1684,losvald/benchmarks-game,other-lang/c/fastaredux.c,135,6,83,2509024.57628385,406415.0,6.173551665169839,1327.0,1308.0,63577.0,31830.0,1964.0,1327.0,1378.0,1070.0,1500000000,0.0016726830508559,1082014363648.0,0.0064835205393501,0.0601528189755468,"/*  The Computer Language Benchmarks Game
 *  http://shootout.alioth.debian.org/
 *  fasta-redux C GNU gcc #3
 * 
 *  contributed by Petr Prokhorenkov
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define ARRAY_SIZE(a) (sizeof(a)/sizeof(a[0]))
#define unlikely(x) __builtin_expect((x), 0)

#define IM 139968
#define IA 3877
#define IC 29573

#define LINE_LEN 60
#define LOOKUP_SIZE 4096
#define LOOKUP_SCALE ((float)(LOOKUP_SIZE - 1))

typedef unsigned random_t;

void
random_init(random_t *random) {
    *random = 42;
}

// Special version with result rescaled to LOOKUP_SCALE.
static inline
float
random_next_lookup(random_t *random) {
    *random = (*random*IA + IC)%IM;

    return (*random)*(LOOKUP_SCALE/IM);
}

struct amino_acid {
   char sym;
   float prob;
   float cprob_lookup;
};

void
repeat(const char *alu, const char *title, int n) {
    int len = strlen(alu);
    char buffer[len + LINE_LEN];
    int pos = 0;

    memcpy(buffer, alu, len);
    memcpy(buffer + len, alu, LINE_LEN);

    fputs_unlocked(title, stdout);
    while (n > 0) {
        int bytes = n > LINE_LEN ? LINE_LEN : n;

        fwrite_unlocked(buffer + pos, bytes, 1, stdout);
        pos += bytes;
        if (pos > len) {
            pos -= len;
        }
        fputc_unlocked('\n', stdout);
        n -= bytes;
    }
}

/*
 * Lookup table contains mapping from real values to cumulative
 * probabilities. Careful selection of table size allows lookup
 * virtually in constant time.
 *
 * All cumulative probabilities are rescaled to LOOKUP_SCALE,
 * this allows to save one multiplication operation on each iteration
 * in randomize().
 */

void *
fill_lookup(struct amino_acid **lookup, struct amino_acid *amino_acid, int amino_acid_size) {
    float p = 0;
    for (int i = 0; i < amino_acid_size; i++) {
        p += amino_acid[i].prob;
        amino_acid[i].cprob_lookup = p*LOOKUP_SCALE;
    }

    // Prevent rounding error.
    amino_acid[amino_acid_size - 1].cprob_lookup = LOOKUP_SIZE - 1;

    for (int i = 0, j = 0; i < LOOKUP_SIZE; i++) {
        while (amino_acid[j].cprob_lookup < i) {
            j++;
        }
        lookup[i] = &amino_acid[j];
    }

    return 0;
}

void
randomize(struct amino_acid *amino_acid, int amino_acid_size,
        const char *title, int n, random_t *rand) {
    struct amino_acid *lookup[LOOKUP_SIZE];
    char line_buffer[LINE_LEN + 1];
    int i, j;

    line_buffer[LINE_LEN] = '\n';

    fill_lookup(lookup, amino_acid, amino_acid_size);

    fputs_unlocked(title, stdout);

    for (i = 0, j = 0; i < n; i++, j++) {
        if (j == LINE_LEN) {
            fwrite_unlocked(line_buffer, LINE_LEN + 1, 1, stdout);
            j = 0;
        }

        float r = random_next_lookup(rand);
        struct amino_acid *u = lookup[(short)r];
        while (unlikely(u->cprob_lookup < r)) {
            ++u;
        }
        line_buffer[j] = u->sym;
    }
    line_buffer[j] = '\n';
    fwrite_unlocked(line_buffer, j + 1, 1, stdout);
}

struct amino_acid amino_acid[] = {
   { 'a', 0.27 },
   { 'c', 0.12 },
   { 'g', 0.12 },
   { 't', 0.27 },

   { 'B', 0.02 },
   { 'D', 0.02 },
   { 'H', 0.02 },
   { 'K', 0.02 },
   { 'M', 0.02 },
   { 'N', 0.02 },
   { 'R', 0.02 },
   { 'S', 0.02 },
   { 'V', 0.02 },
   { 'W', 0.02 },
   { 'Y', 0.02 },
};

struct amino_acid homo_sapiens[] = {
   { 'a', 0.3029549426680 },
   { 'c', 0.1979883004921 },
   { 'g', 0.1975473066391 },
   { 't', 0.3015094502008 },
};

static const char alu[] =
   ""GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTG""
   ""GGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGA""
   ""GACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAA""
   ""AATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAAT""
   ""CCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAAC""
   ""CCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTG""
   ""CACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA"";

int
main(int argc, const char **argv) {
    int n = argc > 1 ? atoi( argv[1] ) : 512;
    random_t rand;

    random_init(&rand);

    repeat(alu, "">ONE Homo sapiens alu\n"", n*2);
    randomize(amino_acid, ARRAY_SIZE(amino_acid),
            "">TWO IUB ambiguity codes\n"", n*3, &rand);
    randomize(homo_sapiens, ARRAY_SIZE(homo_sapiens),
            "">THREE Homo sapiens frequency\n"", n*5, &rand);

    return 0;
}
"
119-1530,pietrodn/middleware-exe,pthread/producer_consumer.c,52,5,31,7520078158.588149,392093.0,19179.322655594464,2347.0,1769.0,89131.0,41735.0,2435.0,1425.0,1701.0,1255.0,1500000000,5.013385439058766,1082014363648.0,0.0104975095194252,0.0520838109210948,"#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define MAX_ITER 10
#define NUM_CONS 5
#define BUFFER_INCREMENT 5

// Global variables
int buffer;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t prod_cond = PTHREAD_COND_INITIALIZER;
pthread_cond_t cons_cond = PTHREAD_COND_INITIALIZER;

void * producer(void *arg) {
    int i;

    for(i=0; i < MAX_ITER; i++) {
        pthread_mutex_lock(&mutex);
        while(buffer > 0) {
            pthread_cond_wait(&prod_cond, &mutex);
        }
        buffer += 5;
        printf(""Producer: buffer = %d\n"", buffer);
        pthread_cond_broadcast(&cons_cond);
        pthread_mutex_unlock(&mutex);
        usleep(0.5E6);
    }
    pthread_exit(NULL);
}

void * consumer(void *arg) {
    int i, id;
    id = *((int *)arg);
    free(arg);

    for(i=0; i < MAX_ITER * BUFFER_INCREMENT / NUM_CONS; i++) {
        pthread_mutex_lock(&mutex);
        while(buffer <= 0) {
            pthread_cond_wait(&cons_cond, &mutex);
        }
        buffer--;
        printf(""Consumer %d: buffer = %d\n"", id, buffer);
        pthread_cond_broadcast(&prod_cond);
        pthread_mutex_unlock(&mutex);
        usleep(0.5E6);
    }

    pthread_exit(NULL);
}


int main(int argc, char *argv[]) {
    pthread_t thr_prod, thr_cons[NUM_CONS];
    int i, *id;

    // Init buffer
    buffer = 0;

    // Spawn producer
    pthread_create(&thr_prod, NULL, producer, NULL);

    // Spawn consumers
    for(i=0; i<NUM_CONS; i++) {
        id = malloc(sizeof(int));
        *id = i;
        pthread_create(&thr_cons[i], NULL, consumer, id);
    }

    pthread_exit(NULL);
}
"
205-7666,ColinIanKing/stress-ng,test/test-atomic_fetch_and.c,24,1,25,1864097.896032,170439.0,10.937033190760332,1145.0,1137.0,38727.0,12788.0,1581.0,586.0,1326.0,544.0,1500000000,0.001242731930688,1082014363648.0,0.0133889544059751,0.0783655246044841,"/*
 * Copyright (C) 2021-2022 Colin Ian King
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 */
int main(int argc, char **argv)
{
	int var;

	__atomic_fetch_and(&var, 1, 0);

	return 0;
}

"
332-22290,acarno/slicer,valgrind/helgrind/tests/tc14_laog_dinphils.c,34,4,26,1503089764.388278,865652.0,1736.3672284012514,1405.0,1377.0,232653.0,65365.0,1664.0,760.0,1362.0,718.0,1500000000,1.0020598429255188,1082014363648.0,0.003213762574337,0.0151131810830218,"
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>
#include <assert.h>
/* Naive dining philosophers with inconsistent lock acquisition
   ordering. */

static pthread_t phil[5];
static struct {
   pthread_mutex_t m;
   char pad[120 - sizeof(pthread_mutex_t)];
} chop[5];

void* dine ( void* arg )
{
   int i;
   long left = (long)arg;
   long right = (left + 1) % 5;
   for (i = 0; i < 1000/*arbitrary*/; i++) {
      pthread_mutex_lock(&chop[left].m);
      pthread_mutex_lock(&chop[right].m);
      /* eating */
      pthread_mutex_unlock(&chop[left].m);
      pthread_mutex_unlock(&chop[right].m);
   }
   return NULL;
}

int main ( void )
{
   long i;
   assert(sizeof(pthread_mutex_t) <= 120);

   for (i = 0; i < 5; i++)
      pthread_mutex_init( &chop[i].m, NULL);

   for (i = 0; i < 5; i++)
      pthread_create(&phil[i], NULL, dine, (void*)i );

   sleep(1);

   for (i = 0; i < 5; i++)
      pthread_join(phil[i], NULL);

   return 0;
}
"
379-16953,zxombie/aarch64-freebsd-binutils,gdb/testsuite/gdb.base/gcore-buffer-overflow.c,19,2,15,1528068.09637695,169100.0,9.036475458308692,1142.0,1132.0,38461.0,12696.0,1567.0,584.0,1317.0,544.0,1500000000,0.0010187120642513,1082014363648.0,0.0134476641040804,0.0784252399476122,"/* Copyright 2007-2014 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/*
 * Test GDB's internal buffers safety for the GCORE command.
 */

int main (void)
{
  return 0;
}
"
100-26340,danadorneanu/portofolio,kr/knr_5_4.c,29,1,29,2308399.5329215503,174203.0,13.251201184824602,1328.0,1309.0,39475.0,13429.0,1626.0,637.0,1345.0,595.0,1500000000,0.0015389330219477,1082014363648.0,0.0151375119831461,0.0794457885982156,"#include <stdio.h>
#include <string.h>

#define YES 1
#define NO 0

///
/// This function returns 
///  -> YES is the string tail occurs at the end of str
///  -> NO otherwise
///
int strend(char *str, char *tail);

int main(void)
{
   int ret = 0;
   char s[] = ""Je veux lui dire,"", t[] = ""dire,"";

   if (strend(s, t) == YES)
      printf(""\nThe string \n\t%s\nappears at the end of \n\t%s\n"", t, s);
   else 
      printf(""\nThe string \n\t%s\ndoes not appear at the end of \n\t%s\n"", t, s);

   return ret; 
}

int strend(char *str, char *tail)
{
   while ((str[strlen(str)] == tail[strlen(tail)]) 
         && (strlen(tail) != 0) 
         && (strlen(str) != 0))
   {
      str--;
      tail--;
   }

   if (strlen(tail) == 0)
      return YES;
   return  NO;

}
"
332-22164,Gurgel100/gcc,gcc/testsuite/c-c++-common/asan/pr80308.c,23,2,18,1555471.6810584,170712.0,9.11166760391771,1146.0,1138.0,38776.0,12800.0,1582.0,587.0,1326.0,546.0,1500000000,0.0010369811207056,1082014363648.0,0.0133792586344252,0.0783503955328059,"/* PR sanitizer/80308 */
/* { dg-do run } */

__attribute__((noinline, noclone)) int
foo (char *a)
{
  int i, j = 0;
  asm volatile ("""" : ""+r"" (a) : : ""memory"");
  for (i = 0; i < 12; i++)
    j += a[i];
  return j;
}

int
main ()
{
  int i, j = 0;
  for (i = 0; i < 4; i++)
    {
      char a[12];
      __builtin_memset (a, 0, sizeof (a));
      j += foo (a);
    }
  return j;
}
"
238-34261,zhuyue1314/pathgrind,valgrind-r12356/VEX/useful/cpuid.c,55,5,27,1566647.90119965,352850.0,9.175278446932124,1375.0,1354.0,73850.0,35252.0,1647.0,683.0,1363.0,640.0,1500000000,0.0010444319341331,1082014363648.0,0.0077341646592036,0.0397151289618888,"
#include <stdio.h>

typedef  unsigned int            UInt;
typedef  unsigned long long int  ULong;

void cpuid ( UInt* eax, UInt* ebx, UInt* ecx, UInt* edx, 
             UInt index, UInt ecx_in )
{
   UInt a,b,c,d;
   asm volatile (""cpuid""
                 : ""=a"" (a), ""=b"" (b), ""=c"" (c), ""=d"" (d) \
                 : ""0"" (index), ""2""(ecx_in) );
   *eax = a; *ebx = b; *ecx = c; *edx = d;
   printf(""%08x %08x -> %08x %08x %08x %08x\n"",
          index,ecx_in, a,b,c,d );
}

int main ( void )
{
  UInt eax, ebx, ecx, edx;
  UInt maxidx, maxextidx, i,ecx_in;

  printf(""\n"");
  cpuid(&eax,&ebx,&ecx,&edx, 0,0);
  maxidx = eax;
  for (i = 1; i <= maxidx +2; i++) {

    cpuid(&eax,&ebx,&ecx,&edx, i,0);

    if (i == 4) {
      printf(""\n"");
      for (ecx_in = 1; ecx_in < 10; ecx_in++) {
         cpuid(&eax,&ebx,&ecx,&edx, i,ecx_in);
      }
      printf(""\n"");
    }

    if (i == 0xb) {
      printf(""\n"");
      for (ecx_in = 1; ecx_in < 10; ecx_in++) {
         cpuid(&eax,&ebx,&ecx,&edx, i,ecx_in);
      }
      printf(""\n"");
    }

    if (i == 0xd) {
      printf(""\n"");
      for (ecx_in = 1; ecx_in < 5; ecx_in++) {
         cpuid(&eax,&ebx,&ecx,&edx, i,ecx_in);
      }
      printf(""\n"");
    }


  }

  printf(""\n"");

  cpuid(&eax,&ebx,&ecx,&edx, 0x80000000,0);
  maxextidx = eax;
  for (i = 0x80000001; i <= maxextidx +2; i++) {
     cpuid(&eax,&ebx,&ecx,&edx, i,0);
  }

  printf(""invalid\n"");
  cpuid(&eax,&ebx,&ecx,&edx, 1234,0);
  cpuid(&eax,&ebx,&ecx,&edx, 0x800004d3,0);


  return 0;
}
"
340-30381,JTWalraven/rust-playground,c_modpow/main.c,22,2,19,3268184104.5850887,169083.0,19322.16103925291,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,2.178789403056726,1082014363648.0,0.0134490161636592,0.0785049652044725,"#include <stdio.h>

int modOfPower(int value, int power, int modulus);

int main(void)
{
    // Loop 100 times
    for (int i = 1; i < 10; i++) {
        // Take the mod of number to large power
        int pow = i * 10000000;
        int value = modOfPower(324322, pow, 3724);
        printf(""324322^(%i) mod 3724 = %i\n"", pow, value);
    }
    return 0;
}

/**
 * Get the modulus of an integer raised to a power.
 */
int modOfPower(int value, int power, int modulus) {
    int x = 1;
    for (int i = 0; i < power; i++) {
        x = (x * value) % modulus;
    }
    return x;
}
"
248-35179,vvavrychuk/glibc,manual/examples/sigh1.c,39,7,31,3937304221.4429007,552668538.0,7.124169281009443,1308.0,1293.0,155064836.0,76117383.0,1624.0,704.0,1341.0,655.0,1500000000,2.6248694809619337,1082014363648.0,4.706256682192392e-06,1.8703860611356105e-05,"/* Signal Handlers that Return
   Copyright (C) 1991-2014 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2
   of the License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, if not, see <http://www.gnu.org/licenses/>.
*/

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>

/* This flag controls termination of the main loop. */
volatile sig_atomic_t keep_going = 1;

/* The signal handler just clears the flag and re-enables itself. */
void
catch_alarm (int sig)
{
  keep_going = 0;
  signal (sig, catch_alarm);
}

void
do_stuff (void)
{
  puts (""Doing stuff while waiting for alarm...."");
}

int
main (void)
{
  /* Establish a handler for SIGALRM signals. */
  signal (SIGALRM, catch_alarm);

  /* Set an alarm to go off in a little while. */
  alarm (2);

  /* Check the flag once in a while to see when to quit. */
  while (keep_going)
    do_stuff ();

  return EXIT_SUCCESS;
}
"
117-28650,harryjackson/doc,c/cache_locality_2d_array_test.c,66,8,46,2973875731.229782,8000358624.0,0.3717178030093267,1454.0,1425.0,59372.0,2000019702.0,11884.0,977511895.0,1362.0,1214096.0,1500000000,1.9825838208198547,1082014363648.0,3.5985886824665426e-07,0.4893502710583332,"#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#if 0
  #define PRINT(a) printf a
#else
  #define PRINT(a) (void)0
#endif

/* The product of these two numbers (ROWS_N * COLS_N) must be greater than the
 * CPU Cache size or you won't see locality effects quite as well */
#define ROWS_N 100000
#define COLS_N 100

#define SWAP 0
#if SWAP
  #define ROWS ROWS_N
  #define COLS COLS_N
#else
  #define ROWS COLS_N
  #define COLS ROWS_N
#endif

static float *  matrix;
static float ** matrix2;

void bench_contig(size_t iter) {
  size_t i = 0;
  size_t r = 0;
  size_t c = 0;
  for(i = 0; i < iter ;i++) {
    for(r = 0; r < ROWS; r++) {
      PRINT((""r%zu->"", r));
      for(c = 0; c < COLS; c++) {
        PRINT((""|%zu"", c));
        matrix[r + r*c] = 1.0;
      }
      PRINT((""\n""));
    }
  }
}
void bench_row_contig(size_t iter) {
  size_t i = 0;
  size_t r = 0;
  size_t c = 0;
  for(i = 0; i < iter ;i++) {
    for(r = 0; r < ROWS; r++) {
      PRINT((""r%zu->"", r));
      for(c = 0; c < COLS; c++) {
        PRINT((""|%zu"", c));
        matrix2[r][c] = 1.0;
      }
      PRINT((""\n""));
    }
  }
}
int main(void) {
  time_t t1; 
  time_t t2; 
  double time_r   = 0.0;
  size_t iterations = 100;
  //size_t i = 0;
  size_t r = 0;
  //size_t c = 0;
  int rows    = ROWS;
  int columns = COLS;

  matrix = malloc(rows * columns * sizeof(float));

  t1 = clock();
  bench_contig(iterations);
  t2 = clock();
  time_r = difftime(t2, t1) / CLOCKS_PER_SEC;
  printf(""%f secs\n"",time_r);

  matrix2 = malloc(rows * sizeof(float*));
  for(r = 0; r < rows; r++) {
    matrix2[r]    = malloc(columns * sizeof(float));
  }
  
  t1 = clock();
  bench_row_contig(iterations);
  t2 = clock();
  time_r = difftime(t2, t1) / CLOCKS_PER_SEC;
  printf(""%f secs\n"",time_r);

  free(matrix);
  for(r = 0; r < rows; r++) {
    free(matrix2[r]);
  }
  free(matrix2);
  return 0;
}


"
324-15333,BackupTheBerlios/rip-dvd,mclean.c,202,8,112,1615353.0450537,180015.0,8.973435547037747,1314.0,1292.0,41200.0,14108.0,1663.0,635.0,1375.0,595.0,1500000000,0.0010769020300358,1082014363648.0,0.014476571396828,0.0771678599840891,"/*
 * Part of rip-dvd - rips DVDs to h264/vorbis|ac3/mkv
 * Copyright (C) 2009 Thomas Spurden
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>

#define BUFSZ	512
#define LINELEN	256
#define MAX_BARLEN 64

static struct {
	float pc;
	time_t lastTime;
	unsigned int update : 1;
	unsigned int verbose : 1;
	struct {
		int x, y, w, h;
		unsigned int active : 1;
	} crop;
} state = {
	.pc = 0.0f,
	.lastTime = 0,
	.update = 0,
	.verbose = 0,
	{ .x = 0, .y = 0, .w = 0, .h = 0, .active = 0 }
};

static void print(char const* prefix, unsigned int barlen) {
	if(state.pc < 0) {
		state.pc = 0;
	} else if(state.pc > 100) {
		state.pc = 100;
	}
	if(barlen > MAX_BARLEN) {
		barlen = MAX_BARLEN;
	}

	{
		unsigned int nbars = ((float)barlen * (state.pc / 100.0f));
		char pcbar[MAX_BARLEN + 3];
		unsigned int i;
		pcbar[0] = '[';
		pcbar[barlen + 1] = ']';
		pcbar[barlen + 2] = '\0';

		for(i = 1; i <= barlen; i++) {
			if(i <= nbars) {
				pcbar[i] = '=';
			} else {
				pcbar[i] = ' ';
			}
		}
		printf(""%s %s %04.1f%%\n"", prefix, pcbar, state.pc);
	}
}

static void parseCropLine(char const* line) {
	char const* pos = strrchr(line, '=');
	int args[4];
	unsigned int i;

	if(pos == NULL) {
		return;
	}

	pos += 1;

	for(i = 0; i < 4; i++) {
		char const* next;
		args[i] = strtol(pos, (char**)(&next), 0);
		if(next == pos) {
			return;
		}
		pos = next + 1;
	}

	if(state.verbose) {
		printf(""Read crop %i:%i:%i:%i\n"", args[0], args[1], args[2], args[3]);
	}

	if(state.crop.active) {
		/* Only expand the crop area, never shrink it */
		state.crop.w = args[0] > state.crop.w ? args[0] : state.crop.w;
		state.crop.h = args[1] > state.crop.h ? args[1] : state.crop.h;
		state.crop.x = args[2] < state.crop.x ? args[2] : state.crop.x;
		state.crop.y = args[3] < state.crop.y ? args[3] : state.crop.y;
	} else {
		state.crop.w = args[0];
		state.crop.h = args[1];
		state.crop.x = args[2];
		state.crop.y = args[3];
	}
}

static void parseStatusLine(char const* line, char const* pcpos) {
	char const* strt = pcpos - 1;
	char const* next;
	float pc;

	if(pcpos == line) {
		return;
	}

	while(strt != line) {
		if(!(isdigit(*strt) || *strt == '.')) {
			break;
		}
		strt--;
	}

	if(strt == pcpos) {
		return;
	}

	pc = strtod(strt, (char**)&next);
	if(state.verbose) {
		printf(""Read percentage %f from \""%s\""\n"", pc, strt);
	}
	if(next == pcpos && pc != state.pc) {
		state.pc = pc;
		state.update = 1;
	}
}

static void parseLine(char* line) {
	char* pos;
	if(strncmp(line, ""[CROP] "", 7) == 0) {
		parseCropLine(line);
		state.crop.active = 1;
		if(state.verbose) {
			printf(""Crop Line: \""%s\""\n"", line);
		}
	} else if((pos = strchr(line, '%')) != NULL) {
		*pos = '\0';
		parseStatusLine(line, pos);
		if(state.verbose) {
			printf(""Percentage Line: \""%s\""\n"", line);
		}
	} else if(state.verbose) {
		printf(""Unknown Line: \""%s\""\n"", line);
	}
}

int main(int argc, char** argv) {
	char const* prefix;
	char buf[BUFSZ];
	char line[LINELEN];
	size_t sz, linePos = 0;
	int barlen = 16;
	int printStatus = 1;

	/*
	 * -v     print debugging info
	 * -l num use a percentage bar num long
	 * -n     don't print percentage status
	 * --     stop checking for options
	 */
	
	{
		unsigned int i;
		for(i = 1; i < argc; ++i) {
			if(strcmp(argv[i], ""--"") == 0) {
				i++;
				break;
			} else if(strcmp(argv[i], ""-v"") == 0) {
				state.verbose = 1;
			} else if(strcmp(argv[i], ""-l"") == 0) {
				i++;
				if(i < argc) {
					barlen = atoi(argv[i]);
				}
			} else if(strcmp(argv[i], ""-n"") == 0) {
				printStatus = 0;
			} else {
				break;
			}
		}
		if(i >= argc) {
			prefix = ""Unknown"";
		} else {
			prefix = argv[i];
		}
	}

	while((sz = fread(buf, 1, BUFSZ, stdin)) != 0) {
		size_t i;
		for(i = 0; i < sz; i++) {
			if(linePos == LINELEN) {
				linePos = 0;
			}
			if(buf[i] == '\n' || buf[i] == '\r') {
				line[linePos] = '\0';
				linePos = 0;
				parseLine(line);
			} else {
				line[linePos++] = buf[i];
			}
			if(state.update && printStatus) {
				time_t thisTime = time(NULL);
				if(thisTime - state.lastTime > 2) {
					print(prefix, barlen);
					state.lastTime = thisTime;
				}
				state.update = 0;
			}
		}
	}
	if(state.crop.active) {
		printf(""%i:%i:%i:%i"", state.crop.w, state.crop.h, state.crop.x, state.crop.y);
		fflush(stdout);
	}
	return 0;
}
"
092-25700,andrew0snake/4,test/thread.c,30,4,29,4033371.1076527503,190081.0,21.219222331532347,1547.0,1512.0,43289.0,15892.0,1667.0,731.0,1375.0,688.0,1500000000,0.0026889140717685,1082014363648.0,0.0160931392406395,0.0753789222892482,"
#include <stdio.h>
#include <pthread.h>

/* This is our thread function.  It is like main(), but for a thread */
void *threadFunc(void *arg)
{
	char *str;
	int i = 0;

	str=(char*)arg;

	while(i < 10 )
	{
		usleep(1);
		printf(""threadFunc says: %s\n"",str);
		++i;
	}

	return NULL;
}

int main(void)
{
	pthread_t pth;	// this is our thread identifier
	int i = 0;

	/* Create worker thread */
	pthread_create(&pth,NULL,threadFunc,""processing..."");

	/* wait for our thread to finish before continuing */
	pthread_join(pth, NULL /* void ** return value could go here */);

	while(i < 10 )
	{
		usleep(1);
		printf(""main() is running...\n"");
		++i;
	}

	return 0;
}


"
200-26625,kujenga/euler,Euler_27/QuadraticPrimes.c,33,4,31,25830160.360783197,134705846.0,0.1917523312239915,1343.0,1322.0,39390.0,13436.0,1619.0,639.0,1340.0,594.0,1500000000,0.0172201069071888,1082014363648.0,1.978384813380705e-05,0.0793548631355771,"// (c) 2013 Aaron M. Taylor
// This program solves problem 27 of Project Euler

#import <stdio.h>


int isPrime(int n)
{
  if (n==2) return 1;
  if (n%2==0)return 0;
  if (n<2) return 0;
  int f = 3;
  while(f*f <= n) {
    if (n%f == 0) return 0;
    f += 2;
  }
  return 1;
}


int main ( int argc, char** argv )
{
  int maxN = 0;
  int maxA = 0;
  int maxB = 0;
  for ( int a = -999; a < 1000; a++ ) {
    for (int b = -999; b < 1000; b++ ) {
      //printf(""a:%d b:%d\n"",b,a);
      int n;
      for ( n = 0; isPrime(n*n + a*n + b); n++) ;
      if ( n > maxN ) {
	maxN = n;
	maxA = a;
	maxB = b;
      }
    }
  } 
  printf(""maxA:%d maxB:%d maxN:%d product:%d\n"",maxA,maxB,maxN,maxA*maxB);
}
"
237-38,Meemaw/Eulers-Project,Problem_23.c,40,5,24,601633132.6682119,1974381812.0,0.3047197499203867,1354.0,1332.0,24326919.0,12169359.0,1010537.0,2992180.0,1350.0,2786.0,1500000000,0.4010887551121413,1082014363648.0,1.360425822237062e-06,0.1097879898876263,"#include<stdio.h>
#include<stdlib.h>


int* tabela;
int* pregledano;

int isAbundant(int stevilo) {
	int i;
	int vsota = 0;
	for(i = 1; i < stevilo/2 + 1; i++) {
		if(stevilo % i == 0) {
			vsota += i;
		}
	}
	return vsota > stevilo ? 1 : 0;
}

int main() {

	
	int indeks = 0;
	tabela = malloc(6965*sizeof(int));
	

	int limit = 28123;
	pregledano = malloc(28123*sizeof(int));
	int i,x;

	for(i = 1; i <= 28123; i++) {
		if(isAbundant(i)) {
			tabela[indeks++] = i;
		}
	}

	long vsota = 0;
	for(i = 0; i < indeks; i++) {
		for(x = i; x < indeks; x++) {
			if(tabela[i] + tabela[x] <= 28123) {
				pregledano[tabela[i]+tabela[x]] = 1;
			}
		}
	}

	for(i = 0; i < 28123; i++) {
		if(pregledano[i] == 0) {
			vsota += i;
		}
	}
	printf(""Sum of all the positive integers which cannot be written as the sum of two abundant numbers:\n"");
	printf(""%ld\n"", vsota);







	return 0;
}"
226-14547,ankitpokhrel/academic-c,Eular/power_digit_sum.c,39,4,29,30897999.06592815,144660070.0,0.2135903777732169,1238.0,1222.0,11599434.0,11579832.0,1603.0,813.0,1329.0,771.0,1500000000,0.0205986660439521,1082014363648.0,1.700538372475556e-05,0.0001948292926963,"/**
 * Power digit sum.
 * https://projecteuler.net/problem=16
 */

#include <stdlib.h>
#include <math.h>
#include <assert.h>

int array_sum(int *arr, int length)
{
    int sum = 0;

    for (int i = 0; i < length; i++) {
        sum = sum + arr[i];
    }

    return sum;
}

int power_digit_sum(int n)
{
    size_t max_required_space = (size_t) ceil(0.35 * n);

    int *power = (int *) calloc(max_required_space, sizeof(int));

    power[0] = 1;

    for (int i = 1; i <= n; i++) {
        power[0] = 2 * power[0];

        for (int k = 1; k < max_required_space; k++) {
            power[k] = 2 * power[k] + power[k - 1] / 10;
        }

        for (int j = 0; j < max_required_space; j++) {
            power[j] = power[j] % 10;
        }
    }

    return array_sum(power, (int) max_required_space);
}

int main()
{
    assert(5 == power_digit_sum(5));
    assert(26 == power_digit_sum(15));
    assert(115 == power_digit_sum(100));
    assert(679 == power_digit_sum(500));
    assert(1366 == power_digit_sum(1000));
    assert(2035 == power_digit_sum(1500));
    assert(2704 == power_digit_sum(2000));
    assert(3871 == power_digit_sum(3000));
}
"
325-30042,TrentQuarantino/CaStore,tcp_in_c/memmem_funz_gen.c,44,1,38,2162344.5209115,184181.0,11.740320662826242,1305.0,1288.0,43624.0,15128.0,1635.0,641.0,1354.0,596.0,1500000000,0.001441563013941,1082014363648.0,0.0140785423034949,0.0719294662309368,"#define _GNU_SOURCE
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

void printa (const char *dato, int len) {
  int i;
  for (i = 0; i < len; ++i) {
    printf(""%c"", dato[i]);
  }
  printf(""\n"");
}

struct dati {
    char dato[256];
    int lung;
};

void substitutor (struct dati *d, const char *str, const char *sub, const char *neu) {
    //char dest[512];
    char *ret;
    int len_str;
    int len_sub;
    int len_neu;
    int diff_bef;
    int diff_aft;

    len_str = strlen(str);
    len_sub = strlen(sub);
    len_neu = strlen(neu);

    ret = (char *)memmem(str, len_str, sub, len_sub);
    diff_bef = ret - str;
    printa(str, diff_bef);
    diff_aft = len_str - diff_bef - len_sub;
    printa(str + diff_bef + len_sub, diff_aft);
    memcpy(d->dato, str, diff_bef);
    printa(d->dato, diff_bef);
    memcpy(d->dato + diff_bef, neu, len_neu);
    printa(d->dato, diff_bef + len_neu);
    memcpy(d->dato + diff_bef + len_neu, str + diff_bef + len_sub, diff_aft);
    printa(d->dato, len_str -len_sub + len_neu);
    d->lung = len_str - len_sub + len_neu;

}

int main (int argc, char **argv) {
    struct dati d;
    char str[] = ""zlatanibrahimovic%40parigistgermain.com"";
    char sub[] = ""%40"";
    char neu[] = ""@"";
    substitutor(&d, str, sub, neu);
    printa(d.dato, d.lung);

   return(0);
}
"
153-13182,sportalski/jp,petle-2.c,12,1,19,1724787.17286135,173646.0,9.932777029128228,1298.0,1280.0,39350.0,13388.0,1607.0,636.0,1333.0,594.0,1500000000,0.0011498581152409,1082014363648.0,0.0148462964882577,0.0790701202169213,"#include <stdio.h>

int main()
{
    int i = 1;
    while (i <= 8) {

        if (i % 2 == 0)
            printf("" * * * * * * * *\n"");
        else
            printf(""* * * * * * * *\n"");

        ++i;
    }
    return 0;
}
"
202-8314,hzq1001/or1k-src,gdb/testsuite/gdb.base/step-break.c,24,2,26,942807763.6985109,9663845478.0,0.0973236289985306,1139.0,1129.0,3221263925.0,2147496345.0,1567.0,588.0,1316.0,547.0,1500000000,0.6285385091323406,1082014363648.0,2.3468918301344558e-07,7.484036905972708e-07,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2008-2013 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

int
main ()
{
    volatile int i = 1;

    while (i > 0) /* place1 */
      {
	i++; /* place2 */
	i++; /* place3, set breakpoint here  */
      }

    return 0;
}
"
357-7730,dplbsd/zcaplib,head/tools/regression/tls/ttls2/ttls2.c,28,2,31,15025250067.00307,209195.0,71804.83894452544,1568.0,1533.0,47032.0,18485.0,1669.0,771.0,1374.0,728.0,1500000000,10.016833378002048,1082014363648.0,0.0148234900451731,0.0693255185676999,"/* $FreeBSD: soc2013/dpl/head/tools/regression/tls/ttls2/ttls2.c 133109 2004-08-03 09:04:01Z dfr $ */

#include <stdio.h>
#include <pthread.h>

int __thread i;

void *
foo1(void *arg)
{
	printf(""thread %p, &i = %p\n"", pthread_self(), &i);
	for (i = 0; i < 10; i++) {
		printf(""thread %p, i = %d\n"", pthread_self(), i);
		sleep(1);
	}
}

void *
foo2(void *arg)
{
	printf(""thread %p, &i = %p\n"", pthread_self(), &i);
	for (i = 10; i > 0; i--) {
		printf(""thread %p, i = %d\n"", pthread_self(), i);
		sleep(1);
	}
}

int main(int argc, char** argv)
{
	pthread_t t1, t2;

	pthread_create(&t1, 0, foo1, 0);
	pthread_create(&t2, 0, foo2, 0);
	pthread_join(t1, 0);
	pthread_join(t2, 0);
}
"
153-5315,axelmuhr/Helios-NG,cmds/private/C40/atst.c,30,1,23,4106121.1377381,209299.0,19.618445381965515,1152.0,1142.0,45874.0,15185.0,1576.0,586.0,1323.0,546.0,1500000000,0.0027374140918254,1082014363648.0,0.0109603963707423,0.0660181136278026,"/* quick hack to test output of non aligned data */
/* PAB 23/6/92 */

#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv)
{
	int sz;
	char *fred = ""abcdefghijklmnopqrstuvwxyz""
			""abcdefghijklmnopqrstuvwxyz""
			""abcdefghijklmnopqrstuvwxyz""
			""abcdefghijklmnopqrstuvwxyz""

			""abcdefghijklmnopqrstuvwxyz""
			""abcdefghijklmnopqrstuvwxyz""
			""abcdefghijklmnopqrstuvwxyz""
			""abcdefghijklmnopqrstuvwxyz""

			""abcdefghijklmnopqrstuvwxyz""
			""abcdefghijklmnopqrstuvwxyz""
			""abcdefghijklmnopqrstuvwxyz""
			""abcdefghijklmnopqrstuvwxyz"";

		/*    012345678901234567890123456789 */

	for (sz = 1 ;sz <= 300; sz++) {
		write(1, &fred[0], sz);
		write(1, ""\n"", 1);
		write(1, &fred[1], sz);
		write(1, ""\n"", 1);
		write(1, &fred[2], sz);
		write(1, ""\n"", 1);
		write(1, &fred[3], sz);
		write(1, ""\n"", 1);
	}
}

/* end of align test */
"
281-34258,Akagi201/akcode,c/ctest/hik_test/test_mprStrcmpAnyCase.c,37,1,34,2454468.16552425,176064.0,13.940771537622682,1348.0,1331.0,40088.0,13535.0,1632.0,633.0,1354.0,590.0,1500000000,0.0016363121103495,1082014363648.0,0.0152160577971646,0.0784924379464035,"
#include <stdio.h>

int mprStrcmpAnyCase(char *str1, char *str2);

int main()
{
    char src[] = ""/Streaming/channels/102/preview"";
    char dst[] = ""/streaming/channels/102/preview"";
    printf(""%d\n"", mprStrcmpAnyCase(src, dst));
    return 0;
}

/*
 *  Case insensitive string comparison. Stop at the end of str1.
 */
int mprStrcmpAnyCase(char *str1, char *str2)
{
    int     rc;

    if (str1 == 0) {
        return -1;
    }
    if (str2 == 0) {
        return 1;
    }
    if (str1 == str2) {
        return 0;
    }
    for (rc = 0; *str1 && *str2 && rc == 0; str1++, str2++) {
        rc = tolower((int) *str1) - tolower((int) *str2);
    }
    if (rc) {
        return rc < 0 ? -1 : 1;
    } else if (*str1 == '\0' && *str2 == '\0') {
        return 0;
    } else if (*str1 == '\0') {
        return -1;
    } else if (*str2 == '\0') {
        return 1;
    }

    return 0;
}

"
375-15705,indigoid/mmalloc,mmalloc.c,50,2,42,200842256.89060983,350141.0,573.6039366997867,1399.0,1374.0,73604.0,37137.0,1636.0,701.0,1353.0,657.0,1500000000,0.1338948379270732,1082014363648.0,0.0079196666485787,0.0392537542554248,"/* malloc until it breaks */
/* Public domain. Do as you will! See LICENSE for long boring version. */
/* John Slee <john@slee.id.au> Sun 15 Sep 2013 01:36:05 MYT */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

#define default_increment 131072

volatile int stop;

void handle_interruption(int x) {
	stop = 1;
}

int main(int argc, char** argv) {
	size_t increment = default_increment, s = 0;
	int steps = 0, speedups = 0, slowdowns = 0;
	printf(""initial increment is %zd\n"", increment);
	s += increment;
	steps++;
	stop = 0;
	signal(SIGINT,  handle_interruption);
	signal(SIGTERM, handle_interruption);
	signal(SIGHUP,  handle_interruption);
	void* p = malloc(s);
	while (increment > 1) {
		void *newp = realloc(p, s + increment);
		if (newp != NULL) {
			p = newp;
			s += increment;
			steps++;
			printf(""incrementing by %zd to %zd bytes\n"", increment, s);
			increment *= 2;
			speedups++;
			printf(""speeding up to %zd-byte steps\n"", increment);
		} else {
			increment /= 2;
			slowdowns++;
			printf(""slowing down to %zd-byte steps\n"", increment);
		}
		steps++;
		if (stop)
			break;
	}
	free(p);
	printf(	""\n\n""
		""allocated %zd bytes of memory\n""
		""steps=%d\n""
		""speedups=%d\n""
		""slowdowns=%d\n"",
		s,
		steps,
		speedups,
		slowdowns
	);
	return 0;
}
"
268-32196,AshwinChandlapur/robocomp,tools/rcmanager/rcmanager.c,21,2,23,4937077.52320905,177634.0,27.793536147359177,1424.0,1399.0,40419.0,14023.0,1634.0,643.0,1354.0,599.0,1500000000,0.0032913850154727,1082014363648.0,0.015892227839265,0.0776973660041879,"#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>

#define BASE ""/opt/robocomp/bin/rcmanager.py""

int main(int argc, char **argv) {
	int i;
	int length;
	char *str, *ptr_str;

	length = strlen(BASE) + 1;
	for (i = 1; i < argc; i++) {
		length += strlen(argv[i] + 1);
	}

	str = (char *)malloc(length*sizeof(char));
	ptr_str = str;

	sprintf(ptr_str, ""%s "", BASE);
	ptr_str += strlen(BASE) + 1;

	for (i = 1; i < argc; i++) {
		sprintf(ptr_str, ""%s "", argv[i]);
		ptr_str += strlen(argv[i]) + 1;
	}

	i = system(str);
	printf(""sytem\n"");
	free(str);
	return i;
}

"
012-18959,mattstock/binutils-bexkat1,gdb/testsuite/gdb.base/watch-bitfields.c,46,1,32,1436357.8520715,169066.0,8.495835945725338,1139.0,1129.0,38453.0,12697.0,1567.0,588.0,1316.0,547.0,1500000000,0.000957571901381,1082014363648.0,0.0134148793962121,0.0785532746823069,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

struct foo
{
  unsigned long a:1;
  unsigned char b:2;
  unsigned long c:3;
  char d:4;
  int e:5;
  char f:6;
  int g:7;
  long h:8;
} q = { 0 };

int
main (void)
{
  q.a = 1;
  q.b = 2;
  q.c = 3;
  q.d = 4;
  q.e = 5;
  q.f = 6;
  q.g = -7;
  q.h = -8;
  q.a--;
  q.h--;
  q.c--;
  q.b--;
  q.e--;
  q.d--;
  q.c--;
  q.f--;
  q.g--;
  q.h--;


  return 0;
}
"
203-34517,argp/macgdb,gdb/testsuite/gdb.base/watchpoints.c,24,2,19,1783682.96474205,169062.0,10.550460777702854,1139.0,1129.0,38452.0,12701.0,1567.0,588.0,1316.0,547.0,1500000000,0.0011891219764947,1082014363648.0,0.0134151967917095,0.0785486677223232,"#include <stdio.h>
#include <unistd.h>
/*
 * This source is mainly to test
 * what happens when a watchpoint is removed
 * while another watchpoint, inserted later is
 * left active.
 */

int count = -1;
int ival1 = -1;
int ival2 = -1;
int ival3 = -1;
int ival4 = -1;

int 
main ()
{
#ifdef usestubs
  set_debug_traps();
  breakpoint();
#endif

  for (count = 0; count < 4; count++) {
    ival1 = count; ival2 = count;
    ival3 = count; ival4 = count;
  }

  ival1 = count; ival2 = count;  /* Outside loop */
  ival3 = count; ival4 = count;

  return 0;
}
"
331-1322,b3h3moth/L-C,c11_language/array/array_bidimensional.c,21,2,23,2430589.5203724,179907.0,13.510252519357223,1352.0,1331.0,40739.0,14281.0,1631.0,634.0,1352.0,591.0,1500000000,0.0016203930135816,1082014363648.0,0.0149132607402713,0.0764812795347146,"#include <stdio.h>
#include <stdlib.h>

#define ROWS    2
#define COLS    3

int main(void) {

    // Array bidimensionale e' sinonimo di matrice
    // Dichiarazione di una matrice di tipo intero
    // Inizializzazione a 0 di ciascun elemento
    int matrix_a[ROWS][COLS] = { {0} };

    // Inizializzazione contestualmente alla dichiarazione
    // Valgono comunque le regole per i vettori
    int matrix_b[ROWS][COLS] = { {10, 20, 30},
                                 {40, 50, 60} };

    // Accesso agli elementi
    int num = matrix_b[0][1]; // Si assegna 20

    printf(""num: %d\n"", num);

    // Visualizzazione elementi della matrice
    for (int i=0; i<ROWS; i++) {
        printf(""ROW[%d] : "", i);
        for (int y=0; y<COLS; y++)
            printf(""%d | "", matrix_b[i][y]);
        printf(""\n"");
    }

    return(EXIT_SUCCESS);
}
"
300-20215,maemo-tools-old/functracer,testsuite/functracer.memtransfer/memtransfer.c,68,1,40,2157183.0147876,189022.0,11.412338246341696,1322.0,1299.0,43212.0,15613.0,1714.0,716.0,1412.0,618.0,1500000000,0.0014381220098584,1082014363648.0,0.0138661108230787,0.0758181045473863,"/*
 * This file is part of Functracer.
 *
 * Copyright (C) 2011-2012 by Nokia Corporation
 *
 * Contact: Eero Tamminen <eero.tamminen@nokia.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *
 */

#define _GNU_SOURCE

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <wchar.h>

void test_char(void)
{
	char src[1024] = ""source string"", dst[1024], *ptr;
	int len = strlen(src) + 1; /* copy also terminator */

	strcpy(dst, src);
	memcpy(dst, src, len);
	memmove(dst, src, len);
	ptr = memccpy(dst, src, '\0', len);
	mempcpy(dst, src, len);
	memset(dst, 0, 100);
	strncpy(dst, src, 5);
	stpcpy(dst, src);
	strcat(dst, src);
	strncat(dst, src, 5);
	bcopy(src, dst, len);
	bzero(dst, 100);
	ptr = strdup(src);
	free(ptr);
	ptr = strndup(src, 5);
	free(ptr);
}

void test_wchar(void)
{
	wchar_t src[1024] = L""source string"", dst[1024], *ptr;
	int len = wcslen(src) + 1; /* copy also terminator */
	wmemcpy(dst, src, len);
	wmempcpy(dst, src, len);
	wmemmove(dst, src, len);
	wmemset(dst, 0, 100);
	wcscpy(dst, src);
	wcsncpy(dst, src, 5);
	wcpcpy(dst, src);
	wcpncpy(dst, src, 5);
	wcscat(dst, src);
	wcsncat(dst, src, 5);
	len = wcsnlen(src, 5);
	ptr = wcsdup(src);
	free(ptr);
}

int main(void)
{
	test_char();
	test_wchar();
	return 0;
}
"
244-7442,df9ry/daisy,test/test0001/hello.c,22,1,24,1934342.784807,172505.0,11.209680878815108,1292.0,1274.0,39031.0,13223.0,1606.0,634.0,1333.0,592.0,1500000000,0.001289561856538,1082014363648.0,0.0148749311614156,0.0797068167030275,"/* Copyright 2017 Tania Hagn
 *
 * This file is part of Daisy.
 *
 *    Daisy is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    Daisy is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with Daisy.  If not, see <http://www.gnu.org/licenses/>.
 */

#define _POSIX_SOURCE 1

#include <stdlib.h>
#include <stdio.h>

int main()
{
	printf(""Hello Test0001\n"");
	return(EXIT_SUCCESS);
}
"
265-18503,Gigers/data-struct,Aulas/aula05/src/lst_no_head.c,33,2,32,1619297.77823385,181058.0,8.943526383810713,1338.0,1320.0,40918.0,14537.0,1618.0,642.0,1339.0,598.0,1500000000,0.0010795318521559,1082014363648.0,0.0146803786631908,0.0756829862050311,"#include <stdio.h>
#include <stdlib.h>

/*
    Código da implementação de uma lista sem cabeça
*/

struct cel {
       int conteudo;
       struct cel *seg; /* seguinte */
};

typedef struct cel celula;

void Imprima2(celula *lst) {
     celula *p;
     for (p = lst; p != NULL; p = p->seg)
         printf (""%d\n"", p->conteudo);
}

void Insere2(int y, celula **p){
    celula *nova;
    nova = malloc(sizeof(celula));
    nova -> conteudo = y;

    if (*p == NULL) { //Esta comparação sempre é feita (Perda de desempenho)
        *p = nova;
        nova -> seg = NULL;
    } else {
        nova -> seg = *p;
        *p = nova;
    }
}

int main(void){
    int i;
    celula *lst; // int a    int *
    lst = NULL;

    for (i = 0; i < 10; i++)
        Insere2(i, &lst);
    Imprima2(lst);
}"
221-4976,swigger/gdb-ios,gdb/testsuite/gdb.base/watchpoints.c,32,3,27,2074190.99751855,169062.0,12.268812624954158,1139.0,1129.0,38452.0,12701.0,1567.0,588.0,1316.0,547.0,1500000000,0.0013827939983457,1082014363648.0,0.0134151967917095,0.0785486677223232,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2009-2016 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

   Please email any bugs, comments, and/or additions to this file to:
   bug-gdb@gnu.org  */

/* This source is mainly to test what happens when a watchpoint is
   removed while another watchpoint, inserted later is left active.  */

int count = -1;
int ival1 = -1;
int ival2 = -1;
int ival3 = -1;
int ival4 = -1;

int 
main ()
{
  for (count = 0; count < 4; count++) {
    ival1 = count; ival2 = count;
    ival3 = count; ival4 = count;
  }

  ival1 = count; ival2 = count;  /* Outside loop */
  ival3 = count; ival4 = count;

  return 0;
}
"
302-24883,codelion/pathgrind,valgrind-r12356/helgrind/tests/tc14_laog_dinphils.c,30,4,25,1505408219.760284,865614.0,1739.1218476133704,1405.0,1377.0,232647.0,65361.0,1666.0,754.0,1362.0,712.0,1500000000,1.0036054798401892,1082014363648.0,0.0032139036568262,0.0150801320769912,"
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>

/* Naive dining philosophers with inconsistent lock acquisition
   ordering. */

static pthread_t phil[5];
static pthread_mutex_t chop[5];

void* dine ( void* arg )
{
   int i;
   long left = (long)arg;
   long right = (left + 1) % 5;
   for (i = 0; i < 1000/*arbitrary*/; i++) {
      pthread_mutex_lock(&chop[left]);
      pthread_mutex_lock(&chop[right]);
      /* eating */
      pthread_mutex_unlock(&chop[left]);
      pthread_mutex_unlock(&chop[right]);
   }
   return NULL;
}

int main ( void )
{
   long i;
   for (i = 0; i < 5; i++)
      pthread_mutex_init( &chop[i], NULL);

   for (i = 0; i < 5; i++)
      pthread_create(&phil[i], NULL, dine, (void*)i );

   sleep(1);

   for (i = 0; i < 5; i++)
      pthread_join(phil[i], NULL);

   return 0;
}
"
301-16301,guillermo-carrasco/algorithmics,src/smallest_multiple.c,32,3,32,727661530.2544087,2193918341.0,0.3316721121299017,1334.0,1315.0,39251.0,13352.0,1619.0,639.0,1340.0,594.0,1500000000,0.4851076868362725,1082014363648.0,1.2074287135010555e-06,0.0796912723608919,"/*
 * This is the bruteforce solution. A smarter solution would be to do a prime 
 * factorization of 1..N and then get the product of the highest powers. This
 * takes advantage of the lowest common multiple. i.e for 1..10:
 *
 * 10 = 5 * 2
 * 9 = 3^2
 * 8 = 2^3
 * 7 = 7
 * 6 = 3 * 2
 * 5 = 5
 * 4 = 2^2
 * 3 = 3
 * 2 = 2
 *
 * res = 5 * 3^2 * 2^3 * 7 = 2520
 * */

#include <stdio.h>
#include <stdlib.h>

#define N 20

int main() {
    char found = 0;
    int res = N;
    while (!found) {
        int i;
        for (i=N; i > 1; i--) {
            if (res%i !=  0)
                break;
        }
        if (i == 1) found = 1;
        else res++;
    }
    printf(""Smallest multiple of 1..%d is %d\n"", N, res);
    return 0;
}
"
197-9828,Gurgel100/gcc,libgomp/testsuite/libgomp.oacc-c-c++-common/declare-vla.c,38,6,31,1512903.1380637502,200928.0,7.529577759197324,1151.0,1143.0,40930.0,16872.0,1586.0,613.0,1328.0,558.0,1500000000,0.0010086020920425,1082014363648.0,0.0114170250039815,0.0706722950762949,"/* Verify OpenACC 'declare' with VLAs.  */

#include <assert.h>


void
f (void)
{
  int N = 1000;
  int i, A[N];
#pragma acc declare copy(A)

  for (i = 0; i < N; i++)
    A[i] = -i;

#pragma acc kernels
  for (i = 0; i < N; i++)
    A[i] = i;

#pragma acc update host(A)

  for (i = 0; i < N; i++)
    assert (A[i] == i);
}


/* The same as 'f' but everything contained in an OpenACC 'data' construct.  */

void
f_data (void)
{
#pragma acc data
  {
    int N = 1000;
    int i, A[N];
# pragma acc declare copy(A)

    for (i = 0; i < N; i++)
      A[i] = -i;

    /* See 'declare-vla-kernels-decompose.c'.  */
#ifdef KERNELS_DECOMPOSE_ICE_HACK
    (volatile int *) &i;
    (volatile int *) &N;
#endif

# pragma acc kernels
    for (i = 0; i < N; i++)
      A[i] = i;

# pragma acc update host(A)

    for (i = 0; i < N; i++)
      assert (A[i] == i);
  }
}


int
main ()
{
  f ();

  f_data ();

  return 0;
}
"
375-1729,ColinIanKing/stress-ng,test/test-atomic_fetch_xor.c,24,1,25,1860333.0245241,170439.0,10.91112362780819,1145.0,1137.0,38727.0,12788.0,1581.0,586.0,1326.0,544.0,1500000000,0.0012402220163494,1082014363648.0,0.0133889544059751,0.0783655246044841,"/*
 * Copyright (C) 2021-2022 Colin Ian King
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 */
int main(int argc, char **argv)
{
	int var;

	__atomic_fetch_xor(&var, 1, 0);

	return 0;
}

"
021-7166,MarcusTherkildsen/Monkey-and-coconut-problem,monkey.c,33,3,29,1791392.918676,209038.0,8.569695462069097,1340.0,1320.0,39185.0,13307.0,1618.0,637.0,1340.0,594.0,1500000000,0.001194261945784,1082014363648.0,0.0127249590983457,0.0798026365922426,"#include <stdio.h>      /* printf */

/* For best result, compile with gcc -O3 monkey.c
Or else the code can be tried out at 
http://codepad.org/
Click ""Try it"" and paste this code
*/
int main()
{
    // Creating some start variables
    int sailors = 5;
    int monkeys = 1;
    int j;
    int coconuts_tot = 0;
    int coconuts;
	
    // Go through the number of coconuts
    while (0 == 0){
        coconuts_tot += 1;
        coconuts = coconuts_tot;
        
        // Go through the number of sailors
        for (j=0; j<sailors;j++){

            // One for each monkey
            coconuts -= monkeys;      
            if (coconuts % sailors != 0){
                break;
            }			
            coconuts -= coconuts/sailors;	
        }
		
        if (coconuts % sailors == 0){
            break;        
        } 
    }
    printf ( ""Solution: %d coconuts to begin with\n"",coconuts_tot);
    return 0;
}
"
234-26770,AndyMender/baby-utils,threaded/t_World.c,19,1,23,22546033396.502026,179787.0,182582.90420886935,1464.0,1432.0,41017.0,14264.0,1651.0,665.0,1363.0,622.0,1500000000,15.03068893100135,1082014363648.0,0.0161079499630117,0.0778024999547765,"/* This is a simple program to test POSIX threads (pthreads) in C. */

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

/* Simple function to execute in a new thread */
void * helloWorldThreaded () {
  
  for ( int i = 0; i < 5; i++ ) {
	  printf (""Hello, World!\n"");
	  sleep (3);
  }
  
  // return NULL; superficial
}

int main (void) {
  
  pthread_t thread_id; // thread pointer hook
  
  printf (""Prior to thread creation.\n"");
  
  /* Create new thread and launch */
  pthread_create (&thread_id, NULL, helloWorldThreaded, NULL);
  
  /* Grab the output of the thread when it finishes */
  pthread_join (thread_id, NULL);
  
  printf (""After thread execution.\n"");
  
  return EXIT_SUCCESS;
}
"
047-24595,Mazuh/Algs,src/uri_judge/begginer/1098_sequence_ij_4.c,16,2,22,2329997.9511648,248233.0,9.386330584571754,1426.0,1403.0,54446.0,23604.0,1630.0,639.0,1350.0,596.0,1500000000,0.0015533319674432,1082014363648.0,0.0113965508212042,0.0540038436899423,"/**
https://www.urionlinejudge.com.br/judge/en/problems/view/1098
*/

#include <stdio.h>

int main(){

	int i, j;
	float iR, jR;

	for(i = 0; i <= 20; i += 2){
		for (j = 10; j <= 30; j += 10){

			iR = (float) i/10;
			jR = (float) (i+j)/10;

			if (i % 10) printf(""I=%.1f J=%.1f\n"", iR, jR);
			else 		printf(""I=%.0f J=%.0f\n"", iR, jR);
			
		}
	}

    return 0;
}"
049-25599,ch3nkula/My-C-Source-Codes,stack_list.c,69,3,36,2949439.4548236,198383.0,14.65733959058992,1371.0,1348.0,45153.0,17196.0,1634.0,649.0,1354.0,604.0,1500000000,0.0019662929698824,1082014363648.0,0.0137058114858632,0.068020337134517,"/* Stack implementation using linkex list */
/* Author: Alangi Derick */

#include<stdio.h>
#include<stdlib.h>

#define max 100 /* maximum size of stack */

void stackInit(int m);
int stackEmpty();
void stackPush(int item);
int stackPop(void);
void stackDisplay(void);

typedef struct stackNode *LINK;
struct stackNode {
	int item;
	LINK next;
};

LINK head;
LINK newNode(int item, LINK h) {
	LINK nnode = malloc(sizeof(*nnode));
	nnode -> item = item;
	nnode -> next = h;
	return nnode;
}

void stackInit(int m)
{
	head = NULL;
}

int stackEmpty() {
	return head == NULL;
}

void stackPush(int item) {
	head = newNode(item, head);
	printf(""%d added to stack "", item);
}

int stackPop(void) {
	int item = head -> item;	
	LINK t = head -> next;
	free(head);
	head = t;
	return item;
}

void stackDisplay(void) {
	LINK t = head;
	while(t!=NULL) {
		printf(""%d "", t->item);
		t = t -> next;
	}
	printf(""\n"");
}


int main(void) {
	int i, item;
	stackInit(max);
	/*add 10 random numbers to stack*/

	for(i=0; i<10; i++){
	stackPush(rand() % 100);
	printf(""\n"");
	}
	printf(""\n"");
	
	printf(""Initial Contents: "");
	stackDisplay();
	/*pop 5 items off the stack*/
	for(i=0; i<5; i++)
	{
		if(!stackEmpty()) {
		item = stackPop();
		printf(""%d popped from stack. "", item);
		printf(""\n"");
		
	}
}

	printf(""\n"");
	printf(""Contents after popping off 5 items: "");
	stackDisplay();
}
"
132-21000,igou/gcc,libgomp/testsuite/libgomp.oacc-c-c++-common/loop-red-g-1.c,42,2,36,1790462.8766700001,169061.0,10.590627051774211,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.00119364191778,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* { dg-do run } */
/* { dg-additional-options ""-O2"" */

#include <stdio.h>

#define N (32*32*32+17)
int main ()
{
  int ix;
  int ondev = 0;
  int t = 0, h = 0;
  
#pragma acc parallel num_gangs(32) vector_length(32) copy(t) copy(ondev)
  {
#pragma acc loop gang  reduction (+:t)
    for (unsigned ix = 0; ix < N; ix++)
      {
	int val = ix;
	
	if (__builtin_acc_on_device (5))
	  {
	    int g = 0, w = 0, v = 0;

	    __asm__ volatile (""mov.u32 %0,%%ctaid.x;"" : ""=r"" (g));
	    __asm__ volatile (""mov.u32 %0,%%tid.y;"" : ""=r"" (w));
	    __asm__ volatile (""mov.u32 %0,%%tid.x;"" : ""=r"" (v));
	    val = (g << 16) | (w << 8) | v;
	    ondev = 1;
	  }
	t += val;
      }
  }

  for (ix = 0; ix < N; ix++)
    {
      int val = ix;
      if(ondev)
	{
	  int g = ix / ((N + 31) / 32);
	  int w = 0;
	  int v = 0;

	  val = (g << 16) | (w << 8) | v;
	}
      h += val;
    }
  if (t != h)
    {
      printf (""t=%x expected %x\n"", t, h);
      return 1;
    }
  
  return 0;
}
"
242-26285,stephenR/glibc-fpp,manual/examples/sigh1.c,39,7,31,4130054583.074526,540828919.0,7.636526890308541,1308.0,1293.0,151742736.0,74486523.0,1624.0,704.0,1341.0,655.0,1500000000,2.7533697220496838,1082014363648.0,4.809284246133296e-06,1.9113354387108697e-05,"/* Signal Handlers that Return
   Copyright (C) 1991-2012 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2
   of the License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, if not, see <http://www.gnu.org/licenses/>.
*/

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>

/* This flag controls termination of the main loop. */
volatile sig_atomic_t keep_going = 1;

/* The signal handler just clears the flag and re-enables itself. */
void
catch_alarm (int sig)
{
  keep_going = 0;
  signal (sig, catch_alarm);
}

void
do_stuff (void)
{
  puts (""Doing stuff while waiting for alarm...."");
}

int
main (void)
{
  /* Establish a handler for SIGALRM signals. */
  signal (SIGALRM, catch_alarm);

  /* Set an alarm to go off in a little while. */
  alarm (2);

  /* Check the flag once in a while to see when to quit. */
  while (keep_going)
    do_stuff ();

  return EXIT_SUCCESS;
}
"
385-9489,AndrewLaing/CHowToProgramExercises,Chapter12/ex12_15.c,128,3,92,2021824.35896235,804478.0,2.513212294183309,1397.0,1376.0,174324.0,95344.0,1651.0,712.0,1369.0,669.0,1500000000,0.0013478829059749,1082014363648.0,0.0034469556656614,0.0163200676387261,"/*
 * Filename:    ex12_15.c
 * Author:      Andrew Laing
 * Email:       parisianconnections@gmail.com
 * Date:        08/08/2017
 */
 
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

struct queueNode {
    int customer;
    struct queueNode *nextPtr;
};

typedef struct queueNode QueueNode;
typedef QueueNode *QueueNodePtr;

void enqueue( QueueNodePtr *, QueueNodePtr *, int );
int dequeue( QueueNodePtr *, QueueNodePtr * );
int isEmpty( QueueNodePtr );
void printQueue( QueueNodePtr );
int getQueueLength( QueueNodePtr );


int main()
{
    srand(time(NULL));
    
    QueueNodePtr headPtr = NULL, tailPtr = NULL;
    
    int arrivalIntervalMax = 4;
    
    int minutes;
    int customerDue;
    int customerServiceTime;
    int currentCustomerArrival;
    
    int temp;
    int longestQueue = 0;
    int longestWait = 0;
    
    
    customerDue =  ( rand() % arrivalIntervalMax ) + 1;
    customerServiceTime =  ( rand() % 4 ) + 1 + customerDue;
    enqueue( &headPtr, &tailPtr, customerDue );
    
    for( minutes=customerDue; minutes<=720; minutes++ )
    {
        temp = getQueueLength( headPtr );
        if( temp > longestQueue )
            longestQueue = temp;
 
        if( minutes == customerDue )
        {
            printf(""A customer arrived at %d\n"", minutes);
            enqueue( &headPtr, &tailPtr, minutes ); 
            
            customerDue = ( rand() % arrivalIntervalMax ) + 1 + minutes;
            
            if( currentCustomerArrival == 0 ) {
                customerServiceTime =  ( rand() % 4 ) + 1 + minutes;
                currentCustomerArrival = minutes;
            }
                
        }
        if( minutes == customerServiceTime )
        {
            if( ( customerServiceTime - currentCustomerArrival ) > longestWait )
                longestWait = customerServiceTime - currentCustomerArrival;
                
            printf(""The customer served at %d arrived at %d\n"", minutes, currentCustomerArrival);
            if( !isEmpty( headPtr ) ) {
                currentCustomerArrival = dequeue( &headPtr, &tailPtr );
                customerServiceTime =  ( rand() % 4 ) + 1 + minutes;
            }
            else
                currentCustomerArrival = 0;
        }
    }
    
    printf(""\nThe maximum number of customers at any one time was %d people.\n"", longestQueue );
    printf(""The longest wait any 1 customer experienced was %d minutes.\n"", longestWait );
    printf(""The number of customers still waiting to be served at closing time was %d\n"", getQueueLength( headPtr ) );

    return 0;
}


/* Add an item onto the queue */
void enqueue( QueueNodePtr *headPtr,  QueueNodePtr *tailPtr, int value )
{
    QueueNodePtr newPtr;
    
    newPtr = malloc( sizeof( QueueNode ) ); /* Now points to a place in memory*/
    
    if( newPtr != NULL ) {
        newPtr->customer = value;
        newPtr->nextPtr = NULL;

        if( isEmpty( *headPtr ) )
            *headPtr = newPtr;
        else
            ( *tailPtr )->nextPtr = newPtr;
        
        *tailPtr = newPtr;
    }
    else
        printf( ""%c not inserted. No memory available.\n"", value );
}


/* Remove an item from the queue */
int dequeue( QueueNodePtr *headPtr, QueueNodePtr *tailPtr )
{
    int value;  
    QueueNodePtr tempPtr;
    
    value = (*headPtr)->customer;   
    tempPtr = *headPtr;

    *headPtr = (*headPtr)->nextPtr;
    
    if( *headPtr == NULL)
        *tailPtr = NULL;
    
    free( tempPtr );
    
    return value;
}


/* Test if the queue is empty */
int isEmpty( QueueNodePtr headPtr )
{
    return headPtr==NULL;
}


/* Print the contents of the queue from currentPtr */
void printQueue( QueueNodePtr currentPtr )
{
    if( currentPtr == NULL )
        printf( ""Queue is empty.\n\n"" );
    else 
    {
        printf( ""The queue is:\n"" );
        
        while( currentPtr != NULL) {
            printf( ""%d --> "", currentPtr->customer );
            currentPtr = currentPtr->nextPtr;
        }
        
        printf( ""NULL\n\n"" );
    }
}


/* Return the length of the queue from currentPtr */
int getQueueLength( QueueNodePtr currentPtr )
{
    int queueLength = 0;
    if( currentPtr != NULL )
    {       
        while( currentPtr != NULL) {
            queueLength++;
            currentPtr = currentPtr->nextPtr;
        }
    }
    
    return queueLength;
}

"
012-18647,omni-compiler/omni-compiler,tests/openacc/kernels/kernels_async.c,40,6,33,441300676.6699254,704817787.0,0.6261202315542584,1309.0,1301.0,100702926.0,100676831.0,6293129.0,6292109.0,4195594.0,6292066.0,1500000000,0.2942004511132836,1082014363648.0,3.703084752031095e-06,0.1145740681373451,"#include <stdio.h>
#include <stdlib.h>
#define N (32 * 1024 * 1024)


int main()
{
  int i, j;
  int *a = (int*)malloc(sizeof(int) * N);
  int *b = (int*)malloc(sizeof(int) * N);
  int *c = (int*)malloc(sizeof(int) * N);

  if(!(a && b && c)){
    printf(""malloc err\n"");
    return 1;
  }

#pragma acc data copyout(a[0:N], b[0:N], c[0:N])
  {
    //for avoiding initial cost
#pragma acc kernels async(2)
    a[0] = 0;
#pragma acc kernels async(10)
    a[1] = 1;
#pragma acc wait


    //A
#pragma acc kernels loop async(2) gang
    for(j = 0; j < 1; j++){
#pragma acc loop vector
      for(i = 0; i < N; i++){
	a[i] = i * 2;
      }
    }

    //B, this will finish before A
#pragma acc kernels loop async(10)
    for(i = 0; i < N; i++){
      b[i] = 1;
    }

#pragma acc wait(10)

#pragma acc kernels loop async(2)
    for(i = 0; i < N; i++){
      c[i] = a[i] + b[i];
    }
#pragma acc wait
  }

  //check
  for(i = 0; i < N; i++){
    if(c[i] != i * 2 + 1){
      return 1;
    }
  }

  free(a);
  free(b);
  free(c);

  printf(""PASS\n"");
  return 0;
}
"
353-4908,dk00/old-stuff,csie/13parllel-programming/omp3-2.c,27,8,24,488287388.92916584,950293780.0,0.5138278270115585,1349.0,1326.0,50039313.0,50013402.0,3126699.0,3125673.0,1340.0,3125593.0,1500000000,0.3255249259527772,1082014363648.0,2.814918982212006e-06,0.0937436330438409,"#include<stdio.h>

#ifndef N
#define N 5000
#endif
#define M 1000000000

int a[N][N], b[N][N];

int main() {
  int i, j, x, y, sum;
  #pragma omp parallel sections
  {
    #pragma omp section
    for (i = 0; i < N; i++)
      for (j = 0; j < N; j++)
        a[i][j] = i + j;
    #pragma omp section
    for (x = 0; x < N; x++)
      for (y = 0; y < N; y++)
        b[x][y] = x - y;
  }
  sum = 0;
  for (i = 0; i < N; i++)
    for (j = 0; j < N; j++) {
      sum += a[i][j];
      sum %= M;
    }
  printf(""%d\n"", sum);
  sum = 0;
  for (i = 0; i < N; i++)
    for (j = 0; j < N; j++) {
      sum += b[i][j];
      sum %= M;
    }
  printf(""%d\n"", sum);
  return 0;
}

"
214-11453,SanDisk-Open-Source/SSD_Dashboard,uefi/gcc/gcc-4.6.3/gcc/testsuite/gcc.c-torture/execute/20080122-1.c,25,1,22,1474775.9560121999,169083.0,8.676839185488783,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0009831839706748,1082014363648.0,0.0134135306328844,0.0785563462891999,"/* PR rtl-optimization/34628 */
/* Origin: Martin Michlmayr <tbm@cyrius.com> */

typedef unsigned short u16;
typedef unsigned char u8;

static void
do_segfault(u8 in_buf[], const u8 out_buf[], const int len)
{
  int i;

  for (i = 0; i < len; i++) {
    asm("""");

    in_buf[2*i] = (   out_buf[2*i] | out_buf[(2*i)+1]<<8  ) & 0xFF;

    asm("""");

    in_buf[(2*i)+1] =  ( out_buf[2*i] | out_buf[(2*i)+1]<<8 ) >> 8;

    asm("""");
  }
}

int main(int argc, char *argv[])
{
  u8 outbuf[32] = ""buffer     "";
  u8 inbuf[32] = ""\f"";

  asm("""");
  do_segfault(inbuf, outbuf, 12);
  asm("""");

  return 0;
}
"
103-30968,fengbohello/practice,clang/posix/strtoul.c,42,1,36,2345928.1073883,189389.0,12.386822888340928,1373.0,1350.0,42391.0,15318.0,1644.0,640.0,1362.0,598.0,1500000000,0.0015639520715922,1082014363648.0,0.0143778149734145,0.0735413886915385,"/*
 * =====================================================================================
 *
 *       Filename:  strtoul.c
 *
 *    Description:  
 *
 *        Version:  1.0
 *        Created:  12/27/2016 05:28:46 PM
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  YOUR NAME (), 
 *   Organization:  
 *
 * =====================================================================================
 */
#include <stdio.h>
#include <stdlib.h>

//unsigned long int strtoul(const char *nptr, char **endptr, int base);

int main() {
    unsigned long int x = 0;
    char *p = NULL;
    const char *pList[] = 
    {
        ""   10M"",
        ""  10m"",
        ""+20M"",
        ""+ 30M"",
        ""1G"",
        ""12 M"",
        ""  13 M"",
        ""w 10 M"",
        "" w 10 M"",
        NULL
    };
    int i = 0;
    for(i = 0; pList[i] != NULL ; i++) {
        x = strtoul(pList[i], &p, 0);
        printf(""[%s] = [%lu], p = [%s], [%s]\n"", pList[i], x, p, 
                p == pList[i] ? ""error"" : ""success"");
    }

    return 0;
}

"
387-1718,ericdahl/project-euler,c/p052.c,26,3,20,7211937.219835799,33077370.0,0.2180323586790606,1343.0,1324.0,2661682.0,1234437.0,1626.0,636.0,1345.0,594.0,1500000000,0.0048079581465572,1082014363648.0,8.062914312715915e-05,0.0010782524866411,"#include <stdio.h>
#include <string.h>

static int same_digits(int a, int b);

int main(int argc, char** argv) {
    for (int x = 100; ; ++x) {
        if (same_digits(x, x * 2) &&
            same_digits(x, x * 3) &&
            same_digits(x, x * 4) &&
            same_digits(x, x * 5) &&
            same_digits(x, x * 6)) {
            printf(""%d\n"", x);
            break;
        }
    }
}

static int same_digits(int a, int b) {
    int digits[10];
    int goal[10];
    memset(digits, 0, 10 * sizeof(int));
    memset(goal, 0, 10 * sizeof(int));
    for (; a > 0; a /= 10) {
        --digits[a % 10];
    }
    for (; b > 0; b /= 10) {
        ++digits[b % 10];
    }

    return !memcmp(digits, goal, 10);
}
"
066-33480,Gurgel100/gcc,gcc/testsuite/gcc.dg/torture/pr98117.c,18,1,17,1763163.01804035,169977.0,10.372950458003142,1146.0,1137.0,38667.0,12781.0,1577.0,586.0,1323.0,546.0,1500000000,0.0011754420120269,1082014363648.0,0.013431228930973,0.0783703934069351,"/* { dg-do run } */
/* { dg-additional-options ""-fno-tree-scev-cprop"" } */

unsigned char c;
void __attribute__((noipa))
e()
{
  do
    {
    }
  while (++c);
}
int main()
{
  e();
  if (c != 0)
    __builtin_abort ();
  return 0;
}
"
036-33823,cupertinomiranda/binutils,gdb/testsuite/gdb.python/py-prettyprint.c,277,1,94,1491766.42298685,169091.0,8.822267299856291,1140.0,1130.0,38458.0,12700.0,1568.0,590.0,1317.0,549.0,1500000000,0.0009945109486579,1082014363648.0,0.0134247239652021,0.0786582743656906,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2008-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <string.h>

struct s
{
  int a;
  int *b;
};

struct ss
{
  struct s a;
  struct s b;
};

struct arraystruct
{
  int y;
  struct s x[2];
};

struct ns {
  const char *null_str;
  int length;
};

struct lazystring {
  const char *lazy_str;
  /* If -1, don't pass length to gdb.lazy_string().  */
  int len;
};

struct hint_error {
  int x;
};

struct children_as_list {
  int x;
};

#ifdef __cplusplus
struct S : public s {
  int zs;
};

struct SS {
  int zss;
  S s;
};

struct SSS
{
  SSS (int x, const S& r);
  int a;
  const S &b;
};
SSS::SSS (int x, const S& r) : a(x), b(r) { }

class VirtualTest 
{ 
 private: 
  int value; 

 public: 
  VirtualTest () 
    { 
      value = 1;
    } 
};

class Vbase1 : public virtual VirtualTest { };
class Vbase2 : public virtual VirtualTest { };
class Vbase3 : public virtual VirtualTest { };

class Derived : public Vbase1, public Vbase2, public Vbase3
{ 
 private: 
  int value; 
  
 public:
  Derived () 
    { 
      value = 2; 
    }
};

class Fake
{
  int sname;
  
 public:
  Fake (const int name = 0):
  sname (name)
  {
  }
};
#endif

struct substruct {
  int a;
  int b;
};

struct outerstruct {
  struct substruct s;
  int x;
};

struct outerstruct
substruct_test (void)
{
  struct outerstruct outer;
  outer.s.a = 0;
  outer.s.b = 0;
  outer.x = 0;

  outer.s.a = 3;		/* MI outer breakpoint here */

  return outer;  
}

typedef struct string_repr
{
  struct whybother
  {
    const char *contents;
  } whybother;
} string;

/* This lets us avoid malloc.  */
int array[100];
int narray[10];

struct justchildren
{
  int len;
  int *elements;
};

typedef struct justchildren nostring_type;

struct memory_error
{
  const char *s;
};

struct container
{
  string name;
  int len;
  int *elements;
};

typedef struct container zzz_type;

string
make_string (const char *s)
{
  string result;
  result.whybother.contents = s;
  return result;
}

zzz_type
make_container (const char *s)
{
  zzz_type result;

  result.name = make_string (s);
  result.len = 0;
  result.elements = 0;

  return result;
}

void
add_item (zzz_type *c, int val)
{
  if (c->len == 0)
    c->elements = array;
  c->elements[c->len] = val;
  ++c->len;
}

void
set_item(zzz_type *c, int i, int val)
{
  if (i < c->len)
    c->elements[i] = val;
}

void init_s(struct s *s, int a)
{
  s->a = a;
  s->b = &s->a;
}

void init_ss(struct ss *s, int a, int b)
{
  init_s(&s->a, a);
  init_s(&s->b, b);
}

void do_nothing(void)
{
  int c;

  c = 23;			/* Another MI breakpoint */
}

struct nullstr
{
  char *s;
};

struct string_repr string_1 = { { ""one"" } };
struct string_repr string_2 = { { ""two"" } };

int
eval_func (int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8)
{
  return p1;
}

static void
eval_sub (void)
{
  struct eval_type_s { int x; } eval1 = { 1 }, eval2 = { 2 }, eval3 = { 3 },
				eval4 = { 4 }, eval5 = { 5 }, eval6 = { 6 },
				eval7 = { 7 }, eval8 = { 8 }, eval9 = { 9 };

  eval1.x++; /* eval-break */
}

static void
bug_14741()
{
  zzz_type c = make_container (""bug_14741"");
  add_item (&c, 71);
  set_item(&c, 0, 42); /* breakpoint bug 14741 */
  set_item(&c, 0, 5);
}

int
main ()
{
  struct ss  ss;
  struct ss  ssa[2];
  struct arraystruct arraystruct;
  string x = make_string (""this is x"");
  zzz_type c = make_container (""container"");
  zzz_type c2 = make_container (""container2"");
  const struct string_repr cstring = { { ""const string"" } };
  /* Clearing by being `static' could invoke an other GDB C++ bug.  */
  struct nullstr nullstr;
  nostring_type nstype, nstype2;
  struct memory_error me;
  struct ns ns, ns2;
  struct lazystring estring, estring2, estring3;
  struct hint_error hint_error;
  struct children_as_list children_as_list;

  nstype.elements = narray;
  nstype.len = 0;

  me.s = ""blah"";

  init_ss(&ss, 1, 2);
  init_ss(ssa+0, 3, 4);
  init_ss(ssa+1, 5, 6);
  memset (&nullstr, 0, sizeof nullstr);

  arraystruct.y = 7;
  init_s (&arraystruct.x[0], 23);
  init_s (&arraystruct.x[1], 24);

  ns.null_str = ""embedded\0null\0string"";
  ns.length = 20;

  /* Make a ""corrupted"" string.  */
  ns2.null_str = NULL;
  ns2.length = 20;

  estring.lazy_str = ""embedded x\201\202\203\204"";
  estring.len = -1;

  /* Incomplete UTF-8, but ok Latin-1.  */
  estring2.lazy_str = ""embedded x\302"";
  estring2.len = -1;

  estring3.lazy_str = NULL;
  estring3.len = 42;

#ifdef __cplusplus
  S cps;

  cps.zs = 7;
  init_s(&cps, 8);

  SS cpss;
  cpss.zss = 9;
  init_s(&cpss.s, 10);

  SS cpssa[2];
  cpssa[0].zss = 11;
  init_s(&cpssa[0].s, 12);
  cpssa[1].zss = 13;
  init_s(&cpssa[1].s, 14);

  SSS sss(15, cps);

  SSS& ref (sss);

  Derived derived;
  
  Fake fake (42);
#endif

  add_item (&c, 23);		/* MI breakpoint here */
  add_item (&c, 72);

#ifdef MI
  add_item (&c, 1011);
  c.elements[0] = 1023;
  c.elements[0] = 2323;

  add_item (&c2, 2222);
  add_item (&c2, 3333);

  substruct_test ();
  do_nothing ();
#endif

  nstype.elements[0] = 7;
  nstype.elements[1] = 42;
  nstype.len = 2;
  
  nstype2 = nstype;

  eval_sub ();

  bug_14741();      /* break to inspect struct and union */
  return 0;
}
"
066-34358,Mikescher/Project-Euler_Befunge,compiled/C/Euler_Problem-037.c,169,3,127,227872634.88862664,1094910699.0,0.2081198349857388,1434.0,1408.0,313605523.0,193593134.0,127347.0,2226963.0,1361.0,131142.0,1500000000,0.1519150899257511,1082014363648.0,2.5956454737319176e-06,0.0049030354589444,"/* transpiled with BefunCompile v1.3.0 (c) 2017 */
#include <stdio.h>
#include <stdlib.h>
#define int64 long long
char* _g = ""v{ }  *// Project Euler - Problem 37{ } ^f{#}~~~{#}/l?{ } 5%>\""d\""45**:10p5\""d\""*:20p*00p230p\"" \"":03p13pv    v075320{ }  (p090<{ } 4D""
           ""v{ }  F<{ }  6_^#`g03g00<{ } 4;>\""X\""30g:10g%\\10g/3+p30g>30g+:00g\\`{ }  '#v_$>30g1+:30p:10g%\\10g/3+g\"" \""-|{ } 4>>90g\""= \"",,.@{ }  (^""
           ""p+3/g01\\%g01:\\\"" \"":<  ^{ }  :<{ } 4;v{ }  K<{ } !'<{ } 3Yv{ }  ,>#{ }  7># $#{ }  vv# -1<{ } 3i$   >v{ }  I>$\\{ }  *v{ }  D< >::.""
           ""55+,90g+90pv{ } 3Y>:!#v_70p9> :70g55+*+:00g\\`|>::10g%\\10g/3+g\""X\""-#^_::55+\\`#v_:55+/1\\:!#^_55+/\\55+*\\v>::10g%\\10g/3+g\""X\""-#v_\\:50p""
           ""%50g55+/\\:|>|{ }  .>\\>:1-#^_$^{ } 3S>$\""= \"",,90g.@      ^   <{ }  >>${ }  *#^!:{ }  '#<{ }  4>$$0{ }  )>    ^>{ }  .^{ } 4n^1$$<{""
           "" } 3j"";
int t=0;int z=0;
int64 g[1028000];
int d(){int s,w,i,j,h;h=z;for(;t<645;t++)if(_g[t]==';')g[z++]=_g[++t];else if(_g[t]=='}')return z-h;else if(_g[t]=='{'){t++;s=z;w=d();for(i=1;i<_g[t+1]*9025+_g[t+2]*95+_g[t+3]-291872;i++)for(j=0;j<w;g[z++]=g[s+j++]);t+=3;}else g[z++]=_g[t];return z-h;}
int64 gr(int64 x,int64 y){if(x>=0&&y>=0&&x<2000&&y<514){return g[y*2000+x];}else{return 0;}}
void gw(int64 x,int64 y,int64 v){if(x>=0&&y>=0&&x<2000&&y<514){g[y*2000+x]=v;}}
int64 td(int64 a,int64 b){ return (b==0)?0:(a/b); }
int64 tm(int64 a,int64 b){ return (b==0)?0:(a%b); }
int64*s;int q=16384;int y=0;
int64 sp(){if(!y)return 0;return s[--y];}
void sa(int64 v){if(q-y<8)s=(int64*)realloc(s,(q*=2)*sizeof(int64));s[y++]=v;}
int64 sr(){if(!y)return 0;return s[y-1];}
int main(void)
{
    int64 t0;
    d();
    s=(int64*)calloc(q,sizeof(int64));
    gw(1,0,2000);
    gw(2,0,500);
    gw(0,0,1000000);
    gw(3,0,2);
    gw(0,3,32);
    gw(1,3,32);
_1:
    gw(tm(gr(3,0),gr(1,0)),(td(gr(3,0),gr(1,0)))+3,88);
    sa(gr(3,0)+gr(3,0));
    sa((gr(3,0)+gr(3,0))<gr(0,0)?1:0);
_2:
    if(sp()!=0)goto _29;else goto _3;
_3:
    sp();
_4:
    sa(gr(3,0)+1);
    sa(gr(3,0)+1);
    gw(3,0,gr(3,0)+1);
    sa(tm(sp(),gr(1,0)));

    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    sa(td(sp(),gr(1,0)));

    sa(sp()+3LL);

    {int64 v0=sp();t0=gr(sp(),v0);}
    t0-=32;
    if((t0)!=0)goto _6;else goto _4;
_6:
    if(gr(0,0)>gr(3,0))goto _1;else goto _7;
_7:
    gw(9,0,0);
    t0=0;
    sa(0);
    sa(2);
    sa(3);
    sa(5);
    sa(7);
    sa(7);
_8:
    if(sp()!=0)goto _10;else goto _9;
_9:
    printf("" ="");
    printf(""%lld "", gr(9,0));
    sp();
    return 0;
_10:
    gw(7,0,sp());
    sa(9);
    sa(9+(gr(7,0)*10));
    sa((9+(gr(7,0)*10))<gr(0,0)?1:0);
_11:
    if(sp()!=0)goto _12;else goto _28;
_12:
    sa(sr());
    sa(tm(sr(),gr(1,0)));
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    sa(td(sp(),gr(1,0)));

    sa(sp()+3LL);

    {int64 v0=sp();t0=gr(sp(),v0);}
    t0-=88;

    if((t0)!=0)goto _27;else goto _13;
_13:
    sa(sr());

    if(sr()<10)goto _14;else goto _20;
_14:
    sp();
    sa((sp()!=0)?0:1);
    sa(sr());
_15:
    sp();
    sp();
_16:
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
_17:
    if(sr()!=1)goto _19;else goto _18;
_18:
    sp();
    sa(sr());
    goto _8;
_19:
    sa(sp()-1LL);

    sa(sr()+(gr(7,0)*10));
    sa(sr()<gr(0,0)?1:0);
    goto _11;
_20:
    sa(sr()/10);
    sa(1);
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    sa(sr());
_21:
    if(sp()!=0)goto _22;else goto _23;
_22:
    sa(sp()/10LL);

    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    sa(sp()*10LL);

    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    sa(sr());
    goto _21;
_23:
    sp();
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
_24:
    sa(sr());
    sa(tm(sr(),gr(1,0)));
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    sa(td(sp(),gr(1,0)));

    sa(sp()+3LL);

    {int64 v0=sp();t0=gr(sp(),v0);}
    t0-=88;

    if((t0)!=0)goto _15;else goto _25;
_25:
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    sa(sr());
    gw(5,0,sp());
    {int64 v0=sp();sa(tm(sp(),v0));}

    sa(gr(5,0)/10);
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    sa(sr());

    if(sp()!=0)goto _24;else goto _26;
_26:
    sp();
    sp();
    sa(sr());
    sa(sr());
    printf(""%lld "", (int64)(sp()));
    printf(""\n"");
    sa(sp()+gr(9,0));

    gw(9,0,sp());
    goto _16;
_27:
    sp();
    goto _17;
_28:
    t0=0;
    goto _27;
_29:
    sa(sr());
    sa(32);
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    sa(tm(sr(),gr(1,0)));
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    sa(td(sp(),gr(1,0)));

    sa(sp()+3LL);

    {int64 v0=sp();int64 v1=sp();gw(v1,v0,sp());}
    sa(sp()+gr(3,0));

    sa(sr()<gr(0,0)?1:0);
    goto _2;
}
"
245-32182,ronsaldo/pharo-raspberry,platforms/win32/util/mkNamedPrims.c,21,2,19,2186524.5653316,174995.0,12.49477985085288,1328.0,1306.0,39733.0,13609.0,1627.0,640.0,1346.0,596.0,1500000000,0.0014576830435544,1082014363648.0,0.0150518586245321,0.0789059277867346,"/* mkNamedPrims.c:
	Generates an sqNamedPrims.c from list of plugins passed in as command line.
*/

#include <stdio.h>

int main(int argc, char **argv) {
	int i;

	printf(""/* Automatically generated on %s, %s */\n\n"", __DATE__, __TIME__);

	printf(""extern sqExport vm_exports[];\n"");
	printf(""extern sqExport os_exports[];\n"");
	for(i = 1; i<argc;i++) {
		printf(""extern sqExport %s_exports[];\n"", argv[i]);
	}
	printf(""\nsqExport *pluginExports[] = {\n"");
	printf(""\tvm_exports,\n"");
	printf(""\tos_exports,\n"");
	for(i = 1; i<argc;i++) {
		printf(""\t%s_exports,\n"", argv[i]);
	}
	printf(""\tNULL\n"");
	printf(""};"");
	return 0;
}
"
059-19519,moreandres/hotspot,tests/examples/mandel/mandel.c,38,4,26,680916013.5453568,2224703611.0,0.3060704399602829,1162.0,1149.0,40537.0,1061609.0,2728.0,66121.0,2364.0,64959.0,1500000000,0.4539440090302378,1082014363648.0,1.0387900610999638e-06,0.1235516891591495,"#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#define X_RESN 1024
#define Y_RESN 1024
#define X_MIN -2.0
#define X_MAX 2.0
#define Y_MIN -2.0
#define Y_MAX 2.0

typedef struct complextype
{
  float real, imag;
} Compl;

int main()
{
  int i, j, k;
  Compl z, c;
  float lensq, temp;
  int iters;
  int res[X_RESN][Y_RESN];

  iters = 1024;
  if (getenv(""N""))
    iters = atoi(getenv(""N""));

#pragma omp parallel for shared(res, iters) private(i, j, z, c, k, temp, lensq)
  for (i = 0; i < Y_RESN; i++)
    for (j = 0; j < X_RESN; j++)
      {
	z.real = z.imag = 0.0;
	c.real = X_MIN + j * (X_MAX - X_MIN) / X_RESN;
	c.imag = Y_MAX - i * (Y_MAX - Y_MIN) / Y_RESN;
	k = 0;

	do
	  {
	    temp = z.real * z.real - z.imag * z.imag + c.real;
	    z.imag = 2.0 * z.real * z.imag + c.imag;
	    z.real = temp;
	    lensq = z.real * z.real + z.imag * z.imag;
	    k++;
	  }
	while (lensq < 4.0 && k < iters);

	if (k >= iters)
	  res[i][j] = 0;
	else
	  res[i][j] = 1;

      }

  assert(res[0][0]);

  return 0;
}
"
357-21766,Gurgel100/gcc,gcc/testsuite/c-c++-common/hwasan/alloca-array-accessible.c,28,2,21,1699548.21467385,170430.0,9.97211758493223,1145.0,1137.0,38722.0,12787.0,1581.0,586.0,1326.0,544.0,1500000000,0.0011330321431159,1082014363648.0,0.0133896614445813,0.0783746529732668,"/* { dg-do run } */
/* { dg-require-effective-target hwaddress_exec } */

#define alloca __builtin_alloca

int __attribute__ ((noinline))
using_alloca (int num)
{
  int retval = 0;
  int *big_array = (int*)alloca (num * sizeof (int));
  for (int i = 0; i < num; ++i) {
      retval += big_array[i];
  }
  return retval;
}

int __attribute__ ((noinline))
using_vararray (int num)
{
  int retval = 0;
  int big_array[num];
  for (int i = 0; i < num; ++i) {
      retval += big_array[i];
  }
  return retval;
}

int main()
{
  using_alloca (16);
  using_vararray (12);
  return 0;
}
"
143-6050,luisbg/hhgtg,algorithms/math/reverse_number.c,35,2,28,1976943.1091844002,196196.0,10.07636751004098,1379.0,1353.0,44369.0,15625.0,1639.0,642.0,1356.0,598.0,1500000000,0.0013179620727896,1082014363648.0,0.0139248506595445,0.0705903923725705,"/* Reverse the digits of a number
 *
 * 234 -> 432
 * -1017 -> -7101
 */

#include <stdlib.h>
#include <stdio.h>
#include <time.h>


int
reverse (int x)
{
  int res = 0;
  int neg = 0;

  if (x < 0) {
    x *= -1;
    neg = 1;
  }

  while (x > 0) {
    res = (x % 10) + (res * 10);
    x = x / 10;
  }

  if (neg)
    res *= -1;

  return res;
}

int
main ()
{
  int i, c;
  srand (time (NULL));

  for (c = 0; c < 10; c++) {
    i = rand () % 100000;
    if (rand () < RAND_MAX / 2)
      i *= -1;

    printf (""%6d  \t->  \t%6d\n"", i, reverse (i));
  }

  return 0;
}
"
193-31061,sebastianscatularo/glibc,malloc/tst-calloc.c,91,8,49,46916578.430682294,270331833.0,0.1735518066050327,1304.0,1286.0,53401234.0,40804625.0,501933.0,426685.0,1486.0,235475.0,1500000000,0.0312777189537882,1082014363648.0,9.580817661233409e-06,0.0123726805569492,"/* Copyright (C) 2000-2014 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@redhat.com>.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#include <errno.h>
#include <error.h>
#include <limits.h>
#include <malloc.h>
#include <stdlib.h>
#include <stdio.h>


/* Number of samples per size.  */
#define N 50000


static void
fixed_test (int size)
{
  char *ptrs[N];
  int i;

  for (i = 0; i < N; ++i)
    {
      int j;

      ptrs[i] = (char *) calloc (1, size);

      if (ptrs[i] == NULL)
	break;

      for (j = 0; j < size; ++j)
	{
	  if (ptrs[i][j] != '\0')
	    error (EXIT_FAILURE, 0,
		   ""byte not cleared (size %d, element %d, byte %d)"",
		   size, i, j);
	  ptrs[i][j] = '\xff';
	}
    }

  while (i-- > 0)
    free (ptrs[i]);
}


static void
random_test (void)
{
  char *ptrs[N];
  int i;

  for (i = 0; i < N; ++i)
    {
      int j;
      int n = 1 + random () % 10;
      int elem = 1 + random () % 100;
      int size = n * elem;

      ptrs[i] = (char *) calloc (n, elem);

      if (ptrs[i] == NULL)
	break;

      for (j = 0; j < size; ++j)
	{
	  if (ptrs[i][j] != '\0')
	    error (EXIT_FAILURE, 0,
		   ""byte not cleared (size %d, element %d, byte %d)"",
		   size, i, j);
	  ptrs[i][j] = '\xff';
	}
    }

  while (i-- > 0)
    free (ptrs[i]);
}


static void
null_test (void)
{
  /* If the size is 0 the result is implementation defined.  Just make
     sure the program doesn't crash.  */
  calloc (0, 0);
  calloc (0, UINT_MAX);
  calloc (UINT_MAX, 0);
  calloc (0, ~((size_t) 0));
  calloc (~((size_t) 0), 0);
}


int
main (void)
{
  /* We are allocating blocks with `calloc' and check whether every
     block is completely cleared.  We first try this for some fixed
     times and then with random size.  */
  fixed_test (15);
  fixed_test (5);
  fixed_test (17);
  fixed_test (6);
  fixed_test (31);
  fixed_test (96);

  random_test ();

  null_test ();

  return 0;
}
"
311-27256,ColinIanKing/stress-ng,test/test-atomic_fetch_nand.c,24,1,25,1722902.9908776,170423.0,10.109562676399312,1145.0,1137.0,38726.0,12788.0,1580.0,586.0,1326.0,544.0,1500000000,0.0011486019939184,1082014363648.0,0.0133902114151258,0.0783476336529875,"/*
 * Copyright (C) 2021-2022 Colin Ian King
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 */
int main(int argc, char **argv)
{
	int var;

	__atomic_fetch_nand(&var, 1, 0);

	return 0;
}

"
318-13167,haipome/nsf,c1000k/client.c,57,3,37,1883252.98950075,183540.0,16.759175111692276,1447.0,1424.0,41923.0,14525.0,1703.0,640.0,1399.0,597.0,1500000000,0.0012555019930005,1082014363648.0,0.0156423667865315,0.0768672052154195,"/*
 * Description: 
 *     History: yang@haipo.me, 2016/03/21, create
 */

# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <unistd.h>
# include <error.h>
# include <errno.h>
# include <sys/types.h>
# include <sys/socket.h>
# include <netinet/in.h>
# include <arpa/inet.h>
# include <netdb.h> 
# include <sys/file.h>
# include <sys/resource.h>

int set_file_limit(size_t limit)
{
    struct rlimit rlim;
    memset(&rlim, 0, sizeof(rlim));
    if (getrlimit(RLIMIT_NOFILE, &rlim) < 0) {
        return -1;
    }
    if (rlim.rlim_cur >= limit)
        return 0;
    rlim.rlim_cur = limit;
    rlim.rlim_max = limit;
    if (setrlimit(RLIMIT_NOFILE, &rlim) < 0) {
        return -1;
    }

    return 0;
}

int main(int argc, char *argv[])
{
    set_file_limit(1000000);

    struct sockaddr_in addr;
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    inet_aton(""127.0.0.1"", &addr.sin_addr);

    int max = 100;
    int *fds = malloc(max * 10000 * sizeof(int));
    int connections = 0;
    for (int i = 0; i < max; ++i) {
        addr.sin_port = htons(5000 + i);
        for (int j = 0; j < 10000; ++j) {
            int sockfd = socket(AF_INET, SOCK_STREAM, 0);
            if (sockfd < 0) {
                goto error;
            }
            if (connect(sockfd, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
                goto error;
            }
            fds[10000*i+j] = sockfd;

            usleep(100);
            connections += 1;
            if (connections % 1000 == 0) {
                printf(""connections: %d\n"", connections);
            }
        }
    }

    printf(""connections: %d\n"", connections);
    sleep(10);

    for (int i = 0; i < max * 10000; ++i)
        close(fds[i]);

    return 0;

error:
    printf(""connections: %d, error: %s\n"", connections, strerror(errno));
    return 0;
}

"
176-6095,epicsdeb/rtems-gdb,gdb/testsuite/gdb.base/whatis.c,241,5,174,1446093.0833592,169168.0,8.548265629433462,1153.0,1143.0,38464.0,12754.0,1570.0,595.0,1319.0,556.0,1500000000,0.0009640620555728,1082014363648.0,0.0135723068192565,0.0788785192705689,"/* This test program is part of GDB, the GNU debugger.

   Copyright 1992, 1993, 1994, 1997, 1999, 2004, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */

/*
 *	Test file with lots of different types, for testing the
 *	""whatis"" command.
 */

/*
 *	First the basic C types.
 */

char		v_char;
signed char	v_signed_char;
unsigned char	v_unsigned_char;

short		v_short;
signed short	v_signed_short;
unsigned short	v_unsigned_short;

int		v_int;
signed int	v_signed_int;
unsigned int	v_unsigned_int;

long		v_long;
signed long	v_signed_long;
unsigned long	v_unsigned_long;

#ifndef NO_LONG_LONG
long long		v_long_long;
signed long long	v_signed_long_long;
unsigned long long	v_unsigned_long_long;
#endif

float		v_float;
double		v_double;

/*
 *	Now some derived types, which are arrays, functions-returning,
 *	pointers, structures, unions, and enumerations.
 */

/**** arrays *******/

char		v_char_array[2];
signed char	v_signed_char_array[2];
unsigned char	v_unsigned_char_array[2];

short		v_short_array[2];
signed short	v_signed_short_array[2];
unsigned short	v_unsigned_short_array[2];

int		v_int_array[2];
signed int	v_signed_int_array[2];
unsigned int	v_unsigned_int_array[2];

long		v_long_array[2];
signed long	v_signed_long_array[2];
unsigned long	v_unsigned_long_array[2];

#ifndef NO_LONG_LONG
long long		v_long_long_array[2];
signed long long	v_signed_long_long_array[2];
unsigned long long	v_unsigned_long_long_array[2];
#endif

float		v_float_array[2];
double		v_double_array[2];

/**** pointers *******/

/* Make sure they still print as pointer to foo even there is a typedef
   for that type.  Test this not just for char *, which might be
   a special case kludge in GDB (Unix system include files like to define
   caddr_t), but for a variety of types.  */
typedef char *char_addr;
static char_addr a_char_addr;
typedef unsigned short *ushort_addr;
static ushort_addr a_ushort_addr;
typedef signed long *slong_addr;
static slong_addr a_slong_addr;
#ifndef NO_LONG_LONG
typedef signed long long *slong_long_addr;
static slong_long_addr a_slong_long_addr;
#endif

char		*v_char_pointer;
signed char	*v_signed_char_pointer;
unsigned char	*v_unsigned_char_pointer;

short		*v_short_pointer;
signed short	*v_signed_short_pointer;
unsigned short	*v_unsigned_short_pointer;

int		*v_int_pointer;
signed int	*v_signed_int_pointer;
unsigned int	*v_unsigned_int_pointer;

long		*v_long_pointer;
signed long	*v_signed_long_pointer;
unsigned long	*v_unsigned_long_pointer;

#ifndef NO_LONG_LONG
long long		*v_long_long_pointer;
signed long long	*v_signed_long_long_pointer;
unsigned long long	*v_unsigned_long_long_pointer;
#endif

float		*v_float_pointer;
double		*v_double_pointer;

/**** structs *******/

struct t_struct {
    char	v_char_member;
    short	v_short_member;
    int		v_int_member;
    long	v_long_member;
#ifndef NO_LONG_LONG
    long long	v_long_long_member;
#endif
    float	v_float_member;
    double	v_double_member;
} v_struct1;

struct {
    char	v_char_member;
    short	v_short_member;
    int		v_int_member;
    long	v_long_member;
#ifndef NO_LONG_LONG
    long long	v_long_long_member;
#endif
    float	v_float_member;
    double	v_double_member;
} v_struct2;

/**** unions *******/

union t_union {
    char	v_char_member;
    short	v_short_member;
    int		v_int_member;
    long	v_long_member;
#ifndef NO_LONG_LONG
    long long	v_long_long_member;
#endif
    float	v_float_member;
    double	v_double_member;
} v_union;

union {
    char	v_char_member;
    short	v_short_member;
    int		v_int_member;
    long	v_long_member;
#ifndef NO_LONG_LONG
    long long	v_long_long_member;
#endif
    float	v_float_member;
    double	v_double_member;
} v_union2;

/*** Functions returning type ********/

char		v_char_func () { return(0); }
signed char	v_signed_char_func () { return (0); }
unsigned char	v_unsigned_char_func () { return (0); }

short		v_short_func () { return (0); }
signed short	v_signed_short_func () { return (0); }
unsigned short	v_unsigned_short_func () { return (0); }

int		v_int_func () { return (0); }
signed int	v_signed_int_func () { return (0); }
unsigned int	v_unsigned_int_func () { return (0); }

long		v_long_func () { return (0); }
signed long	v_signed_long_func () { return (0); }
unsigned long	v_unsigned_long_func () { return (0); }

#ifndef NO_LONG_LONG
long long		v_long_long_func () { return (0); }
signed long long	v_signed_long_long_func () { return (0); }
unsigned long long	v_unsigned_long_long_func () { return (0); }
#endif

float		v_float_func () { return (0.0); }
double		v_double_func () { return (0.0); }

/**** Some misc more complicated things *******/

struct link {
	struct link *next;
#ifdef __STDC__
	struct link *(*linkfunc) (struct link *this, int flags);
#else
	struct link *(*linkfunc) ();
#endif
	struct t_struct stuff[1][2][3];
} *s_link;

union tu_link {
	struct link *next;
#ifdef __STDC__
	struct link *(*linkfunc) (struct link *this, int flags);
#else
	struct link *(*linkfunc) ();
#endif
	struct t_struct stuff[1][2][3];
} u_link;

struct outer_struct {
	int outer_int;
	struct inner_struct {
		int inner_int;
		long inner_long;
	}inner_struct_instance;
	union inner_union {
		int inner_union_int;
		long inner_union_long;
	}inner_union_instance;
	long outer_long;
} nested_su;

/**** Enumerations *******/

enum colors {red, green, blue} color;
enum cars {chevy, ford, porsche} clunker;

/***********/

int main ()
{
#ifdef usestubs
  set_debug_traps();
  breakpoint();
#endif
  /* Some linkers (e.g. on AIX) remove unreferenced variables,
     so make sure to reference them. */
  v_char = 0;
  v_signed_char = 1;
  v_unsigned_char = 2;

  v_short = 3;
  v_signed_short = 4;
  v_unsigned_short = 5;    

  v_int = 6;
  v_signed_int = 7;
  v_unsigned_int = 8;    

  v_long = 9;
  v_signed_long = 10;
  v_unsigned_long = 11;    

#ifndef NO_LONG_LONG
  v_long_long = 12;
  v_signed_long_long = 13;
  v_unsigned_long_long = 14;
#endif

  v_float = 100.0;
  v_double = 200.0;


  v_char_array[0] = v_char;
  v_signed_char_array[0] = v_signed_char;
  v_unsigned_char_array[0] = v_unsigned_char;

  v_short_array[0] = v_short;
  v_signed_short_array[0] = v_signed_short;
  v_unsigned_short_array[0] = v_unsigned_short;

  v_int_array[0] = v_int;
  v_signed_int_array[0] = v_signed_int;
  v_unsigned_int_array[0] = v_unsigned_int;

  v_long_array[0] = v_long;
  v_signed_long_array[0] = v_signed_long;
  v_unsigned_long_array[0] = v_unsigned_long;

#ifndef NO_LONG_LONG
  v_long_long_array[0] = v_long_long;
  v_signed_long_long_array[0] = v_signed_long_long;
  v_unsigned_long_long_array[0] = v_unsigned_long_long;
#endif

  v_float_array[0] = v_float;
  v_double_array[0] = v_double;

  v_char_pointer = &v_char;
  v_signed_char_pointer = &v_signed_char;
  v_unsigned_char_pointer = &v_unsigned_char;

  v_short_pointer = &v_short;
  v_signed_short_pointer = &v_signed_short;
  v_unsigned_short_pointer = &v_unsigned_short;

  v_int_pointer = &v_int;
  v_signed_int_pointer = &v_signed_int;
  v_unsigned_int_pointer = &v_unsigned_int;

  v_long_pointer = &v_long;
  v_signed_long_pointer = &v_signed_long;
  v_unsigned_long_pointer = &v_unsigned_long;

#ifndef NO_LONG_LONG
  v_long_long_pointer = &v_long_long;
  v_signed_long_long_pointer = &v_signed_long_long;
  v_unsigned_long_long_pointer = &v_unsigned_long_long;
#endif

  v_float_pointer = &v_float;
  v_double_pointer = &v_double;

  color = red;
  clunker = porsche;

  u_link.next = s_link;

  v_union2.v_short_member = v_union.v_short_member;

  v_struct1.v_char_member = 0;
  v_struct2.v_char_member = 0;

  nested_su.outer_int = 0;
  return 0;
}
"
115-30283,Gurgel100/gcc,gcc/testsuite/gcc.dg/vect/pr71854.c,22,2,24,1806258.22395075,169183.0,10.676356371503047,1145.0,1135.0,38464.0,12706.0,1569.0,586.0,1318.0,547.0,1500000000,0.0012041721493005,1082014363648.0,0.0134765313299799,0.0785616572210279,"/* PR tree-optimization/71854 */
/* { dg-do compile } */
/* { dg-additional-options ""-O3 -ftree-loop-if-convert"" } */

char a, f = 1;
int b, c, e[8];
short d;

short
foo (short x)
{
  return x >= 2 || x >> c ? x : x << c;
}

int
main ()
{
  while (f)
    for (d = 0; d <= 7; d++)
      {
	f = 7 >> b ? a : a << b;
	e[d] = foo (f);
      }
  return 0;
}
"
034-29908,RobertElderSoftware/recc,test/c89/many-types.c,92,1,59,1653875.9227842002,172746.0,9.574027763305663,1267.0,1252.0,39136.0,13278.0,1612.0,636.0,1330.0,593.0,1500000000,0.0011025839485228,1082014363648.0,0.0145821032035474,0.0795779753500973,"/*
    Copyright 2016 Robert Elder Software Inc.
    
    Licensed under the Apache License, Version 2.0 (the ""License""); you may not 
    use this file except in compliance with the License.  You may obtain a copy 
    of the License at
    
        http://www.apache.org/licenses/LICENSE-2.0
    
    Unless required by applicable law or agreed to in writing, software 
    distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT 
    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the 
    License for the specific language governing permissions and limitations 
    under the License.
*/

#include <stdio.h>

struct k {
int i;
};

union j {
int k;
};

struct a {
  struct b{
    int i;
  } g;
};

struct ggg {long g;};
extern struct ggg foo;
struct ggg foo;

struct c {
	char i;
	char ff;
	short j;
	float l;
	double m;
	long k;
	long n;
};

extern struct c boo;
struct c boo;

extern char ab[3];
extern float ac[3];
extern short ad[3];
extern int ae[3];
extern long af[3];
extern long ag[3];

extern char ****** ah; 
extern int ****** ai; 

int foo1(int);
int foo1(int foo1param){
	return foo1param;
}

int (*foo2(void))(int i);
int (*foo2(void))(int i){
	return foo1;
}

int (*(*foo3(void))(void))(int i);
int (*(*foo3(void))(void))(int i){
	return foo2;
}

int (*(*(*foo4(void))(void))(void))(int i);
int (*(*(*foo4(void))(void))(void))(int i){
	return foo3;
}

int (*(*(*(*foo5(void))(void))(void))(void))(int i);
int (*(*(*(*foo5(void))(void))(void))(void))(int i){
	return foo4;
}

struct foo1{
	unsigned int i:20;
	unsigned int :1;
};


int no_param_names(int, int, int);
int some_param_names(int a, int b, int);
int all_param_names(int a, int b, int c);

enum en1 {num1};

enum en2 {num2, num3, num4};

enum {anon2, anon3, anon4};

enum eninit {num9 = 1, num99, num999};

static int one;
static int two = 2;

/*int three = 3, c(void), ****const* four = (int ****const*)4;*/

void elip(int a, ...);

void elip(int a, ...){
(void)a;
}


typedef int just_int;

typedef int (*(*(*(*foo12(void))(void))(void))(void))(short i);

int main(void){
	(void)one;
	(void)two;
	putchar(foo5()()()()('Z'));
	putchar('a');
	return 0;
}
"
217-14681,NerdWalletOSS/Q,RUNTIME/DNN/src/non_fma_expt_s.c,37,5,32,20742470.8642065,28555037.0,0.7264031911427745,1480.0,1455.0,3200614.0,4218082.0,198351.0,262831.0,1363.0,262749.0,1500000000,0.013828313909471,1082014363648.0,0.0001027839676761,0.0977656989853742,"// gcc -O4 -lm non_fma_expt_s.c  # produces executable a.out
#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <inttypes.h>

#define N 1048576

static uint64_t
RDTSC(
    void
    )
{
  unsigned int lo, hi;
  asm volatile(""rdtsc"" : ""=a"" (lo), ""=d"" (hi));
  return ((uint64_t)hi << 32) | lo;
}

int main() {
  float *A = malloc(N * sizeof(float));
  float *B = malloc(N * sizeof(float));
  float *C = malloc(N * sizeof(float));
  float *D = malloc(N * sizeof(float));
  for ( int i = 0; i < N; i++ ) { A[i] = i; }
  for ( int i = 0; i < N; i++ ) { B[i] = i*2; }
  for ( int i = 0; i < N; i++ ) { C[i] = i*4; }

  printf(""starting\n"");
  uint64_t t_end = 0, t_start = RDTSC();
  for ( int i = 0; i < N; i++ ) { 
    float a = A[i];
    float b = B[i];
    float c = C[i];

    float d = ( a * b ) + c;
    D[i] = d;
  }
  t_end = RDTSC();
  fprintf(stdout, ""cycles  = %"" PRIu64 ""\n"", ( t_end - t_start ) );

  for ( int i = 0; i < 8; i++ ) { 
    printf(""A = %lf \t"", A[i]);
    printf(""B = %lf \t"", B[i]);
    printf(""C = %lf \t"", C[i]);
    printf(""D = %lf \n"", D[i]);
  }

  return 0;
}
"
330-10720,Gurgel100/gcc,gcc/testsuite/gcc.dg/graphite/pr83668.c,29,4,25,1729173.00369585,169979.0,10.172862530077245,1147.0,1138.0,38667.0,12785.0,1579.0,586.0,1325.0,546.0,1500000000,0.0011527820024639,1082014363648.0,0.0134428370563422,0.0784420430692684,"/* { dg-do run } */
/* { dg-options ""-O -fno-tree-dominator-opts -fgraphite-identity"" } */

int a, b, c;
int d[14];

int
main (void)
{
  short e;
  char f;

  for (; b >= 0; b--)
    {
      e = 0;
      for (; e < 2; e++)
	{
	  a = 0;
	  for (; a < 7; a++)
	    d[a] = 1;
	}
      if (c)
	{
	  f = 0;
	  for (; f >= 0; f--)
	    ;
	}
    }

  if (a != 7)
    __builtin_abort ();

  return 0;
}
"
016-10867,balau/nucleo_tests,tests/signal/signal_test.c,81,1,34,2024434.6233084002,183645.0,11.023627106645977,1395.0,1375.0,41806.0,14548.0,1676.0,650.0,1381.0,596.0,1500000000,0.0013496230822056,1082014363648.0,0.0150834490457131,0.0763566029030769,"/*
 * Copyright (c) 2015 Francesco Balducci
 *
 * This file is part of nucleo_tests.
 *
 *    nucleo_tests is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU Lesser General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    nucleo_tests is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU Lesser General Public License for more details.
 *
 *    You should have received a copy of the GNU Lesser General Public License
 *    along with nucleo_tests.  If not, see <http://www.gnu.org/licenses/>.
 */
#include <stdio.h>
#include <signal.h>

static
void alarm_handler(int signo, siginfo_t *info, void *context)
{
    (void)context;
    printf(""Alarm! %d %d %d %d\n"", signo, info->si_signo, info->si_value.sival_int, info->si_code);
}

int main(void)
{
    struct sigaction act;

    act.sa_sigaction = alarm_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = SA_SIGINFO;
    if (sigaction(
                SIGALRM,
                &act,
                NULL) != 0)
    {
        perror(""sigaction"");
        return 1;
    }

    if (sigaction(
                SIGUSR1,
                &act,
                NULL) != 0)
    {
        perror(""sigaction"");
        return 1;
    }

    if (sighold(SIGALRM) != 0)
    {
        perror(""sighold"");
        return 1;
    }
    if (sighold(SIGUSR1) != 0)
    {
        perror(""sighold"");
        return 1;
    }
    printf(""holding...\n"");

    if (raise(SIGALRM) != 0)
    {
        perror(""raise"");
        return 1;
    }
    printf(""raised...\n"");

    if (raise(SIGUSR1) != 0)
    {
        perror(""raise"");
        return 1;
    }
    printf(""raised...\n"");

    printf(""unblocking...\n"");
    sigset_t set;
    sigemptyset(&set);
    sigaddset(&set, SIGALRM);
    sigaddset(&set, SIGUSR1);

    if (sigprocmask(SIG_UNBLOCK, &set, NULL) != 0)
    {
        perror(""sigprocmask"");
        return 1;
    }
    printf(""unblocked!\n"");
}


"
257-12687,anaghajoshi/C_DataStructures_Algorithms,Binart_Search_Tree_BST/BST_height_depth_of_node.c,158,5,118,2357944.26407655,208604.0,11.303445763264367,1402.0,1380.0,47253.0,18608.0,1646.0,656.0,1364.0,613.0,1500000000,0.0015719628427177,1082014363648.0,0.0133362735134513,0.0649701644372238,"#include <stdio.h>
#include <stdlib.h>


typedef struct node{
	int data;
	struct node* left;
	struct node* right;
} node;

node* head;

node* create(int data){
	node* temp = (node* ) malloc(sizeof(node));
	temp->data = data;
	temp->left = NULL;
	temp->right = NULL;
	return temp;
}

node* insert(node* current, int data){

	if(head == NULL){
		node* temp;
		temp = create(data);
		head = temp;
		return temp;

	}
	else{
		if(current == NULL){
			node* temp;
			temp = create(data);
			return temp;
		}

		if(data <= current->data){

			current->left = insert(current->left,data);
		}
		else if ( data > current->data){

			current->right = insert(current->right,data);
		}

	}
	return current;

}


void print_preorder_all(node* temp){
	if(temp != NULL){

		printf(""data %d "",temp->data);

		if(temp->left != NULL){
		printf(""left child %d "",temp->left->data);}
		else {
			printf(""left child NULL "");
		}
		if(temp->right != NULL){
		printf(""right child %d \n"",temp->right->data);}
		else {
			printf(""right child NULL \n"");
		}
		
		print_preorder_all(temp->left);
		print_preorder_all(temp->right);
	}
	return;
}

/* Height of a node is the no.of edges in the longest path from node to leaf */

int find_height (node* temp){
	if (temp == NULL){
		return -1;
	}

	int left_h = find_height(temp->left);
	int right_h = find_height(temp->right);

	if(left_h > right_h){
		return left_h+1;
	}
	else return right_h+1;
}

int height_node(int n){
	node* temp;
	temp =head;
	int found_flag = 0;
	int count = 0;

	
	while(temp->data != n && (temp->left != NULL || temp->right!= NULL)) {
		if(n < temp->data){
			if(temp->left!=NULL){
	
				temp = temp->left;
	
			}
		}
		else {
			if(temp->right!=NULL){

			temp = temp->right;

			}
		}

		}
	
	if (temp != NULL && temp->data == n) {
		found_flag = 1;
		
	}
	else {
		printf(""*******Node not found*******\n"");
		return -1;
	}

	while (found_flag){
		count = find_height(temp);
		return count;
	}
	return -1;
	}

/* Depth of a node is the no.of edges in the path from root to node */


int depth_node( int n){
	node* temp;
	temp =head;
	int found_flag = 0;
	int count = 0;


	while (temp->data != n && (temp->left != NULL || temp->right!= NULL)) {
		
		if(n < temp->data){
			if(temp->left!=NULL){
				temp = temp->left;
				count++;
			}
		}
		else {
			if(temp->right!=NULL){
			temp = temp->right;
			count++;	
			}
		}
	}
	
	if (temp != NULL && temp->data == n) {
		found_flag = 1;
	}
	else {
		printf(""*******Node not found*******\n"");
		return -1;
	}

	while (found_flag){
	return count;
	}
	
	return -1;
}

int main(){
	head = NULL;
	node* temp;
	
	int A[13] = {11, 6, 8, 19, 4, 13, 5, 17, 43, 49, 16, 31, 32};
	int i;
	for(i =0 ; i<13 ; i ++){
		temp = insert(head,A[i]);
	}
	
	
	printf(""all info\n"");
	print_preorder_all(head);
	printf(""\n"");
	
	printf(""level 0 / root node\n"");
	printf(""The height_node of 11 is %d \n"",height_node(11));
	printf(""The depth_node of 11 is %d \n"",depth_node(11));


	printf(""level 1\n"");
	printf(""The height_node of 19 is %d \n"",height_node(19));
	printf(""The depth_node of 19 is %d \n"",depth_node(19));


	printf(""level 2\n"");
	printf(""The height_node of 8 is %d \n"",height_node(8));
	printf(""The depth_node of 8 is %d \n"",depth_node(8));

	
	printf(""level 3\n"");
	printf(""The height_node of 5 is %d \n"",height_node(5));
	printf(""The depth_node of 5 is %d \n"",depth_node(5));


	printf(""level 4\n"");
	printf(""The height_node of 32 is %d \n"",height_node(32));
	printf(""The depth_node of 32 is %d \n"",depth_node(32));


	printf(""level 3\n"");
	printf(""The height_node of 32 is %d \n"",height_node(31));
	printf(""The depth_node of 32 is %d \n"",depth_node(31));
	return 0;
}"
261-14481,xiaoyaozi5566/DynamicCache,tests/test-progs/test/arm/hardstride.c,16,1,21,112983814.55708295,720173911.0,0.1568840696313421,1341.0,1322.0,60039411.0,13431.0,60001675.0,661.0,656698.0,594.0,1500000000,0.0753225430380553,1082014363648.0,3.697717953018157e-06,1.0101042012299768,"#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>

int main(int argc, char **argv) {
    int MEM_SIZE = 10 * 1024 * 1024; // *32 bits (number of ints)
    int DURATION = 60 * 1000 * 1000; // us
    int DELAY_OPS = 1; //us between mem requests
    int count = 0;

    int * mem = ( int* ) malloc( sizeof( int ) * MEM_SIZE );
    int elapsed = 0;
    int tmp=0;

    while( elapsed < DURATION ){
        int read_addr  = count % MEM_SIZE;
        tmp += mem[read_addr];
        elapsed += DELAY_OPS;
        count += 16;
    }
	printf(""Sum is %d\n"", tmp);
}

"
090-3740,kinvaris/mycprojects,hello_world/ex4/ex4.c,62,5,45,1876624.3010758501,201051.0,9.334069464961626,1462.0,1441.0,45117.0,17323.0,1648.0,648.0,1365.0,606.0,1500000000,0.0012510828673839,1082014363648.0,0.0144391224117263,0.0683376040999359,"#include <stdio.h>

/*Playing with C types, loops, if-else & switching*/ 

int main(int argc, char *argv[])
{
    int age = 22;
    double height = 1.8;
    float power = 2.345f;
    char initial = 'G';
    char first_name[] = ""Jonas"";
    char last_name[] = ""Libbrecht"";
    int myarray[4] = {1, 2, 3, 4};
    char *array_of_strings[3] = {""foobar"", ""bar"", ""jonaslibbrecht""};

    printf(""I am %d years old.\n"", age);
    printf(""I am %f meter tall.\n"", height);
    printf(""I have an initial %c \n"", initial);
    printf(""I have a firstname %s \n"", first_name);
    printf(""I have a lastname %s \n"", last_name);
    printf(""I have %f amount of power \n"", power);
    printf(""My whole name is %s %c. %s \n"", first_name, initial, last_name);
    printf(""Amount of arguments %d \n"", argc);

    int i;
    for(i=0;i<argc;i++)
    {
	printf(""Argument %d: %s \n"", i, argv[i]);
    }

    printf(""Size of array `myarray` %lo\n"", sizeof(myarray)/sizeof(myarray[0]));
    int j;
    for(j=0;j<sizeof(myarray)/sizeof(myarray[0]);j++) {
	printf(""array item %d value %d\n"", j, myarray[j]);
    }

    printf(""an integer is %lo bytes large\n"", sizeof(myarray[0]));
    printf(""a double is %lo bytes large\n"", sizeof(height));
    printf(""this char is %lo bytes large\n"", sizeof(first_name));
    printf(""this char is %lo bytes large\n"", sizeof(last_name));
    printf(""this char type is %lo bytes large\n"", sizeof(char));
    
    int x;
    printf(""amount of strings in `array_of_strings` %lo\n"", sizeof(array_of_strings)/sizeof(array_of_strings[0]));
    for(x=0; x<sizeof(array_of_strings)/sizeof(array_of_strings[0]); x++)
    {
        printf(""item %d with value %s\n"", x,array_of_strings[x]);
    }

    int y = 5;
    int z = 0;
    while(z < y) {
        printf(""while number %d\n"", z);
        z++;
        if(z == 4) {
            printf(""my happy number %d\n"", z);
        } else {
            printf(""my sad number %d\n"", z);
        }
    }

    char letter = 'B';
    switch(letter) {
        case 'A':
            printf(""He chose the letter A!\n"");
        case 'B':
            printf(""He chose the letter B!\n"");
        default:
            printf(""He chose poorly, he chose nothing\n"");
    }

    return 0;
}
"
255-10765,Gurgel100/gcc,gcc/testsuite/c-c++-common/pr44715.c,167,17,32,1504336.48377645,170091.0,8.844300991822024,1149.0,1140.0,38671.0,12785.0,1577.0,586.0,1323.0,546.0,1500000000,0.0010028909891843,1082014363648.0,0.0134575021606081,0.0783582089552238,"/* PR c/44715 */
/* { dg-do run } */
/* { dg-options """" } */

void
foo (int x, int y)
{
  int z;
  switch (x)
    {
    case 0:
      while (({ if (y) break; 0; }))
	;
      __builtin_abort ();
      break;
    case 1:
      do
	;
      while (({ if (y) break; 0; }));
      __builtin_abort ();
      break;
    case 2:
      for (z = ({ if (y) break; 0; }); z < 5; z++)
	;
      __builtin_abort ();
      break;
    case 3:
      for (z = 0; z < ({ if (y) break; 5; }); z++)
	;
      __builtin_abort ();
      break;
    case 4:
      for (z = 0; z < 5; z += ({ if (y) break; 1; }))
	;
      __builtin_abort ();
      break;
    case 5:
      switch (({ if (y) break; 1; }))
	{
	default: break;
	}
      __builtin_abort ();
      break;
    default:
      __builtin_abort ();
      break;
    }
}

void
bar (int x, int y)
{
  int z;
  while (x >= 0)
    {
      if (x == 0)
	{
	  while (({ if (y) break; 0; }))
	    ;
	  __builtin_abort ();
	}
      if (x == 1)
	{
	  do
	    ;
	  while (({ if (y) break; 0; }));
	  __builtin_abort ();
	}
      if (x == 2)
	{
	  for (z = ({ if (y) break; 0; }); z < 5; z++)
	    ;
	  __builtin_abort ();
	}
      if (x == 3)
	{
	  for (z = 0; z < ({ if (y) break; 5; }); z++)
	    ;
	  __builtin_abort ();
	}
      if (x == 4)
	{
	  for (z = 0; z < 5; z += ({ if (y) break; 1; }))
	    ;
	  __builtin_abort ();
	}
      if (x == 5)
	{
	  switch (({ if (y) break; 1; }))
	    {
	    default: break;
	    }
	  __builtin_abort ();
	}
    }
}

void
baz (int x, int y)
{
  int z;
  while (x >= 0)
    {
      if (++y == 2)
	return;
      if (x == 0)
	{
	  while (({ if (y) continue; 0; }))
	    ;
	  __builtin_abort ();
	}
      if (x == 1)
	{
	  do
	    ;
	  while (({ if (y) continue; 0; }));
	  __builtin_abort ();
	}
      if (x == 2)
	{
	  for (z = ({ if (y) continue; 0; }); z < 5; z++)
	    ;
	  __builtin_abort ();
	}
      if (x == 3)
	{
	  for (z = 0; z < ({ if (y) continue; 5; }); z++)
	    ;
	  __builtin_abort ();
	}
      if (x == 4)
	{
	  for (z = 0; z < 5; z += ({ if (y) continue; 1; }))
	    ;
	  __builtin_abort ();
	}
      if (x == 5)
	{
	  switch (({ if (y) continue; 1; }))
	    {
	    default: break;
	    }
	  __builtin_abort ();
	}
    }
  __builtin_abort ();
}

int
main ()
{
  foo (0, 1);
  foo (1, 1);
  foo (2, 1);
  foo (3, 1);
  foo (4, 1);
  foo (5, 1);
  bar (0, 1);
  bar (1, 1);
  bar (2, 1);
  bar (3, 1);
  bar (4, 1);
  bar (5, 1);
  baz (0, 0);
  baz (1, 0);
  baz (2, 0);
  baz (3, 0);
  baz (4, 0);
  baz (5, 0);
  return 0;
}
"
137-9573,Chilledheart/glibc,wctype/test_wcfuncs.c,72,4,53,2026939.76461875,184315.0,10.99714618994656,1299.0,1282.0,42826.0,13995.0,1646.0,638.0,1366.0,593.0,1500000000,0.0013512931764125,1082014363648.0,0.0140032010416949,0.0746730962144277,"/* Copyright (C) 1999-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#include <stdio.h>
#include <stdlib.h>
#include <wctype.h>

int
main (int argc, char *argv[])
{
  int result = 0;
  wint_t ch;


  for (ch = 0; ch < 128; ++ch)
    {
      if (iswlower (ch))
	{
	  /* Get corresponding upper case character.  */
	  wint_t up = towupper (ch);
	  /* This should have no effect.  */
	  wint_t low  = towlower (ch);

	  if ((ch != low) || (up == ch) || (up == low))
	    {
	      printf (""iswlower/towupper/towlower for character \\%x failed\n"", ch);
	      result++;
	    }
	}
      if (iswupper (ch))
	{
	  /* Get corresponding lower case character.  */
	  wint_t low = towlower (ch);
	  /* This should have no effect.  */
	  wint_t up  = towupper (ch);

	  if ((ch != up) || (low == ch) || (up == low))
	    {
	      printf (""iswupper/towlower/towupper for character \\%x failed\n"", ch);
	      result++;
	    }
	}
    }

  /* Finally some specific tests.  */
  ch = L'A';
  if (!iswupper (ch) || iswlower (ch))
    {
      printf (""!iswupper/iswlower (L'A') failed\n"");
      result++;

    }
  ch = L'a';
  if (iswupper (ch) || !iswlower (ch))
    {
      printf (""iswupper/!iswlower (L'a') failed\n"");
      result++;
    }
  if (towlower (L'A') != L'a')
    {
      printf (""towlower(L'A') failed\n"");
      result++;
    }
  if (towupper (L'a') != L'A')
    {
      printf (""towupper(L'a') failed\n"");
      result++;
    }

  if (result == 0)
    puts (""All test successful!"");
  return result != 0;
}
"
038-9527,totalspectrum/binutils-propeller,gdb/testsuite/gdb.mi/pr11022.c,24,2,20,1512678.223662,169084.0,8.946310709469849,1142.0,1132.0,38460.0,12697.0,1568.0,585.0,1317.0,546.0,1500000000,0.001008452149108,1082014363648.0,0.0134489366232168,0.078503430615556,"/* This test is part of GDB, the GNU debugger.

   Copyright 2009-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int x;

int
main ()
{
  int i, j;

  for (i = 0; i < 500; ++i) {
    j = 0;  /* break here */
    x = 42;
    j = i;  /* expect HW watchpoint stop */
  }
  return 0;
}
"
113-2619,NikolaiRadke/NOKO,write_eeprom/V10/write_Disc1.c,28,2,23,7502681708.8946705,176863.0,42420.866478573815,1359.0,1334.0,40291.0,13860.0,1640.0,644.0,1354.0,600.0,1500000000,5.00178780592978,1082014363648.0,0.0152264747290275,0.0782626359624014,"// Serial Writer - Nikolai Radke
// Writes file ""Disc1"" with a delay of 5ms for each char to 
// specified destination
//
// Compile with ""gcc write_Disc1.c"" 
// Rename with ""mv a.out write_Disc1""
// Set write_Disc1 with ""chmod 755 write_Disc1"" to be executeable
// Use with ""./write_Disc1 > /dev/ttyUSBX (X=used USB port, see
// port number in Arduino IDE

#include <stdio.h>

int main()
{
   int c;
   FILE *datei;
   usleep(5000000);	
   datei=fopen(""Disc1"",""r"");
   if(datei != NULL)
      {
         while((c=fgetc(datei))!= EOF)
		 {
            putchar(c);
			fflush(stdout);
			usleep(50000);
		 }	
      }
   else
      printf(""ERROR: Could not find or open file\n"");
 return 0;
}
"
003-29445,lolosssss/leetcode,c/56_merge_intervals.c,123,4,49,2070177.1136372997,261619.0,7.912945925181275,1378.0,1354.0,41155.0,94316.0,1748.0,1890.0,1368.0,1120.0,1500000000,0.0013801180757582,1082014363648.0,0.0104426666258949,0.045220010186682,"/**
 * Description : Merge Intervals
 *               Given a collection of intervals,merge all overlapping intervals
 * Author      : Evan Lau
 * Date        : 2016/04/20
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Interval {
    int start;
    int end;
};

struct Interval* merge(struct Interval* intervals, int intervalsSize,
                       int *returnSize)
{
    int i = 0;
    int start = 0;
    int tmp = 0;
    int min = 9999;
    int max = 0;
    int arr[10000];

    struct Interval* ret = (struct Interval*)malloc(sizeof(struct Interval) * intervalsSize);

    memset(arr, 0, sizeof(arr));

    *returnSize = 0;
    for (i = 0; i < intervalsSize; i++)
    {
        tmp = intervals[i].end - intervals[i].start;
        if (arr[intervals[i].start] == 0)
        {
            if (tmp == 0)
                arr[intervals[i].start] = -1;
            else
                arr[intervals[i].start] = tmp;
        }
        else
        {
            if (tmp != 0 && tmp > arr[intervals[i].start])
            {
                arr[intervals[i].start] = tmp;
            }
        }

        if (intervals[i].start < min)
            min = intervals[i].start;
        if (intervals[i].end > max)
            max = intervals[i].end;
    }

    i = min;
    while (i <= max)
    {
        if (start == 0)
        {
            if (arr[i] == 0)
            {
                i++;
                continue;
            }
            else if (arr[i] == -1)
            {
                ret[*returnSize].start = i;
                ret[(*returnSize)++].end = i;
            }
            else
            {
                tmp = arr[i];
                ret[*returnSize].start = i;
                start = 1;
            }
        }
        else
        {
            if (arr[i] > 0)
            {
                if (arr[i] > tmp - 1)
                    tmp = arr[i];
                else
                    tmp--;
            }
            else
            {
                tmp--;
                if (tmp == 0)
                {
                    ret[(*returnSize)++].end = i;
                    start = 0;
                }
            }
        }
        i++;
    }

    return ret;
}

int main(void)
{
    struct Interval intervals1[4];
    struct Interval intervals2[2];
    struct Interval* ret;
    int size = 0;

    intervals1[0].start = 1;
    intervals1[0].end = 3;
    intervals1[1].start = 2;
    intervals1[1].end = 6;
    intervals1[2].start = 8;
    intervals1[2].end = 10;
    intervals1[3].start = 15;
    intervals1[3].end = 18;

    intervals2[0].start = 1;
    intervals2[0].end = 4;
    intervals2[1].start = 2;
    intervals2[1].end = 5;

    ret = merge(intervals1, 4, &size);
    for (int i = 0; i < size; i++)
    {
        printf(""[%d, %d] "", ret[i].start, ret[i].end);
    }
    printf(""\n"");
    free(ret);

    ret = merge(intervals2, 2, &size);
    for (int i = 0; i < size; i++)
    {
        printf(""[%d, %d] "", ret[i].start, ret[i].end);
    }
    printf(""\n"");
    free(ret);

    return 0;
}
"
173-20523,desaiankitb/MTech,sttp_ttt/cprogs/rw.c,178,4,153,7203364104.1489315,262943.0,27395.15447834702,1659.0,1601.0,60325.0,26178.0,1779.0,919.0,1421.0,859.0,1500000000,4.802242736099288,1082014363648.0,0.0123981243083101,0.0575471370935112,"/*
 *	File	: rw.c
 *
 *	Title	: Demo Readers/Writer.
 *
 *	Short	: A solution to the multi-reader's, one writer problem.
 *
 *	Long	:
 *
 *	Author	: Andrae Muys
 *
 *	Date	: 18 September 1997
 *
 *	Revised	:
 */

#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

#define MAXCOUNT 5

#define READER1  50000
#define READER2 100000
#define READER3	400000
#define READER4 800000
#define WRITER1  150000

typedef struct {
	pthread_mutex_t *mut;
	int writers;
	int readers;
	int waiting;
	pthread_cond_t *writeOK, *readOK;
} rwl;

rwl *initlock (void);
void readlock (rwl *lock, int d);
void writelock (rwl *lock, int d);
void readunlock (rwl *lock);
void writeunlock (rwl *lock);
void deletelock (rwl *lock);

typedef struct {
	rwl *lock;
	int id;
	long delay;
} rwargs;

rwargs *newRWargs (rwl *l, int i, long d);
void *reader (void *args);
void *writer (void *args);

static int data = 1;

int main ()
{
	pthread_t r1, r2, r3, r4, w1;
	rwargs *a1, *a2, *a3, *a4, *a5;
	rwl *lock;

	lock = initlock ();
	a1 = newRWargs (lock, 1, WRITER1);
	pthread_create (&w1, NULL, writer, a1);
	a2 = newRWargs (lock, 1, READER1);
	pthread_create (&r1, NULL, reader, a2);
	a3 = newRWargs (lock, 2, READER2);
	pthread_create (&r2, NULL, reader, a3);
	a4 = newRWargs (lock, 3, READER3);
	pthread_create (&r3, NULL, reader, a4);
	a5 = newRWargs (lock, 4, READER4);
	pthread_create (&r4, NULL, reader, a5);
	pthread_join (w1, NULL);
	pthread_join (r1, NULL);
	pthread_join (r2, NULL);
	pthread_join (r3, NULL);
	pthread_join (r4, NULL);
	free (a1); free (a2); free (a3); free (a4); free (a5);

	return 0;
}

rwargs *newRWargs (rwl *l, int i, long d)
{
	rwargs *args;

	args = (rwargs *)malloc (sizeof (rwargs));
	if (args == NULL) return (NULL);
	args->lock = l; args->id = i; args->delay = d;
	return (args);
}

void *reader (void *args)
{
	rwargs *a;
	int d;

	a = (rwargs *)args;

	do {
		readlock (a->lock, a->id);
		d = data;
		usleep (a->delay);
		readunlock (a->lock);
		printf (""Reader %d : Data = %d\n"", a->id, d);
		usleep (a->delay);
	} while (d != 0);
	printf (""Reader %d: Finished.\n"", a->id);

	return (NULL);
}

void *writer (void *args)
{
	rwargs *a;
	int i;

	a = (rwargs *)args;

	for (i = 2; i < MAXCOUNT; i++) {
		writelock (a->lock, a->id);
		data = i;
		usleep (a->delay);
		writeunlock (a->lock);
		printf (""Writer %d: Wrote %d\n"", a->id, i);
		usleep (a->delay);
	}
	printf (""Writer %d: Finishing...\n"", a->id);
	writelock (a->lock, a->id);
	data = 0;
	writeunlock (a->lock);
	printf (""Writer %d: Finished.\n"", a->id);

	return (NULL);
}

rwl *initlock (void)
{
	rwl *lock;

	lock = (rwl *)malloc (sizeof (rwl));
	if (lock == NULL) return (NULL);
	lock->mut = (pthread_mutex_t *) malloc (sizeof (pthread_mutex_t));
	if (lock->mut == NULL) { free (lock); return (NULL); }
	lock->writeOK = 
		(pthread_cond_t *) malloc (sizeof (pthread_cond_t));
	if (lock->writeOK == NULL) { free (lock->mut); free (lock); 
		return (NULL); }
	lock->readOK = 
		(pthread_cond_t *) malloc (sizeof (pthread_cond_t));
	if (lock->writeOK == NULL) { free (lock->mut); free (lock->writeOK); 
		free (lock); return (NULL); }
	
	pthread_mutex_init (lock->mut, NULL);
	pthread_cond_init (lock->writeOK, NULL);
	pthread_cond_init (lock->readOK, NULL);
	lock->readers = 0;
	lock->writers = 0;
	lock->waiting = 0;

	return (lock);
}

void readlock (rwl *lock, int d)
{
	pthread_mutex_lock (lock->mut);
	if (lock->writers || lock->waiting) {
		do {
			printf (""reader %d blocked.\n"", d);
			pthread_cond_wait (lock->readOK, lock->mut);
			printf (""reader %d unblocked.\n"", d);
		} while (lock->writers);
	}
	lock->readers++;
	pthread_mutex_unlock (lock->mut);

	return;
}

void writelock (rwl *lock, int d)
{
	pthread_mutex_lock (lock->mut);
	lock->waiting++;
	while (lock->readers || lock->writers) {
		printf (""writer %d blocked.\n"", d);
		pthread_cond_wait (lock->writeOK, lock->mut);
		printf (""writer %d unblocked.\n"", d);
	}
	lock->waiting--;
	lock->writers++;
	pthread_mutex_unlock (lock->mut);

	return;
}

void readunlock (rwl *lock)
{
	pthread_mutex_lock (lock->mut);
	lock->readers--;
	pthread_cond_signal (lock->writeOK);
	pthread_mutex_unlock (lock->mut);
}

void writeunlock (rwl *lock)
{
	pthread_mutex_lock (lock->mut);
	lock->writers--;
	pthread_cond_broadcast (lock->readOK);
	pthread_mutex_unlock (lock->mut);
}

void deletelock (rwl *lock)
{
	pthread_mutex_destroy (lock->mut);
	pthread_cond_destroy (lock->readOK);
	pthread_cond_destroy (lock->writeOK);
	free (lock);

	return;
}
"
260-8865,mtasic85/nativetrap,vm_hacks/vm0/vm0.c,30,2,26,118569137.99419995,1314458803.0,0.0902037680674272,1335.0,1317.0,39180.0,13311.0,1617.0,636.0,1340.0,593.0,1500000000,0.0790460919961333,1082014363648.0,2.0175603784213845e-06,0.0797470042483473,"// time tcc -run vm0.c
// gcc -O4 -c vm0.c && gcc -o vm0 vm0.o && time ./vm0
// clang -O4 -c vm0.c && clang -o vm0 vm0.o && time ./vm0
#include <stdio.h>

void f() {
    int a = 10;
    int b = 2;
    int c = 200000000;
    int d = 7;
    int e = 1;
    int f = 0;
    // volatile int i = a; // prevent C compiler from optimizing loop
    int i = a;
    
    while (i < c) {
        if (i % d == f) {
            while (i < c) {
                i += e;

                if (i % d == f) {
                    break;
                }
            }
        } else {
            i += b;
        }
    }

    printf(""i: %d\n"", i);
}

int main(int argc, char ** argv) {
    f();
    return 0;
}"
343-30500,cesaro/dpu,tests/regression/data-race-analysis/races3.c,69,4,46,2228853.1763478,292135.0,7.629530867578346,2267.0,1783.0,68526.0,27609.0,2134.0,799.0,1636.0,724.0,1500000000,0.0014859021175652,1082014363648.0,0.0138634535403152,0.0550579913663078,"#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#ifndef N
#define N 20
#endif

#ifndef DIFF
#define DIFF 0
#endif

#ifndef WAIT2
#define WAIT2 1
#endif


struct descriptor
{
  int tid;
  unsigned offset;
  unsigned size;
  int *tab;
};

void bubble_sort(int list[], unsigned n)
{
  int c, d, t;

  for (c = 0 ; c < ( n - 1 ); c++)
  {
    for (d = 0 ; d < n - c - 1; d++)
    {
      if (list[d] > list[d+1])
      {
        t = list[d];
        list[d] = list[d+1];
        list[d+1] = t;
      }
    }
  }
}

void print (int tab[], unsigned n)
{
  int i;
  for (i = 0; i < n; i++)
  {
     if (i == n / 2) printf (""--\n"");
     printf(""i %3d tab %3d\n"", i, tab[i]);
  }
}

void *thread (void *arg)
{
  struct descriptor *d = arg;
  printf (""t%d: sorting %p, offset %u size %u!\n"",
        d->tid, d->tab, d->offset, d->size);
  bubble_sort (d->tab + d->offset, d->size);
  return 0;
}

int main()
{
  pthread_t a, b;
  struct descriptor d[2];
  int i;
  unsigned n;

  n = N & ~1;
  int tab[n];

  srand (123);
  for (i = 0; i < n; i++) tab[i] = rand () % 500;

  d[0].tid = 0;
  d[0].offset = 0;
  d[0].size = n / 2;
  d[0].tab = tab;

  d[1].tid = 1;
  d[1].offset = d[0].offset + d[0].size - DIFF;
  d[1].size = n / 2;
  d[1].tab = tab;

  printf (""m: sorting %p, size %u!\n"", tab, n);

  pthread_create (&a, NULL, thread, d + 0);
  pthread_create (&b, NULL, thread, d + 1);

  pthread_join (a, NULL);
  if (WAIT2)
    pthread_join (b, NULL);
    
  //bubble_sort (tab, n);
 
  print (tab, n);
  pthread_exit (0);
 
  return 0;
}
"
277-17112,jzeng4/pemu,plugins/glibc-2.13-new/debug/backtrace-tst.c,31,3,24,5408773.664385,30991297.0,0.1745255450263988,3029.0,1687.0,6375884.0,358995.0,487428.0,4750.0,2795.0,755.0,1500000000,0.00360584910959,1082014363648.0,0.0001521717532505,0.0736060736948651,"#include <execinfo.h>
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>


static int
compare (const void *p1, const void *p2)
{
  void *ba[20];
  int n = backtrace (ba, sizeof (ba) / sizeof (ba[0]));
  if (n != 0)
    {
      char **names = backtrace_symbols (ba, n);
      if (names != NULL)
	{
	  int i;
	  printf (""called from %s\n"", names[0]);
	  for (i = 1; i < n; ++i)
	    printf (""            %s\n"", names[i]);
	  free (names);
	}
    }

  return *(const uint32_t *) p1 - *(const uint32_t *) p2;
}


int
main (int argc, char *argv[])
{
  uint32_t arr[20];
  size_t cnt;

  for (cnt = 0; cnt < sizeof (arr) / sizeof (arr[0]); ++cnt)
    arr[cnt] = random ();

  qsort (arr, sizeof (arr) / sizeof (arr[0]), sizeof (arr[0]), compare);

  for (cnt = 0; cnt < sizeof (arr) / sizeof (arr[0]); ++cnt)
    printf (""%"" PRIx32 ""\n"", arr[cnt]);

  return 0;
}
"
183-25695,DeforaOS/libc,tests/string.c,141,2,96,3327740.93840265,262458.0,12.679133423252482,1435.0,1414.0,58017.0,25179.0,1701.0,680.0,1385.0,636.0,1500000000,0.0022184939589351,1082014363648.0,0.0108550701445564,0.0529111976537333,"/* $Id$ */
/* Copyright (c) 2012-2017 Pierre Pronchery <khorben@defora.org> */
/* This file is part of DeforaOS System libc */
/* All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS
 * IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */



#include <string.h>
#include <stdio.h>
#include <errno.h>


/* memchr */
static int _memchr(char const * progname)
{
	int ret = 0;
	char const search[] = ""sear\xff\xfe\x7f\x7e\x00\x01ch"";
	size_t i;
	void * p;

	printf(""%s: Testing %s\n"", progname, ""memchr()"");
	for(i = 0; i < sizeof(search); i++)
	{
		p = memchr(search, search[i], sizeof(search));
		if(p == NULL || strcmp(p, &search[i]) != 0)
			ret += 1;
	}
	ret += memchr(search, 'z', sizeof(search)) == NULL ? 0 : 1;
	return ret;
}


/* strerror */
static int _strerror(char const * progname)
{
	int errors[] =
	{
		0,
		E2BIG,
		EACCES,
		EAGAIN,
		EBADF,
		EBUSY,
		ECHILD,
#ifdef EDOM
		EDOM,
#endif
		EEXIST,
		EFAULT,
		EINTR,
		EINVAL,
		EIO,
		EISDIR,
		ENODEV,
		ENOENT,
		ENOEXEC,
		ENOMEM,
#ifdef ENOSPC
		ENOSPC,
#endif
		ENOSYS,
		ENOTDIR,
		ENOTSUP,
		ENOTTY,
		ENXIO,
#ifdef EOPNOTSUPP
		EOPNOTSUPP,
#endif
		EPERM,
		EPIPE,
		ERANGE,
		EROFS,
#ifdef ESPIPE
		ESPIPE,
#endif
#ifdef ESRCH
		ESRCH,
#endif
		ETIMEDOUT,
		EXDEV
	};
	size_t i;

	for(i = 0; i < sizeof(errors) / sizeof(*errors); i++)
		printf(""%s: Testing %s: \""%s\"" (%u)\n"", progname,
				""strerror()"", strerror(errors[i]), errors[i]);
	return 0;
}


/* strstr */
static int _strstr_test(char const * str1, char const * str2,
		char const * expected);

static int _strstr(char const * progname)
{
	printf(""%s: Testing %s\n"", progname, ""strstr()"");
	if(_strstr_test(""haystack"", ""needle"", NULL) != 0
			|| _strstr_test(""needle"", ""needle"", ""needle"") != 0
			|| _strstr_test(""needle "", ""needle"", ""needle "") != 0
			|| _strstr_test(""needle again"", ""needle"",
				""needle again"") != 0
			|| _strstr_test(""haystack with a needle"", ""needle"",
				""needle"") != 0
			|| _strstr_test(""haystack with a needle "", ""needle"",
				""needle "") != 0
			|| _strstr_test(""haystack with a needle again"",
				""needle"", ""needle again"") != 0)
		return -1;
	return 0;
}

static int _strstr_test(char const * str1, char const * str2,
		char const * expected)
{
	int ret;
	char const * res;

	res = strstr(str1, str2);
	if(expected == NULL || res == NULL)
		ret = (res == expected) ? 0 : -1;
	else
		ret = (strcmp(res, expected) == 0) ? 0 : -1;
	printf(""\""%s\"", \""%s\"" => %s%s%s"", str1, str2,
			(res != NULL) ? ""\"""" : """",
			(res != NULL) ? res : ""NULL"",
			(res != NULL) ? ""\"""" : """");
	if(ret != 0)
		printf("" (expected: %s%s%s)"",
				(expected != NULL) ? ""\"""" : """",
				(expected != NULL) ? expected : ""NULL"",
				(expected != NULL) ? ""\"""" : """");
	putc('\n', stdout);
	return ret;
}


/* main */
int main(int argc, char * argv[])
{
	int ret = 0;
	(void) argc;

	ret |= _memchr(argv[0]);
	ret |= _strerror(argv[0]);
	ret |= _strstr(argv[0]);
	return (ret == 0) ? 0 : 2;
}
"
258-28265,dk00/old-stuff,csie/13parllel-programming/omp3-1-1.c,23,8,22,253955068.53237748,450293754.0,0.5639764392556953,1344.0,1322.0,50039305.0,50013402.0,3126699.0,3125673.0,1340.0,3125593.0,1500000000,0.169303379021585,1082014363648.0,5.920579569042834e-06,0.0937436405393809,"#include<stdio.h>

#ifndef N
#define N 5000
#endif
#define M 1000000000

int a[N][N], b[N][N];

int main() {
  int i, j, sum;
  #pragma omp parallel sections
  {
    #pragma omp section
    for (i = 0; i < N; i++)
      for (j = 0; j < N; j++)
        a[i][j] = i + j;
    #pragma omp section
    for (i = 0; i < N; i++)
      for (j = 0; j < N; j++)
        b[i][j] = i - j;
  }
  sum = 0;
  for (i = 0; i < N; i++)
    for (j = 0; j < N; j++)
      sum += a[i][j];
  printf(""%d\n"", sum);
  sum = 0;
  for (i = 0; i < N; i++)
    for (j = 0; j < N; j++)
      sum += b[i][j];
  printf(""%d\n"", sum);
  return 0;
}

"
229-5381,fengbohello/practice,clang/size/point-size.c,35,1,32,2405824.4889601497,178865.0,13.450501775081763,1355.0,1332.0,40365.0,14129.0,1620.0,640.0,1341.0,595.0,1500000000,0.0016038829926401,1082014363648.0,0.0150225030050596,0.0769993026755239,"/*
 * =====================================================================================
 *
 *       Filename:  point-size.c
 *
 *    Description:  
 *
 *        Version:  1.0
 *        Created:  07/26/2018 05:14:03 PM
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  YOUR NAME (), 
 *   Organization:  
 *
 * =====================================================================================
 */
#include <stdio.h>

#define xdebug(fmt, arg...) \
    do{\
        printf(""%s %d : "", __func__, __LINE__); \
        printf(fmt, ##arg); \
    }while(0)

struct A {
    int a;
    char b;
    char c[128];
};

int main(int argc, char * argv[]) {
    struct A a;
    xdebug(""sizeof(a) = [%ld]\n"", sizeof(a));
    xdebug(""sizeof(&a) = [%ld]\n"", sizeof(&a));
    struct A* p = &a;
    xdebug(""sizeof(p) = [%ld]\n"", sizeof(p));
    xdebug(""sizeof(*p) = [%ld]\n"", sizeof(*p));

    return 0;
}

"
212-28469,swigger/gdb-ios,gdb/testsuite/gdb.threads/kill.c,41,3,29,1509497.98990035,169083.0,8.667405948557809,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010063319932669,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2016 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#ifdef USE_THREADS

#include <unistd.h>
#include <pthread.h>

#define NUM 5

pthread_barrier_t barrier;

void *
thread_function (void *arg)
{
  volatile unsigned int counter = 1;

  pthread_barrier_wait (&barrier);

  while (counter > 0)
    {
      counter++;
      usleep (1);
    }

  pthread_exit (NULL);
}

#endif /* USE_THREADS */

void
setup (void)
{
#ifdef USE_THREADS
  pthread_t threads[NUM];
  int i;

  pthread_barrier_init (&barrier, NULL, NUM + 1);
  for (i = 0; i < NUM; i++)
    pthread_create (&threads[i], NULL, thread_function, NULL);
  pthread_barrier_wait (&barrier);
#endif /* USE_THREADS */
}

int
main (void)
{
  setup ();
  return 0; /* set break here */
}
"
009-8719,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.mi/pr11022.c,24,2,20,1715973.2524305,169084.0,10.148642095053347,1142.0,1132.0,38460.0,12697.0,1568.0,585.0,1317.0,546.0,1500000000,0.001143982168287,1082014363648.0,0.0134489366232168,0.078503430615556,"/* This test is part of GDB, the GNU debugger.

   Copyright 2009-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int x;

int
main ()
{
  int i, j;

  for (i = 0; i < 500; ++i) {
    j = 0;  /* break here */
    x = 42;
    j = i;  /* expect HW watchpoint stop */
  }
  return 0;
}
"
053-23623,cesaro/dpu,tests/regression/ssbs/spat.c,58,6,46,1813113.2237612999,178186.0,10.17539537337389,1376.0,1351.0,40655.0,13974.0,1641.0,659.0,1362.0,616.0,1500000000,0.0012087421491742,1082014363648.0,0.0153042326557642,0.0783100550989401,"#include <pthread.h>
#include <stdio.h>
#include <assert.h>

#ifndef PARAM1
#define PARAM1 1
#endif

#ifndef PARAM2
#define PARAM2 1
#endif

#define T PARAM1 // number of threads
#define K PARAM2 // number of mutexes

pthread_mutex_t m[K];

/*
The stair pattern
a
|
b . b   
|   |
d   c . c
    |   |
    e   d . d
        |   |
        f   e . e
            |   |
            g   f . f
*/

// parametric threads
void *th(void *arg)
{
 unsigned id = (unsigned long) arg;

 int i = id;
 int j = 1;

 // Locks
 while (i < K && j < 4) {
   pthread_mutex_lock(&m[i]);
   //printf (""t%u: lock %d\n"", id, i);
   i+=j;
   j++;
 }

 // Unlocks
 while (i > id) {
   j--;
   i-=j;
   //printf (""t%u: unlock %d\n"", id, i);
   pthread_mutex_unlock(&m[i]);
 }
 return NULL;
}

int main()
{
 int i;
 pthread_t ids[T];

 //printf (""== start ==\n"");
 for (i = 0; i < K; i++)
 {
   pthread_mutex_init(&m[i], NULL);
 }
 //for (int i = T-1; i >= 0; i--)
 for (i = 0; i < T; i++)
 {
   pthread_create(&ids[i],  NULL, th, (void*) (long) i);
 }

 for (i = 0; i < T; i++)
 {
   pthread_join(ids[i],NULL);
 }
 //printf (""== end ==\n"");
 return 0;
}
"
291-12040,byt3smith/euler-solutions,C/euler7.c,32,2,25,1492078966.3447068,3977339527.0,0.375144982184972,1341.0,1321.0,39405.0,13457.0,1619.0,637.0,1341.0,594.0,1500000000,0.9947193108964713,1082014363648.0,6.692916161492189e-07,0.0792819038250539,"//
//  euler7.c
//  Project Euler
//
//  Developed by the Byt3smith
//

#include <stdio.h>

int check_if_prime(int c, int i) {
   for ( c = 2 ; c <= i - 1 ; c++ )
      {
         if ( i%c == 0 )
            break;
      }
   return c;
}

int main() {
   int nth, i = 3, count, c;
   nth = 10001;

   printf(""[*] Locating the %dst prime...\n\n"", nth);

   for ( count = 2 ; count <= nth ;  )
   {
      c = check_if_prime(count, i);

      if ( c == i )
      {
         if (count == nth) {
            printf(""[+] Success!\nThe %dst prime is: %d\n"", count, i);
         }
	 count++;
      }
      i++;
   }

   return 0;
}
"
299-19015,jainaman224/Algo_Ds_Notes,Linked_List/Length_of_Linked_List.c,56,2,39,1545784.2964678498,177280.0,8.719449458483755,1345.0,1324.0,40102.0,13940.0,1618.0,639.0,1341.0,597.0,1500000000,0.0010305228643119,1082014363648.0,0.0150552797833935,0.0776248103327042,"// Length of Linked List
#include <stdio.h>
#include <stdlib.h>

/*
This code is written for Char to store in LinkedList, if you want to store numericals or any other datatype,
just replace relevent data type in place of char in class Node.
*/

struct Node 
{	
    char data;
    struct Node* next;
};

void pushing_data_to_LL(struct Node** headPointer, char newData)
{
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode -> data = newData;
    newNode -> next = (*headPointer);
    (*headPointer) = newNode;
}

int gettingLength(struct Node* head)
{
    int count = 0;
    struct Node* current = head;
    while(current != NULL)
    {
    	count++;
    	current = current -> next;
    }
    return count;
}

int main()
{
    struct Node* head = NULL;
    printf(""Currently Length of Linkedlist is: %d"", gettingLength(head));

    pushing_data_to_LL(&head, 'G');
    pushing_data_to_LL(&head, 'S');
    pushing_data_to_LL(&head, 'S');
    pushing_data_to_LL(&head, 'O');
    pushing_data_to_LL(&head, 'C');
	    
    //Intermediate Checking
    printf(""\n Currently Length of Linkedlist is: %d"", gettingLength(head));
	    
    pushing_data_to_LL(&head, '-');
    printf(""\n Currently Length of Linkedlist is: %d"", gettingLength(head));
    
    pushing_data_to_LL(&head, '2');
    pushing_data_to_LL(&head, '0');
    pushing_data_to_LL(&head, '2');
    pushing_data_to_LL(&head, '0');

    printf(""\n Currently Length of Linkedlist is: %d"", gettingLength(head));
    
    return 0;
}

/*
TestCase-1:
Sample Input: G S S O C 2 0 2 0 
Sample Output: 9 //9 letters

TestCase-2:
Sample Input: O p e n - S o u r c e
Sample Output: 11 //11 letters
*/
"
055-11316,hsylx1992/my_leetcode,src/ReverseLinkedListII.c,99,6,70,1870622.8584051,191373.0,9.7747435636166,1349.0,1330.0,43135.0,16033.0,1626.0,644.0,1348.0,600.0,1500000000,0.0012470819056034,1082014363648.0,0.01399883996175,0.071288534342888,"
#include <stdio.h>
#include <stdlib.h>

//#define DEBUG
#define DEBUG_LEVEL 3

struct ListNode {
     int val;
     struct ListNode *next;
};


void printList(struct ListNode * head) {
	while (head) {
#if (DEBUG_LEVEL == 1)
		printf(""[%d]¡¾%2d¡¿->"", head, head->val);
#else
		printf(""[%d]->"", head->val);
#endif
		head = head->next;
	}
	printf(""\n"");
}


struct ListNode *reverseBetween(struct ListNode *head, int m, int n) {
    struct ListNode *p, *pa, *pb, *ph;
	struct ListNode *prev, *next, *h;
	int len = n-m+1;
	int i = 0;
	int sFlag = 0;

	p = head;
	if (m == 1) {
		sFlag = 1;
		pa = head;
	} else {		
		while (m>=3) {p = p->next; m--;}
		ph = p;
		pa = p->next;
	}

	p  = head;
	n  = n-1;
	while (n--) {p = p->next;}
	pb = p;

#ifdef DEBUG
#if (DEBUG_LEVEL == 1)
    printf(""pa - %d %d\npb - %d %d\n"", pa, pa->val, pb, pb->val);
#endif
#endif

	next = pa->next;
	prev = pb->next;//prev = NULL;
	p    = pa;

	while (len--) {
		i++;
		next = p->next;
		h	 = p;
		h->next = prev;
		prev = p;
		p    = next;
	}

    if (sFlag) {head = h;}
	else {ph->next = h;}

#ifdef DEBUG
#if (DEBUG_LEVEL == 2)
	printList(h);
	printList(head);
#endif
#endif

	return head;
}

int val[5] = {1,2,3,4,5};
struct ListNode *head;


void initGlobalList() {
	int i;
	struct ListNode *p;

	head = malloc(sizeof(struct ListNode));
	p	 = head;

	for (i = 0; i < 5; i++) {
		p->val = val[i];
		if (i != 4)
			p->next = malloc(sizeof(struct ListNode));
		else
			p->next = NULL;
		p = p->next;
	}	
}

int main()
{
	/*
	int val[5] = {1,2,3,4,5};
	struct ListNode *head = malloc(sizeof(struct ListNode));
	struct ListNode *p = head;
	int i;

	for (i = 0; i < 5; i++) {
		p->val = val[i];
		if (i != 4)
			p->next = malloc(sizeof(struct ListNode));
		else
			p->next = NULL;
		p = p->next;
	}
	printList(head);

	reverseBetween(head, 2, 4);

	printList(head);
*/
	initGlobalList();
	head = reverseBetween(head, 1, 3);
	printList(head);

	initGlobalList();
	head = reverseBetween(head, 2, 4);
	printList(head);

	initGlobalList();
	head = reverseBetween(head, 3, 5);
	printList(head);

	initGlobalList();
	head = reverseBetween(head, 1, 5);
	printList(head);

	return 0;
}"
049-2654,zhuyehang001/leetcode,121.c,25,1,28,1531713.17651865,173903.0,8.80785840382282,1337.0,1318.0,39416.0,13388.0,1625.0,636.0,1345.0,594.0,1500000000,0.0010211421176791,1082014363648.0,0.0152671316768543,0.0795394288311491,"/*
 * best time to buy and sell stock
 *
 * 	costs 11 minutes
 * 	2016.10.10
 * 	zhuyehang
 */

#include <stdio.h>

int maxProfit(int *prices, int priceSize);

int main(void)
{
	int prices[6] = {7,1,5,3,6,4};
	int priceSize = sizeof(prices) / sizeof(prices[0]);

	printf(""%d\n"", maxProfit(prices, priceSize));
	return 0;
}

int maxProfit(int *prices, int priceSize){
	int min = *prices;
	int profit = *prices - min;

	for(int i = 1; i < priceSize; i++){
		if(min > *(prices + i))
			min = *(prices + i);
		profit = ((*(prices + i) - min) > profit) ? (*(prices + i) - min) : profit;
	}
	return profit;
}
"
388-28832,Gigers/data-struct,Aulas/aula06/teacher_code/codigo_concatena.c,56,3,41,4133601.20728605,214549.0,19.26646593552056,1454.0,1427.0,49096.0,18989.0,1653.0,659.0,1362.0,612.0,1500000000,0.0027557341381907,1082014363648.0,0.0134281679243436,0.0629507233605052,"/*

    Código mostrado em aula pelo Professor

*/

#include <stdio.h>
#include <stdlib.h>
struct cel {
       int conteudo;
       struct cel *seg; /* seguinte */
};
typedef struct cel celula;
void Imprima (celula *lst) {
     celula *p;
     for (p = lst->seg; p != NULL; p = p->seg)
         printf (""%d"", p->conteudo);
     putchar('\n');
}
void Insere(int y, celula *p){
    celula *nova;
    nova = malloc(sizeof(celula));
    nova->conteudo = y;
    nova->seg = p->seg;
    p->seg = nova;
}
int randint(int a, int b){
    double r, x, R = RAND_MAX;
    int i;
    r = rand();
    x = r / (R + 1);
    i = (int) (x * (b - a + 1));
    return a + i;
}

void concatena(celula *lst1, celula *lst2){
    celula *p;
    p = lst1->seg;
    while (p->seg != NULL)
        p = p->seg;
    
    p->seg = lst2->seg;
    free(lst2);
}

int main(void){
    int i;
    celula *lst1, *lst2;
    lst1 = malloc(sizeof(celula));
    lst1->seg = NULL;
    lst2 = malloc(sizeof(celula));
    lst2->seg = NULL;
    srand(time(NULL));
    for (i = 0; i < 10; i++) {
        Insere(randint(0, 9), lst1);
        Insere(randint(0, 9), lst2);
    }
    Imprima(lst1);
    Imprima(lst2);
    concatena(lst1, lst2);
    printf(""Concatena: "");
    Imprima(lst1);       
    system(""pause"");
}"
260-3255,RachelYang02/ExercisesInC,exercises/ex13/mem_errors.c,41,1,34,1550960.8201681501,169878.0,9.12984612486608,1137.0,1130.0,38650.0,12779.0,1569.0,589.0,1318.0,547.0,1500000000,0.0010339738801121,1082014363648.0,0.0133448710250885,0.0782243481304322,"/*
solution by Rachel Yang
Example code for Exercises in C.
Copyright 2014 Allen Downey
License: Creative Commons Attribution-ShareAlike 3.0
*/

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>


void free_anything(int *p) {
    free(p);
}


int read_element(int *array, int index) {
    int x = array[index];
    return x;
}


int main ()
{
    // int never_allocated;
    int *free_twice = malloc (sizeof (int));
    int *use_after_free = malloc (sizeof (int));
    int *never_free = malloc (sizeof (int));
    int array1[100];
    int *array2 = malloc (100 * sizeof (int));

    // valgrind does not bounds-check static arrays
    read_element(array1, 0);
    read_element(array1, 99);

    // but it does bounds-check dynamic arrays
    read_element(array2, 0);
    read_element(array2, 99);

    // and it catches use after free
    *use_after_free = 17;
    free(use_after_free);

    // never_free is definitely lost
    *never_free = 17;
    free(never_free);

    // the following line would generate a warning
    // free(&never_allocated);

    // but this one doesn't
    // free_anything(&never_allocated);

    free(array2);
    free(free_twice);

    return 0;
}
"
198-28218,totalspectrum/binutils-propeller,gdb/testsuite/gdb.btrace/enable-running.c,32,4,23,15011345070.088285,180208.0,82121.01840095888,1381.0,1355.0,41176.0,14476.0,1644.0,715.0,1358.0,671.0,1500000000,10.007563380058857,1082014363648.0,0.01518245582882,0.0788471213972543,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <pthread.h>
#include <unistd.h>

#define NTHREADS 3

static void *
test (void *arg)
{
  /* Let's hope this is long enough for GDB to enable tracing and check that
     everything is working as expected.  */
  sleep (10);

  return arg;
}

int
main (void)
{
  pthread_t th[NTHREADS];
  int i;

  for (i = 0; i < NTHREADS; ++i)
    pthread_create (&th[i], NULL, test, NULL);

  test (NULL); /* bp.1 */

  for (i = 0; i < NTHREADS; ++i)
    pthread_join (th[i], NULL);

  return 0;
}
"
079-32013,PeterBeard/project-euler,c/src/problem-007.c,41,4,27,10607808.013446601,29283295.0,0.3622477593453879,1333.0,1314.0,39181.0,13310.0,1618.0,638.0,1339.0,593.0,1500000000,0.0070718720089644,1082014363648.0,9.03928331835608e-05,0.0797851060181745,"/*
 * Copyright 2016 Peter Beard
 * Distributed under the GNU GPL v2. For full terms, see the LICENSE file.
 *
 * Problem #7
 *
 * By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see
 * that the 6th prime is 13.
 *
 * What is the 10 001st prime number?
 */
#include <stdio.h>

// Determine whether a number is prime - 1 for prime, 0 for not prime
int is_prime(int n)
{
    int f = 2;
    while(f*f <= n)
    {
        if(n % f == 0)
            return 0;
        f++;
    }
    return 1;
}

// Find the nth prime number
int nth_prime(int n)
{
    if(n <= 1)
        return 2;

    int p = 1;
    while(n > 0)
    {
        p++;
        if(is_prime(p))
            n--;
    }
    return p;
}

int main()
{
    printf(""The 10,001st prime is %d.\n"", nth_prime(10001));
}
"
069-392,benjholla/ISU_Spring_2014_NCDC_Anomalies,Anomalies/Decompiling/zipper.c,36,3,23,1730748.1030002,169083.0,10.236085236244922,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0011538320686668,1082014363648.0,0.0134490161636592,0.0785049652044725,"#include <stdio.h>

int main(){
	char str[14] = ""Good morning!"";
	char sub1[27] = ""perntgvqszmwajldbicxfkhuoy"";
	char sub2[27] = ""gjnecidqlsmwzxpvahbfkortuy"";
	int i, j;
	//finding strlen without a statically linked function
	for(i = 0, j = 0; i < 400; i++){
		if(str[i] != '\0'){
			j++;
		}
		else{
			break;
		}
	}
	int strlength = j;
	//Convert to lowercase
	for(i = 0; i < strlength; i++){
		if(str[i] <= 'Z' && str[i] >= 'A'){
			str[i] = str[i] - 'A' + 'a';
		}
	}
	for(i = 0, j= 0; i <  strlength && j < strlength; i++, j++){
		if(str[i] <= 'z' && str[i] >= 'a'){
			if(j %2 == 0){ //If even
				str[i] = sub1[str[i] -'a'];
			}
			else{
				str[i] = sub2[str[i]-'a'];
			}
		}
		else{
			j--;
		}
	}
	return 0;	
}"
251-16988,GM-Connor/_personal,C/squeeze.c,26,2,30,1777742.98936125,173493.0,10.246764999164231,1293.0,1277.0,39322.0,13322.0,1617.0,634.0,1340.0,592.0,1500000000,0.0011851619929075,1082014363648.0,0.0148132777691318,0.0794582478535065,"#include <stdio.h>

void squeeze(char s1[], char s2[]);
int stringContains(char string[], char c);

/* squeese string1 against string2 */
int main() {
	char s1[] = ""green tractor"";
	char s2[] = ""r "";

	squeeze(s1, s2);

	printf(""%s\n"", s1);

	return 0;
}

/* deletes each character in s1 that appears in s2 */
void squeeze(char s1[], char s2[]) {
	int i, j;	/* indexes */
	
	for (i=j=0; s1[i] != '\0'; ++i)
		if (stringContains(s2, s1[i]) == -1)
			s1[j++] = s1[i];
	s1[j] = '\0';
}

/* returns position of char c in string s. returns -1 if not in string */
int stringContains(char s[], char c) {
	int i;	/* index */

	for (i = 0; s[i] != '\0'; ++i)
		if (c == s[i])
			return i;
	return -1;
}"
157-10555,crazyleen/msp430-gdb-7.2a,gdb/testsuite/gdb.reverse/break-reverse.c,29,1,25,1798487.85046485,169062.0,10.638032201204291,1140.0,1130.0,38452.0,12697.0,1567.0,588.0,1316.0,547.0,1500000000,0.0011989919003099,1082014363648.0,0.0134270267712436,0.0785548104557273,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2008, 2009, 2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int xyz;

int bar ()
{
  xyz = 2; /* break in bar */
  return 1;
}

int foo ()
{
  xyz = 1; /* break in foo */
  return bar ();
}

int main ()
{
  xyz = 0;	/* break in main */
  foo ();
  return (xyz == 2 ? 0 : 1);
}		/* end of main */
"
350-3773,c0t0d0s2/swatchtime,swatchtime.c,13,1,23,3357004.2578502,175548.0,19.12299769863513,1445.0,1418.0,39803.0,13662.0,1639.0,637.0,1354.0,593.0,1500000000,0.0022380028385668,1082014363648.0,0.016308929751407,0.0789862526886748,"#include <stdio.h>
#include <time.h>
int main ()
{
    float swatch;
    time_t sec;
    sec = time (NULL);
    /* Swatch time is based on CET (Central European Time) which is +1GMT.  NO DST bullshit either. */
    /* hence, the formula is basically epochtime in seconds + one hour in seconds */
    /* I specifically wanted ""centibeats"" hence the garbage with floats and 3 decimal places. */
    /* As I am a dumbshit at C, I will eventually make a commandline arg for this. */
    swatch = (float)(((sec + 3600) % 86400) * 1000) / 86400;
    printf (""@%06.3f\n"", swatch);
    return 0;
}
"
198-32181,h4ck3rm1k3/gcc-1,gcc/testsuite/gcc.c-torture/execute/pr68532.c,18,2,18,1705983.0715879498,170591.0,20.66383924122609,1147.0,1138.0,38682.0,12908.0,1577.0,590.0,1323.0,550.0,1500000000,0.0011373220477253,1082014363648.0,0.0133946105011401,0.078309749951541,"/* { dg-options ""-O2 -ftree-vectorize -fno-vect-cost-model"" } */

#define SIZE 128
unsigned short _Alignas (16) in[SIZE];

__attribute__ ((noinline)) int
test (unsigned short sum, unsigned short *in, int x)
{
  for (int j = 0; j < SIZE; j += 8)
    sum += in[j] * x;
  return sum;
}

int
main ()
{
  for (int i = 0; i < SIZE; i++)
    in[i] = i;
  if (test (0, in, 1) != 960)
    __builtin_abort ();
  return 0;
}
"
112-31692,ColinIanKing/stress-ng,test/test-sched-rr-get-interval.c,25,1,24,1605813.0422607,170929.0,10.102048218851102,1137.0,1129.0,38931.0,12868.0,1589.0,581.0,1333.0,544.0,1500000000,0.0010705420281738,1082014363648.0,0.0132569663427504,0.0781289214077491,"/*
 * Copyright (C) 2013-2021 Canonical, Ltd.
 * Copyright (C)      2022 Colin Ian King
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 */

#define _GNU_SOURCE

#include <sched.h>

int main(void)
{
	struct timespec ts;
	pid_t pid = 0;

	return sched_rr_get_interval(pid, &ts);
}
"
159-18697,maxjspaulding/Interview-Problems,rand7/c/rand7.c,20,3,18,46376067.213713996,186249090.0,0.2489190578058663,1376.0,1352.0,43884859.0,16675514.0,1642.0,641.0,1359.0,599.0,1500000000,0.030917378142476,1082014363648.0,1.4647051429888863e-05,7.002929126608913e-05,"#include ""stdio.h""
#include <time.h>
#include <stdlib.h>

int rand5(){
	return rand() % 5;
}


int rand7(){
	int sum;
	do{
		sum  = rand5() * 5 + rand5();
	}while(sum > 20);

	return sum % 7;
}

int main(int argc, char **argv){
	// Seed rand
	srand(time(NULL));

	// rand7
	int results[7] = {0};
	for(int i=0; i<1000000; i++)
		results[rand7()]++;
	
	for(int i=0; i<7; i++)
		printf(""%d came up %d times\n"", i, results[i]);

}"
077-23530,ensemblr/llvm-project-boilerplate,include/llvm/projects/test-suite/SingleSource/Benchmarks/Misc/mandel-2.c,19,3,18,880078162.648715,3922907652.0,0.2243433289976411,1311.0,1291.0,491506.0,336624.0,1622.0,697.0,1342.0,656.0,1500000000,0.5867187750991434,1082014363648.0,6.632835210060152e-07,0.0052129496576624,"#include <stdio.h>
#include <stdlib.h>
#include <complex.h>

int max_i = 65536;

double sqr(double x) { return x*x; }

double cnorm2(complex z) { return sqr(creal(z)) + sqr(cimag(z)); }

int loop(complex c) {
    complex z=c;
    int i=1;
    while (cnorm2(z) <= 4.0 && i++ < max_i)
        z = z*z + c;
    return i;
}

int main() {
  int i, j;
    for (j = -39; j < 39; ++j) {
        for (i = -39; i < 39; ++i)
            printf(loop(j/40.0-0.5 + i/40.0*I) > max_i ? ""*"" : "" "");
        printf(""\n"");
    }
    return 0;
}

"
109-26243,NikolaiRadke/NOKO,write_eeprom/V10/write_Disc0.c,30,2,27,7502833418.897353,176863.0,42421.724261151285,1359.0,1334.0,40291.0,13860.0,1640.0,644.0,1354.0,600.0,1500000000,5.001888945931569,1082014363648.0,0.0152264747290275,0.0782626359624014,"// Serial Writer - Nikolai Radke
// Writes file ""texte"" with a delay of 5ms for each char to 
// specified destination
//
// Compile with ""gcc write_Disc0.c"" 
// 
// Linux:
// Rename with ""mv a.out write_Disc0""
// Set write_Disc0 with ""chmod 755 write_Disc0"" to be executeable
// Use with ""./write_Disc0 > /dev/ttyUSBX (X=used USB port, see
// port number in Arduino IDE

#include <stdio.h>

int main()
{
   int c;
   FILE *datei;
   usleep(5000000);	
   datei=fopen(""Disc0"",""r"");
   if(datei != NULL)
      {
         while((c=fgetc(datei))!= EOF)
		 {
            putchar(c);
			fflush(stdout);
			usleep(50000);
		 }	
      }
   else
      printf(""Konnte Datei nicht finden bzw. öffnen!\n"");
 return 0;
}
"
151-8092,Alleysakura/collegeHomeWork,universityFirstGradeLastSemester/学习/第二章课后习题源代码/99full.c,18,2,19,1796418.2188734,285388.0,6.294651492003869,1352.0,1331.0,61105.0,27214.0,1633.0,644.0,1353.0,601.0,1500000000,0.0011976121459156,1082014363648.0,0.0094012362117538,0.047905886615564,"//九九乘法表
//
//x代表乘数，y代表被乘数
//
//Copyright since 2016 杨昊憬，使用VIM与gcc编译器


#include<stdio.h>

int main()
{
	int x,y,sum;
	printf(""________九九乘法表_______\n"");
	printf(""\n"");
	for(x=1;x<=9;x++){
		for(y=1;y<=9;y++){
			printf(""%d*%d=%d "",x,y,x*y);
		}
		printf(""\n"");
	}
	return 0;
}
"
131-22638,JREkiwi/sagetv,third_party/ffmpeg/tools/qt-faststart.c,268,7,215,1951099.2569848502,181766.0,10.73412519393066,1306.0,1289.0,41724.0,14348.0,1693.0,640.0,1397.0,596.0,1500000000,0.0013007328379899,1082014363648.0,0.014276597383449,0.0771508061064345,"/*
 * qt-faststart.c, v0.2
 * by Mike Melanson (melanson@pcisys.net)
 * This file is placed in the public domain. Use the program however you
 * see fit.
 *
 * This utility rearranges a Quicktime file such that the moov atom
 * is in front of the data, thus facilitating network streaming.
 *
 * To compile this program, start from the base directory from which you
 * are building FFmpeg and type:
 *  make tools/qt-faststart
 * The qt-faststart program will be built in the tools/ directory. If you
 * do not build the program in this manner, correct results are not
 * guaranteed, particularly on 64-bit platforms.
 * Invoke the program with:
 *  qt-faststart <infile.mov> <outfile.mov>
 *
 * Notes: Quicktime files can come in many configurations of top-level
 * atoms. This utility stipulates that the very last atom in the file needs
 * to be a moov atom. When given such a file, this utility will rearrange
 * the top-level atoms by shifting the moov atom from the back of the file
 * to the front, and patch the chunk offsets along the way. This utility
 * presently only operates on uncompressed moov atoms.
 */

#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
#include <string.h>

#ifdef __MINGW32__
#define fseeko(x,y,z)  fseeko64(x,y,z)
#define ftello(x)      ftello64(x)
#endif

#define BE_16(x) ((((uint8_t*)(x))[0] << 8) | ((uint8_t*)(x))[1])
#define BE_32(x) ((((uint8_t*)(x))[0] << 24) | \
                  (((uint8_t*)(x))[1] << 16) | \
                  (((uint8_t*)(x))[2] << 8) | \
                   ((uint8_t*)(x))[3])
#define BE_64(x) (((uint64_t)(((uint8_t*)(x))[0]) << 56) | \
                  ((uint64_t)(((uint8_t*)(x))[1]) << 48) | \
                  ((uint64_t)(((uint8_t*)(x))[2]) << 40) | \
                  ((uint64_t)(((uint8_t*)(x))[3]) << 32) | \
                  ((uint64_t)(((uint8_t*)(x))[4]) << 24) | \
                  ((uint64_t)(((uint8_t*)(x))[5]) << 16) | \
                  ((uint64_t)(((uint8_t*)(x))[6]) << 8) | \
                  ((uint64_t)((uint8_t*)(x))[7]))

#define BE_FOURCC( ch0, ch1, ch2, ch3 )             \
        ( (uint32_t)(unsigned char)(ch3) |          \
        ( (uint32_t)(unsigned char)(ch2) << 8 ) |   \
        ( (uint32_t)(unsigned char)(ch1) << 16 ) |  \
        ( (uint32_t)(unsigned char)(ch0) << 24 ) )

#define QT_ATOM BE_FOURCC
/* top level atoms */
#define FREE_ATOM QT_ATOM('f', 'r', 'e', 'e')
#define JUNK_ATOM QT_ATOM('j', 'u', 'n', 'k')
#define MDAT_ATOM QT_ATOM('m', 'd', 'a', 't')
#define MOOV_ATOM QT_ATOM('m', 'o', 'o', 'v')
#define PNOT_ATOM QT_ATOM('p', 'n', 'o', 't')
#define SKIP_ATOM QT_ATOM('s', 'k', 'i', 'p')
#define WIDE_ATOM QT_ATOM('w', 'i', 'd', 'e')
#define PICT_ATOM QT_ATOM('P', 'I', 'C', 'T')
#define FTYP_ATOM QT_ATOM('f', 't', 'y', 'p')
#define UUID_ATOM QT_ATOM('u', 'u', 'i', 'd')

#define CMOV_ATOM QT_ATOM('c', 'm', 'o', 'v')
#define STCO_ATOM QT_ATOM('s', 't', 'c', 'o')
#define CO64_ATOM QT_ATOM('c', 'o', '6', '4')

#define ATOM_PREAMBLE_SIZE 8
#define COPY_BUFFER_SIZE 1024

int main(int argc, char *argv[])
{
    FILE *infile  = NULL;
    FILE *outfile = NULL;
    unsigned char atom_bytes[ATOM_PREAMBLE_SIZE];
    uint32_t atom_type = 0;
    uint64_t atom_size = 0;
    uint64_t atom_offset = 0;
    uint64_t last_offset;
    unsigned char *moov_atom = NULL;
    unsigned char *ftyp_atom = NULL;
    uint64_t moov_atom_size;
    uint64_t ftyp_atom_size = 0;
    uint64_t i, j;
    uint32_t offset_count;
    uint64_t current_offset;
    uint64_t start_offset = 0;
    unsigned char copy_buffer[COPY_BUFFER_SIZE];
    int bytes_to_copy;

    if (argc != 3) {
        printf (""Usage: qt-faststart <infile.mov> <outfile.mov>\n"");
        return 0;
    }

    if (!strcmp(argv[1], argv[2])) {
        fprintf(stderr, ""input and output files need to be different\n"");
        return 1;
    }

    infile = fopen(argv[1], ""rb"");
    if (!infile) {
        perror(argv[1]);
        goto error_out;
    }

    /* traverse through the atoms in the file to make sure that 'moov' is
     * at the end */
    while (!feof(infile)) {
        if (fread(atom_bytes, ATOM_PREAMBLE_SIZE, 1, infile) != 1) {
            break;
        }
        atom_size = (uint32_t)BE_32(&atom_bytes[0]);
        atom_type = BE_32(&atom_bytes[4]);

        /* keep ftyp atom */
        if (atom_type == FTYP_ATOM) {
            ftyp_atom_size = atom_size;
            free(ftyp_atom);
            ftyp_atom = malloc(ftyp_atom_size);
            if (!ftyp_atom) {
                printf (""could not allocate %""PRIu64"" byte for ftyp atom\n"",
                        atom_size);
                goto error_out;
            }
            fseeko(infile, -ATOM_PREAMBLE_SIZE, SEEK_CUR);
            if (fread(ftyp_atom, atom_size, 1, infile) != 1) {
                perror(argv[1]);
                goto error_out;
            }
            start_offset = ftello(infile);
        } else {

        /* 64-bit special case */
        if (atom_size == 1) {
            if (fread(atom_bytes, ATOM_PREAMBLE_SIZE, 1, infile) != 1) {
                break;
            }
            atom_size = BE_64(&atom_bytes[0]);
            fseeko(infile, atom_size - ATOM_PREAMBLE_SIZE * 2, SEEK_CUR);
        } else {
            fseeko(infile, atom_size - ATOM_PREAMBLE_SIZE, SEEK_CUR);
        }
    }
        printf(""%c%c%c%c %10""PRIu64"" %""PRIu64""\n"",
               (atom_type >> 24) & 255,
               (atom_type >> 16) & 255,
               (atom_type >>  8) & 255,
               (atom_type >>  0) & 255,
               atom_offset,
               atom_size);
        if ((atom_type != FREE_ATOM) &&
            (atom_type != JUNK_ATOM) &&
            (atom_type != MDAT_ATOM) &&
            (atom_type != MOOV_ATOM) &&
            (atom_type != PNOT_ATOM) &&
            (atom_type != SKIP_ATOM) &&
            (atom_type != WIDE_ATOM) &&
            (atom_type != PICT_ATOM) &&
            (atom_type != UUID_ATOM) &&
            (atom_type != FTYP_ATOM)) {
            printf (""encountered non-QT top-level atom (is this a Quicktime file?)\n"");
            break;
        }
        atom_offset += atom_size;

        /* The atom header is 8 (or 16 bytes), if the atom size (which
         * includes these 8 or 16 bytes) is less than that, we won't be
         * able to continue scanning sensibly after this atom, so break. */
        if (atom_size < 8)
            break;
    }

    if (atom_type != MOOV_ATOM) {
        printf (""last atom in file was not a moov atom\n"");
        free(ftyp_atom);
        fclose(infile);
        return 0;
    }

    /* moov atom was, in fact, the last atom in the chunk; load the whole
     * moov atom */
    fseeko(infile, -atom_size, SEEK_END);
    last_offset = ftello(infile);
    moov_atom_size = atom_size;
    moov_atom = malloc(moov_atom_size);
    if (!moov_atom) {
        printf (""could not allocate %""PRIu64"" byte for moov atom\n"",
            atom_size);
        goto error_out;
    }
    if (fread(moov_atom, atom_size, 1, infile) != 1) {
        perror(argv[1]);
        goto error_out;
    }

    /* this utility does not support compressed atoms yet, so disqualify
     * files with compressed QT atoms */
    if (BE_32(&moov_atom[12]) == CMOV_ATOM) {
        printf (""this utility does not support compressed moov atoms yet\n"");
        goto error_out;
    }

    /* close; will be re-opened later */
    fclose(infile);
    infile = NULL;

    /* crawl through the moov chunk in search of stco or co64 atoms */
    for (i = 4; i < moov_atom_size - 4; i++) {
        atom_type = BE_32(&moov_atom[i]);
        if (atom_type == STCO_ATOM) {
            printf ("" patching stco atom...\n"");
            atom_size = BE_32(&moov_atom[i - 4]);
            if (i + atom_size - 4 > moov_atom_size) {
                printf ("" bad atom size\n"");
                goto error_out;
            }
            offset_count = BE_32(&moov_atom[i + 8]);
            for (j = 0; j < offset_count; j++) {
                current_offset = BE_32(&moov_atom[i + 12 + j * 4]);
                current_offset += moov_atom_size;
                moov_atom[i + 12 + j * 4 + 0] = (current_offset >> 24) & 0xFF;
                moov_atom[i + 12 + j * 4 + 1] = (current_offset >> 16) & 0xFF;
                moov_atom[i + 12 + j * 4 + 2] = (current_offset >>  8) & 0xFF;
                moov_atom[i + 12 + j * 4 + 3] = (current_offset >>  0) & 0xFF;
            }
            i += atom_size - 4;
        } else if (atom_type == CO64_ATOM) {
            printf ("" patching co64 atom...\n"");
            atom_size = BE_32(&moov_atom[i - 4]);
            if (i + atom_size - 4 > moov_atom_size) {
                printf ("" bad atom size\n"");
                goto error_out;
            }
            offset_count = BE_32(&moov_atom[i + 8]);
            for (j = 0; j < offset_count; j++) {
                current_offset = BE_64(&moov_atom[i + 12 + j * 8]);
                current_offset += moov_atom_size;
                moov_atom[i + 12 + j * 8 + 0] = (current_offset >> 56) & 0xFF;
                moov_atom[i + 12 + j * 8 + 1] = (current_offset >> 48) & 0xFF;
                moov_atom[i + 12 + j * 8 + 2] = (current_offset >> 40) & 0xFF;
                moov_atom[i + 12 + j * 8 + 3] = (current_offset >> 32) & 0xFF;
                moov_atom[i + 12 + j * 8 + 4] = (current_offset >> 24) & 0xFF;
                moov_atom[i + 12 + j * 8 + 5] = (current_offset >> 16) & 0xFF;
                moov_atom[i + 12 + j * 8 + 6] = (current_offset >>  8) & 0xFF;
                moov_atom[i + 12 + j * 8 + 7] = (current_offset >>  0) & 0xFF;
            }
            i += atom_size - 4;
        }
    }

    /* re-open the input file and open the output file */
    infile = fopen(argv[1], ""rb"");
    if (!infile) {
        perror(argv[1]);
        goto error_out;
    }

    if (start_offset > 0) { /* seek after ftyp atom */
        fseeko(infile, start_offset, SEEK_SET);
        last_offset -= start_offset;
    }

    outfile = fopen(argv[2], ""wb"");
    if (!outfile) {
        perror(argv[2]);
        goto error_out;
    }

    /* dump the same ftyp atom */
    if (ftyp_atom_size > 0) {
        printf ("" writing ftyp atom...\n"");
        if (fwrite(ftyp_atom, ftyp_atom_size, 1, outfile) != 1) {
            perror(argv[2]);
            goto error_out;
        }
    }

    /* dump the new moov atom */
    printf ("" writing moov atom...\n"");
    if (fwrite(moov_atom, moov_atom_size, 1, outfile) != 1) {
        perror(argv[2]);
        goto error_out;
    }

    /* copy the remainder of the infile, from offset 0 -> last_offset - 1 */
    printf ("" copying rest of file...\n"");
    while (last_offset) {
        if (last_offset > COPY_BUFFER_SIZE)
            bytes_to_copy = COPY_BUFFER_SIZE;
        else
            bytes_to_copy = last_offset;

        if (fread(copy_buffer, bytes_to_copy, 1, infile) != 1) {
            perror(argv[1]);
            goto error_out;
        }
        if (fwrite(copy_buffer, bytes_to_copy, 1, outfile) != 1) {
            perror(argv[2]);
            goto error_out;
        }

        last_offset -= bytes_to_copy;
    }

    fclose(infile);
    fclose(outfile);
    free(moov_atom);
    free(ftyp_atom);

    return 0;

error_out:
    if (infile)
        fclose(infile);
    if (outfile)
        fclose(outfile);
    free(moov_atom);
    free(ftyp_atom);
    return 1;
}
"
125-19762,totalspectrum/binutils-propeller,gdb/testsuite/gdb.threads/names.c,65,3,35,2006496.3027834,184526.0,10.87378472410392,1395.0,1370.0,42285.0,14920.0,1665.0,712.0,1376.0,669.0,1500000000,0.0013376642018556,1082014363648.0,0.0149843382504362,0.0773009352329341,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2015-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#define _GNU_SOURCE
#include <unistd.h>
#include <stdlib.h>
#include <pthread.h>
#include <assert.h>

#define NUM_THREADS 3

struct thread_data
{
  const char *name;
  pthread_barrier_t *barrier;
};

static void *
thread_func (void *varg)
{
  struct thread_data *arg = (struct thread_data *) varg;
  int res;

  res = pthread_setname_np (pthread_self (), arg->name);
  assert (res == 0);

  pthread_barrier_wait (arg->barrier);

  pthread_barrier_wait (arg->barrier);

  return NULL;
}

static void
all_threads_ready (void)
{
}

int
main (int argc, char **argv)
{
  pthread_t threads[NUM_THREADS];
  struct thread_data args[NUM_THREADS];
  pthread_barrier_t barrier;
  int i, res;
  const char *names[] = { ""carrot"", ""potato"", ""celery"" };

  alarm (20);

  /* Make sure that NAMES contains NUM_THREADS elements.  */
  assert (sizeof (names) / sizeof (names[0]) == NUM_THREADS);

  res = pthread_barrier_init (&barrier, NULL, NUM_THREADS + 1);
  assert (res == 0);;

  res = pthread_setname_np (pthread_self (), ""main"");
  assert (res == 0);

  for (i = 0; i < NUM_THREADS; i++)
    {
      struct thread_data *arg = &args[i];

      arg->name = names[i];
      arg->barrier = &barrier;

      res = pthread_create (&threads[i], NULL, thread_func, arg);
      assert (res == 0);
    }

  pthread_barrier_wait (&barrier);

  all_threads_ready ();

  pthread_barrier_wait (&barrier);

  for (i = 0; i < NUM_THREADS; i++)
    {
      res = pthread_join (threads[i], NULL);
      assert (res == 0);
    }

  return 0;
}
"
282-23114,begeekmyfriend/leetcode,0147_insertion_sort_list/insert_sort_list.c,51,4,36,1791873.13187865,175425.0,10.214467721248395,1276.0,1257.0,39850.0,13538.0,1630.0,639.0,1351.0,594.0,1500000000,0.0011945820879191,1082014363648.0,0.0144392190394755,0.0789315951150071,"#include <stdio.h>
#include <stdlib.h>

struct ListNode {
    int val;
    struct ListNode *next;
};

static struct ListNode *insertionSortList(struct ListNode *head)
{
    if (head == NULL) {
        return NULL;
    }

    if (head->next == NULL) {
        return head;
    }

    struct ListNode dummy;
    struct ListNode *p0, *p, *p1;
    dummy.next = head;

    for (p0 = head, p = head->next; p != NULL; p0 = p, p = p->next) {
        if (p->val < p0->val) {
            p0->next = p->next;
            for (p1 = &dummy; p1 != p0; p1 = p1->next) {
                if (p1->next->val >= p->val) {
                    p->next = p1->next;
                    p1->next = p;
                    break;
                }
            }
            p = p0;
        }
    }

    return dummy.next;
}

int main(int argc, char **argv)
{
    int i, count = argc - 1;
    struct ListNode *head = NULL, *p, *prev;
    for (i = 0; i < count; i++) {
        p = malloc(sizeof(*p));
        p->val = atoi(argv[i + 1]);
        p->next = NULL;
        if (head == NULL) {
            head = p;
        } else {
            prev->next = p;
        }
        prev = p;
    }

    for (p = insertionSortList(head); p != NULL; p = p->next) {
        printf(""%d "", p->val);
    }
    printf(""\n"");
    return 0;
}
"
025-15913,zhangrxiang/learn-c,linux/ctype/isspace.c,17,1,18,1326077.8505354999,170811.0,7.763416875962321,1147.0,1137.0,38920.0,12867.0,1588.0,586.0,1329.0,546.0,1500000000,0.000884051900357,1082014363648.0,0.0133715041771314,0.078185645046054,"//
// Created by zing on 5/29/2020.
//
#include <ctype.h>
#include <assert.h>
//checks for white-space characters.  In the ""C"" and ""POSIX""
//locales, these are: space, form-feed ('\f'), newline ('\n'),
//carriage return ('\r'), horizontal tab ('\t'), and vertical
//tab ('\v').
int main(){
    assert(isspace(' '));
    assert(isspace('\t'));
    assert(isspace('\n'));
    assert(isspace('\f'));
    assert(isspace('\r'));
    assert(isspace('\v'));
    assert(!isspace('\\'));
    return 0;
}"
048-10419,SanDisk-Open-Source/SSD_Dashboard,uefi/userspace/glibc/manual/examples/sigh1.c,39,7,31,4766561352.065764,565062920.0,8.435452377586552,1308.0,1293.0,158542596.0,77824660.0,1624.0,704.0,1341.0,655.0,1500000000,3.177707568043843,1082014363648.0,4.603027216862858e-06,1.8293566008990686e-05,"/* Signal Handlers that Return
   Copyright (C) 1991-2013 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2
   of the License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, if not, see <http://www.gnu.org/licenses/>.
*/

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>

/* This flag controls termination of the main loop. */
volatile sig_atomic_t keep_going = 1;

/* The signal handler just clears the flag and re-enables itself. */
void
catch_alarm (int sig)
{
  keep_going = 0;
  signal (sig, catch_alarm);
}

void
do_stuff (void)
{
  puts (""Doing stuff while waiting for alarm...."");
}

int
main (void)
{
  /* Establish a handler for SIGALRM signals. */
  signal (SIGALRM, catch_alarm);

  /* Set an alarm to go off in a little while. */
  alarm (2);

  /* Check the flag once in a while to see when to quit. */
  while (keep_going)
    do_stuff ();

  return EXIT_SUCCESS;
}
"
145-26413,saoyagi2/integer,prime/prime2.c,21,4,21,1333747713.1281047,5726043786.0,0.2329265655042617,1347.0,1326.0,912265213.0,929878181.0,1565511.0,100872810.0,1345.0,1563156.0,1500000000,0.8891651420854032,1082014363648.0,4.668144533814782e-07,0.0564575061522056,"#include <stdio.h>

#define ARRAY_SIZE   (100000000)
#define ARRAY_SIZE_SQRT (10000)

char    array[ARRAY_SIZE];


int main( void )
{
    int n, i;

    /*  配列を初期化する    */
    for( i = 0; i < ARRAY_SIZE; i++ )
        array[i] = 1;

    /*  配列をふるいにかける    */
    for( n = 2; n <= ARRAY_SIZE_SQRT; n++ ) {
        if( array[n] == 1 ) {
            for( i = n * n; i < ARRAY_SIZE; i += n )
                array[i] = 0;
        }
    }

    /*  ふるいで残った数は素数である    */
    for( n = 2; n < ARRAY_SIZE; n++ ) {
        if( array[n] == 1 )
            printf( ""%d\n"", n );
    }

    return( 0 );
}
"
086-9482,aababilov/linux-research,scala/scala_vs_c/PiCalculator.c,13,1,17,220968913.519755,1600175498.0,0.13809042400423,1432.0,1408.0,39741.0,13658.0,1631.0,637.0,1350.0,593.0,1500000000,0.14731260901317,1082014363648.0,1.7748053282590631e-06,0.0788591546658177,"#include <stdio.h>
#include <time.h>

int main() {
   clock_t clock_start;
   int nrOfElements = 1000 * 1000 * 100;
   int start = 0;
   double acc = 0;
   register int i;
   clock_start = clock();
   for (i = start; i < (nrOfElements); ++i)
        acc += 4.0 * (1 - (i % 2) * 2) / (2 * i + 1);
   printf(""%d ms\n"", (int)((clock() - clock_start) / (CLOCKS_PER_SEC / 1000)));
   printf(""%.8lf\n"", acc);
   return 0;
}
"
246-31233,ColinIanKing/stress-ng,test/test-sched-getaffinity.c,24,1,24,1516668.00957165,171322.0,14.459462299062585,1150.0,1140.0,39026.0,12893.0,1587.0,586.0,1330.0,545.0,1500000000,0.0010111120063811,1082014363648.0,0.0133666429296879,0.0779676033821915,"/*
 * Copyright (C) 2013-2021 Canonical, Ltd.
 * Copyright (C)      2022 Colin Ian King
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 */

#define _GNU_SOURCE

#include <sched.h>

int main(void)
{
	cpu_set_t mask;

	return sched_getaffinity(0, sizeof(mask), &mask);
}
"
178-12487,changlong/uber_gdb,gdb/testsuite/gdb.base/funcargs.c,563,3,230,1601206.487976,169214.0,9.462609476757242,1140.0,1130.0,38488.0,12709.0,1574.0,588.0,1322.0,549.0,1500000000,0.001067470991984,1082014363648.0,0.0134149656647795,0.0787741469226712,"/*  Test passing of arguments to functions.  Use various sorts of arguments,
    including basic types, pointers to those types, structures, lots of
    args, etc, in various combinations. */

/* AIX requires this to be the first thing in the file.  */
#ifdef __GNUC__
#  define alloca __builtin_alloca
#  define HAVE_STACK_ALLOCA 1
#else /* not __GNUC__ */
#  ifdef _AIX
     #pragma alloca
#    define HAVE_STACK_ALLOCA 1
#  else /* Not AIX */
#    ifdef sparc
#      include <alloca.h>
#      define HAVE_STACK_ALLOCA 1
#      ifdef __STDC__
         void *alloca ();
#      else
         char *alloca ();
#      endif /* __STDC__ */
#    endif /* sparc */
#  endif /* Not AIX */
#endif /* not __GNUC__ */

char c = 'a';
char *cp = &c;

unsigned char uc = 'b';
unsigned char *ucp = &uc;

short s = 1;
short *sp = &s;

unsigned short us = 6;
unsigned short *usp = &us;

int i = 2;
int *ip = &i;

unsigned int ui = 7;
unsigned int *uip = &ui;

long l = 3;
long *lp = &l;

unsigned long ul = 8;
unsigned long *ulp = &ul;

float f = 4.0;
float *fp = &f;

double d = 5.0;
double *dp = &d;

#ifdef TEST_COMPLEX
float _Complex fc = 1.0F + 2.0iF;
double _Complex dc = 3.0 + 4.0i;
long double _Complex ldc = 5.0L + 6.0iL;
#endif /* TEST_COMPLEX */

struct stag {
    int s1;
    int s2;
} st = { 101, 102 };
struct stag *stp = &st;

union utag {
    int u1;
    long u2;
} un;
union utag *unp = &un;

char carray[] = {'a', 'n', ' ', 'a', 'r', 'r', 'a', 'y', '\0'};


/* Test various permutations and interleaving of integral arguments */


#ifdef PROTOTYPES
void call0a (char c, short s, int i, long l)
#else
call0a (c, s, i, l)
char c; short s; int i; long l;
#endif
{
  c = 'a';
  s = 5;
  i = 6;
  l = 7;
}

#ifdef PROTOTYPES
void call0b (short s, int i, long l, char c)
#else
call0b (s, i, l, c)
short s; int i; long l; char c;
#endif
{
  s = 6; i = 7; l = 8; c = 'j';
}

#ifdef PROTOTYPES
void call0c (int i, long l, char c, short s)
#else
call0c (i, l, c, s)
int i; long l; char c; short s;
#endif
{
  i = 3; l = 4; c = 'k'; s = 5;
}

#ifdef PROTOTYPES
void call0d (long l, char c, short s, int i)
#else
call0d (l, c, s, i)
long l; char c; short s; int i;
#endif
{
  l = 7; c = 'z'; s = 8; i = 9;
}

#ifdef PROTOTYPES
void call0e (char c1, long l, char c2, int i, char c3, short s, char c4, char c5)
#else
call0e (c1, l, c2, i, c3, s, c4, c5)
char c1; long l; char c2; int i; char c3; short s; char c4; char c5;
#endif
{
  c1 = 'a'; l = 5; c2 = 'b'; i = 7; c3 = 'c'; s = 7; c4 = 'f'; c5 = 'g';
}


/* Test various permutations and interleaving of unsigned integral arguments */


#ifdef PROTOTYPES
void call1a (unsigned char uc, unsigned short us, unsigned int ui, unsigned long ul)
#else
call1a (uc, us, ui, ul)
unsigned char uc; unsigned short us; unsigned int ui; unsigned long ul;
#endif
{
  uc = 5; us = 6; ui = 7; ul = 8;
}

#ifdef PROTOTYPES
void call1b (unsigned short us, unsigned int ui, unsigned long ul, unsigned char uc)
#else
call1b (us, ui, ul, uc)
unsigned short us; unsigned int ui; unsigned long ul; unsigned char uc;
#endif
{
  uc = 5; us = 6; ui = 7; ul = 8;
}

#ifdef PROTOTYPES
void call1c (unsigned int ui, unsigned long ul, unsigned char uc, unsigned short us)
#else
call1c (ui, ul, uc, us)
unsigned int ui; unsigned long ul; unsigned char uc; unsigned short us;
#endif
{
  uc = 5; us = 6; ui = 7; ul = 8;
}

#ifdef PROTOTYPES
void call1d (unsigned long ul, unsigned char uc, unsigned short us, unsigned int ui)
#else
call1d (ul, uc, us, ui)
unsigned long ul; unsigned char uc; unsigned short us; unsigned int ui;
#endif
{
  uc = 5; us = 6; ui = 7; ul = 8;
}

#ifdef PROTOTYPES
void call1e (unsigned char uc1, unsigned long ul, unsigned char uc2, unsigned int ui, unsigned char uc3, unsigned short us, unsigned char uc4, unsigned char uc5)
#else
call1e (uc1, ul, uc2, ui, uc3, us, uc4, uc5)
unsigned char uc1; unsigned long ul; unsigned char uc2; unsigned int ui;
unsigned char uc3; unsigned short us; unsigned char uc4; unsigned char uc5;
#endif
{
  uc1 = 5; ul = 7; uc2 = 8; ui = 9; uc3 = 10; us = 11; uc4 = 12; uc5 = 55;
}

/* Test various permutations and interleaving of integral arguments with
   floating point arguments. */


#ifdef PROTOTYPES
void call2a (char c, float f1, short s, double d1, int i, float f2, long l, double d2)
#else
call2a (c, f1, s, d1, i, f2, l, d2)
char c; float f1; short s; double d1; int i; float f2; long l; double d2;
#endif
{
  c = 'a'; f1 = 0.0; s = 5; d1 = 0.0; i = 6; f2 = 0.1; l = 7; d2 = 0.2;
}

#ifdef PROTOTYPES
void call2b (float f1, short s, double d1, int i, float f2, long l, double d2, char c)
#else
call2b (f1, s, d1, i, f2, l, d2, c)
float f1; short s; double d1; int i; float f2; long l; double d2; char c;
#endif
{
  c = 'a'; f1 = 0.0; s = 5; d1 = 0.0; i = 6; f2 = 0.1; l = 7; d2 = 0.2;
}

#ifdef PROTOTYPES
void call2c (short s, double d1, int i, float f2, long l, double d2, char c, float f1)
#else
call2c (s, d1, i, f2, l, d2, c, f1)
short s; double d1; int i; float f2; long l; double d2; char c; float f1;
#endif
{
  c = 'a'; f1 = 0.0; s = 5; d1 = 0.0; i = 6; f2 = 0.1; l = 7; d2 = 0.2;
}

#ifdef PROTOTYPES
void call2d (double d1, int i, float f2, long l, double d2, char c, float f1, short s)
#else
call2d (d1, i, f2, l, d2, c, f1, s)
double d1; int i; float f2; long l; double d2; char c; float f1; short s;
#endif
{
  c = 'a'; f1 = 0.0; s = 5; d1 = 0.0; i = 6; f2 = 0.1; l = 7; d2 = 0.2;
}

#ifdef PROTOTYPES
void call2e (int i, float f2, long l, double d2, char c, float f1, short s, double d1)
#else
call2e (i, f2, l, d2, c, f1, s, d1)
int i; float f2; long l; double d2; char c; float f1; short s; double d1;
#endif
{
  c = 'a'; f1 = 0.0; s = 5; d1 = 0.0; i = 6; f2 = 0.1; l = 7; d2 = 0.2;
}

#ifdef PROTOTYPES
void call2f (float f2, long l, double d2, char c, float f1, short s, double d1, int i)
#else
call2f (f2, l, d2, c, f1, s, d1, i)
float f2; long l; double d2; char c; float f1; short s; double d1; int i;
#endif
{
  c = 'a'; f1 = 0.0; s = 5; d1 = 0.0; i = 6; f2 = 0.1; l = 7; d2 = 0.2;
}

#ifdef PROTOTYPES
void call2g (long l, double d2, char c, float f1, short s, double d1, int i, float f2)
#else
call2g (l, d2, c, f1, s, d1, i, f2)
long l; double d2; char c; float f1; short s; double d1; int i; float f2;
#endif
{
  c = 'a'; f1 = 0.0; s = 5; d1 = 0.0; i = 6; f2 = 0.1; l = 7; d2 = 0.2;
}

#ifdef PROTOTYPES
void call2h (double d2, char c, float f1, short s, double d1, int i, float f2, long l)
#else
call2h (d2, c, f1, s, d1, i, f2, l)
double d2; char c; float f1; short s; double d1; int i; float f2; long l;
#endif
{
  c = 'a'; f1 = 0.0; s = 5; d1 = 0.0; i = 6; f2 = 0.1; l = 7; d2 = 0.2;
}

#ifdef PROTOTYPES
void call2i (char c1, float f1, char c2, char c3, double d1, char c4, char c5, char c6, float f2, short s, char c7, double d2)
#else
call2i (c1, f1, c2, c3, d1, c4, c5, c6, f2, s, c7, d2)
char c1; float f1; char c2; char c3; double d1; char c4; char c5; char c6;
float f2; short s; char c7; double d2;
#endif
{
  c1 = 'a'; f1 = 0.0; c2 = 5; d1 = 0.0; c3 = 6; f2 = 0.1; c4 = 7; d2 = 0.2;
  c5 = 's'; c6 = 'f'; c7 = 'z'; s = 77;
}


/* Test pointers to various integral and floating types. */


#ifdef PROTOTYPES
void call3a (char *cp, short *sp, int *ip, long *lp)
#else
call3a (cp, sp, ip, lp)
char *cp; short *sp; int *ip; long *lp;
#endif
{
  cp = 0; sp = 0; ip = 0; lp = 0;
}

#ifdef PROTOTYPES
void call3b (unsigned char *ucp, unsigned short *usp, unsigned int *uip, unsigned long *ulp)
#else
call3b (ucp, usp, uip, ulp)
unsigned char *ucp; unsigned short *usp; unsigned int *uip;
unsigned long *ulp;
#endif
{
  ucp = 0; usp = 0; uip = 0; ulp = 0;
}

#ifdef PROTOTYPES
void call3c (float *fp, double *dp)
#else
call3c (fp, dp)
float *fp; double *dp;
#endif
{
  fp = 0; dp = 0;
}



#ifdef TEST_COMPLEX

/* Test various _Complex type args.  */

#ifdef PROTOTYPES
void callca (float _Complex f1, float _Complex f2, float _Complex f3)
#else
callca (f1, f2, f3)
float _Complex f1; float _Complex f2; float _Complex f3;
#endif
{

}

#ifdef PROTOTYPES
void callcb (double _Complex d1, double _Complex d2, double _Complex d3)
#else
callcb (d1, d2, d3)
double _Complex d1; double _Complex d2; double _Complex d3;
#endif
{

}

#ifdef PROTOTYPES
void callcc (long double _Complex ld1, long double _Complex ld2, long double _Complex ld3)
#else
callcc (ld1, ld2, ld3)
long double _Complex ld1; long double _Complex ld2; long double _Complex ld3;
#endif
{

}

#ifdef PROTOTYPES
void callcd (float _Complex fc1, double _Complex dc1, long double _Complex ldc1)
#else
callcd (fc1, dc1, ldc1)
float _Complex fc1; double _Complex dc1; long double _Complex ldc1;
#endif
{
}

#ifdef PROTOTYPES
void callce (double _Complex dc1, long double _Complex ldc1, float _Complex fc1)
#else
callce (dc1, ldc1, fc1)
double _Complex dc1; long double _Complex ldc1; float _Complex fc1;
#endif
{
}

#ifdef PROTOTYPES
void callcf (long double _Complex ldc1, float _Complex fc1, double _Complex dc1)
#else
callcf (ldc1, fc1, dc1)
long double _Complex ldc1; float _Complex fc1; double _Complex dc1;
#endif
{
}


/* Test passing _Complex type and integral.  */
#ifdef PROTOTYPES
void callc1a (char c, short s, int i, unsigned int ui, long l,
	      float _Complex fc1, double _Complex dc1,
	      long double _Complex ldc1)
#else
callc1a (c, s, i, ui, l, fc1, dc1, ldc1)
char c; short s; int i; unsigned int ui; long l; float _Complex fc1; double _Complex dc1; long double _Complex ldc1;
#endif
{}

#ifdef PROTOTYPES
void callc1b (long double _Complex ldc1, char c, short s, int i,
	      float _Complex fc1, unsigned int ui, long l,  double _Complex dc1)
#else
callc1b (ldc1, c, s, i, fc1, ui, l, dc1)
char c; short s; int i; unsigned int ui; long l; float _Complex fc1; double _Complex dc1; long double _Complex ldc1;
#endif
{}


#ifdef PROTOTYPES
void callc2a (char c, short s, int i, unsigned int ui, long l, float f,
	      double d, float _Complex fc1, double _Complex dc1,
	      long double _Complex ldc1)
#else
callc2a (c, s, i, ui, l, f, d, fc1, dc1, ldc1)
     char c; short s; int i; unsigned int ui; long l; float f; double d;
     float _Complex fc1; double _Complex dc1;
     long double _Complex ldc1;
#endif
{}

#ifdef PROTOTYPES
void callc2b (float _Complex fc1, char c, short s, int i, unsigned int ui,
	      long double _Complex ldc1, long l, float f, double d,
	      double _Complex dc1)
#else
callc2b (fc1, c, s, i, ui, ldc1, l, f, d, dc1)
     char c; short s; int i; unsigned int ui; long l; float f; double d;
     float _Complex fc1; double _Complex dc1;
     long double _Complex ldc1;
#endif
{}


#endif /* TEST_COMPLEX */

/* Test passing structures and unions by reference. */


#ifdef PROTOTYPES
void call4a (struct stag *stp)
#else
call4a (stp)
struct stag *stp;
#endif
{stp = 0;}

#ifdef PROTOTYPES
void call4b (union utag *unp)
#else
call4b (unp)
union utag *unp;
#endif
{
  unp = 0;
}


/* Test passing structures and unions by value. */


#ifdef PROTOTYPES
void call5a (struct stag st)
#else
call5a (st)
struct stag st;
#endif
{st.s1 = 5;}

#ifdef PROTOTYPES
void call5b (union utag un)
#else
call5b (un)
union utag un;
#endif
{un.u1 = 7;}


/* Test shuffling of args */


void call6k ()
{
}

#ifdef PROTOTYPES
void call6j (unsigned long ul)
#else
call6j (ul)
unsigned long ul;
#endif
{
  ul = ul;
    call6k ();
}

#ifdef PROTOTYPES
void call6i (unsigned int ui, unsigned long ul)
#else
call6i (ui, ul)
unsigned int ui; unsigned long ul;
#endif
{
  ui = ui;
    call6j (ul);
}

#ifdef PROTOTYPES
void call6h (unsigned short us, unsigned int ui, unsigned long ul)
#else
call6h (us, ui, ul)
unsigned short us; unsigned int ui; unsigned long ul;
#endif
{
  us = us;
    call6i (ui, ul);
}

#ifdef PROTOTYPES
void call6g (unsigned char uc, unsigned short us, unsigned int ui, unsigned long ul)
#else
call6g (uc, us, ui, ul)
unsigned char uc; unsigned short us; unsigned int ui; unsigned long ul;
#endif
{
  uc = uc;
    call6h (us, ui, ul);
}

#ifdef PROTOTYPES
void call6f (double d, unsigned char uc, unsigned short us, unsigned int ui, unsigned long ul)
#else
call6f (d, uc, us, ui, ul)
double d;
unsigned char uc; unsigned short us; unsigned int ui; unsigned long ul;
#endif
{
  d = d;
    call6g (uc, us, ui, ul);
}

#ifdef PROTOTYPES
void call6e (float f, double d, unsigned char uc, unsigned short us, unsigned int ui, unsigned long ul)
#else
call6e (f, d, uc, us, ui, ul)
float f; double d;
unsigned char uc; unsigned short us; unsigned int ui; unsigned long ul;
#endif
{
  f = f;
    call6f (d, uc, us, ui, ul);
}

#ifdef PROTOTYPES
void call6d (long l, float f, double d, unsigned char uc, unsigned short us, unsigned int ui, unsigned long ul)
#else
call6d (l, f, d, uc, us, ui, ul)
long l; float f; double d;
unsigned char uc; unsigned short us; unsigned int ui; unsigned long ul;
#endif
{
  l = l;
    call6e (f, d, uc, us, ui, ul);
}

#ifdef PROTOTYPES
void call6c (int i, long l, float f, double d, unsigned char uc, unsigned short us, unsigned int ui, unsigned long ul)
#else
call6c (i, l, f, d, uc, us, ui, ul)
int i; long l; float f; double d;
unsigned char uc; unsigned short us; unsigned int ui; unsigned long ul;
#endif
{
  i = i;
    call6d (l, f, d, uc, us, ui, ul);
}

#ifdef PROTOTYPES
void call6b (short s, int i, long l, float f, double d, unsigned char uc, unsigned short us, unsigned int ui, unsigned long ul)
#else
call6b (s, i, l, f, d, uc, us, ui, ul)
short s; int i; long l; float f; double d;
unsigned char uc; unsigned short us; unsigned int ui; unsigned long ul;
#endif
{
  s = s;
    call6c (i, l, f, d, uc, us, ui, ul);
}

#ifdef PROTOTYPES
void call6a (char c, short s, int i, long l, float f, double d, unsigned char uc, unsigned short us, unsigned int ui, unsigned long ul)
#else
call6a (c, s, i, l, f, d, uc, us, ui, ul)
char c; short s; int i; long l; float f; double d;
unsigned char uc; unsigned short us; unsigned int ui; unsigned long ul;
#endif
{
  c = c;
    call6b (s, i, l, f, d, uc, us, ui, ul);
}

/*  Test shuffling of args, round robin */


#ifdef PROTOTYPES
void call7k (char c, int i, short s, long l, float f, unsigned char uc, double d, unsigned short us, unsigned long ul, unsigned int ui)
#else
call7k (c, i, s, l, f, uc, d, us, ul, ui)
char c; int i; short s; long l; float f; unsigned char uc; double d; unsigned short us; unsigned long ul; unsigned int ui;
#endif
{
  c = 'a'; i = 7; s = 8; l = 7; f = 0.3; uc = 44; d = 0.44; us = 77;
  ul = 43; ui = 33;
}

#ifdef PROTOTYPES
void call7j (unsigned int ui, char c, int i, short s, long l, float f, unsigned char uc, double d, unsigned short us, unsigned long ul)
#else
call7j (ui, c, i, s, l, f, uc, d, us, ul)
unsigned int ui; char c; int i; short s; long l; float f; unsigned char uc; double d; unsigned short us; unsigned long ul;
#endif
{
    call7k (c, i, s, l, f, uc, d, us, ul, ui);
}

#ifdef PROTOTYPES
void call7i (unsigned long ul, unsigned int ui, char c, int i, short s, long l, float f, unsigned char uc, double d, unsigned short us)
#else
call7i (ul, ui, c, i, s, l, f, uc, d, us)
unsigned long ul; unsigned int ui; char c; int i; short s; long l; float f; unsigned char uc; double d; unsigned short us;
#endif
{
    call7j (ui, c, i, s, l, f, uc, d, us, ul);
}

#ifdef PROTOTYPES
void call7h (unsigned short us, unsigned long ul, unsigned int ui, char c, int i, short s, long l, float f, unsigned char uc, double d)
#else
call7h (us, ul, ui, c, i, s, l, f, uc, d)
unsigned short us; unsigned long ul; unsigned int ui; char c; int i; short s; long l; float f; unsigned char uc; double d;
#endif
{
    call7i (ul, ui, c, i, s, l, f, uc, d, us);
}

#ifdef PROTOTYPES
void call7g (double d, unsigned short us, unsigned long ul, unsigned int ui, char c, int i, short s, long l, float f, unsigned char uc)
#else
call7g (d, us, ul, ui, c, i, s, l, f, uc)
double d; unsigned short us; unsigned long ul; unsigned int ui; char c; int i; short s; long l; float f; unsigned char uc;
#endif
{
    call7h (us, ul, ui, c, i, s, l, f, uc, d);
}

#ifdef PROTOTYPES
void call7f (unsigned char uc, double d, unsigned short us, unsigned long ul, unsigned int ui, char c, int i, short s, long l, float f)
#else
call7f (uc, d, us, ul, ui, c, i, s, l, f)
unsigned char uc; double d; unsigned short us; unsigned long ul; unsigned int ui; char c; int i; short s; long l; float f;
#endif
{
    call7g (d, us, ul, ui, c, i, s, l, f, uc);
}

#ifdef PROTOTYPES
void call7e (float f, unsigned char uc, double d, unsigned short us, unsigned long ul, unsigned int ui, char c, int i, short s, long l)
#else
call7e (f, uc, d, us, ul, ui, c, i, s, l)
float f; unsigned char uc; double d; unsigned short us; unsigned long ul; unsigned int ui; char c; int i; short s; long l;
#endif
{
    call7f (uc, d, us, ul, ui, c, i, s, l, f);
}

#ifdef PROTOTYPES
void call7d (long l, float f, unsigned char uc, double d, unsigned short us, unsigned long ul, unsigned int ui, char c, int i, short s)
#else
call7d (l, f, uc, d, us, ul, ui, c, i, s)
long l; float f; unsigned char uc; double d; unsigned short us; unsigned long ul; unsigned int ui; char c; int i; short s;
#endif
{
    call7e (f, uc, d, us, ul, ui, c, i, s, l);
}

#ifdef PROTOTYPES
void call7c (short s, long l, float f, unsigned char uc, double d, unsigned short us, unsigned long ul, unsigned int ui, char c, int i)
#else
call7c (s, l, f, uc, d, us, ul, ui, c, i)
short s; long l; float f; unsigned char uc; double d; unsigned short us; unsigned long ul; unsigned int ui; char c; int i;
#endif
{
    call7d (l, f, uc, d, us, ul, ui, c, i, s);
}

#ifdef PROTOTYPES
void call7b (int i, short s, long l, float f, unsigned char uc, double d, unsigned short us, unsigned long ul, unsigned int ui, char c)
#else
call7b (i, s, l, f, uc, d, us, ul, ui, c)
int i; short s; long l; float f; unsigned char uc; double d; unsigned short us; unsigned long ul; unsigned int ui; char c;
#endif
{
    call7c (s, l, f, uc, d, us, ul, ui, c, i);
}

#ifdef PROTOTYPES
void call7a (char c, int i, short s, long l, float f, unsigned char uc, double d, unsigned short us, unsigned long ul, unsigned int ui)
#else
call7a (c, i, s, l, f, uc, d, us, ul, ui)
char c; int i; short s; long l; float f; unsigned char uc; double d; unsigned short us; unsigned long ul; unsigned int ui;
#endif
{
    call7b (i, s, l, f, uc, d, us, ul, ui, c);
}


/*  Test printing of structures passed as arguments to recursive functions. */


typedef struct s
{
  short s;
  int i;
  long l;
} SVAL;	

void hitbottom ()
{
}

#ifdef PROTOTYPES
void recurse (SVAL a, int depth)
#else
void recurse (a, depth)
SVAL a;
int depth;
#endif
{
  a.s = a.i = a.l = --depth;
  if (depth == 0)
    hitbottom ();
  else
    recurse (a, depth);
}

void test_struct_args ()
{
  SVAL s; s.s = 5; s.i = 5; s.l = 5;

  recurse (s, 5);
}

/* On various machines (pa, 29k, and rs/6000, at least), a function which
   calls alloca may do things differently with respect to frames.  So give
   it a try.  */

#ifdef PROTOTYPES
void localvars_after_alloca (char c, short s, int i, long l)
#else
void
localvars_after_alloca (c, s, i, l)
     char c;
     short s;
     int i;
     long l;
#endif
{
#ifdef HAVE_STACK_ALLOCA
  /* No need to use the alloca.c alloca-on-top-of-malloc; it doesn't
     test what we are looking for, so if we don't have an alloca which
     allocates on the stack, just don't bother to call alloca at all.  */

  char *z = alloca (s + 50);
#endif
  c = 'a';
  s = 5;
  i = 6;
  l = 7;
}

#ifdef PROTOTYPES
void call_after_alloca_subr (char c, short s, int i, long l, unsigned char uc, unsigned short us, unsigned int ui, unsigned long ul)
#else
void
call_after_alloca_subr (c, s, i, l, uc, us, ui, ul)
char c; int i; short s; long l; unsigned char uc; unsigned short us; unsigned long ul; unsigned int ui;
#endif
{
  c = 'a';
  i = 7; s = 8; l = 7; uc = 44; us = 77;
  ul = 43; ui = 33;
}

#ifdef PROTOTYPES
void call_after_alloca (char c, short s, int i, long l)
#else
void
call_after_alloca (c, s, i, l)
     char c;
     short s;
     int i;
     long l;
#endif
{
#ifdef HAVE_STACK_ALLOCA
  /* No need to use the alloca.c alloca-on-top-of-malloc; it doesn't
     test what we are looking for, so if we don't have an alloca which
     allocates on the stack, just don't bother to call alloca at all.  */

  char *z = alloca (s + 50);
#endif
  call_after_alloca_subr (c, s, i, l, 'b', 11, 12, (unsigned long)13);
}



/* The point behind this test is the PA will call this indirectly
   through dyncall.  Unlike the indirect calls to call0a, this test
   will require a trampoline between dyncall and this function on the
   call path, then another trampoline on between this function and main
   on the return path.  */
#ifdef PROTOTYPES
double call_with_trampolines (double d1)
#else
double
call_with_trampolines (d1)
double d1;
#endif
{
  return d1;
} /* End of call_with_trampolines, this comment is needed by funcargs.exp */

/* Dummy functions which the testsuite can use to run to, etc.  */

void
marker_indirect_call () {}

void
marker_call_with_trampolines () {}

int main ()
{
  void (*pointer_to_call0a) (char, short, int, long) = (void (*)(char, short, int, long))call0a;
  double (*pointer_to_call_with_trampolines) (double) = call_with_trampolines;

  /* Test calling with basic integer types */
  call0a (c, s, i, l);
  call0b (s, i, l, c);
  call0c (i, l, c, s);
  call0d (l, c, s, i);
  call0e (c, l, c, i, c, s, c, c);

  /* Test calling with unsigned integer types */
  call1a (uc, us, ui, ul);
  call1b (us, ui, ul, uc);
  call1c (ui, ul, uc, us);
  call1d (ul, uc, us, ui);
  call1e (uc, ul, uc, ui, uc, us, uc, uc);

  /* Test calling with integral types mixed with floating point types */
  call2a (c, f, s, d, i, f, l, d);
  call2b (f, s, d, i, f, l, d, c);
  call2c (s, d, i, f, l, d, c, f);
  call2d (d, i, f, l, d, c, f, s);
  call2e (i, f, l, d, c, f, s, d);
  call2f (f, l, d, c, f, s, d, i);
  call2g (l, d, c, f, s, d, i, f);
  call2h (d, c, f, s, d, i, f, l);
  call2i (c, f, c, c, d, c, c, c, f, s, c, d);

#ifdef TEST_COMPLEX
  /* Test calling with _Complex types.  */
  callca (fc, fc, fc);
  callcb (dc, dc, dc);
  callcc (ldc, ldc, ldc);
  callcd (fc, dc, ldc);
  callce (dc, ldc, fc);
  callcf (ldc, fc, dc);


  callc1a (c, s, i, ui, l, fc, dc, ldc);
  callc1b (ldc, c, s, i, fc, ui, l, dc);

  callc2a (c, s, i, ui, l, f, d, fc, dc, ldc);
  callc2b (fc, c, s, i, ui, ldc, l, f, d, dc);
#endif /* TEST_COMPLEX */

  /* Test dereferencing pointers to various integral and floating types */

  call3a (cp, sp, ip, lp);
  call3b (ucp, usp, uip, ulp);
  call3c (fp, dp);

  /* Test dereferencing pointers to structs and unions */

  call4a (stp);
  un.u1 = 1;
  call4b (unp);

  /* Test calling with structures and unions. */

  call5a (st);
  un.u1 = 2;
  call5b (un);

  /* Test shuffling of args */

  call6a (c, s, i, l, f, d, uc, us, ui, ul);
  call7a (c, i, s, l, f, uc, d, us, ul, ui);
  
  /* Test passing structures recursively. */

  test_struct_args ();

  localvars_after_alloca (c, s, i, l);

  call_after_alloca (c, s, i, l);

  /* This is for localvars_in_indirect_call.  */
  marker_indirect_call ();
  /* The comment on the following two lines is used by funcargs.exp,
     don't change it.  */
  (*pointer_to_call0a) (c, s, i, l);	/* First step into call0a.  */
  (*pointer_to_call0a) (c, s, i, l);	/* Second step into call0a.  */
  marker_call_with_trampolines ();
  (*pointer_to_call_with_trampolines) (d); /* Test multiple trampolines.  */
  return 0;
}
"
265-4481,dk00/old-stuff,csie/13parllel-programming/omp3-1.c,27,8,24,482625749.6606558,950293780.0,0.5078700494072476,1349.0,1326.0,50039313.0,50013402.0,3126699.0,3125673.0,1340.0,3125593.0,1500000000,0.3217504997737705,1082014363648.0,2.814918982212006e-06,0.0937436330438409,"#include<stdio.h>

#ifndef N
#define N 5000
#endif
#define M 1000000000

int a[N][N], b[N][N];

int main() {
  int i, j, sum;
  {
    for (i = 0; i < N; i++)
      for (j = 0; j < N; j++)
        a[i][j] = i + j;
    for (i = 0; i < N; i++)
      for (j = 0; j < N; j++)
        b[i][j] = i - j;
  }
  sum = 0;
  for (i = 0; i < N; i++)
    for (j = 0; j < N; j++) {
      sum += a[i][j];
      sum %= M;
    }
  printf(""%d\n"", sum);
  sum = 0;
  for (i = 0; i < N; i++)
    for (j = 0; j < N; j++) {
      sum += b[i][j];
      sum %= M;
    }
  printf(""%d\n"", sum);
  return 0;
}
"
297-10865,b3h3moth/L-LP,src/C/Algorithms_and_Data_Structures/data_structures/array/crivello_eratostene.c,24,4,27,2410189.36503675,1319202.0,1.827005265304328,1366.0,1345.0,240469.0,165750.0,2844.0,6260.0,1364.0,1193.0,1500000000,0.0016067929100245,1082014363648.0,0.0020550302379772,0.0287061905031522,"#include <stdio.h>
#include <stdlib.h>

#define MAX_NUM 10000


/* Il crivello di eratostene e' un metodo risalente al III secolo A.C. per il
calcolo di numeri numeri primi.

L'algoritmo: si accede a ciascun elemento dell'array mediante il proprio 
indice, dopodiche' si eliminano prima i multipli del 2, poi del 3 ed infine del
5, ottenendo in tal modo una tabella di numeri primi.

arr[i] = 1 (se e' numero primo)
arr[i] = 0 (se non e' numero primo) */

int main(void) {
	int i, j, arr[MAX_NUM];

	/* Si inizializzano tutti gli elementi dell'array ad 1 */
	for (i=2; i<MAX_NUM; i++)
		arr[i] = 1;

	/* I multipli di 2, 3 e 5 si pongono a 0 */
	for (i=2; i<MAX_NUM; i++)
		if (arr[i])
			for (j=i; i*j <MAX_NUM; j++)
				arr[i*j] = 0;

	/* Si stampano i numeri primi */
	for (i=2; i<MAX_NUM; i++)
		if (arr[i])
			printf(""%4d "", i);
	printf(""\n"");
	
	return(EXIT_SUCCESS);
}
"
093-21371,moehuster/czq,day10/pthread.c,47,3,33,15003470896.510406,283946.0,52839.16975762997,2366.0,1834.0,66707.0,27098.0,2259.0,939.0,1666.0,848.0,1500000000,10.002313931006938,1082014363648.0,0.0147915448712079,0.0608922765311017,"#include <stdio.h>
#include <unistd.h>
#include <pthread.h>

void *f1(void* p)
{
	int i;
	printf(""mytid=%u\n"",pthread_self());
	for (i=0; i<10; i++){
		write(1,""."",1);
		sleep(1);
	}
	return (void*)123;//c++ reinterpret_cast
}

void *f2(void* p)
{
	int i;
	printf(""mytid=%u\n"",pthread_self());
	for (i=0; i<5; i++){
		write(1,""*"",1);
		sleep(1);
	}
	pthread_exit(""Hello"");
	puts(""you cannot see me"");
}

void* f3(void* p)
{
	int i;
	printf(""mytid=%u\n"",pthread_self());
	for (i=0;;i++){
		write(1,""$"",1);
		sleep(1);
	}
	return (void*)456;
}

int main()
{
	pthread_t ids[3];
	pthread_create(ids+0,NULL,f1,NULL);
	pthread_create(ids+1,NULL,f2,NULL);
	pthread_create(ids+2,NULL,f3,NULL);
	sleep(3);
	pthread_cancel(ids[2]);
	void* ret;
	pthread_join(ids[0],&ret);
	printf(""线程%u返回%d\n"",ids[0],(int)ret);
	pthread_join(ids[1],&ret);
	printf(""线程%u返回%s\n"",ids[1],(char*)ret);
	pthread_join(ids[2],&ret);
	printf(""线程%u返回%p\n"",ids[2],ret);
}
"
224-20776,freecores/logicprobe,tst/sim-c/lfsr128.c,42,4,35,2664302.82499635,6307654.0,0.4223919067215798,1384.0,1360.0,1385955.0,939515.0,1638.0,699.0,1356.0,656.0,1500000000,0.0017762018833309,1082014363648.0,0.0004350270322373,0.0018701595806439,"/*
 * lfsr128.c -- a linear feedback shift register with 128 bits
 *              (actually constructed from 4 instances of a 32-bit lfsr)
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


int main(void) {
  unsigned int startState[4] = {
    0xC70337DB,
    0x7F4D514F,
    0x75377599,
    0x7D5937A3
  };
  /* taps at 32 31 29 1 */
  unsigned int taps = 0xD0000001;
  unsigned int lfsr[4];
  int i, n;

  for (i = 0; i < 4; i++) {
    lfsr[i] = startState[i];
  }
  for (n = 0; n < 530; n++) {
    /*
     * The trigger condition in the actual hardware test will be set
     * to lfsr[0]==0x7119C0CD, which is reached at n==10. Therefore
     * we print out n-10 instead of n to get identical index numbers.
     */
    printf(""%03d:  "", n - 10);
    for (i = 0; i < 4; i++) {
      printf(""%02X  "", (lfsr[i] >> 24) & 0xFF);
      printf(""%02X  "", (lfsr[i] >> 16) & 0xFF);
      printf(""%02X  "", (lfsr[i] >>  8) & 0xFF);
      printf(""%02X  "", (lfsr[i] >>  0) & 0xFF);
    }
    printf(""\n"");
    for (i = 0; i < 4; i++) {
      if ((lfsr[i] & 1) == 0) {
        lfsr[i] = lfsr[i] >> 1;
      } else {
        lfsr[i] = (lfsr[i] >> 1) ^ taps;
      }
    }
  }
  return 0;
}
"
155-23909,EliteTK/c-stuff,sleep.c,18,3,18,15619588132.482025,173387.0,90085.11671578608,1301.0,1283.0,39323.0,13361.0,1612.0,635.0,1338.0,594.0,1500000000,10.413058754988016,1082014363648.0,0.0149030780854389,0.0793219952926884,"/*
 * Copyright (C) 2014  Tomasz Kramkowski <tk@the-tk.com>
 *
 * This program is free software. It is licensed under version 3 of the
 * GNU General Public License.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see [http://www.gnu.org/licenses/].
 */

#include<stdio.h>
#include<stdlib.h>

int main(void) {
    printf(""This is before the sleep.\n"");
    sleep(10);
    printf(""This is after the sleep and before the for loop.\n"");
    long i;
    for(i = 0; i < 999999999999999; i++)
        ;
    printf(""This is after the for loop.\n"");
}
"
044-24526,FeiLi0211/432053414D504C4553,0X0073.c,70,6,35,1658343.12792855,184454.0,8.99055048955295,1353.0,1328.0,42476.0,15170.0,1655.0,641.0,1356.0,600.0,1500000000,0.0011055620852857,1082014363648.0,0.0145347891615253,0.0737605384588696,"/* 字符串操作 */
#include <stdio.h>
#include <ctype.h>

void put_stringn(const char s[], int n);
void put_stringr(const char s[]);
int str_length(const char s[]);
void rev_string(char s[]);
void del_digit(char s[]);

int main(void)
{
  char s1[] = ""djfaks32132fjdksa1321fei,sjd"";


  printf(""%s重复输出5次之后:"", s1);
  put_stringn(s1, 5);
  putchar('\n');

  printf(""%s倒序输出:"", s1);
  put_stringr(s1);
  putchar('\n');

  printf(""%s反转之后:"", s1);
  rev_string(s1);
  printf(""%s"", s1);
  putchar('\n');

  printf(""%s删除数字之后:"", s1);
  del_digit(s1);
  printf(""%s"", s1);
  putchar('\n');

  return 0;
}

void put_stringn(const char s[], int n)
{
  for (int i = 0; i < n; i++) {
    /* printf(""%s"", s); */
    int j = 0;
    while (s[j]) {
      putchar(s[j++]);
    }
  }
}

void put_stringr(const char s[])
{
  int len = str_length(s);

  for (int i = len - 1; i >= 0; i--) {
    putchar(s[i]);
  }
}

int str_length(const char s[])
{
  int len = 0;

  while (s[len]) {
    len++;
  }
  return len;
}

void rev_string(char s[])
{
  int len = str_length(s);

  for (int i = 0; i < len / 2; i++) {
    int t = s[i];
    s[i] = s[len - i - 1];
    s[len - i - 1] = t;
  }
}

void del_digit(char s[])
{
  int i = 0, j = 0;

  while (s[i]) {
    if (!isdigit(s[i])) {
      s[j++] = s[i];
    }
    i++;
  }
  s[j] = '\0';
}
"
236-27719,luisbg/hhgtg,algorithms/other/buy_sell_stock.c,65,6,48,1988642.849028,188336.0,10.55579390026336,1346.0,1328.0,42548.0,15574.0,1628.0,642.0,1346.0,598.0,1500000000,0.001325761899352,1082014363648.0,0.0141980290544558,0.0725026668043081,"/* Given an array for which the ith element is the price of a given stock on
 * day i. Design an algorithm to find the maximum profit if you wereo only
 * permitted to complete at most one transaction (buy once and sell once).
 */

#include <stdio.h>

#define INT_MAX 2147483647

int
max_profit_one_transaction (int *prices, int pricesSize)
{
  int min_price_seen = prices[0];
  int max_profit = 0;

  for (int p = 1; p < pricesSize; p++) {
    if (prices[p] < min_price_seen)
      min_price_seen = prices[p];
    else if (prices[p] - min_price_seen > max_profit)
      max_profit = prices[p] - min_price_seen;
  }

  return max_profit;
}

int
max_profit_multiple_transactions (int *prices, int pricesSize)
{
  int sum = 0;
  int bought_at = prices[0];
  for (int p = 0; p < (pricesSize - 1); p++) {
    if (prices[p] < bought_at)  // if price lower than what we bought, we should buy here
      bought_at = prices[p];
    else {                      // meanwhile price goes up, keep and do nothing
      if (prices[p] > prices[p + 1]) {  // if price going down next, time to sell
        sum += prices[p] - bought_at;
        bought_at = prices[p + 1];      // buy at next price (which is lower than current)
      }
    }
  }

  // check if it there is a gain selling in last price
  if (prices[pricesSize - 1] > bought_at) {
    sum += prices[pricesSize - 1] - bought_at;
  }

  return sum;
}

int
main ()
{
  int stock_a[6] = { 7, 1, 5, 3, 6, 4 };
  int stock_b[5] = { 7, 6, 4, 3, 1 };
  int stock_c[7] = { 1, 3, 4, 6, 7, 9 };

  printf (""Max profit of the following stock day prices windows:\n["");
  for (int i = 0; i < 6; i++)
    printf (""%d, "", stock_a[i]);
  printf (""]\n   one transaction %d\n"", max_profit_one_transaction (stock_a,
          6));
  printf (""   multiple transactions %d\n["",
      max_profit_multiple_transactions (stock_a, 6));

  for (int i = 0; i < 5; i++)
    printf (""%d, "", stock_b[i]);
  printf (""]\n   one transaction %d\n"", max_profit_one_transaction (stock_b,
          5));
  printf (""   multiple transactions %d\n["",
      max_profit_multiple_transactions (stock_b, 6));

  for (int i = 0; i < 6; i++)
    printf (""%d, "", stock_c[i]);
  printf (""]\n   one transaction %d\n"", max_profit_one_transaction (stock_c,
          7));
  printf (""   multiple transactions %d\n"",
      max_profit_multiple_transactions (stock_c, 6));

  return 0;
}
"
377-30730,dvtate/single-files,goldbach.c,26,4,30,477425766.0610601,5692129577.0,0.0838747185111734,1359.0,1337.0,8054329.0,5039185.0,1624.0,699.0,1343.0,656.0,1500000000,0.3182838440407067,1082014363648.0,4.736364419555096e-07,0.0003300870950304,"#include <stdio.h>
#include <inttypes.h>


uint8_t isPrime(int num) 
{

	if(num <= 1)
		return 0;

	for (int i = 2; i <= num / 2; i++)
		if (num % i == 0)
			return 0;

	return 1;

}

// a brute force approach to goldbach's conjecture
void conjecture(unsigned start, unsigned stop)
{

	// only even numbers
	for (unsigned i = start; i <= stop; i += 2)

		// try every reasonable combination of numbers
		for (unsigned n1 = 2; n1 < i / 2 + 1; n1++) // limit first number to prevent duplicates
			for (unsigned n2 = 2; n2 < i - 1; n2++)

				// if matches desired conditions, print the solution
				// note: the order of tests, best performance -> worst performance
				if (n1 + n2 == i && isPrime(n2) && isPrime(n1))
					printf(""%3i = %3i + %3i\n"", i, n1, n2);

}


int main()
{
	conjecture(2, 2000);
}
"
108-30868,totalspectrum/binutils-propeller,gdb/testsuite/gdb.threads/manythreads.c,48,5,35,10268991028.424353,356571551.0,28.799243796092977,1387.0,1352.0,102446819.0,65476589.0,4174922.0,5103383.0,1621.0,6619.0,1500000000,6.845994018949568,1082014363648.0,7.68148774718149e-06,0.0553022661379049,"/* Manythreads test program.
   Copyright 2004-2017 Free Software Foundation, Inc.

   Written by Jeff Johnston <jjohnstn@redhat.com> 
   Contributed by Red Hat

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <pthread.h>
#ifdef DEBUG
#include <stdio.h>
#endif
#include <limits.h>

void *
thread_function (void *arg)
{
  int x = * (int *) arg;

#ifdef DEBUG
  printf (""Thread <%d> executing\n"", x);
#endif /* DEBUG */

  return NULL;
}

int 
main (int argc, char **argv)
{
  pthread_attr_t attr;
  pthread_t threads[256];
  int args[256];
  int i, j;

  pthread_attr_init (&attr);

#ifdef PTHREAD_STACK_MIN
  pthread_attr_setstacksize (&attr, 2*PTHREAD_STACK_MIN);
#endif

  /* Create a ton of quick-executing threads, then wait for them to
     complete.  */
  for (i = 0; i < 1000; ++i) 
    {
      for (j = 0; j < 256; ++j)
	{
	  args[j] = i * 1000 + j;
	  pthread_create (&threads[j], &attr, thread_function, &args[j]);
	}

      for (j = 0; j < 256; ++j)
	{
	  pthread_join (threads[j], NULL);
	}
    }

  pthread_attr_destroy (&attr);

  return 0;
}
"
064-28142,alpine9000/BitOS,tests/gcc.c-torture/20021219-1.c,14,1,24,1538402.9829874502,170414.0,9.027439060171112,1143.0,1135.0,38717.0,12791.0,1581.0,590.0,1325.0,547.0,1500000000,0.0010256019886583,1082014363648.0,0.0133674463365685,0.0784926613341616,"/* { dg-do run } */
/* PR optimization/8988 */
/* Contributed by Kevin Easton */

void foo(char *p1, char **p2)
{}
 
int main(void)
{
  char str[] = ""foo { xx }"";
  char *ptr = str + 5;

  foo(ptr, &ptr);

  while (*ptr && (*ptr == 13 || *ptr == 32))
    ptr++;

  return 0;
}
"
281-16822,Gurgel100/gcc,gcc/testsuite/gcc.dg/graphite/pr69067.c,25,3,28,1692963.1819948498,169107.0,10.0111940960457,1144.0,1134.0,38464.0,12700.0,1568.0,585.0,1317.0,546.0,1500000000,0.0011286421213299,1082014363648.0,0.0134707611157432,0.0784926901727777,"/* { dg-do link } */
/* { dg-options "" -O1 -floop-nest-optimize"" } */
/* { dg-additional-options ""-flto"" { target lto } } */

int a1, c1, cr, kt;
int aa[2];

int
ce (void)
{
  while (a1 < 1)
    {
      int g8;
      for (g8 = 0; g8 < 3; ++g8)
	if (c1 != 0)
	  cr = aa[a1 * 2] = kt;
      for (c1 = 0; c1 < 2; ++c1)
	aa[c1] = cr;
      ++a1;
    }
  return 0;
}

int
main (void)
{
  return ce ();
}
"
322-27396,cartman300/picoc,tests/csmith/rand110.c,1236,83,781,2447524.4572386,864095.0,2.8324709667339816,1407.0,1385.0,162077.0,98811.0,1631.0,714.0,1348.0,672.0,1500000000,0.0016316829714924,1082014363648.0,0.0032311262071878,0.0167313176535524,"#include <stdio.h>
int print_hash_value = 1;
static void platform_main_begin(void)
{
}
static unsigned crc32_tab[256];
static unsigned crc32_context = 0xFFFFFFFFUL;
static void
crc32_gentab (void)
{
 unsigned crc;
 unsigned poly = 0xEDB88320UL;
 int i, j;
 for (i = 0; i < 256; i++) {
  crc = i;
  for (j = 8; j > 0; j--) {
   if (crc & 1) {
    crc = (crc >> 1) ^ poly;
   } else {
    crc >>= 1;
   }
  }
  crc32_tab[i] = crc;
 }
}
static void
crc32_byte (unsigned char b) {
 crc32_context =
  ((crc32_context >> 8) & 0x00FFFFFF) ^
  crc32_tab[(crc32_context ^ b) & 0xFF];
}
extern int strcmp ( char *, char *);
static void
crc32_8bytes (unsigned val)
{
 crc32_byte ((val>>0) & 0xff);
 crc32_byte ((val>>8) & 0xff);
 crc32_byte ((val>>16) & 0xff);
 crc32_byte ((val>>24) & 0xff);
}
static void
transparent_crc (unsigned val, char* vname, int flag)
{
 crc32_8bytes(val);
 if (flag) {
    printf(""...checksum after hashing %s : %X\n"", vname, crc32_context ^ 0xFFFFFFFFU);
 }
}
static void
platform_main_end (int x, int flag)
{
  if (!flag) printf (""checksum = %x\n"", x);
}
static long __undefined;
void csmith_compute_hash(void);
void step_hash(int stmt_id);
static int g_2 = 0x24A8C6A5L;
static int g_47 = 0xD53D2AE4L;
static unsigned short g_60 = 0x1B9BL;
static signed char g_118 = 0L;
static signed char g_143 = (-4L);
static int *g_149 = &g_2;
static int *g_153 = &g_2;
static signed char g_160 = 1L;
static int g_163 = 0x1E14FE22L;
static int g_168 = 1L;
static short g_169[9] = {0x8E0DL, 0x1F6BL, 0x8E0DL, 0x1F6BL, 0x8E0DL, 0x1F6BL, 0x8E0DL, 0x1F6BL, 0x8E0DL};
static int g_170 = 0xDB654FA8L;
static short g_171 = 3L;
static short g_180 = 0x4318L;
static short g_181[3] = {0x626EL, 0x626EL, 0x626EL};
static short g_182 = (-2L);
static signed char g_183 = (-1L);
static unsigned g_184 = 1UL;
static unsigned g_206[1][6] = {{4294967295UL, 4294967295UL, 4294967295UL, 4294967295UL, 4294967295UL, 4294967295UL}};
static int **g_241 = &g_149;
static int ***g_240[6] = {&g_241, &g_241, &g_241, &g_241, &g_241, &g_241};
static unsigned char g_264[5][6] = {{0xE4L, 0UL, 0xE4L, 0UL, 0xE4L, 0UL}, {0xE4L, 0UL, 0xE4L, 0UL, 0xE4L, 0UL}, {0xE4L, 0UL, 0xE4L, 0UL, 0xE4L, 0UL}, {0xE4L, 0UL, 0xE4L, 0UL, 0xE4L, 0UL}, {0xE4L, 0UL, 0xE4L, 0UL, 0xE4L, 0UL}};
static unsigned short g_277 = 0xA542L;
static int **g_364[7] = {&g_149, &g_149, &g_149, &g_149, &g_149, &g_149, &g_149};
static short g_481 = 1L;
static short g_483 = 8L;
static int g_568 = (-1L);
static unsigned g_594 = 4294967295UL;
static short g_609[2][6] = {{0L, 0x7F01L, (-2L), (-2L), 0x7F01L, 0L}, {0L, 0x7F01L, (-2L), (-2L), 0x7F01L, 0L}};
static short g_622 = 0x51D2L;
static int *g_696 = (void*)0;
static unsigned g_789 = 4294967295UL;
static int *g_862 = (void*)0;
static unsigned g_877 = 5UL;
static short g_908 = 0x9487L;
static int g_1187 = 0xB5F68AEFL;
static unsigned short g_1219[3] = {65526UL, 65526UL, 65526UL};
static unsigned g_1510 = 0x795E7EECL;
static unsigned char g_1514 = 0x34L;
static short func_1(void);
static int func_5(unsigned char p_6, unsigned char p_7, unsigned p_8, signed char p_9, short p_10);
static int func_19(unsigned p_20, int p_21, unsigned char p_22, unsigned char p_23, signed char p_24);
static unsigned short func_27(unsigned short p_28, unsigned p_29, unsigned p_30);
static unsigned short func_36(unsigned p_37, unsigned p_38, unsigned char p_39, signed char p_40, signed char p_41);
static int * func_65(unsigned p_66, int * p_67, unsigned p_68, int p_69);
static signed char func_80(int * p_81, unsigned char p_82, short p_83, unsigned p_84, int p_85);
static int func_121(unsigned char p_122, short p_123);
static int * func_124(unsigned p_125, int * p_126);
static int func_127(int p_128, unsigned p_129, int * p_130, int * p_131, int * p_132);
static short func_1(void)
{
    unsigned short l_35[2][1];
    unsigned l_1425[7] = {1UL, 1UL, 0UL, 1UL, 1UL, 0UL, 1UL};
    int l_1458[2][2];
    int **l_1463 = (void*)0;
    int l_1515 = 0x3003920BL;
    unsigned l_1517 = 4294967295UL;
    int i, j;
    for (i = 0; i < 2; i++)
    {
        for (j = 0; j < 1; j++)
            l_35[i][j] = 0xF8B4L;
    }
    for (i = 0; i < 2; i++)
    {
        for (j = 0; j < 2; j++)
            l_1458[i][j] = 0xB16A6C64L;
    }
    step_hash(809);
    for (g_2 = 0; (g_2 == 7); g_2 += 8)
    {
        unsigned l_13 = 0x3EE32743L;
        int *l_1449 = &g_163;
        int **l_1462 = (void*)0;
        int l_1466[10][3] = {{0xC02E53E6L, (-2L), 0x7C201188L}, {0xC02E53E6L, (-2L), 0x7C201188L}, {0xC02E53E6L, (-2L), 0x7C201188L}, {0xC02E53E6L, (-2L), 0x7C201188L}, {0xC02E53E6L, (-2L), 0x7C201188L}, {0xC02E53E6L, (-2L), 0x7C201188L}, {0xC02E53E6L, (-2L), 0x7C201188L}, {0xC02E53E6L, (-2L), 0x7C201188L}, {0xC02E53E6L, (-2L), 0x7C201188L}, {0xC02E53E6L, (-2L), 0x7C201188L}};
        int *l_1513 = &g_168;
        short l_1516 = (-9L);
        int i, j;
    }
    step_hash(810);
    l_1517++;
    step_hash(811);
    return g_481;
}
static int func_5(unsigned char p_6, unsigned char p_7, unsigned p_8, signed char p_9, short p_10)
{
    int l_1422 = 0xCD897E88L;
    step_hash(744);
    l_1422 = (l_1422 && (func_36((g_609[0][2] ^ 1L), g_1219[2], g_264[1][0], g_169[8], g_181[1]) > p_9));
    step_hash(745);
    return p_7;
}
static int func_19(unsigned p_20, int p_21, unsigned char p_22, unsigned char p_23, signed char p_24)
{
    unsigned short l_893 = 1UL;
    int *l_898 = &g_2;
    int l_909 = 0x5BA3F23DL;
    short l_911 = 0xA06BL;
    int l_912[2][1];
    signed char l_913 = 0xB6L;
    int l_946 = (-1L);
    int l_953[8] = {1L, 0L, 1L, 0L, 1L, 0L, 1L, 0L};
    int *l_1009 = &l_953[5];
    signed char l_1014 = 0x00L;
    int ***l_1054 = &g_241;
    int *l_1066 = &l_912[1][0];
    unsigned short l_1077 = 1UL;
    int *l_1133 = &l_953[5];
    signed char l_1140 = 0x1DL;
    short l_1148 = 0x0BA7L;
    int l_1149 = 0L;
    int *l_1174[2][3] = {{&g_47, &g_47, (void*)0}, {&g_47, &g_47, (void*)0}};
    short l_1254 = 0x1287L;
    short l_1321 = 1L;
    int *l_1417[5] = {&l_912[0][0], &l_912[1][0], &l_912[0][0], &l_912[1][0], &l_912[0][0]};
    int i, j;
    for (i = 0; i < 2; i++)
    {
        for (j = 0; j < 1; j++)
            l_912[i][j] = 0xC1DF05E8L;
    }
    step_hash(699);
    if ((*l_898))
    {
        unsigned l_899 = 0xE477032BL;
        int l_900 = 0x41CE44D2L;
        step_hash(457);
        l_900 = l_899;
        step_hash(458);
        l_900 = p_21;
        step_hash(459);
        return p_22;
    }
    else
    {
        int *l_905[10][4] = {{(void*)0, &g_168, &g_47, &g_168}, {(void*)0, &g_168, &g_47, &g_168}, {(void*)0, &g_168, &g_47, &g_168}, {(void*)0, &g_168, &g_47, &g_168}, {(void*)0, &g_168, &g_47, &g_168}, {(void*)0, &g_168, &g_47, &g_168}, {(void*)0, &g_168, &g_47, &g_168}, {(void*)0, &g_168, &g_47, &g_168}, {(void*)0, &g_168, &g_47, &g_168}, {(void*)0, &g_168, &g_47, &g_168}};
        int ***l_921 = &g_364[6];
        unsigned l_944 = 4294967295UL;
        unsigned char l_987[2][9] = {{1UL, 1UL, 0x70L, 246UL, 0xF6L, 246UL, 0x70L, 1UL, 1UL}, {1UL, 1UL, 0x70L, 246UL, 0xF6L, 246UL, 0x70L, 1UL, 1UL}};
        unsigned l_991 = 4294967295UL;
        int *l_992[3][3] = {{&g_168, &g_168, &l_953[3]}, {&g_168, &g_168, &l_953[3]}, {&g_168, &g_168, &l_953[3]}};
        int l_997 = (-1L);
        signed char l_1065 = 0x06L;
        int l_1073 = 1L;
        unsigned short l_1093 = 0x900EL;
        int l_1121 = 0L;
        int *l_1171 = &l_1121;
        int l_1244 = 0x098D35D0L;
        short l_1277 = (-10L);
        int *l_1322 = (void*)0;
        int *l_1336 = &l_1149;
        int i, j;
        step_hash(523);
        if ((((unsigned short)((unsigned short)0xA1A0L >> (unsigned short)13) + (unsigned short)(p_21 == func_80(l_905[9][1], g_143, func_27(g_182, p_21, p_21), p_23, g_789))) == 0xB1A7L))
        {
            short l_906[8] = {0x680DL, 0x5615L, 0x680DL, 0x5615L, 0x680DL, 0x5615L, 0x680DL, 0x5615L};
            int l_907 = 0x1E2BE269L;
            int l_910 = 0x51D8E82DL;
            int l_914[6][2] = {{(-1L), (-1L)}, {(-1L), (-1L)}, {(-1L), (-1L)}, {(-1L), (-1L)}, {(-1L), (-1L)}, {(-1L), (-1L)}};
            short l_915[3];
            unsigned l_916 = 7UL;
            int **l_926 = &l_898;
            short l_929 = (-1L);
            int i, j;
            for (i = 0; i < 3; i++)
                l_915[i] = 1L;
            step_hash(462);
            l_916--;
            step_hash(468);
            for (l_916 = 0; (l_916 < 35); ++l_916)
            {
                signed char l_930 = 0L;
                int l_931 = 0x21B3892EL;
                step_hash(466);
                p_21 = func_27((((void*)0 != l_921) & (p_24 & (!((signed char)0xF7L / (signed char)((unsigned char)(0xEFL || ((void*)0 == l_926)) % (unsigned char)((unsigned char)251UL + (unsigned char)((void*)0 != &l_898))))))), l_929, l_930);
                step_hash(467);
                l_931 = (**l_926);
            }
            step_hash(469);
            p_21 = p_22;
        }
        else
        {
            unsigned l_940 = 4294967294UL;
            int l_949 = 0x2BCA82F7L;
            int l_951 = 0x1130121FL;
            int l_952 = 0L;
            int l_959 = (-1L);
            int l_962 = 0x2CC8EA25L;
            signed char l_973 = 0L;
            int l_974 = 0L;
            int *l_986 = &l_953[7];
            int *l_1006[5][4] = {{&l_953[7], (void*)0, &l_997, &l_997}, {&l_953[7], (void*)0, &l_997, &l_997}, {&l_953[7], (void*)0, &l_997, &l_997}, {&l_953[7], (void*)0, &l_997, &l_997}, {&l_953[7], (void*)0, &l_997, &l_997}};
            unsigned char l_1067 = 0UL;
            int i, j;
            step_hash(499);
            for (p_24 = 0; (p_24 >= 0); p_24 -= 1)
            {
                short l_943 = 0L;
                int *l_945 = &g_47;
                int l_950 = 0xF2A1F318L;
                int l_954 = (-1L);
                int l_956 = 0xAA53A08EL;
                int l_958 = 4L;
                int l_960 = (-4L);
                int l_963 = (-4L);
                int l_964 = 0x09A47A30L;
                int l_965 = (-1L);
                int l_967 = 0x6EA205E6L;
                int l_970 = (-5L);
                int l_971 = 2L;
                int l_972 = (-1L);
                step_hash(474);
                (*g_241) = &p_21;
                step_hash(475);
                p_21 = (p_24 > (func_80(func_65((((unsigned short)(((**g_241) < p_21) ^ ((signed char)(((unsigned short)((unsigned short)l_940 - (unsigned short)(1UL < p_24)) * (unsigned short)func_36(((*g_153) <= 1L), ((int)((((~((0x775EBC43L > l_943) <= l_944)) || g_163) ^ 0x9965L) >= p_22) / (int)p_21), g_594, g_264[1][5], g_206[0][5])) ^ p_23) << (signed char)p_24)) - (unsigned short)0x95E4L) > (-9L)), l_945, p_22, l_940), l_946, g_143, g_171, p_21) == 0xE8L));
                step_hash(498);
                for (l_893 = 0; (l_893 <= 0); l_893 += 1)
                {
                    short l_947[10][2] = {{0x8813L, (-6L)}, {0x8813L, (-6L)}, {0x8813L, (-6L)}, {0x8813L, (-6L)}, {0x8813L, (-6L)}, {0x8813L, (-6L)}, {0x8813L, (-6L)}, {0x8813L, (-6L)}, {0x8813L, (-6L)}, {0x8813L, (-6L)}};
                    int l_948[5][6];
                    unsigned char l_975 = 1UL;
                    unsigned short l_978 = 0xEF91L;
                    int ***l_983 = &g_364[6];
                    int l_1000 = 0xD4449F1DL;
                    int i, j;
                    for (i = 0; i < 5; i++)
                    {
                        for (j = 0; j < 6; j++)
                            l_948[i][j] = 1L;
                    }
                    step_hash(486);
                    for (g_483 = 0; (g_483 <= 0); g_483 += 1)
                    {
                        int l_955 = 0L;
                        int l_957 = 0xC6F9D72DL;
                        int l_961 = 0x39950F4EL;
                        int l_966 = 0x3158F380L;
                        int l_968 = 0x14F9D0BFL;
                        int l_969[7];
                        int i, j;
                        for (i = 0; i < 7; i++)
                            l_969[i] = 0x0B9A8A53L;
                        step_hash(482);
                        l_975++;
                        step_hash(483);
                        (*l_945) ^= l_912[(g_483 + 1)][p_24];
                        step_hash(484);
                        (**l_921) = &p_21;
                        step_hash(485);
                        ++l_978;
                    }
                }
            }
            step_hash(500);
            (*l_1009) = ((((unsigned)((0L || func_80(l_1009, g_206[0][5], func_36(((unsigned short)((((signed char)func_27(((void*)0 == l_921), (*l_986), g_877) / (signed char)(-4L)) > p_24) != (*l_986)) - (unsigned short)1L), p_23, p_22, p_22, g_2), (*l_898), p_22)) <= p_22) % (unsigned)l_1014) | g_622) >= 1L);
            step_hash(501);
            (*l_1009) = ((short)(((unsigned char)((((unsigned char)((unsigned char)g_481 << (unsigned char)(g_609[1][0] <= p_21)) << (unsigned char)4) ^ ((unsigned short)((unsigned short)(p_23 == (*l_986)) % (unsigned short)((p_24 | ((unsigned short)0xD5E7L * (unsigned short)0xB63CL)) && (*l_898))) * (unsigned short)g_181[1])) != (*l_898)) + (unsigned char)g_181[0]) != 0xA90DL) >> (short)0);
            step_hash(522);
            for (g_622 = 1; (g_622 >= 0); g_622 -= 1)
            {
                int ***l_1033 = &g_364[1];
                int l_1068 = 0xA211296BL;
                int l_1071[3][2] = {{0x7485DD73L, 0x7485DD73L}, {0x7485DD73L, 0x7485DD73L}, {0x7485DD73L, 0x7485DD73L}};
                int i, j;
                step_hash(509);
                for (l_973 = 0; (l_973 <= 0); l_973 += 1)
                {
                    int i, j;
                    step_hash(508);
                    (*l_1009) &= (l_912[l_973][l_973] ^ (((unsigned char)l_987[l_973][(l_973 + 3)] % (unsigned char)((int)g_206[l_973][l_973] - (int)(g_264[0][0] < (-1L)))) ^ p_21));
                }
                step_hash(510);
                (*l_1009) = ((((short)(((int)p_20 - (int)(((short)((signed char)(((((unsigned char)((void*)0 == &g_241) * (unsigned char)(l_1054 != l_1054)) > ((short)((unsigned char)((unsigned short)(((short)g_168 << (short)((unsigned short)((((((((p_24 >= (g_908 || g_168)) && (*l_1009)) | p_20) == 0x5820L) <= 65535UL) | 0x0AL) ^ p_20) != 0xB0D3L) << (unsigned short)g_182)) ^ g_609[1][0]) >> (unsigned short)8) - (unsigned char)g_568) + (short)p_22)) & g_789) || l_1067) % (signed char)g_908) << (short)15) | 0xB9D6558CL)) >= g_180) << (short)1) > 255UL) == 0x8C61A88DL);
                step_hash(511);
                p_21 &= ((void*)0 == &p_21);
                step_hash(521);
                for (l_952 = 0; (l_952 >= 0); l_952 -= 1)
                {
                    short l_1070 = 0x4F35L;
                    int l_1072[10][1] = {{1L}, {1L}, {1L}, {1L}, {1L}, {1L}, {1L}, {1L}, {1L}, {1L}};
                    int i, j;
                    step_hash(520);
                    for (l_959 = 0; (l_959 >= 0); l_959 -= 1)
                    {
                        int l_1069 = 0xD387E225L;
                        unsigned l_1074 = 0xCD55DC8EL;
                        int i, j;
                        step_hash(518);
                        l_1074--;
                        step_hash(519);
                        p_21 &= func_36(l_912[l_959][l_959], l_912[(l_959 + 1)][l_959], l_987[l_952][(l_952 + 6)], g_2, p_22);
                    }
                }
            }
        }
        step_hash(572);
        for (g_160 = 6; (g_160 >= 0); g_160 -= 1)
        {
            int l_1082 = 0L;
            int *l_1083 = (void*)0;
            unsigned char l_1090 = 0xECL;
            step_hash(527);
            (*l_1009) ^= p_21;
            step_hash(528);
            (*g_241) = &p_21;
            step_hash(529);
            if ((*g_153))
                break;
            step_hash(565);
            if (((((void*)0 != (*l_1054)) && func_80(&p_21, (l_1077 == (p_20 >= p_23)), g_908, p_24, g_184)) & 0x96BEL))
            {
                step_hash(531);
                return p_22;
            }
            else
            {
                short l_1115 = 0xEDC8L;
                int *l_1116 = (void*)0;
                int l_1122[8] = {1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L};
                int i;
                step_hash(563);
                if ((((short)g_622 * (short)((0x8FL | (+(0x02L & g_481))) & func_27(((unsigned short)(((void*)0 == &g_364[3]) < ((signed char)g_184 % (signed char)l_1090)) << (unsigned short)12), ((unsigned char)(((g_168 ^ p_24) <= 1L) && 0xD5A2L) >> (unsigned char)7), p_21))) | l_1093))
                {
                    unsigned l_1096[8] = {1UL, 0x4060C70EL, 1UL, 0x4060C70EL, 1UL, 0x4060C70EL, 1UL, 0x4060C70EL};
                    int l_1114 = 0x85F7C919L;
                    int i;
                    step_hash(534);
                    (*l_1009) = (p_23 | p_23);
                    step_hash(535);
                    (*g_241) = (**l_1054);
                    step_hash(540);
                    for (p_22 = 0; (p_22 <= 5); p_22 += 1)
                    {
                        step_hash(539);
                        (*l_1066) = ((short)0x2F66L >> (short)0);
                    }
                    step_hash(548);
                    for (g_171 = 0; (g_171 <= 1); g_171 += 1)
                    {
                        int i, j;
                        step_hash(544);
                        l_1096[7]--;
                        step_hash(545);
                        if (l_987[g_171][(g_171 + 7)])
                            continue;
                        step_hash(546);
                        l_1114 |= ((signed char)((short)(((short)((void*)0 != (*l_1054)) * (short)((unsigned short)(((int)p_21 - (int)(g_264[0][4] | (((l_1096[0] == ((short)((short)0xF2D3L << (short)func_80((**l_921), (g_568 && (-(unsigned short)(!0xA78FL))), g_568, g_60, g_568)) * (short)g_264[4][3])) && g_277) >= g_60))) >= 0xE2L) * (unsigned short)p_22)) & p_20) / (short)g_481) / (signed char)p_20);
                        step_hash(547);
                        return l_1115;
                    }
                }
                else
                {
                    int **l_1119 = (void*)0;
                    int *l_1120 = &l_997;
                    step_hash(556);
                    if (p_22)
                    {
                        step_hash(551);
                        (**l_921) = l_1083;
                    }
                    else
                    {
                        unsigned l_1123 = 4294967294UL;
                        int i;
                        step_hash(553);
                        l_1123++;
                        step_hash(554);
                        (**l_921) = &l_1122[4];
                        step_hash(555);
                        (**g_241) ^= 1L;
                    }
                    step_hash(561);
                    for (g_180 = 0; (g_180 <= 5); g_180 += 1)
                    {
                        short l_1128 = 1L;
                        step_hash(560);
                        (*l_1120) = (3UL == func_80(l_1120, ((short)l_1128 * (short)g_163), g_206[0][3], func_36(((unsigned char)((unsigned short)((&g_364[6] != (void*)0) || g_168) << (unsigned short)(&g_241 == &g_241)) >> (unsigned char)g_169[8]), p_24, g_206[0][0], g_184, (*l_1009)), g_47));
                    }
                    step_hash(562);
                    (**l_1054) = &p_21;
                }
                step_hash(564);
                (*l_1066) |= (p_21 <= (4294967291UL < ((g_594 == (((l_1133 == (void*)0) | (-4L)) != ((short)func_80(&p_21, (((int)p_22 % (int)(+p_23)) != p_20), g_264[0][5], p_22, p_23) << (short)6))) | 0L)));
            }
            step_hash(571);
            for (g_568 = 0; (g_568 <= 5); g_568 += 1)
            {
                int l_1141 = 0x9B094F94L;
                step_hash(569);
                l_1140 |= (((unsigned char)247UL / (unsigned char)(+p_23)) <= 0x84L);
                step_hash(570);
                if (l_1141)
                    continue;
            }
        }
        step_hash(573);
        (*g_241) = &p_21;
        step_hash(698);
        if (((~g_160) > (((unsigned char)func_80((**l_921), p_20, ((short)g_47 * (short)(***l_921)), func_36(g_609[1][0], ((unsigned)0x5DE6CA27L % (unsigned)l_1148), (*l_898), g_609[1][1], g_163), g_206[0][4]) * (unsigned char)l_1149) > p_20)))
        {
            unsigned char l_1156[10] = {255UL, 0x8DL, 0x62L, 0x62L, 0x8DL, 255UL, 0x8DL, 0x62L, 0x62L, 0x8DL};
            int l_1175 = 1L;
            int l_1185 = 9L;
            int l_1186[2][9] = {{(-8L), (-8L), 1L, (-8L), (-8L), 1L, (-8L), (-8L), 1L}, {(-8L), (-8L), 1L, (-8L), (-8L), 1L, (-8L), (-8L), 1L}};
            unsigned short l_1188 = 65530UL;
            unsigned l_1196[10][2] = {{0xB2840402L, 1UL}, {0xB2840402L, 1UL}, {0xB2840402L, 1UL}, {0xB2840402L, 1UL}, {0xB2840402L, 1UL}, {0xB2840402L, 1UL}, {0xB2840402L, 1UL}, {0xB2840402L, 1UL}, {0xB2840402L, 1UL}, {0xB2840402L, 1UL}};
            int i, j;
            step_hash(616);
            if (((signed char)((signed char)(***l_1054) >> (signed char)((*l_1054) == (*l_921))) - (signed char)func_36(g_877, ((signed char)(g_609[0][5] < ((((void*)0 == &p_21) >= 4294967286UL) & p_22)) - (signed char)l_1156[9]), g_789, (***l_1054), p_20)))
            {
                signed char l_1165 = 6L;
                int l_1181 = 0xF14441FDL;
                int l_1182 = 0L;
                int l_1183 = (-7L);
                int l_1184[8] = {6L, 2L, 6L, 2L, 6L, 2L, 6L, 2L};
                int **l_1202 = &g_862;
                int i;
                step_hash(591);
                if (((*g_149) & ((unsigned short)((*g_153) == ((unsigned char)p_23 - (unsigned char)(+0x4DL))) % (unsigned short)((unsigned short)((((void*)0 == &g_364[0]) & func_36(((*l_1133) ^ ((unsigned char)(p_24 ^ g_160) >> (unsigned char)l_1165)), l_1156[6], l_1165, p_24, p_23)) != p_22) % (unsigned short)p_21))))
                {
                    step_hash(581);
                    for (g_60 = 0; (g_60 <= 1); g_60 += 1)
                    {
                        int i;
                        step_hash(580);
                        return g_169[(g_60 + 7)];
                    }
                }
                else
                {
                    signed char l_1168 = 0x97L;
                    unsigned short l_1176[1][8] = {{0x7B16L, 0x6ED2L, 0x7B16L, 0x6ED2L, 0x7B16L, 0x6ED2L, 0x7B16L, 0x6ED2L}};
                    int i, j;
                    step_hash(583);
                    (*l_1133) &= (((unsigned char)func_121(((***l_1054) <= g_908), l_1168) * (unsigned char)(g_181[0] >= 4UL)) & ((unsigned short)g_877 / (unsigned short)(-1L)));
                    step_hash(584);
                    (**g_241) = (&p_21 != l_1171);
                    step_hash(589);
                    for (g_877 = 0; (g_877 > 13); g_877 += 1)
                    {
                        step_hash(588);
                        (**l_921) = (**l_921);
                    }
                    step_hash(590);
                    l_1176[0][7]--;
                }
                step_hash(597);
                for (g_183 = (-16); (g_183 >= 20); g_183 += 7)
                {
                    step_hash(595);
                    (*l_1133) &= 0xC2BE1739L;
                    step_hash(596);
                    return p_22;
                }
                step_hash(598);
                l_1188++;
                step_hash(613);
                for (g_170 = (-15); (g_170 > 25); g_170 += 6)
                {
                    int *l_1195 = &l_1121;
                    step_hash(602);
                    if ((**g_241))
                        break;
                    step_hash(611);
                    if ((l_1182 >= ((unsigned)(~(0x33L >= p_24)) - (unsigned)(*g_149))))
                    {
                        int *l_1197 = &l_1186[1][1];
                        step_hash(604);
                        p_21 = l_1182;
                        step_hash(605);
                        (**l_921) = &p_21;
                        step_hash(606);
                        (*l_1197) &= (((short)(*l_1133) >> (short)11) >= g_609[0][0]);
                        step_hash(607);
                        p_21 &= (((g_160 != (&p_21 == (*g_241))) >= ((((unsigned short)g_143 * (unsigned short)(l_1202 != &l_1195)) == g_483) <= g_594)) && (((short)((!((signed char)((g_789 >= l_1156[2]) | g_181[1]) - (signed char)1UL)) > 1L) / (short)9UL) != l_1185));
                    }
                    else
                    {
                        unsigned char l_1207[4][3] = {{0x18L, 0xA8L, 0x18L}, {0x18L, 0xA8L, 0x18L}, {0x18L, 0xA8L, 0x18L}, {0x18L, 0xA8L, 0x18L}};
                        int i, j;
                        step_hash(609);
                        ++l_1207[0][0];
                        step_hash(610);
                        p_21 |= (p_20 <= (l_921 == &g_364[6]));
                    }
                    step_hash(612);
                    return l_1188;
                }
            }
            else
            {
                step_hash(615);
                (*l_1133) ^= p_21;
            }
        }
        else
        {
            int *l_1214[5];
            unsigned char l_1248 = 0x6CL;
            unsigned short l_1251 = 0x9B75L;
            unsigned l_1256 = 0x6A7B2E7CL;
            int ***l_1263 = &g_241;
            int i;
            for (i = 0; i < 5; i++)
                l_1214[i] = (void*)0;
            step_hash(663);
            for (p_20 = 0; (p_20 <= 1); p_20 += 1)
            {
                int l_1231 = 0x67E08DB2L;
                unsigned l_1234 = 0x100EFEDDL;
                int l_1255[2][2];
                int ***l_1276[6] = {&g_241, &g_241, (void*)0, &g_241, &g_241, (void*)0};
                int i, j;
                for (i = 0; i < 2; i++)
                {
                    for (j = 0; j < 2; j++)
                        l_1255[i][j] = 0x3B2DDD24L;
                }
            }
            step_hash(696);
            for (l_1248 = (-18); (l_1248 != 52); l_1248 += 4)
            {
                int l_1280[2];
                int *l_1296 = &g_163;
                int l_1297[8][6] = {{0xF43FA6C4L, 0xD2FF1DCFL, 0xF43FA6C4L, 0xD2FF1DCFL, 0xF43FA6C4L, 0xD2FF1DCFL}, {0xF43FA6C4L, 0xD2FF1DCFL, 0xF43FA6C4L, 0xD2FF1DCFL, 0xF43FA6C4L, 0xD2FF1DCFL}, {0xF43FA6C4L, 0xD2FF1DCFL, 0xF43FA6C4L, 0xD2FF1DCFL, 0xF43FA6C4L, 0xD2FF1DCFL}, {0xF43FA6C4L, 0xD2FF1DCFL, 0xF43FA6C4L, 0xD2FF1DCFL, 0xF43FA6C4L, 0xD2FF1DCFL}, {0xF43FA6C4L, 0xD2FF1DCFL, 0xF43FA6C4L, 0xD2FF1DCFL, 0xF43FA6C4L, 0xD2FF1DCFL}, {0xF43FA6C4L, 0xD2FF1DCFL, 0xF43FA6C4L, 0xD2FF1DCFL, 0xF43FA6C4L, 0xD2FF1DCFL}, {0xF43FA6C4L, 0xD2FF1DCFL, 0xF43FA6C4L, 0xD2FF1DCFL, 0xF43FA6C4L, 0xD2FF1DCFL}, {0xF43FA6C4L, 0xD2FF1DCFL, 0xF43FA6C4L, 0xD2FF1DCFL, 0xF43FA6C4L, 0xD2FF1DCFL}};
                short l_1303 = 0x685CL;
                signed char l_1319 = 0xCDL;
                int i, j;
                for (i = 0; i < 2; i++)
                    l_1280[i] = 0x714C9F04L;
                step_hash(680);
                for (g_180 = 0; (g_180 <= 8); g_180 += 1)
                {
                    unsigned short l_1298 = 0xE5B4L;
                    step_hash(670);
                    p_21 = l_1280[0];
                }
                step_hash(695);
                for (g_168 = 0; (g_168 >= (-13)); g_168 -= 8)
                {
                    unsigned short l_1306 = 0xEB7EL;
                    unsigned l_1324 = 0UL;
                    step_hash(684);
                    (*l_1133) = (+(&p_21 == (**l_1263)));
                    step_hash(693);
                    if (func_80((**l_1263), (((&p_21 == &p_21) && (l_1303 == p_23)) >= p_20), ((signed char)((void*)0 != &g_241) >> (signed char)5), l_1306, p_24))
                    {
                        short l_1320[8][3] = {{0xFF61L, 0x5A70L, 0xFF61L}, {0xFF61L, 0x5A70L, 0xFF61L}, {0xFF61L, 0x5A70L, 0xFF61L}, {0xFF61L, 0x5A70L, 0xFF61L}, {0xFF61L, 0x5A70L, 0xFF61L}, {0xFF61L, 0x5A70L, 0xFF61L}, {0xFF61L, 0x5A70L, 0xFF61L}, {0xFF61L, 0x5A70L, 0xFF61L}};
                        int *l_1323 = (void*)0;
                        int i, j;
                        step_hash(686);
                        (*l_1066) = (((unsigned)0x4E8CC0BCL % (unsigned)(((((unsigned char)((short)0xE1DBL / (short)g_169[8]) << (unsigned char)3) & (***l_1054)) && l_1324) & (*l_1133))) != p_20);
                        step_hash(687);
                        (*l_1133) = (-6L);
                        step_hash(688);
                        (*l_1066) = (((signed char)(+(-(short)((unsigned)(((unsigned short)1UL + (unsigned short)0UL) | ((signed char)((((+g_182) || 1L) ^ (***l_1263)) ^ g_184) / (signed char)p_24)) / (unsigned)((unsigned short)g_163 - (unsigned short)(g_118 == p_22))))) + (signed char)g_168) | g_264[4][3]);
                        step_hash(689);
                        if (p_21)
                            break;
                    }
                    else
                    {
                        unsigned char l_1337 = 0x8DL;
                        step_hash(691);
                        (*l_1133) = ((p_20 != func_36((p_20 | (p_24 < p_23)), p_23, p_24, func_80(l_1336, g_180, g_184, g_609[1][0], g_1187), g_169[8])) || g_171);
                        step_hash(692);
                        if (l_1337)
                            break;
                    }
                    step_hash(694);
                    (*l_921) = (void*)0;
                }
            }
            step_hash(697);
            (**l_1263) = (**l_1263);
        }
    }
    step_hash(741);
    for (p_24 = 4; (p_24 >= 1); p_24 -= 1)
    {
        signed char l_1338[3];
        int *l_1355 = &l_1149;
        int l_1364 = 0xF86B0A32L;
        int l_1365 = 0xEAF68E67L;
        int l_1370 = 0x28A3F8DCL;
        int l_1371 = 0x76B49374L;
        int l_1373 = 1L;
        int l_1374 = 0x5E9E835CL;
        int l_1377[5] = {(-1L), (-9L), (-1L), (-9L), (-1L)};
        short l_1410 = (-2L);
        int *l_1418 = &l_909;
        short l_1419 = 0x0113L;
        int i;
        for (i = 0; i < 3; i++)
            l_1338[i] = 5L;
    }
    step_hash(742);
    return p_24;
}
static unsigned short func_27(unsigned short p_28, unsigned p_29, unsigned p_30)
{
    short l_76 = (-1L);
    int *l_77[9];
    signed char l_891 = 0xCBL;
    unsigned l_892[9][3] = {{0x5410DABFL, 0xAE168533L, 0x6EDE564AL}, {0x5410DABFL, 0xAE168533L, 0x6EDE564AL}, {0x5410DABFL, 0xAE168533L, 0x6EDE564AL}, {0x5410DABFL, 0xAE168533L, 0x6EDE564AL}, {0x5410DABFL, 0xAE168533L, 0x6EDE564AL}, {0x5410DABFL, 0xAE168533L, 0x6EDE564AL}, {0x5410DABFL, 0xAE168533L, 0x6EDE564AL}, {0x5410DABFL, 0xAE168533L, 0x6EDE564AL}, {0x5410DABFL, 0xAE168533L, 0x6EDE564AL}};
    int i, j;
    for (i = 0; i < 9; i++)
        l_77[i] = &g_2;
    step_hash(448);
    for (p_30 = 0; (p_30 > 40); p_30 += 1)
    {
        unsigned char l_72 = 0x5AL;
        int *l_86 = &g_47;
        int l_863 = 0x1C3A6D85L;
        int l_864 = 0x41A87B9FL;
        int l_865 = 0x60445050L;
        short l_866 = 9L;
        int l_867 = 0x6801D6FEL;
        int l_868 = 6L;
        int l_869 = 1L;
        int l_870 = 9L;
        int l_871 = 5L;
        int l_872 = 3L;
        int l_873[3][6] = {{5L, 5L, 0x08659854L, (-1L), 0L, (-1L)}, {5L, 5L, 0x08659854L, (-1L), 0L, (-1L)}, {5L, 5L, 0x08659854L, (-1L), 0L, (-1L)}};
        unsigned short l_874 = 0x697AL;
        int i, j;
    }
    step_hash(453);
    for (g_170 = 0; (g_170 >= (-9)); --g_170)
    {
        int *l_882 = (void*)0;
        step_hash(452);
        (*g_241) = l_882;
    }
    step_hash(454);
    return p_30;
}







static unsigned short func_36(unsigned p_37, unsigned p_38, unsigned char p_39, signed char p_40, signed char p_41)
{
    int *l_46 = &g_47;
    int l_48 = 1L;
    int *l_49 = (void*)0;
    int *l_50 = &l_48;
    int *l_51 = &g_47;
    int *l_52 = &g_47;
    int *l_53 = &l_48;
    int l_54 = (-4L);
    int *l_55 = &g_47;
    int *l_56 = &l_54;
    int *l_57 = &g_47;
    int *l_58[5][2] = {{(void*)0, (void*)0}, {(void*)0, (void*)0}, {(void*)0, (void*)0}, {(void*)0, (void*)0}, {(void*)0, (void*)0}};
    int l_59 = 0x236511F0L;
    int i, j;
    step_hash(6);
    --g_60;
    step_hash(7);
    return (*l_57);
}







static int * func_65(unsigned p_66, int * p_67, unsigned p_68, int p_69)
{
    unsigned l_283 = 1UL;
    int *l_302 = &g_2;
    int l_334 = 1L;
    int l_343 = (-9L);
    int l_344 = 0xD1ED096BL;
    int l_347 = 0x8158996BL;
    int l_349 = 1L;
    int l_350 = 1L;
    int l_351 = 0x19A99B7AL;
    int l_352[10] = {0x358AF41BL, 0x358AF41BL, 0x033CB161L, 0x358AF41BL, 0x358AF41BL, 0x033CB161L, 0x358AF41BL, 0x358AF41BL, 0x033CB161L, 0x358AF41BL};
    int ***l_386 = &g_364[6];
    unsigned l_417 = 0xCA51754DL;
    short l_477 = (-1L);
    signed char l_544 = 0x64L;
    short l_545 = 0xF955L;
    unsigned char l_546 = 1UL;
    unsigned char l_570 = 0x51L;
    unsigned short l_636[7][2] = {{0UL, 5UL}, {0UL, 5UL}, {0UL, 5UL}, {0UL, 5UL}, {0UL, 5UL}, {0UL, 5UL}, {0UL, 5UL}};
    int *l_672 = &l_344;
    int l_713[7] = {0x0D93A79EL, 0x0D93A79EL, 0xD45FC68DL, 0x0D93A79EL, 0x0D93A79EL, 0xD45FC68DL, 0x0D93A79EL};
    signed char l_742 = 0xDEL;
    int l_823 = 0xBBF2409EL;
    unsigned short l_824 = 0x7FD5L;
    int l_841 = 1L;
    unsigned l_842 = 4294967286UL;
    int *l_845 = (void*)0;
    int i, j;
    step_hash(274);
    for (g_60 = 0; (g_60 != 21); g_60++)
    {
        int l_292 = 0x75F8133EL;
        int *l_305 = &g_163;
        int l_332 = 0x81374B14L;
        int l_335 = (-1L);
        int l_339 = 0x9B219FC2L;
        int l_340 = 0x3AF24F68L;
        int l_341 = 0x22182E24L;
        int l_342 = (-10L);
        int l_346 = 0x15A7122BL;
        int l_353 = 0x0B4E7AACL;
        int ***l_433 = &g_364[6];
        unsigned l_451[9] = {4294967294UL, 4294967288UL, 4294967294UL, 4294967288UL, 4294967294UL, 4294967288UL, 4294967294UL, 4294967288UL, 4294967294UL};
        int l_479 = 0xDACAA398L;
        int l_480 = 0L;
        int l_482[10][2];
        unsigned l_521[3];
        int *l_539 = &l_347;
        int *l_540 = &l_344;
        int *l_541 = &l_353;
        int *l_542 = &g_163;
        int *l_543[3];
        int i, j;
        for (i = 0; i < 10; i++)
        {
            for (j = 0; j < 2; j++)
                l_482[i][j] = 0x0A20FAC9L;
        }
        for (i = 0; i < 3; i++)
            l_521[i] = 0x52AF3082L;
        for (i = 0; i < 3; i++)
            l_543[i] = &l_334;
    }
    step_hash(281);
    for (g_160 = 0; (g_160 == 19); g_160 += 1)
    {
        signed char l_553 = 0x2DL;
        int *l_556[6];
        int i;
        for (i = 0; i < 6; i++)
            l_556[i] = &l_350;
        step_hash(278);
        (*p_67) = (((short)l_553 * (short)g_182) <= ((short)0x722FL + (short)(~g_264[0][4])));
        step_hash(279);
        (*g_241) = l_556[0];
        step_hash(280);
        (*g_149) = (*p_67);
    }
    step_hash(415);
    for (p_69 = 0; (p_69 < 1); p_69++)
    {
        int *l_559 = &g_163;
        unsigned char l_560 = 0x33L;
        int l_567 = 9L;
        int l_569[3][5] = {{0xCC8681FCL, 0xD8455F49L, 0xCC8681FCL, 0xD8455F49L, 0xCC8681FCL}, {0xCC8681FCL, 0xD8455F49L, 0xCC8681FCL, 0xD8455F49L, 0xCC8681FCL}, {0xCC8681FCL, 0xD8455F49L, 0xCC8681FCL, 0xD8455F49L, 0xCC8681FCL}};
        int l_620 = 2L;
        unsigned l_658 = 8UL;
        int *l_661 = &l_347;
        int *l_671 = &l_349;
        unsigned l_714[1];
        unsigned l_764 = 4294967293UL;
        int i, j;
        for (i = 0; i < 1; i++)
            l_714[i] = 1UL;
    }
    step_hash(423);
    if ((*l_672))
    {
        int *l_818 = (void*)0;
        int *l_819 = &l_334;
        int *l_820 = &l_343;
        int *l_821 = &l_352[0];
        int *l_822[8][4] = {{&g_168, &l_713[6], &l_713[6], &g_170}, {&g_168, &l_713[6], &l_713[6], &g_170}, {&g_168, &l_713[6], &l_713[6], &g_170}, {&g_168, &l_713[6], &l_713[6], &g_170}, {&g_168, &l_713[6], &l_713[6], &g_170}, {&g_168, &l_713[6], &l_713[6], &g_170}, {&g_168, &l_713[6], &l_713[6], &g_170}, {&g_168, &l_713[6], &l_713[6], &g_170}};
        int i, j;
        step_hash(417);
        l_824++;
        step_hash(418);
        (*l_820) = func_36((~((unsigned short)(***l_386) << (unsigned short)8)), p_68, g_160, (~((((&g_364[0] != (void*)0) | ((*g_149) < ((unsigned char)func_36(((short)((short)(((signed char)(*l_821) % (signed char)p_66) != ((0x0DL & g_181[1]) == 1UL)) + (short)p_69) * (short)0xE0D7L), (*l_819), g_264[4][3], p_68, g_568) % (unsigned char)0xC1L))) > g_183) ^ 0xFEC8L)), p_66);
    }
    else
    {
        int *l_837 = (void*)0;
        int *l_838 = &l_344;
        int *l_839[6];
        signed char l_840 = 0xB3L;
        int i;
        for (i = 0; i < 6; i++)
            l_839[i] = &l_334;
        step_hash(420);
        (*l_672) &= ((void*)0 != l_837);
        step_hash(421);
        (*p_67) = (*p_67);
        step_hash(422);
        l_842++;
    }
    step_hash(424);
    return l_845;
}







static signed char func_80(int * p_81, unsigned char p_82, short p_83, unsigned p_84, int p_85)
{
    int *l_105 = &g_47;
    signed char l_117 = 6L;
    int l_272[8] = {0x56C0A20DL, 0x56C0A20DL, 0x732B217FL, 0x56C0A20DL, 0x56C0A20DL, 0x732B217FL, 0x56C0A20DL, 0x56C0A20DL};
    int *l_280 = &g_163;
    int i;
    step_hash(127);
    for (p_83 = 0; (p_83 <= (-23)); p_83 -= 4)
    {
        unsigned char l_108 = 0x9AL;
        unsigned l_120[7] = {0x58C9C965L, 0x58C9C965L, 4294967291UL, 0x58C9C965L, 0x58C9C965L, 4294967291UL, 0x58C9C965L};
        int l_267 = 0L;
        int *l_268 = &g_170;
        int *l_269 = &l_267;
        int *l_270 = &g_168;
        int *l_271 = &g_163;
        int *l_273 = (void*)0;
        int *l_274 = &g_168;
        int *l_275 = &g_163;
        int *l_276[8] = {&l_272[2], &g_168, &l_272[2], &g_168, &l_272[2], &g_168, &l_272[2], &g_168};
        int i;
        step_hash(26);
        if (((signed char)((signed char)((signed char)g_47 << (signed char)(((unsigned short)g_47 - (unsigned short)(l_105 == p_81)) ^ (l_108 > ((unsigned short)0UL % (unsigned short)(((unsigned short)((unsigned)((unsigned short)(p_83 >= (((void*)0 != p_81) > l_108)) >> (unsigned short)p_84) - (unsigned)g_60) - (unsigned short)p_83) | 0x18L))))) + (signed char)l_117) << (signed char)6))
        {
            unsigned l_119[1];
            int i;
            for (i = 0; i < 1; i++)
                l_119[i] = 0xC5CEC10CL;
            step_hash(17);
            if (l_108)
                break;
            step_hash(18);
            g_118 &= (7UL != (*l_105));
            step_hash(23);
            for (p_82 = 0; (p_82 <= 0); p_82 += 1)
            {
                int i;
                step_hash(22);
                if (l_119[p_82])
                    break;
            }
        }
        else
        {
            step_hash(25);
            return p_84;
        }
        step_hash(124);
        for (p_84 = 0; (p_84 <= 6); p_84 += 1)
        {
            int i;
        }
        step_hash(125);
        ++g_277;
        step_hash(126);
        return p_82;
    }
    step_hash(128);
    (*l_280) |= (&l_272[2] != l_280);
    step_hash(129);
    (*g_241) = p_81;
    step_hash(130);
    return (*l_280);
}







static int func_121(unsigned char p_122, short p_123)
{
    int l_135[10][6];
    int *l_152 = &g_47;
    int ***l_262 = (void*)0;
    int *l_263[5];
    short l_265 = 0x96ABL;
    int l_266 = 0xE223FE2AL;
    int i, j;
    for (i = 0; i < 10; i++)
    {
        for (j = 0; j < 6; j++)
            l_135[i][j] = 8L;
    }
    for (i = 0; i < 5; i++)
        l_263[i] = &g_170;
    step_hash(118);
    l_152 = func_124((func_127((((unsigned char)((l_135[4][1] != (1L || ((l_135[4][1] && g_118) || (+((void*)0 == &g_2))))) ^ ((!(0xF5L == ((signed char)((unsigned char)((signed char)(0xD522L ^ 0x96F1L) / (signed char)g_118) >> (unsigned char)p_122) % (signed char)4UL))) >= g_118)) >> (unsigned char)6) == 9L), p_122, &l_135[2][4], &l_135[4][1], &l_135[4][1]) >= p_122), l_152);
    step_hash(119);
    g_264[4][3] = ((unsigned char)(((&l_152 == &l_152) == ((*l_152) == g_180)) >= ((short)((unsigned)((int)p_123 % (int)p_123) - (unsigned)(&g_241 != l_262)) >> (short)8)) % (unsigned char)func_127(((*g_149) != 0L), g_2, &l_135[7][2], &l_135[5][2], &l_135[9][5]));
    step_hash(120);
    l_265 = ((void*)0 != (*g_241));
    step_hash(121);
    l_266 = (0xC0L == 0xEFL);
    step_hash(122);
    return p_122;
}







static int * func_124(unsigned p_125, int * p_126)
{
    int *l_154 = (void*)0;
    int l_155 = 0L;
    int l_176[9][1] = {{0x9491B29FL}, {0x9491B29FL}, {0x9491B29FL}, {0x9491B29FL}, {0x9491B29FL}, {0x9491B29FL}, {0x9491B29FL}, {0x9491B29FL}, {0x9491B29FL}};
    int l_190[6] = {(-5L), (-5L), 0xC775878EL, (-5L), (-5L), 0xC775878EL};
    int *l_219 = &l_176[6][0];
    int *l_252 = &l_176[6][0];
    int *l_253[1][5] = {{&g_168, &g_168, &g_168, &g_168, &g_168}};
    int i, j;
    step_hash(115);
    if ((g_143 || (g_47 != g_143)))
    {
        step_hash(47);
        return &g_47;
    }
    else
    {
        int l_172 = 0L;
        int l_174 = 0xE64C0ED6L;
        int l_177[4];
        int i;
        for (i = 0; i < 4; i++)
            l_177[i] = 0x2EC8A694L;
        step_hash(64);
        for (g_118 = (-14); (g_118 < 16); g_118 += 9)
        {
            unsigned char l_161 = 253UL;
            int l_175 = (-7L);
            int l_178 = (-6L);
            int *l_191 = &g_163;
            step_hash(62);
            for (l_155 = (-30); (l_155 <= 21); l_155++)
            {
                int l_166 = 7L;
                int l_167 = 0x37D4A057L;
                int l_173 = 5L;
                int l_179 = 0L;
                int *l_187 = &g_170;
                step_hash(55);
                g_160 = (*g_153);
                step_hash(60);
                if (l_161)
                {
                    int *l_162 = &g_163;
                    int *l_164 = (void*)0;
                    int *l_165[8] = {&g_47, &g_47, &g_163, &g_47, &g_47, &g_163, &g_47, &g_47};
                    int i;
                    step_hash(57);
                    g_184++;
                }
                else
                {
                    step_hash(59);
                    return l_187;
                }
                step_hash(61);
                if ((*g_153))
                    break;
            }
            step_hash(63);
            (*l_191) = ((signed char)0xAAL - (signed char)(l_190[5] < (p_125 == p_125)));
        }
        step_hash(114);
        if ((g_163 & (g_118 & ((((unsigned char)(g_169[6] < (!l_172)) + (unsigned char)((unsigned short)0UL - (unsigned short)((4294967295UL | (*p_126)) >= (((unsigned short)(((g_168 != l_174) <= p_125) ^ 0x9566L) >> (unsigned short)g_168) == l_177[2])))) <= g_60) != l_177[2]))))
        {
            int *l_198 = &g_168;
            int l_199 = (-4L);
            int l_200 = 0x3571D3B0L;
            int *l_201 = (void*)0;
            int *l_202 = &l_174;
            int *l_203 = &l_200;
            int *l_204 = &l_155;
            int *l_205[5];
            int i;
            for (i = 0; i < 5; i++)
                l_205[i] = &l_174;
            step_hash(66);
            ++g_206[0][5];
            step_hash(74);
            for (g_182 = 0; (g_182 <= 3); g_182 += 1)
            {
                int i;
                step_hash(70);
                l_177[g_182] ^= (*g_153);
                step_hash(71);
                if (l_177[1])
                    break;
                step_hash(72);
                (*l_198) ^= ((((unsigned short)p_125 - (unsigned short)(((unsigned short)(l_177[1] == (*p_126)) << (unsigned short)1) & p_125)) > ((~((p_125 || g_180) || l_177[3])) == 0UL)) & p_125);
                step_hash(73);
                if (l_172)
                    break;
            }
            step_hash(75);
            (*l_202) ^= (*l_204);
        }
        else
        {
            int **l_220[3][10] = {{&l_219, &l_219, &g_153, &l_219, &l_219, &g_153, &l_219, &l_219, &g_153, &l_219}, {&l_219, &l_219, &g_153, &l_219, &l_219, &g_153, &l_219, &l_219, &g_153, &l_219}, {&l_219, &l_219, &g_153, &l_219, &l_219, &g_153, &l_219, &l_219, &g_153, &l_219}};
            int i, j;
            step_hash(77);
            p_126 = &l_177[2];
            step_hash(112);
            for (l_174 = 0; (l_174 <= 5); l_174 += 1)
            {
                int *l_244 = &g_168;
                unsigned char l_249 = 255UL;
                int i;
                step_hash(81);
                p_126 = &l_177[3];
                step_hash(82);
                if (l_190[l_174])
                    break;
                step_hash(110);
                for (g_118 = 3; (g_118 >= 0); g_118 -= 1)
                {
                    int **l_221 = &l_154;
                    step_hash(93);
                    for (g_163 = 1; (g_163 <= 5); g_163 += 1)
                    {
                        int ***l_222 = (void*)0;
                        int ***l_223 = &l_221;
                        int i;
                        step_hash(89);
                        l_219 = &l_177[g_118];
                        step_hash(90);
                        (*l_223) = l_221;
                        step_hash(91);
                        l_177[g_118] = (*g_153);
                        step_hash(92);
                        if ((*g_149))
                            continue;
                    }
                    step_hash(100);
                    for (g_183 = 0; (g_183 <= 0); g_183 += 1)
                    {
                        int i, j;
                        step_hash(97);
                        (*p_126) = g_169[(g_183 + 5)];
                        step_hash(98);
                        (*l_219) = g_206[g_183][g_118];
                        step_hash(99);
                        return &g_168;
                    }
                    step_hash(109);
                    if ((*p_126))
                    {
                        int *l_226 = (void*)0;
                        step_hash(102);
                        (*l_221) = l_226;
                        step_hash(103);
                        (*l_244) &= (((((unsigned short)func_127(l_190[l_174], ((short)((unsigned char)(-(unsigned short)((&g_149 != l_220[2][0]) ^ ((g_160 == (*p_126)) >= p_125))) >> (unsigned char)p_125) >> (short)7), (*g_241), p_126, p_126) >> (unsigned short)l_174) <= g_206[0][5]) & g_206[0][5]) & p_125);
                        step_hash(104);
                        (*p_126) = (*l_244);
                    }
                    else
                    {
                        step_hash(106);
                        (*l_244) |= (*l_219);
                        step_hash(107);
                        (*l_219) = ((unsigned short)((unsigned)2UL + (unsigned)0x29A21605L) >> (unsigned short)10);
                        step_hash(108);
                        (*p_126) &= l_249;
                    }
                }
                step_hash(111);
                (*p_126) = ((1L < (((signed char)((**g_241) > (g_181[0] || (0x49L != 251UL))) % (signed char)8L) && (((&g_241 == (void*)0) && ((void*)0 == &p_126)) & p_125))) == p_125);
            }
            step_hash(113);
            l_252 = p_126;
        }
    }
    step_hash(116);
    (*g_241) = l_253[0][3];
    step_hash(117);
    return (*g_241);
}







static int func_127(int p_128, unsigned p_129, int * p_130, int * p_131, int * p_132)
{
    int l_142 = 0x4B622C33L;
    int l_151[1][1];
    int i, j;
    for (i = 0; i < 1; i++)
    {
        for (j = 0; j < 1; j++)
            l_151[i][j] = (-6L);
    }
    step_hash(32);
    (*p_132) = (l_142 >= g_143);
    step_hash(38);
    for (l_142 = 0; (l_142 < (-19)); l_142 -= 2)
    {
        unsigned l_148 = 0x50633388L;
        int **l_150 = &g_149;
        step_hash(36);
        (*p_131) &= ((signed char)7L * (signed char)l_148);
        step_hash(37);
        (*l_150) = g_149;
    }
    step_hash(43);
    for (g_143 = 0; (g_143 <= 0); g_143 += 1)
    {
        step_hash(42);
        return (*p_132);
    }
    step_hash(44);
    return (*g_149);
}


void csmith_compute_hash(void)
{
    int i, j;
    transparent_crc(g_2, ""g_2"", print_hash_value);
    transparent_crc(g_47, ""g_47"", print_hash_value);
    transparent_crc(g_60, ""g_60"", print_hash_value);
    transparent_crc(g_118, ""g_118"", print_hash_value);
    transparent_crc(g_143, ""g_143"", print_hash_value);
    transparent_crc(g_160, ""g_160"", print_hash_value);
    transparent_crc(g_163, ""g_163"", print_hash_value);
    transparent_crc(g_168, ""g_168"", print_hash_value);
    for (i = 0; i < 9; i++)
    {
        transparent_crc(g_169[i], ""g_169[i]"", print_hash_value);
        if (print_hash_value) printf(""index = [%d]\n"", i);

    }
    transparent_crc(g_170, ""g_170"", print_hash_value);
    transparent_crc(g_171, ""g_171"", print_hash_value);
    transparent_crc(g_180, ""g_180"", print_hash_value);
    for (i = 0; i < 3; i++)
    {
        transparent_crc(g_181[i], ""g_181[i]"", print_hash_value);
        if (print_hash_value) printf(""index = [%d]\n"", i);

    }
    transparent_crc(g_182, ""g_182"", print_hash_value);
    transparent_crc(g_183, ""g_183"", print_hash_value);
    transparent_crc(g_184, ""g_184"", print_hash_value);
    for (i = 0; i < 1; i++)
    {
        for (j = 0; j < 6; j++)
        {
            transparent_crc(g_206[i][j], ""g_206[i][j]"", print_hash_value);
            if (print_hash_value) printf(""index = [%d][%d]\n"", i, j);

        }
    }
    for (i = 0; i < 5; i++)
    {
        for (j = 0; j < 6; j++)
        {
            transparent_crc(g_264[i][j], ""g_264[i][j]"", print_hash_value);
            if (print_hash_value) printf(""index = [%d][%d]\n"", i, j);

        }
    }
    transparent_crc(g_277, ""g_277"", print_hash_value);
    transparent_crc(g_481, ""g_481"", print_hash_value);
    transparent_crc(g_483, ""g_483"", print_hash_value);
    transparent_crc(g_568, ""g_568"", print_hash_value);
    transparent_crc(g_594, ""g_594"", print_hash_value);
    for (i = 0; i < 2; i++)
    {
        for (j = 0; j < 6; j++)
        {
            transparent_crc(g_609[i][j], ""g_609[i][j]"", print_hash_value);
            if (print_hash_value) printf(""index = [%d][%d]\n"", i, j);

        }
    }
    transparent_crc(g_622, ""g_622"", print_hash_value);
    transparent_crc(g_789, ""g_789"", print_hash_value);
    transparent_crc(g_877, ""g_877"", print_hash_value);
    transparent_crc(g_908, ""g_908"", print_hash_value);
    transparent_crc(g_1187, ""g_1187"", print_hash_value);
    for (i = 0; i < 3; i++)
    {
        transparent_crc(g_1219[i], ""g_1219[i]"", print_hash_value);
        if (print_hash_value) printf(""index = [%d]\n"", i);

    }
    transparent_crc(g_1510, ""g_1510"", print_hash_value);
    transparent_crc(g_1514, ""g_1514"", print_hash_value);
}

void step_hash(int stmt_id)
{
    int i = 0;
    csmith_compute_hash();
    printf(""before stmt(%d): checksum = %X\n"", stmt_id, crc32_context ^ 0xFFFFFFFFUL);
    crc32_context = 0xFFFFFFFFUL;
    for (i = 0; i < 256; i++) {
        crc32_tab[i] = 0;
    }
    crc32_gentab();
}



int main (void)
{
    int i, j;
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    csmith_compute_hash();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}
"
138-11173,T-J-Teru/synopsys-binutils-gdb,gdb/testsuite/gdb.python/py-prettyprint.c,252,1,80,2078991.03406815,169091.0,12.29510145424653,1140.0,1130.0,38458.0,12700.0,1568.0,590.0,1317.0,549.0,1500000000,0.0013859940227121,1082014363648.0,0.0134247239652021,0.0786582743656906,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2008-2012 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <string.h>

struct s
{
  int a;
  int *b;
};

struct ss
{
  struct s a;
  struct s b;
};

struct arraystruct
{
  int y;
  struct s x[2];
};

struct ns {
  const char *null_str;
  int length;
};

struct lazystring {
  const char *lazy_str;
};

struct hint_error {
  int x;
};

#ifdef __cplusplus
struct S : public s {
  int zs;
};

struct SS {
  int zss;
  S s;
};

struct SSS
{
  SSS (int x, const S& r);
  int a;
  const S &b;
};
SSS::SSS (int x, const S& r) : a(x), b(r) { }

class VirtualTest 
{ 
 private: 
  int value; 

 public: 
  VirtualTest () 
    { 
      value = 1;
    } 
};

class Vbase1 : public virtual VirtualTest { };
class Vbase2 : public virtual VirtualTest { };
class Vbase3 : public virtual VirtualTest { };

class Derived : public Vbase1, public Vbase2, public Vbase3
{ 
 private: 
  int value; 
  
 public:
  Derived () 
    { 
      value = 2; 
    }
};

class Fake
{
  int sname;
  
 public:
  Fake (const int name = 0):
  sname (name)
  {
  }
};
#endif

struct substruct {
  int a;
  int b;
};

struct outerstruct {
  struct substruct s;
  int x;
};

struct outerstruct
substruct_test (void)
{
  struct outerstruct outer;
  outer.s.a = 0;
  outer.s.b = 0;
  outer.x = 0;

  outer.s.a = 3;		/* MI outer breakpoint here */

  return outer;  
}

typedef struct string_repr
{
  struct whybother
  {
    const char *contents;
  } whybother;
} string;

/* This lets us avoid malloc.  */
int array[100];
int narray[10];

struct justchildren
{
  int len;
  int *elements;
};

typedef struct justchildren nostring_type;

struct memory_error
{
  const char *s;
};

struct container
{
  string name;
  int len;
  int *elements;
};

typedef struct container zzz_type;

string
make_string (const char *s)
{
  string result;
  result.whybother.contents = s;
  return result;
}

zzz_type
make_container (const char *s)
{
  zzz_type result;

  result.name = make_string (s);
  result.len = 0;
  result.elements = 0;

  return result;
}

void
add_item (zzz_type *c, int val)
{
  if (c->len == 0)
    c->elements = array;
  c->elements[c->len] = val;
  ++c->len;
}

void init_s(struct s *s, int a)
{
  s->a = a;
  s->b = &s->a;
}

void init_ss(struct ss *s, int a, int b)
{
  init_s(&s->a, a);
  init_s(&s->b, b);
}

void do_nothing(void)
{
  int c;

  c = 23;			/* Another MI breakpoint */
}

struct nullstr
{
  char *s;
};

struct string_repr string_1 = { { ""one"" } };
struct string_repr string_2 = { { ""two"" } };

static int
eval_func (int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8)
{
  return p1;
}

static void
eval_sub (void)
{
  struct eval_type_s { int x; } eval1 = { 1 }, eval2 = { 2 }, eval3 = { 3 },
				eval4 = { 4 }, eval5 = { 5 }, eval6 = { 6 },
				eval7 = { 7 }, eval8 = { 8 }, eval9 = { 9 };

  eval1.x++; /* eval-break */
}

int
main ()
{
  struct ss  ss;
  struct ss  ssa[2];
  struct arraystruct arraystruct;
  string x = make_string (""this is x"");
  zzz_type c = make_container (""container"");
  zzz_type c2 = make_container (""container2"");
  const struct string_repr cstring = { { ""const string"" } };
  /* Clearing by being `static' could invoke an other GDB C++ bug.  */
  struct nullstr nullstr;
  nostring_type nstype, nstype2;
  struct memory_error me;
  struct ns ns, ns2;
  struct lazystring estring, estring2;
  struct hint_error hint_error;

  nstype.elements = narray;
  nstype.len = 0;

  me.s = ""blah"";

  init_ss(&ss, 1, 2);
  init_ss(ssa+0, 3, 4);
  init_ss(ssa+1, 5, 6);
  memset (&nullstr, 0, sizeof nullstr);

  arraystruct.y = 7;
  init_s (&arraystruct.x[0], 23);
  init_s (&arraystruct.x[1], 24);

  ns.null_str = ""embedded\0null\0string"";
  ns.length = 20;

  /* Make a ""corrupted"" string.  */
  ns2.null_str = NULL;
  ns2.length = 20;

  estring.lazy_str = ""embedded x\201\202\203\204"" ;

  /* Incomplete UTF-8, but ok Latin-1.  */
  estring2.lazy_str = ""embedded x\302"";

#ifdef __cplusplus
  S cps;

  cps.zs = 7;
  init_s(&cps, 8);

  SS cpss;
  cpss.zss = 9;
  init_s(&cpss.s, 10);

  SS cpssa[2];
  cpssa[0].zss = 11;
  init_s(&cpssa[0].s, 12);
  cpssa[1].zss = 13;
  init_s(&cpssa[1].s, 14);

  SSS sss(15, cps);

  SSS& ref (sss);

  Derived derived;
  
  Fake fake (42);
#endif

  add_item (&c, 23);		/* MI breakpoint here */
  add_item (&c, 72);

#ifdef MI
  add_item (&c, 1011);
  c.elements[0] = 1023;
  c.elements[0] = 2323;

  add_item (&c2, 2222);
  add_item (&c2, 3333);

  substruct_test ();
  do_nothing ();
#endif

  nstype.elements[0] = 7;
  nstype.elements[1] = 42;
  nstype.len = 2;
  
  nstype2 = nstype;

  eval_sub ();

  return 0;      /* break to inspect struct and union */
}
"
154-5060,wrmsr/lljvm,thirdparty/llvm/test/FrontendC/2007-03-05-DataLayout.c,35,1,34,1413812.9772618,171854.0,8.226820440606561,1225.0,1212.0,38868.0,13119.0,1592.0,633.0,1326.0,591.0,1500000000,0.0009425419848412,1082014363648.0,0.0141806417074958,0.0796737645949949,"// Testcase for PR1242
// RUN: %llvmgcc -S %s -o - | grep datalayout | \
// RUN:    not grep {""\[Ee\]-p:\[36\]\[24\]:\[36\]\[24\]""}
// END.
#include <stdlib.h>
#define NDIM 3
#define BODY 01
typedef double vector[NDIM];
typedef struct bnode* bodyptr;
// { i16, double, [3 x double], i32, i32, [3 x double], [3 x double], [3 x
// double], double, \2 *, \2 * }
struct bnode {
  short int type;
  double mass;
  vector pos;
  int proc;
  int new_proc;
  vector vel;
  vector acc;
  vector new_acc;
  double phi;
  bodyptr next;
  bodyptr proc_next;
} body;

#define Type(x) ((x)->type)
#define Mass(x) ((x)->mass)
#define Pos(x)  ((x)->pos)
#define Proc(x) ((x)->proc)
#define New_Proc(x) ((x)->new_proc)
#define Vel(x)  ((x)->vel)
#define Acc(x)  ((x)->acc)
#define New_Acc(x)  ((x)->new_acc)
#define Phi(x)  ((x)->phi)
#define Next(x) ((x)->next)
#define Proc_Next(x) ((x)->proc_next)

bodyptr ubody_alloc(int p)
{ 
  register bodyptr tmp;
  tmp = (bodyptr)malloc(sizeof(body));

  Type(tmp) = BODY;
  Proc(tmp) = p;
  Proc_Next(tmp) = NULL;
  New_Proc(tmp) = p;
  return tmp;
}

int main(int argc, char** argv) {
  bodyptr b = ubody_alloc(17);
  return 0;
}
"
022-33504,nben/libtopfield,test_swab.c,35,2,24,1424251.5899239501,177544.0,8.018074392826566,1338.0,1318.0,40355.0,13826.0,1641.0,638.0,1365.0,595.0,1500000000,0.0009495010599493,1082014363648.0,0.0149596719686387,0.0782377586238718,"
/* $Id: test_swab.c,v 1.1.1.1 2005/11/23 10:25:07 steveb Exp $ */

/*

  Copyright (c) 2005 Steve Bennett <msteveb at ozemail.com.au>

  This file is part of libtopfield.

  libtopfield is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  puppy is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with puppy; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*/

#define _XOPEN_SOURCE 600
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <assert.h>


/**
 * Tests the swab function.
 * 
 * The man page for swab() doesn't specify whether
 * it can swap a buffer in place, so test that here
 * Also test that swapping an odd length leaves the last byte unchanged
 */
int main(void)
{
	char buf[] = ""01234567"";
	char buf2[] = ""0123456"";

	swab(buf, buf, strlen(buf));

	printf(""test_swab: After swapping, buf=%s\n"", buf);

	assert(strcmp(buf, ""10325476"") == 0);

	swab(buf2, buf2, strlen(buf2));

	printf(""test_swab: After swapping, buf2=%s\n"", buf2);

	assert(strcmp(buf2, ""1032546"") == 0);

	return 0;
}
"
069-15772,glennlopez/CS50.HarvardX,pset5/2021/sandbox/practice_5.c,62,3,50,1807217.9518639501,176390.0,10.245575145983333,1353.0,1333.0,40008.0,13795.0,1618.0,639.0,1341.0,594.0,1500000000,0.0012048119679093,1082014363648.0,0.0152276206134134,0.0779138709737375,"
#include <stdio.h>
#include <stdlib.h>

typedef struct node_struct
{
    int data;
    struct node_struct *next;
}
node;

void PrintList(node *head);
void FreeNodes(node* head);

int main() 
{
    node *list = NULL;
    node *tmp = NULL;

    tmp = malloc(sizeof(node));
    tmp->data = 10;
    tmp->next = list;
    list = tmp;

    tmp = malloc(sizeof(node));
    tmp->data = 20;
    tmp->next = list;
    list = tmp;

    tmp = malloc(sizeof(node));
    tmp->data = 33;
    tmp->next = list;
    list = tmp;

    

    PrintList(list);

    //MEMORY MANAGEMENT
    FreeNodes(list);

    return 0;
}

/**
 * @brief  Free allocated memory in HEAP, used in linked list
 * @note   
 * @param  head: Pointer to the start of the linked list
 * @retval None
 */
void FreeNodes(node* head)
{
    // temp pointer for reference
    node* tmp = NULL;

    // iterate through the linked list until a NULL pointer is found
    while (head != NULL)
    {
       tmp = head;          // point the temp pointer to the head of the linked list pointer
       head = head->next;   // advance the head pointer to the next node
       free(tmp);           // free the current nodes memory
    }

}

/**
 * @brief  Print the contents of the linked list on the console
 * @note   
 * @param  *head: 
 * @retval None
 */
void PrintList(node *head)
{
    node *tmp = head;
    while (tmp != NULL)
    {
        printf(""%i\n"", tmp->data);
        tmp = tmp->next;
    }
    
}"
262-15051,ZakharBondia/libc11,test/stdlib/check-macros.c,7,3,16,1445687.9580393,169061.0,8.55127439208333,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0009637919720262,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* This is free and unencumbered software released into the public domain. */

#include <assert.h> /* for assert() */
#include <stdio.h>  /* for printf() */
#include <stdlib.h> /* for EXIT_SUCCESS */

int
main(void) {
  (void)EXIT_FAILURE;
  (void)EXIT_SUCCESS;

  return EXIT_SUCCESS;
}
"
174-23455,stuaxo/dosemu2,src/plugin/translate/crunch_UnicodeData.c,142,4,51,2408717.9917842,835908.0,2.8815575398249567,1370.0,1348.0,106788.0,79750.0,4826.0,3744.0,1374.0,3668.0,1500000000,0.0016058119945228,1082014363648.0,0.0032515539987654,0.0729717269403553,"#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>

#define MAX_SYMBOLS 65536
#define MAX_LETTERS 256
#define MAX_PROPERTY_LENGTH 2

typedef unsigned char t_property[MAX_PROPERTY_LENGTH+1];
static t_property properties[MAX_SYMBOLS];

#define MAX_SYMBOL_LENGTH 4

static void init_properties(void)
{
	int i;
	for(i = 0; i < MAX_SYMBOLS; i++) {
		properties[i][0] = '\0';
	}
}

static void set_property(unsigned symbol, t_property *property)
{
	if (symbol < MAX_SYMBOLS) {
		strcpy(properties[symbol], *property);
#if 0
		fprintf(stderr, ""%04x %s %s\n"",
			symbol,
			properties[symbol],
			*property);
#endif
	}
}

static void set_property_range(
	unsigned symbol_start, unsigned symbol_end, t_property *property)
{
	unsigned i;
	for(i = symbol_start; (i <= symbol_end) && (i < MAX_SYMBOLS); i++) {
		strcpy(properties[symbol_start], *property);
	}
}


static void process_UnicodeData_input(FILE *input)
{

#define STATE_RESETTING 	0
#define STATE_GETTING_SYMBOL	1
#define STATE_SKIPPING_NAME	2
#define STATE_GETTING_LETTER	3
#define STATE_GETTING_EOL	4

	int state = STATE_RESETTING;
	char symbol_digit[MAX_SYMBOL_LENGTH+1];
	int symbol_digits;
	unsigned symbol;
	t_property property;
	int property_length;
	int c;
	int line = 1;

#define next_char() \
c = getc(input); if (c < 0) break

	c = 0;
	while (c >= 0) {
		switch (state) {
		case STATE_RESETTING:
			symbol = 0;
			symbol_digits = 0;
			symbol_digit[0] = '\0';
			state = STATE_GETTING_SYMBOL;
			property[0] = '\0';
			property_length = 0;
			/* fall through */
		case STATE_GETTING_SYMBOL:
			next_char();
			if ((symbol_digits <= MAX_SYMBOL_LENGTH) &&
				(isxdigit(c))) {
				symbol_digit[symbol_digits++] = c;
			}
			else if (c == ';') {
				symbol_digit[symbol_digits] = '\0';
				symbol = strtoul(symbol_digit, 0, 16);
				state = STATE_SKIPPING_NAME;
			} else {
				fprintf(stderr, ""Bad symbol number line %d\n"", line);
				state = STATE_GETTING_EOL;
			}
			break;
		case STATE_SKIPPING_NAME:
			next_char();
			if (c == ';') {
				state = STATE_GETTING_LETTER;
			}
			break;
		case STATE_GETTING_LETTER:
			next_char();
			if ((property_length < MAX_PROPERTY_LENGTH) &&
				isalpha(c)) {
				property[property_length++] = c;
#if 0
				fprintf(stderr, ""%c\n"", c);
#endif
			}
			else if (c == ';') {
				property[property_length] = '\0';
				set_property(symbol, &property);
				state = STATE_GETTING_EOL;
			}
			else {
				fprintf(stderr, ""Can't find letter on line %d\n"", line);
				state = STATE_GETTING_EOL;
			}
			break;
		case STATE_GETTING_EOL:
			next_char();
			if (c == '\n') {
				line++;
				state = STATE_RESETTING;
			}
			break;
		}
	}
#undef STATE_RESETTING
#undef STATE_GETTING_SYMBOL
#undef STATE_SKIPPING_NAME
#undef STATE_GETTING_LETTER
#undef STATE_GETTING_EOL
}

static void create_crunched_output(char *name, FILE *output)
{
	int i;
	t_property *last_property = 0;
	fprintf(output,
		""# This file has been automatically generated by %s\n""
		""# Do not modify\n"",
		name );
	for(i = 0; i < MAX_SYMBOLS; i++) {
		if (last_property) {
			if (strcmp(*last_property, properties[i]) != 0) {
				if (last_property != &properties[i-1]) {
					fprintf(output, ""-%04X"", i-1);
				}
				fprintf(output, ""\n"");
				last_property = 0;
			}
		}
		if (!last_property && properties[i][0] != '\0') {
			last_property = &properties[i];
			fprintf(output, ""%s %04X"", *last_property, i);
		}
	}
	if (last_property) {
		if (last_property != &properties[i-1]) {
			fprintf(output, ""-%04X"", i-1);
		}
		fprintf(output, ""\n"");
	}
}

static void init(void)
{
	init_properties();
}

static int crunch_UnicodeData(char *name, FILE *in, FILE *out)
{
	init();
	process_UnicodeData_input(in);
	create_crunched_output(name, out);
	return 0;
}

int main(int argc, char **argv)
{
	return crunch_UnicodeData(argv[0], stdin, stdout);
}
"
296-9134,arante/cloc,head-first-c-bak/ex012_missing2.c,18,1,17,1412896.5558483,177136.0,7.976334567789721,1338.0,1319.0,39992.0,13847.0,1618.0,638.0,1339.0,593.0,1500000000,0.0009419310372322,1082014363648.0,0.0149997741848071,0.0777874774791508,"/* head-first-c/missing2.c
 *
 * Created by Billy Wilson Arante <arantebillywilson@gmail.com>
 * Last updated on 2017/04/01 PHT
 */

#include <stdio.h>

int main()
{
	int x = 0;
	int y = 0;
	while (x < 5) {
		y = y + 2;
		if (y > 4)
			y = y - 1;
		printf(""%i%i "", x, y);
		x = x + 1;
	}

	return 0;
}
"
000-6282,buaabarty/syspro_hw,syspro_hw1/testers/tester-5.c,68,2,45,422049428.80198354,302247942.0,1.3963682439233944,1416.0,1407.0,116557788.0,91472283.0,1595568.0,1404970.0,542203.0,1077934.0,1500000000,0.281366285867989,1082014363648.0,9.340013967737786e-06,0.0222115724798267,"#include <stdio.h>
#include <stdlib.h>

#define MIN_ALLOC_SIZE 24
#define MAX_ALLOC_SIZE 1024 * 100
#define CHANCE_OF_FREE 95
#define CHANCE_OF_REALLOC 50
#define TOTAL_ALLOCS 400000

int main()
{
    malloc(1);

    int i;
    void *realloc_ptr = NULL;
    void **dictionary = malloc(TOTAL_ALLOCS * sizeof(void *));
    int *dictionary_elem_size = malloc(TOTAL_ALLOCS * sizeof(int));
    int dictionary_ct = 0;
    int data_written = 0;

    for (i = 0; i < TOTAL_ALLOCS; i++)
    {
        int size = (rand() % (MAX_ALLOC_SIZE - MIN_ALLOC_SIZE + 1)) + MIN_ALLOC_SIZE;
        void *ptr;

        if (realloc_ptr == NULL)
        {
            ptr = malloc(size);
            data_written = 0;
        }
        else
        {
            ptr = realloc(realloc_ptr, size);
            realloc_ptr = NULL;
        }


        if (ptr == NULL)
        {
            printf(""Memory failed to allocate!\n"");
            return 1;
        }

        if (rand() % 100 < CHANCE_OF_FREE) {
            //printf(""hey we want to free!\n"");
            free(ptr);
        }
        else
        {
            if (!data_written)
            {
                *((void **)ptr) = &dictionary[dictionary_ct];
                data_written = 1;
            }

            if (rand() % 100 < CHANCE_OF_REALLOC)
                realloc_ptr = ptr;
            else
            {
                *((void **)(ptr + size - sizeof(void *))) = &dictionary[dictionary_ct];
                dictionary[dictionary_ct] = ptr;
                dictionary_elem_size[dictionary_ct] = size;
                dictionary_ct++;
            }
        }
    }

    for (i = dictionary_ct - 1; i >= 0; i--)
    {
        if ( *((void **)dictionary[i]) != &dictionary[i] )
        {
            printf(""Memory failed to contain correct data after many allocations (beginning of segment)!\n"");
            return 100;
        }

        if ( *((void **)(dictionary[i] + dictionary_elem_size[i] - sizeof(void *))) != &dictionary[i] )
        {
            printf(""Memory failed to contain correct data after many allocations (end of segment)!\n"");
            return 101;
        }
        //printf(""free dictionary %p\n"", dictionary[i]);
        free(dictionary[i]);
    }

    printf(""Memory was allocated and freed!\n"");
    return 0;
}
"
000-15547,Spacial/csstuff,Algorithms/C/1list/exerc09.c,57,4,36,2247696.04392345,325092.0,6.914030489830571,1371.0,1348.0,72089.0,36050.0,1634.0,652.0,1353.0,609.0,1500000000,0.0014984640292823,1082014363648.0,0.0083637862512765,0.0392827749470588,"/*
9. Um coeficiente binomial, geralmente denotado (n?k), representa o número de possı́veis combinações de n
    elementos tomados k a k. Um “Triângulo de Pascal”, uma homenagem ao grande matemático Blaise
    Pascal, é uma tabela de valores de coeficientes combinatoriais para pequenos valores de n e k. Os
    números que não são mostrados na tabela têm valor zero. Este triângulo pode ser construı́do auto-
    maticamente usando-se uma propriedade conhecida dos coeficientes binomiais, denominada “fórmula
    da adição"": (r?k) = (r-1 ?k ) + (r-1 ? k-1) ou seja, cada elemento do triângulo é a soma de dois
    elementos da linha anterior, um da mesma coluna e um da coluna anterior. Veja um exemplo de um triângulo de
    Pascal com 7 linhas:
    1
    1 1
    1 2 1
    1 3 3 1
    1 4 6 4 1
    1 5 10 10 5 1
    1 6 15 20 15 6 1

    Faça um programa em que imprima na tela um triângulo de Pascal com 10 linhas. Seu programa deve
    obrigatoriamente fazer uso de exatamente dois vetores durante o processo de construção. Um deles
    conterá a última linha ı́mpar gerada, enquanto que o outro conterá a última linha par gerada.

*/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define ANSI_COLOR_RED     ""\x1b[31m""
#define ANSI_COLOR_GREEN   ""\x1b[32m""
#define ANSI_COLOR_YELLOW  ""\x1b[33m""
#define ANSI_COLOR_BLUE    ""\x1b[34m""
#define ANSI_COLOR_MAGENTA ""\x1b[35m""
#define ANSI_COLOR_CYAN    ""\x1b[36m""
#define ANSI_COLOR_RESET   ""\x1b[0m""

#define RESET   ""\033[1;25r""

#define DEBUG 0

#define TAMANHO 20

void mostra(int *seq, int tam);

void mostrad(int *seq, int destaque, int tam);

int main(){
 	int *bp = NULL, k=0, tam=1;
	bp = malloc(sizeof(int)*TAMANHO);
	for (int i=0; i < TAMANHO; i++)
        bp[i]=0;
	bp[0]=1;
	printf(""1\n"");
    do {
        if (DEBUG){
            printf(""Loop>> k: %d, t: %d\n"",k,tam);
        }
        bp[tam++] = 1;
        mostra(bp,tam);
        for(int i=(tam-1); i > 0; i--){
            bp[i] = bp[i-1] + bp[i];
        }
        k++;
    } while (k < TAMANHO);
    return 0;
}

void mostra(int *seq, int tam){
    mostrad(seq,-1,tam);
}

void mostrad(int *seq, int destaque, int tam){
    for(int x=0; x<tam;x++){
        if (x==destaque)
            printf(ANSI_COLOR_RED""%d ""ANSI_COLOR_RESET ,seq[x]);
        else
            printf(""%d "",seq[x]);
	}
	printf(""\n"");
    if (DEBUG){
                printf(""Mostrou com: dest: %d, tam: %d\n"",destaque,tam);
    }
}
"
208-15157,mattstock/binutils-bexkat1,gdb/testsuite/gdb.mi/pr11022.c,24,2,20,1384006.23109185,169084.0,8.18246552009652,1142.0,1132.0,38460.0,12697.0,1568.0,585.0,1317.0,546.0,1500000000,0.0009226708207279,1082014363648.0,0.0134489366232168,0.078503430615556,"/* This test is part of GDB, the GNU debugger.

   Copyright 2009-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int x;

int
main ()
{
  int i, j;

  for (i = 0; i < 500; ++i) {
    j = 0;  /* break here */
    x = 42;
    j = i;  /* expect HW watchpoint stop */
  }
  return 0;
}
"
192-22604,jentszej/RepDoJezProg,Lab6/zad1.c,68,2,42,1636340.9813493,179489.0,9.11665895960198,1346.0,1323.0,40746.0,14136.0,1644.0,642.0,1360.0,599.0,1500000000,0.0010908939875662,1082014363648.0,0.0148699920329379,0.0773477642943041,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX_DL_SLOWA 30
typedef struct sl
{
  char slowo[MAX_DL_SLOWA];
  struct sl* dalej;
}* lista;
//=======================================================
int pusta(lista lis)
{
  // jesli  lis  jest lista pusta (wskaznik  NULL)
  // to wartoscia jest liczba rozna od 0, w przeciwnym razie 0
  if(lis==NULL) return 1;
  else return 0;
}
//=======================================================
char* pierwsze(lista lis)
{
  // zwraca pierwsze slowo z listy  lis
  // jesli jest pusta, to dzialanie nieokreslone
  return lis->slowo;
}
//=======================================================
lista reszta(lista lis)
{
  // zwraca liste  lis  z usunietym pierwszym slowem
  // jesli jest pusta, to dzialanie nieokreslone
  return lis->dalej;
}
//=======================================================
lista dolacz(char slow[MAX_DL_SLOWA], lista lis)
{
  // dolacza  slowo  do poczatku listy  lis
  lista pom = (lista)(malloc(sizeof(struct sl)));
  strcpy(pom->slowo, slow);
  pom->dalej=lis;
  return pom;
}
//=======================================================
void druk(lista lis)
{
  // drukuje po kolei wszystkie slowa z  lis
  lista wynik = lis;
  while(wynik!=NULL)
  {
    printf(""%s "", wynik->slowo);
    wynik=wynik->dalej;
  }
}
//=======================================================
lista odwroc(lista lis)
{
  // odwraca liste  lis  od konca
  lista pom=NULL;
  char slowo[MAX_DL_SLOWA];
  while(!pusta(lis))
  {
    strcpy(slowo, pierwsze(lis));
    lis=reszta(lis);
    pom=dolacz(slowo, pom);
  }
  return pom;
}
//=======================================================
int main()
{
  lista lis=NULL;
  lis=dolacz(""abc"", dolacz(""def"", dolacz(""ghi"", lis)));
  druk(odwroc(lis));
}
"
153-15556,czankel/xtensa-glibc,stdlib/tst-strtoll.c,374,4,310,2185848.0758964,670062.0,3.2621578301709397,1417.0,1391.0,131865.0,66943.0,2024.0,828.0,1546.0,785.0,1500000000,0.0014572320505976,1082014363648.0,0.0041906569839805,0.026070379461591,"/* My bet is this was written by Chris Torek.
   I reformatted and ansidecl-ized it, and tweaked it a little.  */

#include <ctype.h>
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

struct ltest
  {
    const char *str;		/* Convert this.  */
    unsigned long long int expect;	/* To get this.  */
    int base;			/* Use this base.  */
    char left;			/* With this left over.  */
    int err;			/* And this in errno.  */
  };
static const struct ltest tests[] =
  {
  /* First, signed numbers:  */
  /* simple... */
  {""123"", 123, 0, 0, 0},
  {""+123"", 123, 0, 0, 0},
  {""  123"", 123, 0, 0, 0},
  {"" 123 "", 123, 0, ' ', 0},
  {""   -17"", -17, 0, 0, 0},

  /* implicit base... */
  {""0123"", 0123, 0, 0, 0},
  {""0123a"", 0123, 0, 'a', 0},
  {""01239"", 0123, 0, '9', 0},
  {""0x123"", 0x123, 0, 0, 0},
  {""-0x123"", -0x123, 0, 0, 0},
  {""0x0xc"", 0, 0, 'x', 0},
  {"" +0x123fg"", 0x123f, 0, 'g', 0},

  /* explicit base... */
  {""123"", 0x123, 16, 0, 0},
  {""0x123"", 0x123, 16, 0, 0},
  {""123"", 0123, 8, 0, 0},
  {""0123"", 0123, 8, 0, 0},
  {""0123"", 123, 10, 0, 0},
  {""0x123"", 0, 10, 'x', 0},

  /* case insensitivity... */
  {""abcd"", 0xabcd, 16, 0, 0},
  {""AbCd"", 0xabcd, 16, 0, 0},
  {""0xABCD"", 0xabcd, 16, 0, 0},
  {""0Xabcd"", 0xabcd, 16, 0, 0},

  /* odd bases... */
  {""0xyz"", 33 * 35 + 34, 35, 'z', 0},
  {""yz!"", 34 * 36 + 35, 36, '!', 0},
  {""-yz"", -(34*36 + 35), 36, 0, 0},
  {""GhI4"", ((16*20 + 17)*20 + 18)*20 + 4, 20, 0, 0},

  /* special case for the 32-bit version of strtoll,
     from a ncftp configure test */
  {""99000000001"", 1000000000ll * 99ll + 1ll, 0, 0},

  /* extremes... */
  {""9223372036854775807"", 9223372036854775807ll, 0, 0, 0},
  {""9223372036854775808"", 9223372036854775807ll, 0, 0, ERANGE},
  {""922337203685477580777"", 9223372036854775807ll, 0, 0, ERANGE},
  {""9223372036854775810"", 9223372036854775807ll, 0, 0, ERANGE},
  {""-2147483648"", -2147483648ll, 0, 0, 0},
  {""-9223372036854775808"", -9223372036854775807ll - 1, 0, 0, 0},
  {""-9223372036854775809"", -9223372036854775807ll - 1, 0, 0, ERANGE},
  {""0x112233445566778899z"", 9223372036854775807ll, 16, 'z', ERANGE},
  {""0xFFFFFFFFFFFF00FF"" , 9223372036854775807ll, 0, 0, ERANGE},

  {""111111111111111111111111111111111111111111111111111111111111111"",
   9223372036854775807ll, 2, 0, 0},
  {""1000000000000000000000000000000000000000000000000000000000000000"",
   9223372036854775807ll, 2, 0, ERANGE},
  {""2021110011022210012102010021220101220221"",
   9223372036854775807ll, 3, 0, 0},
  {""2021110011022210012102010021220101220222"",
   9223372036854775807ll, 3, 0, ERANGE},
  {""13333333333333333333333333333333"", 9223372036854775807ll, 4, 0, 0},
  {""20000000000000000000000000000000"", 9223372036854775807ll, 4, 0, ERANGE},
  {""1104332401304422434310311212"", 9223372036854775807ll, 5, 0, 0},
  {""1104332401304422434310311213"", 9223372036854775807ll, 5, 0, ERANGE},
  {""1540241003031030222122211"", 9223372036854775807ll, 6, 0, 0},
  {""1540241003031030222122212"", 9223372036854775807ll, 6, 0, ERANGE},
  {""22341010611245052052300"", 9223372036854775807ll, 7, 0, 0},
  {""22341010611245052052301"", 9223372036854775807ll, 7, 0, ERANGE},
  {""777777777777777777777"", 9223372036854775807ll, 8, 0, 0},
  {""1000000000000000000000"", 9223372036854775807ll, 8, 0, ERANGE},
  {""67404283172107811827"", 9223372036854775807ll, 9, 0, 0},
  {""67404283172107811828"", 9223372036854775807ll, 9, 0, ERANGE},
  {""9223372036854775807"", 9223372036854775807ll, 10, 0, 0},
  {""9223372036854775808"", 9223372036854775807ll, 10, 0, ERANGE},
  {""1728002635214590697"", 9223372036854775807ll, 11, 0, 0},
  {""1728002635214590698"", 9223372036854775807ll, 11, 0, ERANGE},
  {""41a792678515120367"", 9223372036854775807ll, 12, 0, 0},
  {""41a792678515120368"", 9223372036854775807ll, 12, 0, ERANGE},
  {""10b269549075433c37"", 9223372036854775807ll, 13, 0, 0},
  {""10b269549075433c38"", 9223372036854775807ll, 13, 0, ERANGE},
  {""4340724c6c71dc7a7"", 9223372036854775807ll, 14, 0, 0},
  {""4340724c6c71dc7a8"", 9223372036854775807ll, 14, 0, ERANGE},
  {""160e2ad3246366807"", 9223372036854775807ll, 15, 0, 0},
  {""160e2ad3246366808"", 9223372036854775807ll, 15, 0, ERANGE},
  {""7fffffffffffffff"", 9223372036854775807ll, 16, 0, 0},
  {""8000000000000000"", 9223372036854775807ll, 16, 0, ERANGE},
  {""33d3d8307b214008"", 9223372036854775807ll, 17, 0, 0},
  {""33d3d8307b214009"", 9223372036854775807ll, 17, 0, ERANGE},
  {""16agh595df825fa7"", 9223372036854775807ll, 18, 0, 0},
  {""16agh595df825fa8"", 9223372036854775807ll, 18, 0, ERANGE},
  {""ba643dci0ffeehh"", 9223372036854775807ll, 19, 0, 0},
  {""ba643dci0ffeehi"", 9223372036854775807ll, 19, 0, ERANGE},
  {""5cbfjia3fh26ja7"", 9223372036854775807ll, 20, 0, 0},
  {""5cbfjia3fh26ja8"", 9223372036854775807ll, 20, 0, ERANGE},
  {""2heiciiie82dh97"", 9223372036854775807ll, 21, 0, 0},
  {""2heiciiie82dh98"", 9223372036854775807ll, 21, 0, ERANGE},
  {""1adaibb21dckfa7"", 9223372036854775807ll, 22, 0, 0},
  {""1adaibb21dckfa8"", 9223372036854775807ll, 22, 0, ERANGE},
  {""i6k448cf4192c2"", 9223372036854775807ll, 23, 0, 0},
  {""i6k448cf4192c3"", 9223372036854775807ll, 23, 0, ERANGE},
  {""acd772jnc9l0l7"", 9223372036854775807ll, 24, 0, 0},
  {""acd772jnc9l0l8"", 9223372036854775807ll, 24, 0, ERANGE},
  {""64ie1focnn5g77"", 9223372036854775807ll, 25, 0, 0},
  {""64ie1focnn5g78"", 9223372036854775807ll, 25, 0, ERANGE},
  {""3igoecjbmca687"", 9223372036854775807ll, 26, 0, 0},
  {""3igoecjbmca688"", 9223372036854775807ll, 26, 0, ERANGE},
  {""27c48l5b37oaop"", 9223372036854775807ll, 27, 0, 0},
  {""27c48l5b37oaoq"", 9223372036854775807ll, 27, 0, ERANGE},
  {""1bk39f3ah3dmq7"", 9223372036854775807ll, 28, 0, 0},
  {""1bk39f3ah3dmq8"", 9223372036854775807ll, 28, 0, ERANGE},
  {""q1se8f0m04isb"", 9223372036854775807ll, 29, 0, 0},
  {""q1se8f0m04isc"", 9223372036854775807ll, 29, 0, ERANGE},
  {""hajppbc1fc207"", 9223372036854775807ll, 30, 0, 0},
  {""hajppbc1fc208"", 9223372036854775807ll, 30, 0, ERANGE},
  {""bm03i95hia437"", 9223372036854775807ll, 31, 0, 0},
  {""bm03i95hia438"", 9223372036854775807ll, 31, 0, ERANGE},
  {""7vvvvvvvvvvvv"", 9223372036854775807ll, 32, 0, 0},
  {""8000000000000"", 9223372036854775807ll, 32, 0, ERANGE},
  {""5hg4ck9jd4u37"", 9223372036854775807ll, 33, 0, 0},
  {""5hg4ck9jd4u38"", 9223372036854775807ll, 33, 0, ERANGE},
  {""3tdtk1v8j6tpp"", 9223372036854775807ll, 34, 0, 0},
  {""3tdtk1v8j6tpq"", 9223372036854775807ll, 34, 0, ERANGE},
  {""2pijmikexrxp7"", 9223372036854775807ll, 35, 0, 0},
  {""2pijmikexrxp8"", 9223372036854775807ll, 35, 0, ERANGE},
  {""1y2p0ij32e8e7"", 9223372036854775807ll, 36, 0, 0},
  {""1y2p0ij32e8e8"", 9223372036854775807ll, 36, 0, ERANGE},

  {""-1000000000000000000000000000000000000000000000000000000000000000"",
   -9223372036854775808ull, 2, 0, 0},
  {""-1000000000000000000000000000000000000000000000000000000000000001"",
   -9223372036854775808ull, 2, 0, ERANGE},
  {""-2021110011022210012102010021220101220222"",
   -9223372036854775808ull, 3, 0, 0},
  {""-2021110011022210012102010021220101221000"",
   -9223372036854775808ull, 3, 0, ERANGE},
  {""-20000000000000000000000000000000"", -9223372036854775808ull, 4, 0, 0},
  {""-20000000000000000000000000000001"", -9223372036854775808ull, 4, 0, ERANGE},
  {""-1104332401304422434310311213"", -9223372036854775808ull, 5, 0, 0},
  {""-1104332401304422434310311214"", -9223372036854775808ull, 5, 0, ERANGE},
  {""-1540241003031030222122212"", -9223372036854775808ull, 6, 0, 0},
  {""-1540241003031030222122213"", -9223372036854775808ull, 6, 0, ERANGE},
  {""-22341010611245052052301"", -9223372036854775808ull, 7, 0, 0},
  {""-22341010611245052052302"", -9223372036854775808ull, 7, 0, ERANGE},
  {""-1000000000000000000000"", -9223372036854775808ull, 8, 0, 0},
  {""-1000000000000000000001"", -9223372036854775808ull, 8, 0, ERANGE},
  {""-67404283172107811828"", -9223372036854775808ull, 9, 0, 0},
  {""-67404283172107811830"", -9223372036854775808ull, 9, 0, ERANGE},
  {""-9223372036854775808"", -9223372036854775808ull, 10, 0, 0},
  {""-9223372036854775809"", -9223372036854775808ull, 10, 0, ERANGE},
  {""-1728002635214590698"", -9223372036854775808ull, 11, 0, 0},
  {""-1728002635214590699"", -9223372036854775808ull, 11, 0, ERANGE},
  {""-41a792678515120368"", -9223372036854775808ull, 12, 0, 0},
  {""-41a792678515120369"", -9223372036854775808ull, 12, 0, ERANGE},
  {""-10b269549075433c38"", -9223372036854775808ull, 13, 0, 0},
  {""-10b269549075433c39"", -9223372036854775808ull, 13, 0, ERANGE},
  {""-4340724c6c71dc7a8"", -9223372036854775808ull, 14, 0, 0},
  {""-4340724c6c71dc7a9"", -9223372036854775808ull, 14, 0, ERANGE},
  {""-160e2ad3246366808"", -9223372036854775808ull, 15, 0, 0},
  {""-160e2ad3246366809"", -9223372036854775808ull, 15, 0, ERANGE},
  {""-8000000000000000"", -9223372036854775808ull, 16, 0, 0},
  {""-8000000000000001"", -9223372036854775808ull, 16, 0, ERANGE},
  {""-33d3d8307b214009"", -9223372036854775808ull, 17, 0, 0},
  {""-33d3d8307b21400a"", -9223372036854775808ull, 17, 0, ERANGE},
  {""-16agh595df825fa8"", -9223372036854775808ull, 18, 0, 0},
  {""-16agh595df825fa9"", -9223372036854775808ull, 18, 0, ERANGE},
  {""-ba643dci0ffeehi"", -9223372036854775808ull, 19, 0, 0},
  {""-ba643dci0ffeei0"", -9223372036854775808ull, 19, 0, ERANGE},
  {""-5cbfjia3fh26ja8"", -9223372036854775808ull, 20, 0, 0},
  {""-5cbfjia3fh26ja9"", -9223372036854775808ull, 20, 0, ERANGE},
  {""-2heiciiie82dh98"", -9223372036854775808ull, 21, 0, 0},
  {""-2heiciiie82dh99"", -9223372036854775808ull, 21, 0, ERANGE},
  {""-1adaibb21dckfa8"", -9223372036854775808ull, 22, 0, 0},
  {""-1adaibb21dckfa9"", -9223372036854775808ull, 22, 0, ERANGE},
  {""-i6k448cf4192c3"", -9223372036854775808ull, 23, 0, 0},
  {""-i6k448cf4192c4"", -9223372036854775808ull, 23, 0, ERANGE},
  {""-acd772jnc9l0l8"", -9223372036854775808ull, 24, 0, 0},
  {""-acd772jnc9l0l9"", -9223372036854775808ull, 24, 0, ERANGE},
  {""-64ie1focnn5g78"", -9223372036854775808ull, 25, 0, 0},
  {""-64ie1focnn5g79"", -9223372036854775808ull, 25, 0, ERANGE},
  {""-3igoecjbmca688"", -9223372036854775808ull, 26, 0, 0},
  {""-3igoecjbmca689"", -9223372036854775808ull, 26, 0, ERANGE},
  {""-27c48l5b37oaoq"", -9223372036854775808ull, 27, 0, 0},
  {""-27c48l5b37oap0"", -9223372036854775808ull, 27, 0, ERANGE},
  {""-1bk39f3ah3dmq8"", -9223372036854775808ull, 28, 0, 0},
  {""-1bk39f3ah3dmq9"", -9223372036854775808ull, 28, 0, ERANGE},
  {""-q1se8f0m04isc"", -9223372036854775808ull, 29, 0, 0},
  {""-q1se8f0m04isd"", -9223372036854775808ull, 29, 0, ERANGE},
  {""-hajppbc1fc208"", -9223372036854775808ull, 30, 0, 0},
  {""-hajppbc1fc209"", -9223372036854775808ull, 30, 0, ERANGE},
  {""-bm03i95hia438"", -9223372036854775808ull, 31, 0, 0},
  {""-bm03i95hia439"", -9223372036854775808ull, 31, 0, ERANGE},
  {""-8000000000000"", -9223372036854775808ull, 32, 0, 0},
  {""-8000000000001"", -9223372036854775808ull, 32, 0, ERANGE},
  {""-5hg4ck9jd4u38"", -9223372036854775808ull, 33, 0, 0},
  {""-5hg4ck9jd4u39"", -9223372036854775808ull, 33, 0, ERANGE},
  {""-3tdtk1v8j6tpq"", -9223372036854775808ull, 34, 0, 0},
  {""-3tdtk1v8j6tpr"", -9223372036854775808ull, 34, 0, ERANGE},
  {""-2pijmikexrxp8"", -9223372036854775808ull, 35, 0, 0},
  {""-2pijmikexrxp9"", -9223372036854775808ull, 35, 0, ERANGE},
  {""-1y2p0ij32e8e8"", -9223372036854775808ull, 36, 0, 0},
  {""-1y2p0ij32e8e9"", -9223372036854775808ull, 36, 0, ERANGE},
  {NULL, 0, 0, 0, 0},

  /* Then unsigned.  */
  {""  0"", 0, 0, 0, 0},
  {""0xffffffffg"", 0xffffffff, 0, 'g', 0},
  {""0xffffffffffffffffg"", 0xffffffffffffffffull, 0, 'g', 0},
  {""-0xfedcba987654321"", 0xf0123456789abcdfull, 0, 0, 0},
  {""0xf1f2f3f4f5f6f7f8f9"", 0xffffffffffffffffull, 0, 0, ERANGE},
  {""-0x123456789abcdef01"", 0xffffffffffffffffull, 0, 0, ERANGE},

  {""1111111111111111111111111111111111111111111111111111111111111111"",
   0xffffffffffffffff, 2, 0, 0},
  {""10000000000000000000000000000000000000000000000000000000000000000"",
   0xffffffffffffffff, 2, 0, ERANGE},
  {""11112220022122120101211020120210210211220"",
   0xffffffffffffffff, 3, 0, 0},
  {""11112220022122120101211020120210210211221"",
   0xffffffffffffffff, 3, 0, ERANGE},
  {""33333333333333333333333333333333"", 0xffffffffffffffff, 4, 0, 0},
  {""100000000000000000000000000000000"", 0xffffffffffffffff, 4, 0, ERANGE},
  {""2214220303114400424121122430"", 0xffffffffffffffff, 5, 0, 0},
  {""2214220303114400424121122431"", 0xffffffffffffffff, 5, 0, ERANGE},
  {""3520522010102100444244423"", 0xffffffffffffffff, 6, 0, 0},
  {""3520522010102100444244424"", 0xffffffffffffffff, 6, 0, ERANGE},
  {""45012021522523134134601"", 0xffffffffffffffff, 7, 0, 0},
  {""45012021522523134134602"", 0xffffffffffffffff, 7, 0, ERANGE},
  {""1777777777777777777777"", 0xffffffffffffffff, 8, 0, 0},
  {""2000000000000000000000"", 0xffffffffffffffff, 8, 0, ERANGE},
  {""145808576354216723756"", 0xffffffffffffffff, 9, 0, 0},
  {""145808576354216723757"", 0xffffffffffffffff, 9, 0, ERANGE},
  {""18446744073709551615"", 0xffffffffffffffff, 10, 0, 0},
  {""18446744073709551616"", 0xffffffffffffffff, 10, 0, ERANGE},
  {""335500516a429071284"", 0xffffffffffffffff, 11, 0, 0},
  {""335500516a429071285"", 0xffffffffffffffff, 11, 0, ERANGE},
  {""839365134a2a240713"", 0xffffffffffffffff, 12, 0, 0},
  {""839365134a2a240714"", 0xffffffffffffffff, 12, 0, ERANGE},
  {""219505a9511a867b72"", 0xffffffffffffffff, 13, 0, 0},
  {""219505a9511a867b73"", 0xffffffffffffffff, 13, 0, ERANGE},
  {""8681049adb03db171"", 0xffffffffffffffff, 14, 0, 0},
  {""8681049adb03db172"", 0xffffffffffffffff, 14, 0, ERANGE},
  {""2c1d56b648c6cd110"", 0xffffffffffffffff, 15, 0, 0},
  {""2c1d56b648c6cd111"", 0xffffffffffffffff, 15, 0, ERANGE},
  {""ffffffffffffffff"", 0xffffffffffffffff, 16, 0, 0},
  {""10000000000000000"", 0xffffffffffffffff, 16, 0, ERANGE},
  {""67979g60f5428010"", 0xffffffffffffffff, 17, 0, 0},
  {""67979g60f5428011"", 0xffffffffffffffff, 17, 0, ERANGE},
  {""2d3fgb0b9cg4bd2f"", 0xffffffffffffffff, 18, 0, 0},
  {""2d3fgb0b9cg4bd2g"", 0xffffffffffffffff, 18, 0, ERANGE},
  {""141c8786h1ccaagg"", 0xffffffffffffffff, 19, 0, 0},
  {""141c8786h1ccaagh"", 0xffffffffffffffff, 19, 0, ERANGE},
  {""b53bjh07be4dj0f"", 0xffffffffffffffff, 20, 0, 0},
  {""b53bjh07be4dj0g"", 0xffffffffffffffff, 20, 0, ERANGE},
  {""5e8g4ggg7g56dif"", 0xffffffffffffffff, 21, 0, 0},
  {""5e8g4ggg7g56dig"", 0xffffffffffffffff, 21, 0, ERANGE},
  {""2l4lf104353j8kf"", 0xffffffffffffffff, 22, 0, 0},
  {""2l4lf104353j8kg"", 0xffffffffffffffff, 22, 0, ERANGE},
  {""1ddh88h2782i515"", 0xffffffffffffffff, 23, 0, 0},
  {""1ddh88h2782i516"", 0xffffffffffffffff, 23, 0, ERANGE},
  {""l12ee5fn0ji1if"", 0xffffffffffffffff, 24, 0, 0},
  {""l12ee5fn0ji1ig"", 0xffffffffffffffff, 24, 0, ERANGE},
  {""c9c336o0mlb7ef"", 0xffffffffffffffff, 25, 0, 0},
  {""c9c336o0mlb7eg"", 0xffffffffffffffff, 25, 0, ERANGE},
  {""7b7n2pcniokcgf"", 0xffffffffffffffff, 26, 0, 0},
  {""7b7n2pcniokcgg"", 0xffffffffffffffff, 26, 0, ERANGE},
  {""4eo8hfam6fllmo"", 0xffffffffffffffff, 27, 0, 0},
  {""4eo8hfam6fllmp"", 0xffffffffffffffff, 27, 0, ERANGE},
  {""2nc6j26l66rhof"", 0xffffffffffffffff, 28, 0, 0},
  {""2nc6j26l66rhog"", 0xffffffffffffffff, 28, 0, ERANGE},
  {""1n3rsh11f098rn"", 0xffffffffffffffff, 29, 0, 0},
  {""1n3rsh11f098ro"", 0xffffffffffffffff, 29, 0, ERANGE},
  {""14l9lkmo30o40f"", 0xffffffffffffffff, 30, 0, 0},
  {""14l9lkmo30o40g"", 0xffffffffffffffff, 30, 0, ERANGE},
  {""nd075ib45k86f"", 0xffffffffffffffff, 31, 0, 0},
  {""nd075ib45k86g"", 0xffffffffffffffff, 31, 0, ERANGE},
  {""fvvvvvvvvvvvv"", 0xffffffffffffffff, 32, 0, 0},
  {""g000000000000"", 0xffffffffffffffff, 32, 0, ERANGE},
  {""b1w8p7j5q9r6f"", 0xffffffffffffffff, 33, 0, 0},
  {""b1w8p7j5q9r6g"", 0xffffffffffffffff, 33, 0, ERANGE},
  {""7orp63sh4dphh"", 0xffffffffffffffff, 34, 0, 0},
  {""7orp63sh4dphi"", 0xffffffffffffffff, 34, 0, ERANGE},
  {""5g24a25twkwff"", 0xffffffffffffffff, 35, 0, 0},
  {""5g24a25twkwfg"", 0xffffffffffffffff, 35, 0, ERANGE},
  {""3w5e11264sgsf"", 0xffffffffffffffff, 36, 0, 0},
  {""3w5e11264sgsg"", 0xffffffffffffffff, 36, 0, ERANGE},
  {NULL, 0, 0, 0, 0},
  };

/* Prototypes for local functions.  */
static void expand (char *dst, int c);

int
main (void)
{
  register const struct ltest *lt;
  char *ep;
  int status = 0;
  int save_errno;

  for (lt = tests; lt->str != NULL; ++lt)
    {
      register long long int l;

      errno = 0;
      l = strtoll (lt->str, &ep, lt->base);
      save_errno = errno;
      printf (""strtoll(\""%s\"", , %d) test %u"",
	      lt->str, lt->base, (unsigned int) (lt - tests));
      if (l == (long long int) lt->expect && *ep == lt->left
	  && save_errno == lt->err)
	puts(""\tOK"");
      else
	{
	  puts(""\tBAD"");
	  if (l != (long long int) lt->expect)
	    printf(""  returns %lld, expected %lld\n"",
		   l, (long long int) lt->expect);
	  if (lt->left != *ep)
	    {
	      char exp1[5], exp2[5];
	      expand (exp1, *ep);
	      expand (exp2, lt->left);
	      printf (""  leaves '%s', expected '%s'\n"", exp1, exp2);
	    }
	  if (save_errno != lt->err)
	    printf (""  errno %d (%s)  instead of %d (%s)\n"",
		    save_errno, strerror (save_errno),
		    lt->err, strerror (lt->err));
	  status = 1;
	}
    }

  for (++lt; lt->str != NULL; lt++)
    {
      register unsigned long long int ul;

      errno = 0;
      ul = strtoull (lt->str, &ep, lt->base);
      save_errno = errno;
      printf (""strtoull(\""%s\"", , %d) test %u"",
	      lt->str, lt->base, (unsigned int) (lt - tests));
      if (ul == lt->expect && *ep == lt->left && save_errno == lt->err)
	puts(""\tOK"");
      else
	{
	  puts (""\tBAD"");
	  if (ul != lt->expect)
	    printf (""  returns %llu, expected %llu\n"",
		    ul, lt->expect);
	  if (lt->left != *ep)
	    {
	      char exp1[5], exp2[5];
	      expand (exp1, *ep);
	      expand (exp2, lt->left);
	      printf (""  leaves '%s', expected '%s'\n"", exp1, exp2);
	    }
	  if (save_errno != lt->err)
	    printf (""  errno %d (%s) instead of %d (%s)\n"",
		    save_errno, strerror (save_errno),
		    lt->err, strerror (lt->err));
	  status = 1;
	}
    }

  return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

static void
expand (dst, c)
     char *dst;
     int c;
{
  if (isprint (c))
    {
      dst[0] = c;
      dst[1] = '\0';
    }
  else
    (void) sprintf (dst, ""%#.3o"", (unsigned int) c);
}
"
384-17488,xiaoehaier/leetcode,Length-of-Last-Word.c,18,1,20,1758032.9440533,174595.0,10.069200148916062,1337.0,1316.0,39554.0,13479.0,1624.0,633.0,1346.0,590.0,1500000000,0.0011720219627022,1082014363648.0,0.015195165955497,0.0790639790319235,"#include <ctype.h>

int lengthOfLastWord(char *s) {
    char *start = s, *end = s;
    
    while(*s){
        if(*s == ' ' && isalpha(*(s+1)))
            start = s+1;
            
        if(!isalpha(*(s+1)) && isalpha(*s))
            end = s+1;
            
        ++s;
    }
    
    return end>start ? end-start : 0;
}

int main(int argc, char const *argv[])
{
    char *s = ""    as     ddfdf fss       "";
    printf(""%d\n"", *s);
    printf(""%d\n"", lengthOfLastWord(s));
    return 0;
}"
099-35012,Gurgel100/gcc,gcc/testsuite/gcc.dg/guality/pr90131.c,34,5,31,1622417.94168945,169140.0,9.592154428284262,1143.0,1133.0,38471.0,12709.0,1569.0,585.0,1318.0,546.0,1500000000,0.0010816119611263,1082014363648.0,0.0134563083835875,0.0785072293864791,"/* { dg-do run } */
/* { dg-options ""-g"" } */

void __attribute__((noinline))
optimize_me_not ()
{
  __asm__ volatile ("""" : : : ""memory"");
}
volatile long a;
int b[9][1];
static short c[2][1] = {3};
int main()
{
  int i, d, e;
  i = 0;
  for (; i < 9; i++)
    a = b[i][0];
  i = 0;
  for (; i < 2; i++)
    {
      d = 0;
      for (; d < 1; d++)
	{
	  e = 0;
	  for (; e < 1; e++)
	    a = c[i][e];
	  /* i may very well be optimized out, so we cannot test for i == 0.
	     Instead test i + 1 which will make the test UNSUPPORTED if i
	     is optimized out.  Since the test previously had wrong debug
	     with i == 9 this is acceptable.  */
	  optimize_me_not(); /* { dg-final { gdb-test . ""i + 1"" ""1"" } } */
	}
    }
  return 0;
}
"
091-3858,mattstock/binutils-bexkat1,gdb/testsuite/gdb.btrace/enable-running.c,32,4,24,15009288563.858717,180126.0,83326.60783562617,1381.0,1355.0,41159.0,14464.0,1643.0,715.0,1358.0,671.0,1500000000,10.006192375905812,1082014363648.0,0.01518936744279,0.0788702515146612,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2017-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <pthread.h>
#include <unistd.h>

#define NTHREADS 3

static void *
test (void *arg)
{
  /* Let's hope this is long enough for GDB to enable tracing and check that
     everything is working as expected.  */
  sleep (10);

  return arg;
}

int
main (void)
{
  pthread_t th[NTHREADS];
  int i;

  for (i = 0; i < NTHREADS; ++i)
    pthread_create (&th[i], NULL, test, NULL);

  test (NULL); /* bp.1 */

  for (i = 0; i < NTHREADS; ++i)
    pthread_join (th[i], NULL);

  return 0;
}
"
147-27258,danielmapar/TheCProgrammingLanguage,src/Chapter-1/Sections/1.2-VariablesandArithmeticExpressions-1.c,29,2,32,2258914.52282655,189040.0,11.949396953025817,1343.0,1324.0,42286.0,15380.0,1617.0,637.0,1339.0,595.0,1500000000,0.0015059430152177,1082014363648.0,0.0141081252644942,0.0726251170533763,"/*
 ============================================================================
 Name        : 1.2-VariablesandArithmeticExpressions-1.c
 Author      : Daniel Marchena Parreira
 Email       : danielmapar@gmail.com
 Date        : 02/11/2013
 Version     : 0.1
 Copyright   : GNU General Public License Version 2
 Description : Fahrenheit-Celsius table
 ============================================================================
 */

#include <stdio.h>

/* print Fahrenheit-Celsius table
   for fahr = 0, 20, ..., 300 */

int main(void)
{

	int fahr, celsius;
	int lower, upper, step;

	lower = 0;   /* lower limit of temperature scale */
	upper = 300; /* upper limit */
	step  = 20;  /* step size */

	fahr = lower;
	while(fahr <= upper)
	{
		celsius = 5 * (fahr-32) / 9;
		printf(""%d\t%d\n"", fahr, celsius);
		fahr = fahr + step;
	}

	return 0;
}
"
316-23045,acarno/slicer,valgrind/massif/tests/pages_as_heap.c,25,5,19,33594680.833630204,3371929.0,9.963044892107751,1144.0,1134.0,999271.0,493029.0,1604.0,590.0,1343.0,547.0,1500000000,0.0223964538890868,1082014363648.0,0.0006755776886168,0.0027367151377068,"#include <stdio.h>
#include <unistd.h>

#define MAX 20000

int main () {
  int i;
  int inc_dec;
  int delta;
  intptr_t brk_stat;

  // loop to first increase, then decrease
  for (inc_dec = 1; inc_dec >= -1; inc_dec-=2) {
     // loop to increase(decrease) with small then big delta
     for (delta = 1; delta <= 400; delta+=399) {
        if (0) printf(""initial brk value for inc_dec %d delta %d: %p\n"",
               inc_dec, delta, sbrk(0));
        for (i=0; i<MAX; i++) {
           brk_stat = (intptr_t)brk(sbrk(0) + inc_dec * delta);
           if (brk_stat == -1) {
              printf(""brk value at failure: %p\n"", sbrk(0));
              perror (""brk() failed!\n"");
              return 0;
           }
        }
        if (0) printf(""resulting brk value for inc_dec %d delta %d: %p\n"",
               inc_dec, delta, sbrk(0));
     }
  }

  return 0;
} 
"
108-21262,djsilenceboy/LearnTest,Cpp_Test/LongCommonSubsequence/src/LongCommonSubsequence.c,82,7,41,1899452.7636094498,672046.0,2.826372004297325,1389.0,1366.0,139650.0,76428.0,1644.0,697.0,1361.0,653.0,1500000000,0.0012663018424063,1082014363648.0,0.0040994217657719,0.0201547589296457,"/*
 ============================================================================
 Name        : LongCommonSubsequence.c
 Author      : 
 Version     :
 Copyright   : Your copyright notice
 Description : The longest common subsequence (LCS) problem is the problem of finding the longest subsequence common to all sequences in a set of sequences (often just two sequences).
               It differs from problems of finding common substrings: unlike substrings, subsequences are not required to occupy consecutive positions within the original sequences.
               The longest common subsequence problem is a classic computer science problem, the basis of data comparison programs such as the diff utility, and has applications in bioinformatics.
               It is also widely used by revision control systems such as Git for reconciling multiple changes made to a revision-controlled collection of files.
 ============================================================================
 */

#include <stdio.h>
#include <stdlib.h>

void printData(char *data)
{
	int size = strlen(data);
	int i;

	for (i = 0; i < size; i++)
	{
		printf(""%2c"", data[i]);
	}
	printf(""\n"");
}

void printDataPart(char *data, int size)
{
	int i;

	for (i = 0; i < size; i++)
	{
		printf(""%2c"", data[i]);
	}
	printf(""\n"");
}

void process(char* dataA, char* dataB)
{
	int sizeA = strlen(dataA);
	int sizeB = strlen(dataB);
	int subLen, posB, posA, k;
	int count = 0;

	printf(""Data A: "");
	printData(dataA);
	printf(""Data B: "");
	printData(dataB);

	printf(""Size A, B = %2d, %2d\n"", sizeA, sizeB);

	for (subLen = 1; subLen <= sizeB; subLen++)
	{
		int foundAny = 0;

		for (posB = 0; posB <= sizeB - subLen; posB++)
		{
			for (posA = 0; posA <= sizeA - subLen; posA++)
			{
				for (k = 0; k < subLen; k++)
				{
					count++;

					printf(""subLen, posB, posA, k = %2d, %2d, %2d, %2d\n"", subLen, posB, posA, k);

					if (dataA[posA + k] != dataB[posB + k])
					{
						break;
					}
				}

				if (k == subLen)
				{
					printf(""Find part = "");
					printDataPart(dataB + posB, subLen);
					printf(""\n"");

					foundAny++;
				}
			}
		}

		if (foundAny == 0)
		{
			printf(""No more, no need to continue.\n"");

			break;
		}
	}

	printf(""Count = %d\n"", count);
}

int main(void)
{
	char* dataA = ""programming"";
	char* dataB = ""dynamic"";

	process(dataA, dataB);

	return EXIT_SUCCESS;
}
"
192-2179,adamhleslie/QuickRename,source/QuickRename.c,87,2,64,7361548.6035123,207773.0,35.418134213781386,1420.0,1397.0,47196.0,16561.0,1825.0,650.0,1522.0,603.0,1500000000,0.0049076990690082,1082014363648.0,0.0135580657737049,0.0721489405084931,"#include <stdio.h>
#include <dirent.h>
#include <string.h>

static const char* const FILE_TYPE = "".xwm"";
static const int MAX_FILES = 111;

/* returns 0 (false) if over 111, o.w. 1 (true) */
char incrementName(char new_name[], int* file_count)
{
    (*file_count)++;
    if (*file_count > MAX_FILES)
        return 0;

    if (*file_count % 100 == 0)
    {
        new_name[3]++;
        new_name[4] = '0';
        new_name[5] = '0';
    }
    else if (*file_count % 10 == 0)
    {
        new_name[4]++;
        new_name[5] = '0';
    }
    else
        new_name[5]++;

    return 1;
}

/* returns num from valid MUS name or 0 if invalid */
char getNameVal(char name[])
{
    if (strlen(name) == 10 && name[0] == 'M' &&
        name[1] == 'U' && name[2] == 'S' &&
        name[3] >= '0' && name[3] <= '9' &&
        name[4] >= '0' && name[4] <= '9' &&
        name[5] >= '0' && name[5] <= '9')
    {
        return ((name[3] - 48) * 100) +
                ((name[4] - 48) * 10) +
                (name[5] - 48);
    }

    return 0;
}

/* changes file names if they have valid type */
int main()
{
    DIR* dir_ptr;

    if ((dir_ptr = opendir(""./"")))
    {
        struct dirent* entry_ptr;
        char* cur_file_type;
        int cur_name_val;
        char new_name[] = ""MUS001.xwm"";
        int file_count = 1;
        char files_valid = 1;
        FILE *fp = fopen(""log.txt"", ""a"");

        if(fp == NULL)
        {
            printf(""ERROR: Can not write to log.txt\n"");
            return 1;
        }

        /* loop through all files in the current directory */
        while ((entry_ptr = readdir(dir_ptr)) && files_valid)
        {
            /* check if file is of valid type */
            cur_file_type = strrchr(entry_ptr->d_name, '.');
            if (cur_file_type && !strcmp(cur_file_type, FILE_TYPE))
            {
                /* check if valid file is already named correctly */
                if ((cur_name_val = getNameVal(entry_ptr->d_name)) == 0)
                {
                    /* rename with the next name, if already taken continue with next */
                    while (rename(entry_ptr->d_name, new_name) && files_valid)
                    {
                        files_valid = incrementName(new_name, &file_count);
                    }
                    if (files_valid)
                    {
                        fprintf(fp, ""Renamed %s to %s\n"", entry_ptr->d_name, new_name);
                        files_valid = incrementName(new_name, &file_count);
                    }
                }
                else if (cur_name_val == file_count)
                {
                    files_valid = incrementName(new_name, &file_count);
                }
            }
        }

        fprintf(fp, ""\n%d files ready\n\n"", file_count - 1);
    }

    return 0;
}
"
057-4922,kgaipal/workspace,test-code/Google/rw.c,179,4,159,7458108268.445357,262981.0,28359.87492632548,1665.0,1604.0,60334.0,26183.0,1777.0,917.0,1421.0,859.0,1500000000,4.972072178963572,1082014363648.0,0.0124305558196219,0.0574915912479628,"/*
http://www.cs.nmsu.edu/~jcook/Tools/pthreads/examples.html
 *	File	: rw.c
 *
 *	Title	: Demo Readers/Writer.
 *
 *	Short	: A solution to the multi-reader's, one writer problem.
 *
 *	Long	:
 *
 *	Author	: Andrae Muys
 *
 *	Date	: 18 September 1997
 *
 *	Revised	:
 */

#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

#define MAXCOUNT 5

#define READER1  50000
#define READER2 100000
#define READER3	400000
#define READER4 800000
#define WRITER1  150000

typedef struct {
	pthread_mutex_t *mut;
	int writers;
	int readers;
	int waiting;
	pthread_cond_t *writeOK, *readOK;
} rwl;

rwl *initlock (void);
void readlock (rwl *lock, int d);
void writelock (rwl *lock, int d);
void readunlock (rwl *lock);
void writeunlock (rwl *lock);
void deletelock (rwl *lock);

typedef struct {
	rwl *lock;
	int id;
	long delay;
} rwargs;

rwargs *newRWargs (rwl *l, int i, long d);
void *reader (void *args);
void *writer (void *args);

static int data = 1;

int main ()
{
	pthread_t r1, r2, r3, r4, w1;
	rwargs *a1, *a2, *a3, *a4, *a5;
	rwl *lock;

	lock = initlock ();
	a1 = newRWargs (lock, 1, WRITER1);
	pthread_create (&w1, NULL, writer, a1);
	a2 = newRWargs (lock, 1, READER1);
	pthread_create (&r1, NULL, reader, a2);
	a3 = newRWargs (lock, 2, READER2);
	pthread_create (&r2, NULL, reader, a3);
	a4 = newRWargs (lock, 3, READER3);
	pthread_create (&r3, NULL, reader, a4);
	a5 = newRWargs (lock, 4, READER4);
	pthread_create (&r4, NULL, reader, a5);
	pthread_join (w1, NULL);
	pthread_join (r1, NULL);
	pthread_join (r2, NULL);
	pthread_join (r3, NULL);
	pthread_join (r4, NULL);
	free (a1); free (a2); free (a3); free (a4); free (a5);

	return 0;
}

rwargs *newRWargs (rwl *l, int i, long d)
{
	rwargs *args;

	args = (rwargs *)malloc (sizeof (rwargs));
	if (args == NULL) return (NULL);
	args->lock = l; args->id = i; args->delay = d;
	return (args);
}

void *reader (void *args)
{
	rwargs *a;
	int d;

	a = (rwargs *)args;

	do {
		readlock (a->lock, a->id);
		d = data;
		usleep (a->delay);
		readunlock (a->lock);
		printf (""Reader %d : Data = %d\n"", a->id, d);
		usleep (a->delay);
	} while (d != 0);
	printf (""Reader %d: Finished.\n"", a->id);

	return (NULL);
}

void *writer (void *args)
{
	rwargs *a;
	int i;

	a = (rwargs *)args;

	for (i = 2; i < MAXCOUNT; i++) {
		writelock (a->lock, a->id);
		data = i;
		usleep (a->delay);
		writeunlock (a->lock);
		printf (""Writer %d: Wrote %d\n"", a->id, i);
		usleep (a->delay);
	}
	printf (""Writer %d: Finishing...\n"", a->id);
	writelock (a->lock, a->id);
	data = 0;
	writeunlock (a->lock);
	printf (""Writer %d: Finished.\n"", a->id);

	return (NULL);
}

rwl *initlock (void)
{
	rwl *lock;

	lock = (rwl *)malloc (sizeof (rwl));
	if (lock == NULL) return (NULL);
	lock->mut = (pthread_mutex_t *) malloc (sizeof (pthread_mutex_t));
	if (lock->mut == NULL) { free (lock); return (NULL); }
	lock->writeOK = 
		(pthread_cond_t *) malloc (sizeof (pthread_cond_t));
	if (lock->writeOK == NULL) { free (lock->mut); free (lock); 
		return (NULL); }
	lock->readOK = 
		(pthread_cond_t *) malloc (sizeof (pthread_cond_t));
	if (lock->writeOK == NULL) { free (lock->mut); free (lock->writeOK); 
		free (lock); return (NULL); }
	
	pthread_mutex_init (lock->mut, NULL);
	pthread_cond_init (lock->writeOK, NULL);
	pthread_cond_init (lock->readOK, NULL);
	lock->readers = 0;
	lock->writers = 0;
	lock->waiting = 0;

	return (lock);
}

void readlock (rwl *lock, int d)
{
	pthread_mutex_lock (lock->mut);
	if (lock->writers || lock->waiting) {
		do {
			printf (""reader %d blocked.\n"", d);
			pthread_cond_wait (lock->readOK, lock->mut);
			printf (""reader %d unblocked.\n"", d);
		} while (lock->writers);
	}
	lock->readers++;
	pthread_mutex_unlock (lock->mut);

	return;
}

void writelock (rwl *lock, int d)
{
	pthread_mutex_lock (lock->mut);
	lock->waiting++;
	while (lock->readers || lock->writers) {
		printf (""writer %d blocked.\n"", d);
		pthread_cond_wait (lock->writeOK, lock->mut);
		printf (""writer %d unblocked.\n"", d);
	}
	lock->waiting--;
	lock->writers++;
	pthread_mutex_unlock (lock->mut);

	return;
}

void readunlock (rwl *lock)
{
	pthread_mutex_lock (lock->mut);
	lock->readers--;
	pthread_cond_signal (lock->writeOK);
	pthread_mutex_unlock (lock->mut);
}

void writeunlock (rwl *lock)
{
	pthread_mutex_lock (lock->mut);
	lock->writers--;
	pthread_cond_broadcast (lock->readOK);
	pthread_mutex_unlock (lock->mut);
}

void deletelock (rwl *lock)
{
	pthread_mutex_destroy (lock->mut);
	pthread_cond_destroy (lock->readOK);
	pthread_cond_destroy (lock->writeOK);
	free (lock);

	return;
}
"
372-2819,omni-compiler/omni-compiler,tests/openacc/parallel/parallel_async.c,38,5,31,415475029.614754,704817787.0,0.5894786378312555,1309.0,1301.0,100702926.0,100676831.0,6293129.0,6292109.0,4195594.0,6292066.0,1500000000,0.2769833530765027,1082014363648.0,3.703084752031095e-06,0.1145740681373451,"#include <stdio.h>
#include <stdlib.h>
#define N (32 * 1024 * 1024)


int main()
{
  int i;
  int *a = (int*)malloc(sizeof(int) * N);
  int *b = (int*)malloc(sizeof(int) * N);
  int *c = (int*)malloc(sizeof(int) * N);

  if(!(a && b && c)){
    printf(""malloc err\n"");
    return 1;
  }

#pragma acc data copyout(a[0:N], b[0:N], c[0:N])
  {
    //for avoiding initial cost
#pragma acc parallel async(2)
    a[0] = 0;
#pragma acc parallel async(10)
    a[1] = 1;
#pragma acc wait


    //A
#pragma acc parallel loop async(2) num_gangs(1)
    for(i = 0; i < N; i++){
      a[i] = i * 2;
    }

    //B, this will finish before A
#pragma acc parallel loop async(10)
    for(i = 0; i < N; i++){
      b[i] = 1;
    }

#pragma acc wait(10)

#pragma acc parallel loop async(2)
    for(i = 0; i < N; i++){
      c[i] = a[i] + b[i];
    }
#pragma acc wait
  }

  //check
  for(i = 0; i < N; i++){
    if(c[i] != i * 2 + 1){
      return 1;
    }
  }

  free(a);
  free(b);
  free(c);

  printf(""PASS\n"");
  return 0;
}
"
242-30627,fengbohello/practice,clang/posix/atoi.c,36,1,34,2220574.64998215,182042.0,12.198141088320275,1376.0,1353.0,41002.0,14410.0,1641.0,637.0,1357.0,595.0,1500000000,0.0014803830999881,1082014363648.0,0.0149910460223464,0.0763372554681296,"/*
 * =====================================================================================
 *
 *       Filename:  atoi.c
 *
 *    Description:  
 *
 *        Version:  1.0
 *        Created:  12/21/2016 11:40:32 AM
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  YOUR NAME (), 
 *   Organization:  
 *
 * =====================================================================================
 */
#include <stdio.h>
#include <stdlib.h>

/* int atoi(const char *nptr); */

int main() {
    const char *pNum[] = 
    {
        ""-10"",
        ""0"",
        ""10"",
        ""a100"",
        ""100a"",
        ""-100a"",
        "" 12x"",
        NULL
    };
    int i = 0;
    for(i = 0; pNum[i] != NULL; i++) {
        printf(""[%-s] \t= [%d]\n"", pNum[i], atoi(pNum[i]));
    }

    return 0;
}

"
060-12245,Shashaankar/C_programs,leet-programming/reverse_integer.c,40,2,32,2004873.00753585,173784.0,11.536579892280072,1336.0,1317.0,39260.0,13361.0,1618.0,639.0,1339.0,594.0,1500000000,0.0013365820050239,1082014363648.0,0.0152660774294526,0.0796260048269702,"#include <stdio.h>


/*
 * Reverse digits of an integer.
 *
 * Example1: x = 123, return 321
 * Example2: x = -123, return -321
 */

int reverse(int x) {
    
    int val,res;
    int flag = 0; // set for negative numbers
    int max_int = 1<<31;
    
    //printf(""max_int = %d\n"", max_int);
    val = res = 0;
    if (x < 0) {
        
        flag = 1;
        val = -x;
    } else {
        val = x;
    }
    
    if (x == 0) {
        return 0;
    }
    
    while(val) {
        
        /* Handle overflow condition */
        if (res != 0 && max_int/res < 10 && max_int/res > -10) {
            return 0;
        }
        
        res = res * 10 + val%10;
        val = val/10;
    }
    
    if(flag) {
        return -res;
    }
    
    return res;
}


int
main()
{
    printf(""Reverse and interger %d : %d\n"", -12345670, reverse(-1234567));

    return 0;
}
"
130-27429,chaws/personal,weird_c/overflow_truncate.c,24,1,23,1687966.51996665,496576.0,3.399209788632556,1342.0,1322.0,102423.0,55595.0,1621.0,701.0,1340.0,656.0,1500000000,0.0011253110133111,1082014363648.0,0.0053647377239334,0.0273260008353478,"/*
 * Whil i increments to 300, c will be getting i*i every time
 * but c can stand only 1 unsigned char byte. What happens here is that
 * i*i is truncated to fit in a char. Ex:
 * if i*i == 0xFE, 'F' will be truncated so 'E' could fit into 'c'
 * thus making a whole new mess
 *
 * The same happened with 'd', which is a signed char, so when assigned 0xFF
 * will become '-1' (since 0xF means all bits set, or -1 in complement of 2)
 */
#include <stdio.h>
int main(void)
{
    unsigned char c;
    char d;
    int i;
    for(i = 0; i < 300; i++)
    {
        c = i * i;
        printf(""i = %i, c = %i\n"", i, c);
    }
    d = 0xFF;
    printf(""(char)0xFF = %i\n"", d);
    return 0;
}
"
027-26679,grafi-tt/Maizul,fpu-misc/finvTable.c,38,4,36,20400976.4129295,185844247.0,0.109774589901618,1394.0,1372.0,260880.0,163286.0,1668.0,822.0,1361.0,715.0,1500000000,0.013600650941953,1082014363648.0,1.4883430854870636e-05,0.0107646534611449,"/* written by panooz */
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int main() {
  int i, cons[1024], grad[1024];
  for (i=0; i<1024; i++) {
    float A0 = i+1024, x0 = (1/A0 + 1/(A0+1)) / (1<<14);
    cons[i] = pow(2,48) * x0 - pow(2,60) * x0 * x0 * A0;
    grad[i] = pow(2,47) * x0 * x0 * (1<<12);
  }

  int A0, A1;
  int diffMax = 0;
  for (A0=0; A0<(1<<10); A0++) {
    for (A1=0; A1<(1<<13); A1++) {
      union {
        int i;
        float f;
      } u;
      u.i = (127 << 23) | (A0 << 13) | A1;
      u.f = 1/u.f;
      int M = (1<<23) + (u.i & ((1<<23)-1));
      int finvman;
      if (A0 || A1) {
        finvman = cons[A0] - ((grad[A0]*A1) >> 12);
      } else {
        finvman = (1<<23);
      }
      int diff = M - finvman;
      if (diffMax < diff) diffMax = diff;
    }
  }
  fprintf(stderr, ""diffMax = %d\n"", diffMax);

  for (i=0; i<1024; i++) {
    int a, b;
    a = (cons[i] << 9) | (grad[i] >> 4);
    b = grad[i] & ((1<<4)-1);
    printf(""%08X%X\n"", a, b);
  }

  return 0;
}
"
348-8804,trichner/tools,asciitable/asciitable.c,22,3,21,1762847.9981794502,279730.0,10.2932041611554,1343.0,1322.0,63878.0,30802.0,1649.0,653.0,1353.0,608.0,1500000000,0.0011752319987863,1082014363648.0,0.0095270439352232,0.0450253485424588,"// Generates the ASCII table of printable characters.
#include <stdio.h>

int main(){
  const char A[]=""*              THE ASCII TABLE BY JOSEF ZIEGLER              *"";
  int i = -1, j = 0;
  while(j < 3) {
    while(++i < sizeof(A)-1) { // because of the '\0'
      if(j%2 == 0)
	putc('*', stdout);
      else
	putc(*(A+i), stdout);}
    putc('\n', stdout);
    j++;
    i = -1;
  }
  for(i = 33; i < 127; i++){
    printf(""%.3d  "", i);
    putc(i, stdout);
    printf(""  "");
    if (i % 8==0)
      putc(10, stdout);
  }
}
"
116-9633,7sujit/Project-Euler,prime-sieve.c,38,4,34,3274100.9490563995,9128698.0,0.3586601287500145,1338.0,1317.0,1863651.0,1260342.0,3283.0,49352.0,1339.0,2227.0,1500000000,0.0021827339660376,1082014363648.0,0.0002908410377909,0.0179901171353456,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>

 #define SQRT_MAX 317
 #define PRIME_RANGE 100489

//#define SQRT_MAX 1000
//#define PRIME_RANGE 1000000

/* BEWARE OF GIVING LARGE RANGE NUMBERS AS IT MIGHT TAKE A LONG TIME */

char *bool_str;
static const char true = '1';
static const char false = '0';

void print_prime_numbers(void)
{
	int i;
	for(i=0; i < PRIME_RANGE;++i)
	{
		if(bool_str[i] == true)
			printf(""%d,"", i);
	}
}

int main(void)
{

	int i,j,k,n;

	bool_str = (char *) malloc ( (PRIME_RANGE + 1) *  sizeof(char));
	
	/* initialising the bool_str */
	for(i = 0; i < PRIME_RANGE; bool_str[i]=true,++i);
	bool_str[0] = bool_str[1] = false;
	bool_str[PRIME_RANGE] = '\0';

	for(i = 2; i <= SQRT_MAX ; ++i)
	{
		if( bool_str[i] == true)
		{
			for(j = 1, k = i*i; k < PRIME_RANGE; ++j)
			{
				bool_str[k] = false;
				k = i * (i+j);
			}
		}	
	}

	print_prime_numbers();	// prints all prime numbers in range
	//puts(bool_str);	// prints bool_str
	
	return EXIT_SUCCESS;
}
"
102-315,jhbsz/OSI-OS,tools/regression/pipe/pipe-overcommit1.c,41,1,40,85476835.258305,355782.0,240.25058884373016,1289.0,1274.0,67425.0,31343.0,1635.0,651.0,1353.0,605.0,1500000000,0.05698455683887,1082014363648.0,0.0072038495483189,0.0429693827960473,"/*-
 * Copyright (C) 2005 Michael J. Silbersack <silby@freebsd.org> 
 *  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice(s), this list of conditions and the following disclaimer as
 *    the first lines of this file unmodified other than the possible
 *    addition of one or more copyright notices.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice(s), this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 */

#include <stdio.h>
#include <stdlib.h>

/*
 * $FreeBSD$
 * This program just allocates as many pipes as it can to ensure
 * that using up all pipe memory doesn't cause a panic.
 */

int main (void)

{
	int i, returnval;
	int pipes[10000];
	for (i = 0; i < 10000; i++) {
		returnval = pipe(&pipes[i]);
	}
	printf(""PASS\n"");
}
"
146-4377,GuardianRG/angr,angr/tools/sym.c,29,1,28,1523643.1499943,176722.0,8.62169396000498,1214.0,1189.0,40502.0,13610.0,1631.0,592.0,1357.0,549.0,1500000000,0.0010157620999962,1082014363648.0,0.0135976279127669,0.0763047013601419,"/**
 * This little c program retrieve and resolve the indirect symbols
 * present in a dynamic library.
*/
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>

int main(int argc, char **argv)
{
  char *lib = argv[1];
  int i;
  int show = 1, ret;
  Dl_info info;

  void *so_ptr = dlopen(lib, RTLD_NOW);
  char *error = dlerror();

  // only dinamyc libraries are well handled
  if  (error) {    
    fprintf(stderr, ""%s"", error);
    return -1;
  }

  for (i = 2; i < argc; i++) {
    char *func = argv[i];
    void *func_ptr = dlsym(so_ptr, func);
    
    if (show) {    
      show = 0;
      ret = dladdr(func_ptr+1, &info);
      //printf(""Base_SO %p\n"", (ret) ? info.dli_fbase : ""???"");      
    }
    fprintf(stdout, ""%s %p\n"", func, (void*)(func_ptr - info.dli_fbase));
  }
  return 0;
}
"
038-26860,Gurgel100/gcc,gcc/testsuite/gcc.dg/c2x-labels-1.c,20,1,21,1630669.57611585,169061.0,9.645447501197792,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010871130507439,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* Tests for labels before declarations and at ends of compound statements.  */
/* { dg-do run } */
/* { dg-options ""-std=c2x -pedantic-errors"" } */

int f(int x) 
{ 
	goto b;
	a: int i = 2 * x;
	aa: int u = 0; int v = 0;
           goto c;
	b: goto a;
	{ i *= 3; c: }
	return i + u + v;
        d:
}

int main(void)
{
	if (2 != f(1))
		__builtin_abort();

	return 0;
}
"
262-32361,unnamed42/code_learning,rubbish/test2/7.c,24,3,21,1796554.4247999,190706.0,15.570527408681428,1437.0,1413.0,42862.0,15745.0,1648.0,638.0,1364.0,598.0,1500000000,0.0011977029498666,1082014363648.0,0.0149444694975512,0.0724828092207415,"#include <stdio.h>
void print_array_5(double* array){
    int i;
    for(i=0;i<5;i++)
        printf(""%.4f "",*(array+i));
    printf(""\n"");
}

void cleandata(double* p){
    int i,j=0;
    for(i=0;i<5;i++){
        if(*(p+i)>=0.001){
            *(p+j)=*(p+i);
            j++;
        }
    }
    for(;j<5;j++)
        *(p+j)=0;
}
            
int main(){
    double data[5]={0.89,0.78,0.0009,0.67,0.56};
    print_array_5(data);
    cleandata(data);
    print_array_5(data);
    return 0;
}"
160-22440,arante/cloc,c-htp/ch06/fig06_05.c,18,2,19,2080053.0910491,183214.0,11.353133494165291,1341.0,1321.0,41291.0,14631.0,1627.0,636.0,1345.0,595.0,1500000000,0.0013867020606994,1082014363648.0,0.0145294573558789,0.0751582561424841,"/*
 * fig06_05.c
 * Initialize an array to even integers.
 *
 * Written by Billy Wilson Arante <arantebillywilson@gmail.com>
 * Last updated on 2017/12/14 PHT
 */

#include <stdio.h>
#define SIZE 10

int main(void) {
        int arr[SIZE];
        int counter;

        for (counter = 0; counter < SIZE; counter++) {
                arr[counter] = 2 + 2 * counter;
        }

        for (counter = 0; counter < SIZE; counter++) {
                printf(""%d => %d\n"", counter, arr[counter]);
        }

        return 0;
}
"
276-32406,swigger/gdb-ios,gdb/testsuite/gdb.base/whatis.c,237,5,175,1997644.6637882998,169168.0,11.77081362905514,1153.0,1143.0,38464.0,12754.0,1570.0,596.0,1319.0,557.0,1500000000,0.0013317631091922,1082014363648.0,0.0135723068192565,0.078917568042485,"/* This test program is part of GDB, the GNU debugger.

   Copyright 1992-2016 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/*
 *	Test file with lots of different types, for testing the
 *	""whatis"" command.
 */

/*
 *	First the basic C types.
 */

char		v_char;
signed char	v_signed_char;
unsigned char	v_unsigned_char;

short		v_short;
signed short	v_signed_short;
unsigned short	v_unsigned_short;

int		v_int;
signed int	v_signed_int;
unsigned int	v_unsigned_int;

long		v_long;
signed long	v_signed_long;
unsigned long	v_unsigned_long;

#ifndef NO_LONG_LONG
long long		v_long_long;
signed long long	v_signed_long_long;
unsigned long long	v_unsigned_long_long;
#endif

float		v_float;
double		v_double;

/*
 *	Now some derived types, which are arrays, functions-returning,
 *	pointers, structures, unions, and enumerations.
 */

/**** arrays *******/

char		v_char_array[2];
signed char	v_signed_char_array[2];
unsigned char	v_unsigned_char_array[2];

short		v_short_array[2];
signed short	v_signed_short_array[2];
unsigned short	v_unsigned_short_array[2];

int		v_int_array[2];
signed int	v_signed_int_array[2];
unsigned int	v_unsigned_int_array[2];

long		v_long_array[2];
signed long	v_signed_long_array[2];
unsigned long	v_unsigned_long_array[2];

#ifndef NO_LONG_LONG
long long		v_long_long_array[2];
signed long long	v_signed_long_long_array[2];
unsigned long long	v_unsigned_long_long_array[2];
#endif

float		v_float_array[2];
double		v_double_array[2];

/**** pointers *******/

/* Make sure they still print as pointer to foo even there is a typedef
   for that type.  Test this not just for char *, which might be
   a special case kludge in GDB (Unix system include files like to define
   caddr_t), but for a variety of types.  */
typedef char *char_addr;
char_addr a_char_addr;
typedef unsigned short *ushort_addr;
ushort_addr a_ushort_addr;
typedef signed long *slong_addr;
slong_addr a_slong_addr;
#ifndef NO_LONG_LONG
typedef signed long long *slong_long_addr;
slong_long_addr a_slong_long_addr;
#endif

char		*v_char_pointer;
signed char	*v_signed_char_pointer;
unsigned char	*v_unsigned_char_pointer;

short		*v_short_pointer;
signed short	*v_signed_short_pointer;
unsigned short	*v_unsigned_short_pointer;

int		*v_int_pointer;
signed int	*v_signed_int_pointer;
unsigned int	*v_unsigned_int_pointer;

long		*v_long_pointer;
signed long	*v_signed_long_pointer;
unsigned long	*v_unsigned_long_pointer;

#ifndef NO_LONG_LONG
long long		*v_long_long_pointer;
signed long long	*v_signed_long_long_pointer;
unsigned long long	*v_unsigned_long_long_pointer;
#endif

float		*v_float_pointer;
double		*v_double_pointer;

/**** structs *******/

struct t_struct {
    char	v_char_member;
    short	v_short_member;
    int		v_int_member;
    long	v_long_member;
#ifndef NO_LONG_LONG
    long long	v_long_long_member;
#endif
    float	v_float_member;
    double	v_double_member;
} v_struct1;

struct {
    char	v_char_member;
    short	v_short_member;
    int		v_int_member;
    long	v_long_member;
#ifndef NO_LONG_LONG
    long long	v_long_long_member;
#endif
    float	v_float_member;
    double	v_double_member;
} v_struct2;

/**** unions *******/

union t_union {
    char	v_char_member;
    short	v_short_member;
    int		v_int_member;
    long	v_long_member;
#ifndef NO_LONG_LONG
    long long	v_long_long_member;
#endif
    float	v_float_member;
    double	v_double_member;
} v_union;

union {
    char	v_char_member;
    short	v_short_member;
    int		v_int_member;
    long	v_long_member;
#ifndef NO_LONG_LONG
    long long	v_long_long_member;
#endif
    float	v_float_member;
    double	v_double_member;
} v_union2;

/*** Functions returning type ********/

char		v_char_func () { return(0); }
signed char	v_signed_char_func () { return (0); }
unsigned char	v_unsigned_char_func () { return (0); }

short		v_short_func () { return (0); }
signed short	v_signed_short_func () { return (0); }
unsigned short	v_unsigned_short_func () { return (0); }

int		v_int_func () { return (0); }
signed int	v_signed_int_func () { return (0); }
unsigned int	v_unsigned_int_func () { return (0); }

long		v_long_func () { return (0); }
signed long	v_signed_long_func () { return (0); }
unsigned long	v_unsigned_long_func () { return (0); }

#ifndef NO_LONG_LONG
long long		v_long_long_func () { return (0); }
signed long long	v_signed_long_long_func () { return (0); }
unsigned long long	v_unsigned_long_long_func () { return (0); }
#endif

float		v_float_func () { return (0.0); }
double		v_double_func () { return (0.0); }

/**** Some misc more complicated things *******/

struct link {
	struct link *next;
#ifdef __STDC__
	struct link *(*linkfunc) (struct link *this, int flags);
#else
	struct link *(*linkfunc) ();
#endif
	struct t_struct stuff[1][2][3];
} *s_link;

union tu_link {
	struct link *next;
#ifdef __STDC__
	struct link *(*linkfunc) (struct link *this, int flags);
#else
	struct link *(*linkfunc) ();
#endif
	struct t_struct stuff[1][2][3];
} u_link;

struct outer_struct {
	int outer_int;
	struct inner_struct {
		int inner_int;
		long inner_long;
	}inner_struct_instance;
	union inner_union {
		int inner_union_int;
		long inner_union_long;
	}inner_union_instance;
	long outer_long;
} nested_su;

/**** Enumerations *******/

enum colors {red, green, blue} color;
enum cars {chevy, ford, porsche} clunker;

/***********/

int main ()
{
  /* Some linkers (e.g. on AIX) remove unreferenced variables,
     so make sure to reference them. */
  v_char = 0;
  v_signed_char = 1;
  v_unsigned_char = 2;

  v_short = 3;
  v_signed_short = 4;
  v_unsigned_short = 5;    

  v_int = 6;
  v_signed_int = 7;
  v_unsigned_int = 8;    

  v_long = 9;
  v_signed_long = 10;
  v_unsigned_long = 11;    

#ifndef NO_LONG_LONG
  v_long_long = 12;
  v_signed_long_long = 13;
  v_unsigned_long_long = 14;
#endif

  v_float = 100.0;
  v_double = 200.0;


  v_char_array[0] = v_char;
  v_signed_char_array[0] = v_signed_char;
  v_unsigned_char_array[0] = v_unsigned_char;

  v_short_array[0] = v_short;
  v_signed_short_array[0] = v_signed_short;
  v_unsigned_short_array[0] = v_unsigned_short;

  v_int_array[0] = v_int;
  v_signed_int_array[0] = v_signed_int;
  v_unsigned_int_array[0] = v_unsigned_int;

  v_long_array[0] = v_long;
  v_signed_long_array[0] = v_signed_long;
  v_unsigned_long_array[0] = v_unsigned_long;

#ifndef NO_LONG_LONG
  v_long_long_array[0] = v_long_long;
  v_signed_long_long_array[0] = v_signed_long_long;
  v_unsigned_long_long_array[0] = v_unsigned_long_long;
#endif

  v_float_array[0] = v_float;
  v_double_array[0] = v_double;

  v_char_pointer = &v_char;
  v_signed_char_pointer = &v_signed_char;
  v_unsigned_char_pointer = &v_unsigned_char;

  v_short_pointer = &v_short;
  v_signed_short_pointer = &v_signed_short;
  v_unsigned_short_pointer = &v_unsigned_short;

  v_int_pointer = &v_int;
  v_signed_int_pointer = &v_signed_int;
  v_unsigned_int_pointer = &v_unsigned_int;

  v_long_pointer = &v_long;
  v_signed_long_pointer = &v_signed_long;
  v_unsigned_long_pointer = &v_unsigned_long;

#ifndef NO_LONG_LONG
  v_long_long_pointer = &v_long_long;
  v_signed_long_long_pointer = &v_signed_long_long;
  v_unsigned_long_long_pointer = &v_unsigned_long_long;
#endif

  v_float_pointer = &v_float;
  v_double_pointer = &v_double;

  color = red;
  clunker = porsche;

  u_link.next = s_link;

  v_union2.v_short_member = v_union.v_short_member;

  v_struct1.v_char_member = 0;
  v_struct2.v_char_member = 0;

  nested_su.outer_int = 0;
  return 0;
}
"
331-11637,dataBaseError/os_examples,locking.c,41,2,36,3134449.36182345,206698.0,15.164389592545646,1580.0,1546.0,46736.0,17966.0,1679.0,765.0,1382.0,722.0,1500000000,0.0020896329078823,1082014363648.0,0.0151235135318193,0.0702914902166857,"
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>

#include <pthread.h>

pthread_mutex_t mutex;

int count = 0;

void *runner(void *arg)
{
    char *str;
    int i = 0;

    str=(char*)arg;

    while(i < 10 )
    {
        // Request lock
        pthread_mutex_lock (&mutex);

        // Increase the count safely.
        count++;
        printf(""%s says %i\n"",str, count);

        // Yield the lock.
        pthread_mutex_unlock (&mutex);

        // Sleep to simulate some work.
        usleep(1);
        ++i;
    }

    return NULL;
}

/**
 * Example with two threads incrementing a shared variable
 * with a mutex.
 */
int main(int argc, char *argv[]) {

    pthread_t pth;
    pthread_t pth2;

    // Initialize the mutex
    pthread_mutex_init(&mutex, NULL);

    // Create two threads.
    pthread_create(&pth, 0, runner, (void *) ""Thread 1"");
    pthread_create(&pth2, 0, runner, (void *) ""Thread 2"");

    // wait for our thread to finish before continuing
    pthread_join(pth, 0);
    pthread_join(pth2, 0);

    // Clean up the mutex
    pthread_mutex_destroy(&mutex);

    return 0;
}"
183-25187,artnavsegda/crossnavsegda,src/allocstring.c,34,2,26,1469298.0330436502,177154.0,8.29390248032785,1363.0,1344.0,40213.0,13858.0,1626.0,639.0,1346.0,594.0,1500000000,0.0009795320220291,1082014363648.0,0.0152804904207638,0.0777681196944757,"#include <stdio.h>
#include <stdlib.h>

typedef char *callback_func_t (void);

char * callback(void)
{
  static int i = 0;
  i++;
  if (i < 10)
    return ""hoba"";
  else
    return NULL;
}

char ** array_allocate(callback_func_t *cb_func)
{
  char *string;
  char **string_list = NULL;
  //string_list = (char **)malloc(sizeof (char *));
  int counter = 0;

  while (string = (*cb_func)())
  {
    counter++;
    string_list = (char **)realloc(string_list, sizeof(char *) * counter);
    string_list[counter-1] = string;
  }
  printf(""%d\n"",counter);

  for (int i = 0; i < counter; i++)
  {
    puts(string_list[i]);
  }

  return string_list;
}

int main()
{
	array_allocate(callback);
	return 0;
}
"
102-30650,autumn-lake/Programming-and-Data-Structures-in-C,7c.c,24,2,23,1768187.9689915502,173906.0,10.167487033224846,1333.0,1314.0,39429.0,13389.0,1626.0,636.0,1346.0,594.0,1500000000,0.0011787919793277,1082014363648.0,0.015220866445091,0.0795562118974592,"/* Write a C program using strcmp() */

#include<stdio.h>

int Strcmp1(char *s, char *t){	
	int i=0,j=0;	
	while( (s[i]!='\0') & (t[i]!='\0') ){
		j = s[i]-t[i];
		if(j!=0)
			return j;
		i++;
	}
	j = s[i]-t[i];
	return j;
}

int Strcmp2(char *s, char *t){
	for( ; *s==*t; s++,t++){
		if(*s=='\0') return 0;
	}
	return *s-*t;
}

int main(){
	char target[] = ""stackf"";
	char source[] = ""stacked"";
	printf(""%d\n"", Strcmp2(source,target));
	return 0;
}
"
282-31353,trevstanhope/scratch-C,examples/arrays/arrays.c,18,1,21,1868541.0032047501,174593.0,10.7022675594096,1339.0,1320.0,39464.0,13490.0,1617.0,636.0,1340.0,593.0,1500000000,0.0012456940021365,1082014363648.0,0.0152297056583024,0.0790497412848887,"/*
arrays.c
 */
#include <stdio.h>
int array[3]; /* creates a 3 element array from array[0] to array[2] */
int i; /* counter */
int j; /* another counter */
int main() {
  array[0] = 1;
  array[1] = 2;
  array[2] = 3;
  i = 0;
  j = 10;
  while (i<j) {
    i = (i + j);
    j = (j / i) + j;
    printf(""i %d j %d\n"", i, j);
  }
}
"
148-32078,fatedier/fatest,algorithm/quick_sort/quick_sort.c,61,3,45,1739387.74969425,212922.0,8.169127661772857,1376.0,1347.0,48400.0,18285.0,1644.0,642.0,1363.0,598.0,1500000000,0.0011595918331295,1082014363648.0,0.0127887207522003,0.0636874859413661,"#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <time.h>

#define NUMBER 20
#define RANDMIN 0
#define RANDMAX 1000

#ifndef true
typedef char bool;
#define true 1
#define false 0
#endif

void swap(int *a, int *b)
{
    if (a == b)
        return;
    *a = (*a) ^ (*b);
    *b = (*a) ^ (*b);
    *a = (*a) ^ (*b);
}

int random_in_range(int start, int end)
{
    return rand() % (end - start + 1) + start;
}

int sort_one(int a[], int length, int left, int right)
{
    if (a == NULL || length <= 0 || left < 0 || right >= length) {
        return -1;  /* error */
    }
    int index = random_in_range(left, right);
    swap(&a[index], &a[right]);
    int small = left - 1;

    for (index = left; index < right; index++) {
        if (a[index] < a[right]) {
            small++;
            if (small != index)
                swap(&a[small], &a[index]);
        }
    }
    small++;
    swap(&a[small], &a[right]);
    return small;
}

void quick_sort(int a[], int length, int left, int right)
{
    if (left == right)
        return;

    int index = sort_one(a, length, left, right);
    if (index < 0) /* error */
        return;
    if (index > left)
        quick_sort(a, length, left, index - 1);
    if (index < right)
        quick_sort(a, length, index + 1, right);
}

int main(int argc, char **argv)
{
    int a[NUMBER];
    srand(time(NULL));
    int i;
    for (i=0; i<NUMBER; i++) {
        a[i] = rand() % (RANDMAX - RANDMIN) + RANDMIN;
        printf(""%d "", a[i]);
    }
    printf(""\n"");

    quick_sort(a, NUMBER, 0, NUMBER - 1);

    for (i=0; i<NUMBER; i++) {
        printf(""%d "", a[i]);
    }
    printf(""\n"");
    return 0;
}
"
283-15225,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.dwarf2/dw2-single-line-discriminators.c,22,3,20,1456985.7157765501,169059.0,8.618204295541792,1139.0,1129.0,38452.0,12697.0,1567.0,580.0,1318.0,544.0,1500000000,0.0009713238105177,1082014363648.0,0.013415434848189,0.0783788539365383,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2014-2015 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

int x;

int
main ()
{
  int i;

  /* Ensure runto_main stops before the for loop.  */
  x = 0;

  for (i = 0; i < 10; ++i) continue; /* stepi line */

  return 0;
}
"
189-26350,alpine9000/BitOS,tests/gcc.dg/pr63594-2.c,74,2,48,1678352.8262748,174459.0,9.62032339976728,1245.0,1232.0,39685.0,13230.0,1590.0,586.0,1333.0,546.0,1500000000,0.0011189018841832,1082014363648.0,0.0141981783685565,0.076632334876689,"/* PR target/63594 */
/* { dg-do run } */
/* { dg-options ""-O2 -Wno-psabi"" } */
/* { dg-additional-options ""-mno-mmx"" { target i?86-*-* x86_64-*-* } } */
/* { dg-prune-output ""non-standard ABI extension"" } */

#define C1 c
#define C2 C1, C1
#define C4 C2, C2
#define C8 C4, C4
#define C16 C8, C8
#define C32 C16, C16
#define C64 C32, C32
#define C_(n) n
#define C(n) C_(C##n)

#define T(t,s) \
typedef t v##t##s __attribute__ ((__vector_size__ (s * sizeof (t))));	\
__attribute__((noinline, noclone)) v##t##s				\
test1##t##s (t c)							\
{									\
  v##t##s v = { C(s) };							\
  return v;								\
}									\
									\
__attribute__((noinline, noclone)) v##t##s				\
test2##t##s (t *p)							\
{									\
  t c = *p;								\
  v##t##s v = { C(s) };							\
  return v;								\
}									\
									\
void									\
test3##t##s (void)							\
{									\
  t c = 17;								\
  int i;								\
  v##t##s a = test1##t##s (c);						\
  for (i = 0; i < s; i++)						\
    if (a[i] != 17)							\
      __builtin_abort ();						\
  v##t##s b = test2##t##s (&c);						\
  for (i = 0; i < s; i++)						\
    if (a[i] != 17)							\
      __builtin_abort ();						\
}

typedef long long llong;

#define TESTS \
T(char, 64) \
T(char, 32) \
T(char, 16) \
T(char, 8) \
T(char, 4) \
T(char, 2) \
T(char, 1) \
T(short, 32) \
T(short, 16) \
T(short, 8) \
T(short, 4) \
T(short, 2) \
T(short, 1) \
T(int, 16) \
T(int, 8) \
T(int, 4) \
T(int, 2) \
T(int, 1) \
T(float, 16) \
T(float, 8) \
T(float, 4) \
T(float, 2) \
T(float, 1) \
T(llong, 8) \
T(llong, 4) \
T(llong, 2) \
T(llong, 1) \
T(double, 8) \
T(double, 4) \
T(double, 2) \
T(double, 1)

TESTS

int
main ()
{
#undef T
#define T(t,s) test3##t##s ();
  TESTS
  return 0;
}
"
145-8071,mythdraenor/riscv-gdb,gdb/testsuite/gdb.base/step-break.c,24,2,25,1082222548.1970236,9663845478.0,0.1119459018113244,1139.0,1129.0,3221263925.0,2147496345.0,1567.0,588.0,1316.0,547.0,1500000000,0.7214816987980157,1082014363648.0,2.3468918301344558e-07,7.484036905972708e-07,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2008, 2009, 2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

int
main ()
{
    volatile int i = 1;

    while (i > 0) /* place1 */
      {
	i++; /* place2 */
	i++; /* place3, set breakpoint here  */
      }

    return 0;
}
"
024-12082,urmyfaith/roadofios,diary/solveoutlines/do_on_class/week2/week2_day1_maopao.c,33,4,22,2092127.92105965,186890.0,23.13056343303548,1350.0,1329.0,42265.0,15374.0,1630.0,638.0,1350.0,594.0,1500000000,0.0013947519473731,1082014363648.0,0.0143346353469955,0.0730755217821266,"#include <stdio.h>

#define NUM 10

int main()
{
	int array[NUM]={10,9,8,7,6,5,4,3,2,1};
	int i,j,temp;

	for (i = 0 ; i < NUM; i++)
	{
		printf(""%d\t"",array[i]);
	}
	printf(""\n"");

	for( i = 0; i < NUM -1 ; i++)  //外层循环，
	{
		//找出最大的数，下沉到最后。
		for(j = 0 ; j < NUM - i - 1; j++)  //第一次下沉需要执行9次,第二次下沉需要执行8次。。。。
		{
		
			if(array[j] > array[j+1])
			{
				temp = array[j];
				array[j] =array[j+1];
				array[j+1] = temp;
			}
		}
	
	}

	for (i = 0 ; i < NUM; i++)
	{
		printf(""%d\t"",array[i]);
	}
	printf(""\n"");

	return 0;
}
#if 0
冒泡排序的思想：

循环第一次，将最大的数下沉到最后。
循环第二次，将次大的数下沉到倒数第二。
循环第N次， 。。。。


#endif
"
278-5494,Mazuh/Algs,src/uri_judge/begginer/1096_sequence_ij_2.c,12,2,17,1795562.91550395,188006.0,9.550556897120304,1338.0,1319.0,42132.0,15246.0,1618.0,636.0,1340.0,592.0,1500000000,0.0011970419436693,1082014363648.0,0.0141325276852866,0.0729547910348914,"/**
https://www.urionlinejudge.com.br/judge/en/problems/view/1096
*/

#include <stdio.h>

int main(){

	int i, j;

	for (i = 1; i <= 9; i += 2){
		for (j = 7; j > 4; j--){
			printf(""I=%d J=%d\n"", i, j);
		}
	}

	return 0;
}
"
337-15005,ColinIanKing/stress-ng,test/test-builtin-sfence.c,24,1,26,1773603.0276863999,169062.0,10.48664395310596,1139.0,1129.0,38452.0,12696.0,1568.0,584.0,1318.0,544.0,1500000000,0.0011824020184576,1082014363648.0,0.0134151967917095,0.0784781418628294,"/*
 * Copyright (C) 2017-2021 Canonical, Ltd.
 * Copyright (C)      2022 Colin Ian King
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 */

int main(int argc, char **argv)
{
	__builtin_ia32_sfence();

	return 0;
}
"
122-9083,sirodoht/project-euler,Problem_09_pythagoren_triplet_1k_product/problem_9.c,19,3,18,620746441.3018897,6963256538.0,0.0891459962177829,1401.0,1377.0,39781.0,13746.0,1624.0,642.0,1344.0,599.0,1500000000,0.4138309608679265,1082014363648.0,3.9895126437462884e-07,0.078633213144768,"#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int i, j, k, ni=0, nj=0, nk=0;
    
    for(i=1;i<999;i++)
        for(j=1;j<999;j++)
            for(k=1;k<999;k++)
                if((i*i)+(j*j)==(k*k))
                {
                    if(i+j+k==1000)
                    {
                        ni=i;
                        nj=j;
                        nk=k;
                    }
                }
    
    printf(""Pythagorean triplet with sum 1000: %d, %d, %d\nProduct: %d\n"", ni, nj, nk, ni*nj*nk);
    
    system(""PAUSE"");
	return 0;
}
"
110-18700,peifu/tests,linux/crc16/crc16.c,315,19,140,1830319.5247426499,187456.0,9.763992616934107,1358.0,1340.0,40804.0,14248.0,1643.0,637.0,1361.0,596.0,1500000000,0.0012202130164951,1082014363648.0,0.0143927108228064,0.0769635980527501,"#include <stdio.h>
#include <stdlib.h>

/** CRC table for the CRC-16. The poly is 0x8005 (x^16 + x^15 + x^2 + 1) */
unsigned short const crc16_table[256] = {
	0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241,
	0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
	0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40,
	0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,
	0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40,
	0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,
	0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641,
	0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,
	0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,
	0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,
	0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41,
	0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,
	0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41,
	0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,
	0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640,
	0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,
	0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,
	0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,
	0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41,
	0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,
	0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41,
	0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,
	0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640,
	0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,
	0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241,
	0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,
	0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,
	0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,
	0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40,
	0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,
	0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641,
	0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040
};

static unsigned short crc16_byte(unsigned short crc, const unsigned char data)
{
	return (crc >> 8) ^ crc16_table[(crc ^ data) & 0xff];
}

/**
 * crc16 - compute the CRC-16 for the data buffer
 * @crc:	previous CRC value
 * @buffer:	data pointer
 * @len:	number of bytes in the buffer
 *
 * Returns the updated CRC value.
 */
static unsigned short crc16(unsigned short crc, unsigned char const *buffer, size_t len)
{
	while (len--) {
		crc = crc16_byte(crc, *buffer++);
	}
	return crc;
}

static const unsigned short crc16tbl_[256] = {
	0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241,
	0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
	0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40,
	0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,
	0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40,
	0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,
	0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641,
	0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,
	0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,
	0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,
	0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41,
	0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,
	0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41,
	0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,
	0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640,
	0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,
	0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,
	0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,
	0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41,
	0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,
	0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41,
	0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,
	0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640,
	0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,
	0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241,
	0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,
	0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,
	0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,
	0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40,
	0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,
	0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641,
	0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040
};

unsigned short crc16_fast(const unsigned char* buf, unsigned int len)
{
	unsigned int Y = 0xFFFF;
	int i;
	for (i = 0; i != len; ++i) {
		Y = (Y >> 8) ^ crc16tbl_[(Y & 0xFF) ^ buf[i] ];
	}

	return ((Y & 0xFF) << 8) | (Y >> 8);
}

unsigned short crc16_(const unsigned char* buf, unsigned int len)
{
	unsigned int Y = 0xFFFF;
	int i, j;

	for (i = 0; i != len; ++i) {
		Y ^= buf[i];
		for (j = 0; j != 8; ++j) {
			if (Y & 1) {
				Y = (Y >> 1) ^ 0xA001;
			} else {
				Y = (Y >> 1);
			}
		}
	}

	return ((Y & 0xFF) << 8) | (Y >> 8);
}

#define CRC_SEED 0xFFFF
#define POLY16 0x1021
//#define POLY16 0x8005
unsigned short crc16_4(unsigned char *buf, unsigned short length)
{
	unsigned short shift, data, val;
	int i;

	shift = CRC_SEED;

	for (i = 0; i < length; i++) {
		if ((i % 8) == 0) {
			data = (*buf++) << 8;
		}
		val = shift ^ data;
		shift = shift << 1;
		data = data << 1;
		if (val & 0x8000) {
			shift = shift ^ POLY16;
		}
	}
	return shift;
}

static unsigned short ccitt_table[256] = {
	0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,
	0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,
	0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,
	0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,
	0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485,
	0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,
	0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4,
	0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,
	0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823,
	0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B,
	0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12,
	0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,
	0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41,
	0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,
	0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70,
	0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,
	0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F,
	0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,
	0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E,
	0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,
	0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D,
	0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
	0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C,
	0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,
	0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB,
	0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,
	0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A,
	0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92,
	0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9,
	0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,
	0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,
	0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0
};

unsigned short crc_ccitt(unsigned char *q, int len)
{
	unsigned short crc = 0;

	while (len-- > 0) {
		crc = ccitt_table[(crc >> 8 ^ *q++) & 0xff] ^ (crc << 8);
	}
	return ~crc;

}

unsigned short crc_dsp(unsigned short reg, unsigned char data_crc)
{
	unsigned short msb;
	unsigned short data;
	unsigned short gx = 0x8005, i = 0;
	data = (unsigned short)data_crc;
	data = data << 8;
	reg = reg ^ data;
	do {
		msb = reg & 0x8000;
		reg = reg << 1;
		if (msb == 0x8000) {
			reg = reg ^ gx;
		}
		i++;
	} while (i < 8);
	return (reg);
}

unsigned short crc_16(unsigned char *data, unsigned int len)
{
	unsigned short crc = ~0x0000;
	unsigned char *p = data;
	while (len-- > 0) {
		crc = crc_dsp(crc, *p++);
	}

	return crc;
}

/**
  * @brief  Update CRC16 for input byte
  * @param  CRC input value
  * @param  input byte
  * @retval None
  */
unsigned short UpdateCRC16(unsigned short crcIn, unsigned char byte)
{
  unsigned int crc = crcIn;
  unsigned int in = byte | 0x100;

  do
  {
    crc <<= 1;
    in <<= 1;
    if(in & 0x100)
      ++crc;
    if(crc & 0x10000)
      crc ^= 0x1021;
  }

  while(!(in & 0x10000));

  return crc & 0xffffu;
}

/**
  * @brief  Cal CRC16 for YModem Packet
  * @param  data
  * @param  length
  * @retval None
  */
unsigned short Cal_CRC16(const unsigned char* data, unsigned int size)
{
  unsigned int crc = 0;
  const unsigned char* dataEnd = data+size;

  while(data < dataEnd)
    crc = UpdateCRC16(crc, *data++);

  crc = UpdateCRC16(crc, 0);
  crc = UpdateCRC16(crc, 0);

  return crc&0xffffu;
}

static void crc16_b(unsigned int *crc, unsigned char db)
{
    int i;

    for(i=0;i<8;i++) {
        *crc <<= 1;
        if((db^(*crc>>16)) & 1)
            *crc ^= 0x8005;
        db >>= 1;
    }
    *crc &= 0xFFFF;
}

static unsigned int crc16_area(unsigned char *dbs, int size, unsigned int crc)
{
    while(size--)
        crc16_b(&crc, *(dbs++));
    return crc;
}

unsigned short csum(unsigned char *addr, int count)
{
       /* Compute Internet Checksum for ""count"" bytes
        * beginning at location ""addr"".
       */
       unsigned long sum = 0;

       while( count > 1 )

       {
           /* This is the inner loop */
           sum += * (unsigned short *) addr++;
           count -= 2;
        }

       /* Add left-over byte, if any */
       if( count > 0 )
           sum += * (unsigned char *) addr;

       /* Fold 32-bit sum to 16 bits */
       while (sum>>16)
           sum = (sum & 0xffff) + (sum >> 16);

       return ~sum;
}

int main(int argc, char **argv)
{
#if 0
	unsigned char buf[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
	unsigned int len = 4;
	unsigned char buf[] = {0x7E, 0x00, 0x05, 0x60, 0x31, 0x32, 0x33};
	unsigned int len = 7;
#endif
	unsigned char buf[] = {0x45, 0x00, 0x00, 0x83, 0x00, 0x00, 0x40, 0x00, 0x40, 0x11, 
		0x00, 0x00, 0x0a, 0x44, 0x0c, 0x03, 0xff, 0xff, 0xff, 0xff};
	unsigned int len = 20;
	unsigned short cksum1;
	unsigned short cksum2;
	unsigned short cksum3;
	unsigned short cksum4;
	unsigned short cksum5;
	unsigned short cksum6;
	unsigned short cksum7;
	unsigned short cksum8;
	unsigned short cksum9;
	int i;

	cksum1 = crc16_(buf, len);
	cksum2 = crc16_fast(buf, len);
	cksum3 = crc16(~0x0000, buf, len);
	cksum4 = crc16_4(buf, len);
	cksum5 = crc_ccitt(buf, len);
	cksum6 = crc_16(buf, len);
	cksum7 = Cal_CRC16(buf, len);
	cksum8 = crc16_area(buf, len, ~0x0000);
	cksum9 = csum(buf, len);

	printf(""crc16_1: 0x%x\n"", cksum1);
	printf(""crc16_2: 0x%x\n"", cksum2);
	printf(""crc16_3: 0x%x\n"", cksum3);
	printf(""crc16_4: 0x%x\n"", cksum4);
	printf(""crc16_5: 0x%x\n"", cksum5);
	printf(""crc16_6: 0x%x\n"", cksum6);
	printf(""crc16_7: 0x%x\n"", cksum7);
	printf(""crc16_8: 0x%x\n"", cksum8);
	printf(""crc16_9: 0x%x\n"", cksum9);

	return 0;
}


"
191-18588,ernestyalumni/CompPhys,CFitz/random.c,24,1,28,120374941.4999037,728895301.0,0.1651470942875511,1461.0,1433.0,220042332.0,90014364.0,1653.0,639.0,1367.0,596.0,1500000000,0.0802499609999358,1082014363648.0,3.970391901319172e-06,1.3723296593472053e-05,"/* random.c */
/*
  Program to test operation of rand() function
*/

#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#define N_MAX 10000000

int main()
{
  int i, seed;
  double sum_0, sum_1, mean, var, x;

  /* Seed random number generator */
  seed = time(NULL);
  srand(seed);

  /* Calculate mean and variance of x: random number uniformly
     distributed in range 0 to 1 */
  for (i = 1, sum_0 = 0., sum_1 = 0.; i <= N_MAX; i++)
    {
      x = (double) rand() / (double) RAND_MAX;

      sum_0 += x;
      sum_1 += (x - 0.5) * (x - 0.5);
    }
  mean = sum_0 / (double) N_MAX;
  var = sum_1 / (double) N_MAX;

  printf(""mean(x) = %12.10f  var(x) = %12.10f\n"", mean, var);

  return 0;
}

"
290-3575,Shinigami072/CzLab,lab-5/03.c,40,4,27,1941602.90993745,205872.0,9.431112535944663,1473.0,1447.0,46891.0,17403.0,1660.0,642.0,1375.0,599.0,1500000000,0.0012944019399583,1082014363648.0,0.0141835703738245,0.0665069835443431,"#include<stdlib.h>
#include<stdio.h>
#include<time.h>

double* vector(int n){
	double *v;
	v = malloc( n* sizeof(double));
	for(int i=0;i<n;i++)
		v[i]=0.0;
	return v;
}
void initVec(double *a,int size){
	for(int i=0;i<size;i++)
		a[i]=(double)(rand()%100)/10.0;
}
void printTab(double *d,int size)
{
	printf(""["");
	for(int i=0;i<size-1;i++)
		printf(""%f,"",d[i]);
	printf(""%f]"",d[size-1]);
	

}
double * addVec(double *a,double *b,int size)
{
	double *c = vector(size);
	for(int i=0;i<size;i++)
		c[i]=a[i]+b[i];
	return c;
}
int main(){
	int size =4;
	srand(time(0));

	double *a = vector(size);
	initVec(a,size);
	double *b = vector(size);
	initVec(b,size);
	double *c = addVec(a,b,size);


	printTab(a,size);
	printf(""\n"");
	printTab(b,size);
	printf(""\n"");
	printTab(c,size);
	printf(""\n"");
}
"
244-12236,aaronshim/ctci-workspace,Chapter1/1-3/urlify.c,59,4,49,1851093.0240153002,173971.0,10.640238890389778,1141.0,1133.0,39804.0,13211.0,1603.0,588.0,1345.0,547.0,1500000000,0.0012340620160102,1082014363648.0,0.0130711440412482,0.0770159388852211,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//must supply string with enough buffer at the end to do in-place sub
// plus the ""true length"" of the string (length minus buffers)
// (this will do the in place swap and then return the pointer)
char* urlify(char* str, int len_true)
{
	//moving from back to front with two pointers seems better
	int write_pos = strlen(str) - 1;
	for (int i=len_true-1; i >= 0; i--)
	{
		if (str[i] == ' ')
		{
			str[write_pos] = '0';
			str[write_pos-1] = '2';
			str[write_pos-2] = '%';
			write_pos-=3;
		}
		else
		{
			str[write_pos] = str[i];
			write_pos--;
		}
	}

	return str;
}

int main(int argc, char* argv[])
{
	//process every argument
	if (argc > 1)
	{
		for (int i=1; i < argc; i++)
		{
			//we will work on getting the version of the string
			// with enough spaces
			int len = strlen(argv[i]);
			int spaces = 0;
			for (int j=0; j < len; j++)
			{
				if (argv[i][j] == ' ')
				{
					spaces++;
				}
			}
			//each space now counts as three (plus null terminator)
			int buffered_len = len + 2*spaces + 1;
			char* buffered_str = calloc(buffered_len,sizeof(char));
			strcpy(buffered_str, argv[i]);
			//move terminator
			buffered_str[buffered_len-1] = buffered_str[len];
			for (int k=len; k<=buffered_len-2; k++)
			{
				buffered_str[k] = ' ';
			}

			urlify(buffered_str, len);
			printf(""%s -> %s\n"", argv[i], buffered_str);

			free(buffered_str);
		}
	}

	return EXIT_SUCCESS;
}"
396-29283,niceandcoolusername/cosmos,code/dynamic_programming/maximum_sum_increasing_subsequence/maximum_sum_increasing_subsequence.c,33,4,24,2071549.65028155,175474.0,11.80544696080331,1345.0,1326.0,39803.0,13514.0,1634.0,635.0,1352.0,594.0,1500000000,0.0013810331001877,1082014363648.0,0.015221628275414,0.07905546073485,"/* Part of Cosmos by OpenGenus Foundation */

#include <stdio.h>

int maxSum(int arr[], int N)
{
    int i , j , max = 0;
    int MSis[N];


    for(i = 0; i<=N; i++)
    {
        MSis[i] = arr[i];
    }
    /* Compute maximum sum values in bottom up manner */
    for(i=1; i < N; i++)
    {
      for(j=0; j < i; j++)
      {
          if(arr[j] < arr[i] && MSis[i] < MSis[j] + arr[i])
            MSis[i] = MSis[j] + arr[i];

      }
    }
    /*Find the max value of array MSis */
    for(i=0; i < N; i++)
    {
        if(max < MSis[i])
            max = MSis[i];
    }
    return max;
}
int main() {
	int arr[] = {4, 6, 1, 3, 8, 4, 6};
    int n = sizeof(arr)/sizeof(arr[0]);
    printf(""Sum of maximum sum increasing subsequence is %d"",
           maxSum( arr, n ) );
	return 0;
}
"
130-25727,mattstock/binutils-bexkat1,gdb/testsuite/gdb.linespec/thread.c,24,1,22,1545633.0729647998,169083.0,9.141267898014585,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010304220486432,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2012-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* http://sourceware.org/bugzilla/show_bug.cgi?id=14643 */

static void
thread ()
{
}

int
main ()
{
  int x = 0;
  thread (); /* set breakpoint 1 here */
  return x;
}
"
312-25158,CajetanP/coding-exercises,CodeWars/Fundamentals/BuildTower/BuildTower.c,39,5,32,1804832.9511656999,181217.0,9.959507110260075,1341.0,1321.0,41163.0,14327.0,1631.0,641.0,1356.0,597.0,1500000000,0.0012032219674438,1082014363648.0,0.0146895710667321,0.0761398450171202,"#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>

char** towerBuilder (int nFloors) {
    char** res = malloc (sizeof(char*)*nFloors);

    int i;
    for (i = 0 ; i < nFloors ; ++i)
        res[i] = malloc(sizeof(char)*(2*nFloors));

    char* temp = malloc(sizeof(char)*(2*nFloors));
    for (i = 0 ; i < nFloors ; ++i) {
        memset (temp, ' ', nFloors-i-1);
        strcat (res[i], temp);
        strcpy (temp, """");

        memset (temp, '*', i*2+1);
        strcat (res[i], temp);
        strcpy (temp, """");

        memset (temp, ' ', nFloors-i-1);
        strcat (res[i], temp);
        strcpy (temp, """");
    }

    free (temp);

    return res;
}

void tests () {
    int floors = 2;
    char** actual = towerBuilder (floors);

    int i;
    for (i = 0 ; i < floors ; ++i)
        printf (""%s\n"", actual[i]);

    floors = 3;

    printf (""\n"");

    actual = towerBuilder (floors);

    for (i = 0 ; i < floors ; ++i)
        printf (""%s\n"", actual[i]);

    for (i = 0 ; i < floors ; ++i)
        free (actual[i]);

    free (actual);

}

int main () {
    tests ();
    return 0;
}

"
103-18766,EvtimPavlov/c-programming-2014-2015-homework,A/03_Antonio_Mindov/homework_vector/main.c,113,3,83,2057987.7309500999,186025.0,11.062959279666712,1381.0,1360.0,42248.0,15112.0,1640.0,639.0,1355.0,598.0,1500000000,0.0013719918206334,1082014363648.0,0.0147345786856605,0.0737796373779637,"#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

// index, size, data
// [0, 0, 0, 0, 0]
// [0, -1, -2, -3, -4 ...]

struct vector_t {
    int *data;
    int index, size;
};

void vector_init(struct vector_t*);
void vector_destroy(struct vector_t*);
int vector_get_size(struct vector_t);
int vector_resize(struct vector_t* v,int);
int vector_at(struct vector_t, int);
void vector_push_back(struct vector_t*, int);
int vector_pop_back(struct vector_t*);
void vector_copy(struct vector_t*, struct vector_t*);

int main() {
    struct vector_t myVector, secondVector;

    vector_init(&myVector);

    vector_push_back(&myVector,3);
    vector_push_back(&myVector,1);
    vector_push_back(&myVector,4);
    vector_push_back(&myVector,1);
    vector_push_back(&myVector,5);
    vector_push_back(&myVector,9);
    vector_push_back(&myVector,2);
    vector_push_back(&myVector,6);

    vector_copy(&myVector, &secondVector);
    printf(""Size of copied vector: %d\n"", vector_get_size(secondVector));

    printf(""Size: %d\n"", vector_get_size(myVector));
    printf(""Pop: %d\n"", vector_pop_back(&myVector));
    printf(""Pop: %d\n"", vector_pop_back(&myVector));
    printf(""Pop: %d\n"", vector_pop_back(&myVector));
    printf(""Pop: %d\n"", vector_pop_back(&myVector));
    printf(""Pop: %d\n"", vector_pop_back(&myVector));
    printf(""Size: %d\n"", vector_get_size(myVector));
    printf(""Pop: %d\n"", vector_pop_back(&myVector));
    printf(""Pop: %d\n"", vector_pop_back(&myVector));
    printf(""Pop: %d\n"", vector_pop_back(&myVector));
    printf(""Size: %d\n"", vector_get_size(myVector));

    vector_destroy(&myVector);
    return 0;
}

void vector_init(struct vector_t* v) {
    v->size = 5;
    v->index = 0;
    v->data = (int*) malloc(v->size * sizeof(int));
}

void vector_destroy(struct vector_t* v){
    free(v->data);
    v->size = 0;
    v->index = 0;
}

int vector_get_size(struct vector_t v) {
    return v.index;
}

void vector_push_back(struct vector_t* v, int value) {
    if(v->index >= v->size)
    {
        vector_resize(v, 0);
    }
    v->data[v->index++] = value;
}

int vector_at(struct vector_t v, int index) {
    if(index < 0 || index >= v.index)
    {
        return INT_MAX;
    }

    return v.data[index];
}

int vector_pop_back(struct vector_t* v) {
    if(v->index <= 0)
    {
        return INT_MAX;
    }
    if(v->index <= v->size / 2)
    {
        vector_resize(v, 1);
    }

    return v->data[--v->index];
}

int vector_resize(struct vector_t* v, int makeLower)
{
    int i;
    int oldData[v->size];

    for(i = 0; i < v->index; i++)
    {
        oldData[i] = vector_at(*v,i);
    }

    if(makeLower==0)
    {
        v->size *= 2;
    }
    else
    {
        v->size /= 2;
    }

    free(v->data);
    v->data = (int*) malloc(v->size * sizeof(int));

    for(i = 0; i < v->index; i++)
    {
        v->data[i] = oldData[i];
    }

    return v->size;
}

void vector_copy(struct vector_t* from, struct vector_t* to)
{
    vector_init(to);
    int i;

    for(i=0; i<vector_get_size(*from); i++)
    {
        vector_push_back(to,vector_at(*from,i));
    }
}
"
278-12713,dawter/tools,find_missing.c,46,4,38,2305773.2032611,189493.0,12.168117028069638,1381.0,1359.0,42802.0,15660.0,1636.0,639.0,1353.0,594.0,1500000000,0.0015371821355074,1082014363648.0,0.014459637031447,0.0722178509117033,"#include <stdio.h>

/*
 * Given an array contains N numbers of 0 .. N, find which number doesn't exist in the array.
 */

void output(int *array, size_t len)
{
	int i;
	for(i=0; i<len; i++) {
		printf(""%2i,"", array[i]);
	}
	puts("""");

}

void swap(int *x, int *y)
{
	if( x != y) {
		*x = *x ^ *y;
		*y = *x ^ *y;
		*x = *x ^ *y;
	}
}

/* find missing number in 0...N array */
int find_missing0(int array[], size_t len)
{
	int i;

	for(i=0; i<len; i++) {
		while(array[i] != i && array[i] < len)  swap(array+i, array+array[i]);
	}

	for(i=array[0]; i<len; i++) {
		if(array[i] != i) return i;
	}

	return len;
}


/* find missing number in array */
int find_missing1(int array[], size_t len)
{

	return 0;
}

int main(int argc, char** argv)
{
	int retval = 0;
	int array[] = {2, 9, 4, 7, 5, 3, 6, 0, 8};
	size_t len = sizeof(array)/sizeof(array[0]);

	output(array, len);
	printf(""missing: %d\n"", find_missing0(array, len));
	output(array, len);

	return retval;
}

"
286-23371,raulperula/uco_student,dpec/practices/p1/non_permutation_code/code.c,26,4,23,20317444.4613978,17477315.0,1.16250373698706,1155.0,1147.0,1320284.0,17294383.0,161625.0,410595.0,161324.0,250546.0,1500000000,0.0135449629742652,1082014363648.0,0.0001317135955952,0.052866376819956,"/**
 * @file    code.c
 * @brief   Brief description.
 *
 * @author  Raul Perula-Martinez <raules@gmail.com>
 * @date    2014-11
 *
 * @license GPL v3
 * @version 1.0.0
 */
 
#include <stdio.h>

float A[2000][2000], B[2000][2000];

int
main()
{
	int i, j;
	
	for(i=0;i<2000;i++){
		for(j=0;j<2000;j++){
			A[i][j] = 0;
		}
	}

	for(i=0;i<1600;i++){
		for(j=0;j<1600;j++){
			A[i][j] = B[i][j];
		}
	}
}
"
152-27746,hyller/CodeLibrary,GnuWin32/libgw32c/src/libgw32c/0.4/libgw32c-0.4/argp/tst-argp1.c,86,4,40,1483802.91648195,261478.0,5.669685403743336,1843.0,1753.0,60323.0,24937.0,1827.0,775.0,1431.0,723.0,1500000000,0.0009892019443213,1082014363648.0,0.0137525910401639,0.05578231292517,"/* Copyright (C) 2002 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#include <argp.h>




#define OPT_TO_THREAD		300
#define OPT_TO_PROCESS		301
#define OPT_SYNC_SIGNAL		302
#define OPT_SYNC_JOIN		303
#define OPT_TOPLEVEL		304


static const struct argp_option options[] =
  {
    { NULL, 0, NULL, 0, ""\
This is a test for threads so we allow ther user to selection the number of \
threads which are used at any one time.  Independently the total number of \
rounds can be selected.  This is the total number of threads which will have \
run when the process terminates:"" },
    { ""threads"", 't', ""NUMBER"", 0, ""Number of threads used at once"" },
    { ""starts"", 's', ""NUMBER"", 0, ""Total number of working threads"" },
    { ""toplevel"", OPT_TOPLEVEL, ""NUMBER"", 0,
      ""Number of toplevel threads which start the other threads; this \
implies --sync-join"" },

    { NULL, 0, NULL, 0, ""\
Each thread can do one of two things: sleep or do work.  The latter is 100% \
CPU bound.  The work load is the probability a thread does work.  All values \
from zero to 100 (inclusive) are valid.  How often each thread repeats this \
can be determined by the number of rounds.  The work cost determines how long \
each work session (not sleeping) takes.  If it is zero a thread would \
effectively nothing.  By setting the number of rounds to zero the thread \
does no work at all and pure thread creation times can be measured."" },
    { ""workload"", 'w', ""PERCENT"", 0, ""Percentage of time spent working"" },
    { ""workcost"", 'c', ""NUMBER"", 0,
      ""Factor in the cost of each round of working"" },
    { ""rounds"", 'r', ""NUMBER"", 0, ""Number of rounds each thread runs"" },

    { NULL, 0, NULL, 0, ""\
There are a number of different methods how thread creation can be \
synchronized.  Synchronization is necessary since the number of concurrently \
running threads is limited."" },
    { ""sync-signal"", OPT_SYNC_SIGNAL, NULL, 0,
      ""Synchronize using a signal (default)"" },
    { ""sync-join"", OPT_SYNC_JOIN, NULL, 0, ""Synchronize using pthread_join"" },

    { NULL, 0, NULL, 0, ""\
One parameter for each threads execution is the size of the stack.  If this \
parameter is not used the system's default stack size is used.  If many \
threads are used the stack size should be chosen quite small."" },
    { ""stacksize"", 'S', ""BYTES"", 0, ""Size of threads stack"" },
    { ""guardsize"", 'g', ""BYTES"", 0,
      ""Size of stack guard area; must fit into the stack"" },

    { NULL, 0, NULL, 0, ""Signal options:"" },
    { ""to-thread"", OPT_TO_THREAD, NULL, 0, ""Send signal to main thread"" },
    { ""to-process"", OPT_TO_PROCESS, NULL, 0,
      ""Send signal to process (default)"" },

    { NULL, 0, NULL, 0, ""Administrative options:"" },
    { ""progress"", 'p', NULL, 0, ""Show signs of progress"" },
    { ""timing"", 'T', NULL, 0,
      ""Measure time from startup to the last thread finishing"" },
    { NULL, 0, NULL, 0, NULL }
  };

/* Prototype for option handler.  */
static error_t parse_opt (int key, char *arg, struct argp_state *state);

/* Data structure to communicate with argp functions.  */
static struct argp argp =
{
  options, parse_opt
};


int
main (void)
{
  int argc = 2;
  char *argv[3] = { (char *) ""tst-argp1"", (char *) ""--help"", NULL };
  int remaining;

  /* Parse and process arguments.  */
  argp_parse (&argp, argc, argv, 0, &remaining, NULL);

  return 0;
}


/* Handle program arguments.  */
static error_t
parse_opt (int key, char *arg, struct argp_state *state)
{
  return ARGP_ERR_UNKNOWN;
}
"
268-16751,metbosch/PCA-Lab,lab4_session/pi/pi_original.c,162,7,81,3567758012.912236,7476398883.0,0.4772027372847169,1313.0,1295.0,1005900191.0,702423698.0,271805.0,31096.0,1365.0,1031.0,1500000000,2.3785053419414908,1082014363648.0,3.488310402926906e-07,0.0001787114270108,"#include <memory.h>
#include <stdio.h>
#include <stdlib.h>

int N, N4;
char a[10240], b[10240], c[10240];
char string[100];

void DIVIDE( char *x, int n )                           
{                                                
    int j, k;
    unsigned q, r, u;
    long v;

    r = 0;                                       
    for( k = 0; k <= N4; k++ )                  
    {                                            
        u = r * 10 + x[k];                       
        q = u / n;                               
        r = u - q * n;                           
        x[k] = q;                                
    }                                           
}

void LONGDIV( char *x, int n )                          
{                                                
    int j, k;
    unsigned q, r, u;
    long v;

    if( n < 6553 )                               
    {                                            
        r = 0;                                   
        for( k = 0; k <= N4; k++ )               
        {                                        
            u = r * 10 + x[k];                   
            q = u / n;                           
            r = u - q * n;                       
            x[k] = q;                            
        }                                       
    }                                            
    else                                         
    {                                            
        r = 0;                                   
        for( k = 0; k <= N4; k++ )              
        {                                       
            if( r < 6553 )                      
            {                                   
                u = r * 10 + x[k];              
                q = u / n;                      
                r = u - q * n;                  
            }                                   
            else                                
            {                                   
                v = (long) r * 10 + x[k];       
                q = v / n;                      
                r = v - q * n;                  
            }                                   
            x[k] = q;                           
        }                                       
    }                                           
}

void MULTIPLY( char *x, int n )                        
{                                            
    int j, k;
    unsigned q, r, u;
    long v;
    r = 0;                                   
    for( k = N4; k >= 0; k-- )               
    {                                        
        q = n * x[k] + r;                    
        r = q / 10;                          
        x[k] = q - r * 10;                   
    }                                        
}

void SET( char *x, int n )                              
{                                                
    memset( x, 0, N4 + 1 );                      
    x[0] = n;                                    
}


void SUBTRACT( char *x, char *y, char *z )                      
{                                                
    int j, k;
    unsigned q, r, u;
    long v;
    for( k = N4; k >= 0; k-- )                   
    {                                            
        if( (x[k] = y[k] - z[k]) < 0 )           
        {                                        
            x[k] += 10;                          
            z[k-1]++;                            
        }                                        
    }                                            
}


void calculate( void );
void progress( void );
void epilog( void );


int main( int argc, char *argv[] )
{
    N = 10000;

    if (argc>1)
      N = atoi(argv[1]);

    setbuf(stdout, NULL);

    calculate();

    epilog();

    return 0;
}

void calculate( void )
{
    int j;

    N4 = N + 4;

    SET( a, 0 );
    SET( b, 0 );

    for( j = 2 * N4 + 1; j >= 3; j -= 2 )
    {
        SET( c, 1 );
        LONGDIV( c, j );

        SUBTRACT( a, c, a );
        DIVIDE( a, 25 );

        SUBTRACT( b, c, b );
        DIVIDE( b, 239 );
        DIVIDE( b, 239 );

        progress();
    }

    SET( c, 1 );

    SUBTRACT( a, c, a );
    DIVIDE( a, 5 );

    SUBTRACT( b, c, b );
    DIVIDE( b, 239 );

    MULTIPLY( a, 4 );
    SUBTRACT( a, a, b );
    MULTIPLY( a, 4 );

    progress();
}

/*

 N = 10000                      
 A = 0                          
 B = 0                          
 J = 2 * (N + 4) + 1            
 FOR J = J TO 3 STEP -2         
     A = (1 / J - A) / 5 ^ 2    
     B = (1 / J - B) / 239 ^ 2  
 NEXT J                         
 A = (1 - A) / 5                
 B = (1 - B) / 239              
 PI = (A * 4 - B) * 4           

*/

void progress( void )
{
    printf(""."");
}

void epilog( void )
{
    int j;

    {
        fprintf( stdout, "" \n3."");
        for( j = 1; j <= N; j++ )
        {
            fprintf( stdout, ""%d"", a[j]);
            if( j % 5  == 0 )
                if( j % 50 == 0 )
                    if( j % 250  == 0 )
                        fprintf( stdout, ""    <%d>\n\n   "", j );
                    else
                        fprintf( stdout, ""\n   "" );
                else
                    fprintf( stdout, "" "" );
        }
    }
}

"
034-1229,EliteTK/c-stuff,crazy-swap.c,26,1,33,1802238.0536421002,169057.0,10.660534612586288,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0012014920357614,1082014363648.0,0.0134155935572026,0.0785563462891999,"/*
 * Copyright (C) 2014  Tomasz Kramkowski <tk@the-tk.com>
 *
 * This program is free software. It is licensed under version 3 of the
 * GNU General Public License.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see [http://www.gnu.org/licenses/].
 */

// Don't try this at home.

static inline void swap(int *a, int *b)
{
        *a=*a^*b;
        *b=*b^*a;
        *a=*a^*b;
}

int main(int argc, char **argv)
{
        int i;
        for (i = 0; i < 999999999; i++) {
                int a = 2;
                int b = 123;
                swap(&a, &b);
        }
        return 0;
}
"
308-2427,fedora-conary/conary,config/site/sizeof.c,24,1,30,2373663.12649095,177011.0,13.409692053036252,1340.0,1320.0,40020.0,13890.0,1621.0,638.0,1343.0,595.0,1500000000,0.0015824420843273,1082014363648.0,0.0150273146866578,0.0778519755147468,"/*
 * Copyright (c) SAS Institute Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include <stdio.h>

int main(void) {
    printf(""ac_cv_sizeof_char=%d\n"", sizeof(char));
    printf(""ac_cv_sizeof_short=%d\n"", sizeof(short));
    printf(""ac_cv_sizeof_int=%d\n"", sizeof(int));
    printf(""ac_cv_sizeof_long=%d\n"", sizeof(long));
    printf(""ac_cv_sizeof_long_long=%d\n"", sizeof(long long));
    printf(""ac_cv_sizeof_double=%d\n"", sizeof(double));
    printf(""ac_cv_sizeof_char_p=%d\n"", sizeof(char *));
}
"
223-24206,zhaoqin/Umbra,test/micro-bench.c,37,2,32,1502549074.7066214,2867388419.0,0.5240130929049414,1496.0,1464.0,409641718.0,819214674.0,1769.0,25601713.0,1369.0,51844.0,1500000000,1.0016993831377476,1082014363648.0,1.0322982336073947e-06,0.0208785136872201,"#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>

 int *p1, *p2;
//long size = 4000 * 4096;
//#define size  (100 * 4096)
long size = 100 * 4096;
//long size = 1024;

void *mem_scan(void *ptr)
{
  long i, j;
  int *p = (int *)ptr;
  volatile int trash = 0;
  
  for (j = 0; j < 500; j++) 
  {
  for (i = 0; i < size; i += 1) {
      p[i] = i;
      trash++;
      //      if (i % 1024 == 0)
      //	printf(""p[%d] at %p is %d\n"", i, &p[i], p[i]);
  }
  }
}


int main()
{
  pthread_t thread1, thread2;
  char *msg1 = ""thread 1"";
  char *msg2 = ""thread 2"";
  p1 = malloc(size * sizeof(int));
  p2 = malloc(size * sizeof(int));
  printf(""create thread 1\n"");
  pthread_create(&thread1, NULL, mem_scan, p1);
  printf(""create thread 2\n"");
  pthread_create(&thread2, NULL, mem_scan, p2);
  sleep(1);
  pthread_join(thread1, NULL);
  pthread_join(thread2, NULL);
  printf(""exiting"");
  return 0;
}
"
183-18644,selmentdev/selment-toolchain,source/gcc-latest/gcc/testsuite/c-c++-common/tsan/thread_leak2.c,15,1,21,1531904797.6518047,181213.0,8453.614238492823,1357.0,1336.0,41439.0,14725.0,1643.0,754.0,1355.0,708.0,1500000000,1.021269865101203,1082014363648.0,0.014860964721074,0.079410298411794,"/* { dg-shouldfail ""tsan"" } */

#include <pthread.h>
#include <unistd.h>

void *Thread(void *x) {
  return 0;
}

int main() {
  int i;
  for (i = 0; i < 5; i++) {
    pthread_t t;
    pthread_create(&t, 0, Thread, 0);
  }
  sleep(1);
  return 0;
}

/* { dg-output ""WARNING: ThreadSanitizer: thread leak.*(\n|\r\n|\r)"" } */
/* { dg-output ""  And 4 more similar thread leaks.*"" } */
"
030-23137,ericdahl/project-euler,c/p073.c,88,10,71,112934164.70289224,557984240.0,0.2023966913474115,1410.0,1385.0,146669266.0,1192429.0,14025007.0,30353.0,2208.0,16650.0,1500000000,0.0752894431352615,1082014363648.0,5.009102049190494e-06,0.095185017323114,"#include <stdlib.h>
#include <stdio.h>
#include <string.h>

struct node* gen_primes(const int max);
struct node** gen_factors(const int max, struct node* primes);
int relative_prime(int n, int d, struct node** factors);

struct node {
    int value;
    struct node* next;
};

int main(int argc, char** argv) {
    const int max = 12000;
    struct node* primes = gen_primes(max);
    struct node** factors = gen_factors(max + 1, primes);

    int count = 0;
    for (int d = 2; d <= max; ++d) {
        for (int n = d / 3 + 1; n < (d - 1) / 2 + 1; ++n) {
            double result = 1.0 * n / d;
            if (result > 1.0 / 3.0 && result < 1.0 / 2.0 && relative_prime(n, d, factors)) {
                count++;
            }
        }
    }

    printf(""%d\n"", count);
    return EXIT_SUCCESS;
}

struct node* gen_primes(const int max) {
    int* primes = calloc(max, sizeof(int));

    primes[0] = 1;
    primes[1] = 1;

    for (int i = 2; i < max; ) {
        for (int j = i * 2; j < max; j += i) {
            primes[j] = 1;
        }
        
        for (i += 1; i < max; i++) {
            if (!primes[i]) {
                break;
            }
        }
    }

    struct node* head = 0;
    struct node* curr = 0;
    for (int i = 0; i < max; ++i) {
        if (!primes[i]) {
            struct node* n = calloc(1, sizeof (struct node));
            n->value = i;
            if (!head) {
                head = n;
            } else {
                curr->next = n;
            }
            curr = n;
        }
    }
    free(primes);
    return head;
}

struct node** gen_factors(const int max, struct node* primes) {
    struct node** factors = calloc(max, sizeof(struct node*));

    for (int i = 1; i < max; ++i) {
        int n = i;
        struct node* n_factors = factors[i];
        for (const struct node* curr = primes; curr; curr = curr->next) {

            if (n % curr->value == 0) {
                n /= curr->value;

                struct node* factor = calloc(1, sizeof(struct node));
                factor->value = curr->value;
                
                if (n_factors == 0) {
                    n_factors = factor;
                    factors[i] = n_factors;
                } else {
                    n_factors->next = factor;
                    n_factors = factor;
                }
            } else if (curr->value > n) {
               break;
            } 
        }
    }
    return factors;
}

int relative_prime(int n, int d, struct node** factors) {
    for (const struct node* n_factor = factors[n]; n_factor; n_factor = n_factor->next) {
        for (const struct node* d_factor = factors[d]; d_factor; d_factor = d_factor->next) {
            if (n_factor->value == d_factor->value) {
                return 0;
            }
        }
        
    }
    return 1;
}
"
210-6578,SuperrSonic/WiiMC-SSLC,source/mplayer/ffmpeg/tools/qt-faststart.c,267,7,215,1756610.81448195,181766.0,9.664128604909608,1306.0,1289.0,41724.0,14348.0,1693.0,640.0,1397.0,596.0,1500000000,0.0011710738763213,1082014363648.0,0.014276597383449,0.0771508061064345,"/*
 * qt-faststart.c, v0.2
 * by Mike Melanson (melanson@pcisys.net)
 * This file is placed in the public domain. Use the program however you
 * see fit.
 *
 * This utility rearranges a Quicktime file such that the moov atom
 * is in front of the data, thus facilitating network streaming.
 *
 * To compile this program, start from the base directory from which you
 * are building FFmpeg and type:
 *  make tools/qt-faststart
 * The qt-faststart program will be built in the tools/ directory. If you
 * do not build the program in this manner, correct results are not
 * guaranteed, particularly on 64-bit platforms.
 * Invoke the program with:
 *  qt-faststart <infile.mov> <outfile.mov>
 *
 * Notes: Quicktime files can come in many configurations of top-level
 * atoms. This utility stipulates that the very last atom in the file needs
 * to be a moov atom. When given such a file, this utility will rearrange
 * the top-level atoms by shifting the moov atom from the back of the file
 * to the front, and patch the chunk offsets along the way. This utility
 * presently only operates on uncompressed moov atoms.
 */

#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
#include <string.h>

#ifdef __MINGW32__
#define fseeko(x, y, z) fseeko64(x, y, z)
#define ftello(x)       ftello64(x)
#endif

#define BE_16(x) ((((uint8_t*)(x))[0] <<  8) | ((uint8_t*)(x))[1])

#define BE_32(x) ((((uint8_t*)(x))[0] << 24) |  \
                  (((uint8_t*)(x))[1] << 16) |  \
                  (((uint8_t*)(x))[2] <<  8) |  \
                   ((uint8_t*)(x))[3])

#define BE_64(x) (((uint64_t)(((uint8_t*)(x))[0]) << 56) |  \
                  ((uint64_t)(((uint8_t*)(x))[1]) << 48) |  \
                  ((uint64_t)(((uint8_t*)(x))[2]) << 40) |  \
                  ((uint64_t)(((uint8_t*)(x))[3]) << 32) |  \
                  ((uint64_t)(((uint8_t*)(x))[4]) << 24) |  \
                  ((uint64_t)(((uint8_t*)(x))[5]) << 16) |  \
                  ((uint64_t)(((uint8_t*)(x))[6]) <<  8) |  \
                  ((uint64_t)( (uint8_t*)(x))[7]))

#define BE_FOURCC(ch0, ch1, ch2, ch3)           \
    ( (uint32_t)(unsigned char)(ch3)        |   \
     ((uint32_t)(unsigned char)(ch2) <<  8) |   \
     ((uint32_t)(unsigned char)(ch1) << 16) |   \
     ((uint32_t)(unsigned char)(ch0) << 24) )

#define QT_ATOM BE_FOURCC
/* top level atoms */
#define FREE_ATOM QT_ATOM('f', 'r', 'e', 'e')
#define JUNK_ATOM QT_ATOM('j', 'u', 'n', 'k')
#define MDAT_ATOM QT_ATOM('m', 'd', 'a', 't')
#define MOOV_ATOM QT_ATOM('m', 'o', 'o', 'v')
#define PNOT_ATOM QT_ATOM('p', 'n', 'o', 't')
#define SKIP_ATOM QT_ATOM('s', 'k', 'i', 'p')
#define WIDE_ATOM QT_ATOM('w', 'i', 'd', 'e')
#define PICT_ATOM QT_ATOM('P', 'I', 'C', 'T')
#define FTYP_ATOM QT_ATOM('f', 't', 'y', 'p')
#define UUID_ATOM QT_ATOM('u', 'u', 'i', 'd')

#define CMOV_ATOM QT_ATOM('c', 'm', 'o', 'v')
#define STCO_ATOM QT_ATOM('s', 't', 'c', 'o')
#define CO64_ATOM QT_ATOM('c', 'o', '6', '4')

#define ATOM_PREAMBLE_SIZE    8
#define COPY_BUFFER_SIZE   1024

int main(int argc, char *argv[])
{
    FILE *infile  = NULL;
    FILE *outfile = NULL;
    unsigned char atom_bytes[ATOM_PREAMBLE_SIZE];
    uint32_t atom_type   = 0;
    uint64_t atom_size   = 0;
    uint64_t atom_offset = 0;
    uint64_t last_offset;
    unsigned char *moov_atom = NULL;
    unsigned char *ftyp_atom = NULL;
    uint64_t moov_atom_size;
    uint64_t ftyp_atom_size = 0;
    uint64_t i, j;
    uint32_t offset_count;
    uint64_t current_offset;
    uint64_t start_offset = 0;
    unsigned char copy_buffer[COPY_BUFFER_SIZE];
    int bytes_to_copy;

    if (argc != 3) {
        printf(""Usage: qt-faststart <infile.mov> <outfile.mov>\n"");
        return 0;
    }

    if (!strcmp(argv[1], argv[2])) {
        fprintf(stderr, ""input and output files need to be different\n"");
        return 1;
    }

    infile = fopen(argv[1], ""rb"");
    if (!infile) {
        perror(argv[1]);
        goto error_out;
    }

    /* traverse through the atoms in the file to make sure that 'moov' is
     * at the end */
    while (!feof(infile)) {
        if (fread(atom_bytes, ATOM_PREAMBLE_SIZE, 1, infile) != 1) {
            break;
        }
        atom_size = (uint32_t) BE_32(&atom_bytes[0]);
        atom_type = BE_32(&atom_bytes[4]);

        /* keep ftyp atom */
        if (atom_type == FTYP_ATOM) {
            ftyp_atom_size = atom_size;
            free(ftyp_atom);
            ftyp_atom = malloc(ftyp_atom_size);
            if (!ftyp_atom) {
                printf(""could not allocate %""PRIu64"" bytes for ftyp atom\n"",
                       atom_size);
                goto error_out;
            }
            fseeko(infile, -ATOM_PREAMBLE_SIZE, SEEK_CUR);
            if (fread(ftyp_atom, atom_size, 1, infile) != 1) {
                perror(argv[1]);
                goto error_out;
            }
            start_offset = ftello(infile);
        } else {
            /* 64-bit special case */
            if (atom_size == 1) {
                if (fread(atom_bytes, ATOM_PREAMBLE_SIZE, 1, infile) != 1) {
                    break;
                }
                atom_size = BE_64(&atom_bytes[0]);
                fseeko(infile, atom_size - ATOM_PREAMBLE_SIZE * 2, SEEK_CUR);
            } else {
                fseeko(infile, atom_size - ATOM_PREAMBLE_SIZE, SEEK_CUR);
            }
        }
        printf(""%c%c%c%c %10""PRIu64"" %""PRIu64""\n"",
               (atom_type >> 24) & 255,
               (atom_type >> 16) & 255,
               (atom_type >>  8) & 255,
               (atom_type >>  0) & 255,
               atom_offset,
               atom_size);
        if ((atom_type != FREE_ATOM) &&
            (atom_type != JUNK_ATOM) &&
            (atom_type != MDAT_ATOM) &&
            (atom_type != MOOV_ATOM) &&
            (atom_type != PNOT_ATOM) &&
            (atom_type != SKIP_ATOM) &&
            (atom_type != WIDE_ATOM) &&
            (atom_type != PICT_ATOM) &&
            (atom_type != UUID_ATOM) &&
            (atom_type != FTYP_ATOM)) {
            printf(""encountered non-QT top-level atom (is this a QuickTime file?)\n"");
            break;
        }
        atom_offset += atom_size;

        /* The atom header is 8 (or 16 bytes), if the atom size (which
         * includes these 8 or 16 bytes) is less than that, we won't be
         * able to continue scanning sensibly after this atom, so break. */
        if (atom_size < 8)
            break;
    }

    if (atom_type != MOOV_ATOM) {
        printf(""last atom in file was not a moov atom\n"");
        free(ftyp_atom);
        fclose(infile);
        return 0;
    }

    /* moov atom was, in fact, the last atom in the chunk; load the whole
     * moov atom */
    fseeko(infile, -atom_size, SEEK_END);
    last_offset    = ftello(infile);
    moov_atom_size = atom_size;
    moov_atom      = malloc(moov_atom_size);
    if (!moov_atom) {
        printf(""could not allocate %""PRIu64"" bytes for moov atom\n"", atom_size);
        goto error_out;
    }
    if (fread(moov_atom, atom_size, 1, infile) != 1) {
        perror(argv[1]);
        goto error_out;
    }

    /* this utility does not support compressed atoms yet, so disqualify
     * files with compressed QT atoms */
    if (BE_32(&moov_atom[12]) == CMOV_ATOM) {
        printf(""this utility does not support compressed moov atoms yet\n"");
        goto error_out;
    }

    /* close; will be re-opened later */
    fclose(infile);
    infile = NULL;

    /* crawl through the moov chunk in search of stco or co64 atoms */
    for (i = 4; i < moov_atom_size - 4; i++) {
        atom_type = BE_32(&moov_atom[i]);
        if (atom_type == STCO_ATOM) {
            printf("" patching stco atom...\n"");
            atom_size = BE_32(&moov_atom[i - 4]);
            if (i + atom_size - 4 > moov_atom_size) {
                printf("" bad atom size\n"");
                goto error_out;
            }
            offset_count = BE_32(&moov_atom[i + 8]);
            for (j = 0; j < offset_count; j++) {
                current_offset  = BE_32(&moov_atom[i + 12 + j * 4]);
                current_offset += moov_atom_size;
                moov_atom[i + 12 + j * 4 + 0] = (current_offset >> 24) & 0xFF;
                moov_atom[i + 12 + j * 4 + 1] = (current_offset >> 16) & 0xFF;
                moov_atom[i + 12 + j * 4 + 2] = (current_offset >>  8) & 0xFF;
                moov_atom[i + 12 + j * 4 + 3] = (current_offset >>  0) & 0xFF;
            }
            i += atom_size - 4;
        } else if (atom_type == CO64_ATOM) {
            printf("" patching co64 atom...\n"");
            atom_size = BE_32(&moov_atom[i - 4]);
            if (i + atom_size - 4 > moov_atom_size) {
                printf("" bad atom size\n"");
                goto error_out;
            }
            offset_count = BE_32(&moov_atom[i + 8]);
            for (j = 0; j < offset_count; j++) {
                current_offset  = BE_64(&moov_atom[i + 12 + j * 8]);
                current_offset += moov_atom_size;
                moov_atom[i + 12 + j * 8 + 0] = (current_offset >> 56) & 0xFF;
                moov_atom[i + 12 + j * 8 + 1] = (current_offset >> 48) & 0xFF;
                moov_atom[i + 12 + j * 8 + 2] = (current_offset >> 40) & 0xFF;
                moov_atom[i + 12 + j * 8 + 3] = (current_offset >> 32) & 0xFF;
                moov_atom[i + 12 + j * 8 + 4] = (current_offset >> 24) & 0xFF;
                moov_atom[i + 12 + j * 8 + 5] = (current_offset >> 16) & 0xFF;
                moov_atom[i + 12 + j * 8 + 6] = (current_offset >>  8) & 0xFF;
                moov_atom[i + 12 + j * 8 + 7] = (current_offset >>  0) & 0xFF;
            }
            i += atom_size - 4;
        }
    }

    /* re-open the input file and open the output file */
    infile = fopen(argv[1], ""rb"");
    if (!infile) {
        perror(argv[1]);
        goto error_out;
    }

    if (start_offset > 0) { /* seek after ftyp atom */
        fseeko(infile, start_offset, SEEK_SET);
        last_offset -= start_offset;
    }

    outfile = fopen(argv[2], ""wb"");
    if (!outfile) {
        perror(argv[2]);
        goto error_out;
    }

    /* dump the same ftyp atom */
    if (ftyp_atom_size > 0) {
        printf("" writing ftyp atom...\n"");
        if (fwrite(ftyp_atom, ftyp_atom_size, 1, outfile) != 1) {
            perror(argv[2]);
            goto error_out;
        }
    }

    /* dump the new moov atom */
    printf("" writing moov atom...\n"");
    if (fwrite(moov_atom, moov_atom_size, 1, outfile) != 1) {
        perror(argv[2]);
        goto error_out;
    }

    /* copy the remainder of the infile, from offset 0 -> last_offset - 1 */
    printf("" copying rest of file...\n"");
    while (last_offset) {
        if (last_offset > COPY_BUFFER_SIZE)
            bytes_to_copy = COPY_BUFFER_SIZE;
        else
            bytes_to_copy = last_offset;

        if (fread(copy_buffer, bytes_to_copy, 1, infile) != 1) {
            perror(argv[1]);
            goto error_out;
        }
        if (fwrite(copy_buffer, bytes_to_copy, 1, outfile) != 1) {
            perror(argv[2]);
            goto error_out;
        }
        last_offset -= bytes_to_copy;
    }

    fclose(infile);
    fclose(outfile);
    free(moov_atom);
    free(ftyp_atom);

    return 0;

error_out:
    if (infile)
        fclose(infile);
    if (outfile)
        fclose(outfile);
    free(moov_atom);
    free(ftyp_atom);
    return 1;
}
"
065-657,ShooShoSha/Course-Work,COP3014/Chapters/5/Exercises/2/ex5-2.c,10,1,17,1926829.45635165,186924.0,10.304123601035714,1359.0,1338.0,42130.0,15181.0,1629.0,638.0,1349.0,596.0,1500000000,0.0012845529709011,1082014363648.0,0.0144283238107466,0.0734937446563487,"#include <stdio.h>

int main (void)
{
	int n;

	printf(""Table of Powers of Two\n\n"");
	printf("" n  n squared\n"");
	printf(""--- ---------\n"");
	
	for (n = 1; n <= 10; n++)
		printf(""%3i %9i\n"", n, n*n);
	
	return 0;
}
"
209-14911,zhuqianqian/LeetCode,C/powerOf.c,77,5,57,1439223.06597225,220326.0,6.532243130633697,1352.0,1332.0,49388.0,20646.0,1647.0,644.0,1361.0,601.0,1500000000,0.0009594820439815,1082014363648.0,0.0121819485671232,0.0607276465716651,"#include <stdio.h>

typedef int bool;
#define true 1
#define false 0

typedef bool(*fptr)(int);

/**
 * Count the 1s in the binary (aka, hamming weight)
 * Numbers that are power of 2 only have one 1.
 * 4ms / 1108 cases.
 */
bool isPowerOfTwo(int n) {
    int w = 0;
    unsigned int un = (unsigned int)n;
    if (n <= 0) return false;
    while (un) {
        w++;
        un &= (un - 1);
    }
    return w == 1;
}

/**
 * Inspired by the above method (calc hamming weight),
 * if the number n has only one 1, (n-1) should have
 * all 1s in the bits after the one and the first 1
 * set to 0. (That is to say, n&(n-1) should equal to 0.
 * 4ms / 1108 cases. (I thought this would be faster...)
 */
bool isPowerOfTwoB(int n) {
    return n < 1 ? false : (n&(n-1)) == 0;
}

/**
 * The direct way with recursion
 */
bool isPowerOfTwoR(int n) {
    if (n <= 1) return n == 1;
    return (n & 0x01) == 0 && isPowerOfTwoR(n / 2);
}

/**
 * The direct way with loop
 */
bool isPowerOfTwoL(int n) {
    while (n > 1 && !(n&0x01)) {  n = n / 2; }
    return n == 1;
}

bool isPowerOfThreeL(int n) {
    while (n > 1 && !(n%3)) {  n = n / 3; }
    return n == 1;
}

bool isPowerOfThree(int n) {
    return isPowerOfThreeL(n);
}

bool isPowerOfThreeR(int n) {
    if (n <= 1) return n == 1;
    return (n % 3) == 0 && isPowerOfThreeR(n / 3);
}


fptr funcs[] = { isPowerOfTwo, isPowerOfTwoB, isPowerOfTwoL, isPowerOfTwoR,
    isPowerOfThree, isPowerOfThreeL, isPowerOfThreeR};
char names[][16] = {""isPowerOfTwo"", ""isPowerOfTwoB"", ""isPowerOfTwoL"", 
""isPowerOfTwoR"", ""isPowerOfThree"", ""isPowerOfThreeL"", ""isPowerOfThreeR"" };
char result[][4] = { ""FK"", ""OK"" };

void unitTest() {
    fptr f;
    int i, j;
    char *fname;
    int nums[][10] = { { -2147483648, 0, 1, 6, 16, 128, 4096, 512, 65535, 65536 },
                       { -3, 0, 1, 6, 9, 27, 1162261467, 81, 6564, 6561 } };
    int eresult[] = { false, false, true, false, true, true, true, true, false, true };
    for (i = 0; i < 7; i++) {
        printf(""Testing %s:"", names[i]);
        for (f = funcs[i], j = 0; j < 10; j++) {
            printf(""%s "", result[eresult[j] == f(nums[i/4][j])]);
        }
        printf(""\n"");
    }
}

int main(int argc, char **argv) {    
    printf(""Run unit Test:\n"");
    unitTest();
    return 0;
}
"
039-19041,godoppl/project,otw/narnia/8/narnia8.c,34,2,25,1646358.05413125,174735.0,9.422027641857673,1333.0,1314.0,39588.0,13462.0,1632.0,636.0,1350.0,593.0,1500000000,0.0010975720360875,1082014363648.0,0.0151486536755658,0.07937794533459,"/*
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
// gcc's variable reordering fucked things up
// to keep the level in its old style i am 
// making ""i"" global unti i find a fix 
// -morla 
int i; 

void func(char *b){
	char *blah=b;
	char bok[20];
	//int i=0;
	
	memset(bok, '\0', sizeof(bok));
	for(i=0; blah[i] != '\0'; i++)
		bok[i]=blah[i];

	printf(""%s\n"",bok);
}

int main(int argc, char **argv){
        
	if(argc > 1)       
		func(argv[1]);
	else    
	printf(""%s argument\n"", argv[0]);

	return 0;
}
"
163-24856,TobyLobster/Inform,babel/extras/simple-marry.c,78,3,61,41625554.78978895,655552.0,63.49695218685932,1472.0,1447.0,142052.0,78119.0,1824.0,718.0,1523.0,672.0,1500000000,0.0277503698598593,1082014363648.0,0.0044527360148394,0.0215150950851837,"/* Simplified version of babel-marry for machines without
   perl.

   babel-marry.pl performs a more sophisticated version of this
   procedure.

   babel must be in your path
*/

#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>
#define DIR_SEP ""\\""

char *cover_ext[] = { ""png"", ""jpg"", ""jpeg"", NULL };
int main(int argc, char **argv)
{
 struct dirent *de;
 DIR *dd;
 char *buf;
 char ifibuf[512];
 char rfn[256];
 if (argc != 1 && argc!=2)
 {
  printf(""usage: %s [ifiction and cover art directory]\n"",argv[0]);
  return 1;
 }
 
 dd=opendir(""."");
 while((de=readdir(dd))!=0)
 {
  char *sp;
  FILE *f;
  int i;
  if (de->d_name[0]=='.' ||
      strstr(de->d_name, "".ifiction"") ||
      strstr(de->d_name, "".iFiction"") ||
      strstr(de->d_name, "".exe"") ||
      strstr(de->d_name, "".blorb"") ||
      strstr(de->d_name, "".blb"") ||
      strstr(de->d_name, "".zblorb"") ||
      strstr(de->d_name, "".gblorb"") ||
      strstr(de->d_name, "".zbl"") ||
      strstr(de->d_name, "".gbl"") ||
      strstr(de->d_name, "".png"") ||
      strstr(de->d_name, "".jpg"") ||
      strstr(de->d_name, "".jpeg"") ||
      strstr(de->d_name, "".txt""))
   continue;
   strcpy(rfn,de->d_name);
   sp=strrchr(rfn,'.');
   if (sp) *sp=0;
   printf(""%s: "",rfn);
   if (argc==2)
    sprintf(ifibuf,""%s%s%s.iFiction"",argv[1],DIR_SEP,rfn);
   else sprintf(ifibuf,""%s.iFiction"",rfn);
   f=fopen(ifibuf,""r"");
   if (!f) { printf(""no metadata found\n""); continue; }
   fclose(f);
   buf=(char *)malloc(2*strlen(ifibuf)+strlen(de->d_name)+20);
   sprintf(buf, ""babel -blorbs %s %s"",de->d_name,ifibuf);
   printf(""%s %s "", de->d_name, ifibuf);
   for(i=0;cover_ext[i];i++)
   {
   if (argc==2)
    sprintf(ifibuf,""%s%s%s.%s"",argv[1],DIR_SEP,rfn,cover_ext[i]);
   else sprintf(ifibuf,""%s.%s"",rfn,cover_ext[i]);
   f=fopen(ifibuf,""r"");
   if (f) {
   fclose(f);
   break;
   }
   }
   if (cover_ext[i])
   {
    strcat(buf,"" "");
    strcat(buf,ifibuf);
    printf(""%s"",ifibuf);
   }
   printf("": blorbing\n"");
/*   printf(buf); */
   system(buf);

   free(buf);
 }
 closedir(dd);

 return 0;
}

"
070-20158,Taffer/courses,c++4c/homework1/sum_orig.c,25,2,23,2224625.9031816,174298.0,12.76334209227874,1337.0,1318.0,39467.0,13437.0,1626.0,636.0,1345.0,594.0,1500000000,0.0014830839354544,1082014363648.0,0.0152325327886722,0.0794079842734008,"/*  Convert this program to C++
*   change to C++ io
*   change to one line comments
*   change defines of constants to const
*   change array to vector<>
*   inline any short function
*/

#include <stdio.h>
#define N 40

void sum(int*p, int n, int d[])
{
  int i;
  *p = 0;
  for(i = 0; i < n; ++i)
     *p = *p + d[i];
}

int main()
{
   int i;
   int accum = 0;
   int data[N];
   for(i = 0; i < N; ++i)

      data[i] = i;

    sum(&accum, N, data);
    printf(""sum is %d\n"", accum);
	return 0;
}
"
132-24170,totalspectrum/binutils-propeller,gdb/testsuite/gdb.threads/no-unwaited-for-left.c,47,1,37,2053249.5109363499,253319.0,8.105388857527466,2121.0,1642.0,60404.0,23112.0,2131.0,763.0,1623.0,696.0,1500000000,0.0013688330072909,1082014363648.0,0.0148547878366802,0.0624191771636572,"/* Copyright 2007-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <pthread.h>
#include <assert.h>
#include <unistd.h>

static volatile pthread_t main_thread;
pthread_barrier_t barrier;

static void *
thread_a (void *arg)
{
  int i;

  return 0; /* break-here */
}

static void *
thread_b (void *arg)
{
  int i;

  pthread_barrier_wait (&barrier);

  i = pthread_join (main_thread, NULL);
  assert (i == 0);

  return arg;
}

int
main (void)
{
  pthread_t thread;
  int i;

  /* First test resuming only `thread_a', which exits.  */
  i = pthread_create (&thread, NULL, thread_a, NULL);
  assert (i == 0);
  pthread_join (thread, NULL);

  /* Then test resuming only the leader, which also exits.  */
  main_thread = pthread_self ();

  pthread_barrier_init (&barrier, NULL, 2);

  i = pthread_create (&thread, NULL, thread_b, NULL);
  assert (i == 0);

  pthread_barrier_wait (&barrier);

  pthread_exit (NULL); /* break-here-2 */
  /* NOTREACHED */
  return 0;
}
"
105-30865,begeekmyfriend/leetcode,0206_reverse_linked_list/reverse_list.c,51,3,36,1957877.7719289,174227.0,11.237506241856888,1274.0,1257.0,39602.0,13450.0,1624.0,638.0,1346.0,593.0,1500000000,0.0013052518479526,1082014363648.0,0.0145270250879599,0.0791864585689512,"#include <stdio.h>
#include <stdlib.h>


struct ListNode {
    int val;
    struct ListNode *next;
};

static struct ListNode *recursive(struct ListNode *prev, struct ListNode *p)
{
    if (p == NULL) {
        return prev;
    }

    struct ListNode *q = p->next;
    p->next = prev;
    return recursive(p, q);
}

struct ListNode *reverseList(struct ListNode *head)
{
    return recursive(NULL, head);
}


#if 0
/* Iteration */
struct ListNode *reverseList(struct ListNode *head)
{
    struct ListNode *prev = NULL;
    struct ListNode *p = head;
    while (p != NULL) {
        struct ListNode *q = p->next;
        p->next = prev;
        prev = p;
        p = q;
    }

    return prev;
}
#endif

int main(int argc, char **argv)
{
    int i, count = argc - 1;
    struct ListNode *head = NULL, *p, *prev;
    for (i = 0; i < count; i++) {
        p = malloc(sizeof(*p));
        p->val = atoi(argv[i + 1]);
        p->next = NULL;
        if (head == NULL) {
            head = p;
        } else {
            prev->next = p;
        }
        prev = p;
    }

    for (p = reverseList(head); p != NULL; p = p->next) {
        printf(""%d "", p->val);
    }
    printf(""\n"");
    return 0;
}
"
021-30476,wuzhouhui/leetcode,40_comb_sum_II.c,97,3,55,1719528.22711305,190301.0,9.035832707132386,1299.0,1277.0,43321.0,15482.0,1614.0,649.0,1346.0,604.0,1500000000,0.0011463521514087,1082014363648.0,0.0135364501500254,0.0716460044555549,"/*
 * accepted, but too slow.
 */
#include <stdlib.h>
#include <string.h>

#define STEP	8

static int **res, *col, maxp, p;
static int *occup;

static void initial(int n)
{
	res = 0;
	col = occup = 0;
	maxp = p = 0;
	occup = calloc(n, sizeof(int));
}

static deinit()
{
	if (occup)
		free(occup);
}

static void add_ans(int *cand, int n)
{
	int	i, j;
	int	*tmp;

	tmp = calloc(n, sizeof(int));
	for (j = i = 0; i < n; i++) {
		if (occup[i])
			tmp[j++] = cand[i];
	}

	for (i = 0; i <= (p - 1); i++) {
		if (!memcmp(res[i], tmp, n * sizeof(int))) {
			free(tmp);
			return;
		}
	}

	if (!res) {
		maxp = STEP;
		p = 0;
		res = malloc(maxp * sizeof(int *));
		col = malloc(maxp * sizeof(int));
	}
	if (p >= maxp) {
		maxp += STEP;
		res = realloc(res, maxp * sizeof(int *));
		col = realloc(col, maxp * sizeof(int));
	}
	res[p] = tmp;
	col[p] = j;
	p++;
}

static void do_comb(int *cand, int n, int tgt, int sum)
{
	int	i;

	if (sum == tgt) {
		add_ans(cand, n);
		return;
	}

	for (i = 0; i < n; i++) {
		if (occup[i])
			continue;
		if ((sum + cand[i]) > tgt)
			break;
		occup[i] = 1;
		do_comb(cand, n, tgt, sum + cand[i]);
		occup[i] = 0;
	}
}

static int intcmp(const void *a, const void *b)
{
	return(*(int *)a - *(int *)b);
}

int **combinationSum2(int *candidates, int candidatesSize, int target,
		int **columnSizes, int *returnSize)
{
	if (!candidatesSize) {
		*columnSizes = 0;
		*returnSize = 0;
		return(0);
	}
	initial(candidatesSize);
	qsort(candidates, candidatesSize, sizeof(int), intcmp);
	do_comb(candidates, candidatesSize, target, 0);
	if (!p) {
		*columnSizes = 0;
		*returnSize = 0;
		deinit();
		return(0);
	}
	*columnSizes = col;
	*returnSize = p;
	deinit();
	return(res);
}

int main(void)
{
	int	**res, *col, ret;
	int	x[] = {10, 1, 2, 7, 6, 1, 5 };
	res = combinationSum2(x, 7, 8, &col, &ret);
	return(0);
}
"
308-4842,apprensemble/exercices_c,polynome.c,118,4,78,2309494.7682693,363851.0,6.347361969597445,1372.0,1352.0,75676.0,37205.0,1625.0,693.0,1345.0,650.0,1500000000,0.0015396631788462,1082014363648.0,0.0074865810455378,0.0382083787351281,"#include <stdio.h>
#include <stdlib.h>

int main () {
  typedef struct monome {
    int coeff;
    int degre;
    struct monome * monome_suivant;
  } monome;

  typedef struct monome * polynome;

  polynome polynomeconstructeur (int c, int d, polynome P) {
    polynome Q;
    Q = (polynome)malloc(sizeof(monome));
    Q-> coeff = c;
    Q-> degre = d;
    Q-> monome_suivant = P;
    printf (""je construis %d %d %d\n"",Q->coeff,Q->degre,Q->monome_suivant);
    return Q;
  }

  int degre (polynome P) {
    int deg = -1;
    polynome iterateur = P;

    while (iterateur) {
      printf (""%d %d %d, "",iterateur->coeff,iterateur->degre,iterateur->monome_suivant);
      if (iterateur->degre > deg) {
	deg = iterateur->degre;
      }
      iterateur = iterateur->monome_suivant;
    }
    return deg;
  }

  int degreR (polynome P) {
    int deg = -1;

    if (P) {
      printf (""%d %d %d, "",P->coeff,P->degre,P->monome_suivant);
      deg = degreR(P->monome_suivant);
      if (P->degre > deg) {
	deg = P->degre;
      }
      return deg;
    }
  }

  polynome copyPolynomeI(polynome P) {
    polynome prec = NULL;
    polynome suiv = NULL;

    if (P != NULL) {
      prec = polynomeconstructeur(P->coeff,P->degre,NULL);
      P = P->monome_suivant;
    }
    while (P != NULL) {
      suiv = polynomeconstructeur(P->coeff,P->degre,prec);
      prec = suiv;
      P = P->monome_suivant;
    }
    return prec;
  }

  polynome copyPolynome(polynome P) {
    polynome tete_de_liste,suivant; 
    int debut = 1;
    /*je suppose que P n'est pas NULL au debut sinon revenir a la version precedente 
     * ou je supposait qu'il pouvait etre null ça ajoute 2 lignes */
    tete_de_liste = polynomeconstructeur(P->coeff,P->degre,NULL);
    P = P->monome_suivant;
    while (P != NULL) {
      if (debut) {
	suivant = tete_de_liste->monome_suivant = polynomeconstructeur(P->coeff,P->degre,NULL);
	debut = 0;
      }
      else {
	suivant = suivant->monome_suivant = polynomeconstructeur(P->coeff,P->degre,NULL);
      }
      P = P->monome_suivant;
    }
    return tete_de_liste;
  }

  polynome copyPolynomeR(polynome P) {
    polynome Q = NULL;

    if (P != NULL) {
      Q = polynomeconstructeur(P->coeff,P->degre,copyPolynomeR(P->monome_suivant));
    }
    return Q;
  }

  polynome ordonnePolynome(polynome P) {
    /* le mieux me semble de creer une nouvelle liste soit le tri par insertion
     * P reste la tete de liste, I pour l'iteration et Q pour la nouvelle liste Q comme Qew euh... New :p
     * Ajout monome en tete de liste
     * ajout monome comme successeur */
    polynome I,Q = NULL;
    I = Q = P;
    I = I->monome_suivant;
    while (I != NULL) {
      if (I->degre > Q->degre);
      


    }
    return Q;



  }

  polynome M,N,O,P,Q,R,A,B,C,D,E,F;
  int mon_deg;

  N = polynomeconstructeur(2,4,NULL);
  M = polynomeconstructeur(1,2,N);
  O = polynomeconstructeur(3,6,M);
  P = polynomeconstructeur(4,1,O);
  A = polynomeconstructeur(3,12,P);
  B = polynomeconstructeur(5,14,A);
  C = polynomeconstructeur(3,16,B);
  D = polynomeconstructeur(4,10,C);

  R = copyPolynome(D);
  Q = copyPolynomeR(D);
  E = copyPolynome(R);
  F = copyPolynomeI(R);

  printf (""\nplus haut degre D : %d\n"",degre(D));
  printf (""\nplus haut degre version Recursive  D : %d\n\n\n"",degreR(D));
  printf (""\nplus haut degre Q : %d\n"",degre(Q));
  printf (""\nplus haut degre version Recursive  Q : %d\n\n\n"",degreR(Q));
  printf (""\nplus haut degre R : %d\n"",degre(R));
  printf (""\nplus haut degre version Recursive  R : %d\n"",degreR(R));
  printf (""\nplus haut degre E : %d\n"",degre(E));
  printf (""\nplus haut degre version Recursive  E : %d\n"",degreR(E));
  printf (""\nplus haut degre F : %d\n"",degre(F));
  printf (""\nplus haut degre version Recursive  F : %d\n"",degreR(F));
  printf("" %dx\xB1"",R->coeff,R->degre);


}
"
085-12667,EddyLuten/potd,2015.02.10.lucky-numbers.c,22,3,19,12746960.8560204,102429229.0,0.1244465093064402,1336.0,1318.0,39181.0,13313.0,1617.0,634.0,1340.0,590.0,1500000000,0.0084979739040136,1082014363648.0,2.5910572850255463e-05,0.0796471977749838,"// 2015.02.10 - http://www.problemotd.com/problem/lucky-numbers/
#include <stdio.h>

unsigned num_repeats(const unsigned test, const unsigned num) {
  unsigned result = num;
  while (result < test) result = (result * 10) + num;
  return test == result;
}

unsigned numlen(unsigned num) {
  unsigned result = 1;
  while (num /= 10) ++result;
  return result;
}

unsigned lucky_nums(const unsigned limit) {
  unsigned result = 0;
  for (unsigned len = 0, i = 0; i <= limit; ++i, len = numlen(i))
    if (3 == len || 7 == len || num_repeats(i, 3) || num_repeats(i, 7))
      ++result;
  return result;
}

int main(void) {
  printf(""Lucky numbers: %u\n"", lucky_nums(1000000));
  return 0;
}
"
180-5429,8l/beri,cheritest/trunk/fuzz_fpu.c,72,4,58,2309178.0021786,1020422.0,2.262963754211493,1381.0,1356.0,222290.0,133403.0,1653.0,701.0,1373.0,658.0,1500000000,0.0015394520014524,1082014363648.0,0.0026822236290475,0.012328046939355,"/*-
 * Copyright (c) 2014 Michael Roe
 * All rights reserved.
 *
 * This software was developed by SRI International and the University of
 * Cambridge Computer Laboratory under DARPA/AFRL contract FA8750-10-C-0237
 * (""CTSRD""), as part of the DARPA CRASH research programme.
 *
 * @BERI_LICENSE_HEADER_START@
 *
 * Licensed to BERI Open Systems C.I.C. (BERI) under one or more contributor
 * license agreements.  See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.  BERI licenses this
 * file to you under the BERI Hardware-Software License, Version 1.0 (the
 * ""License""); you may not use this file except in compliance with the
 * License.  You may obtain a copy of the License at:
 *
 *   http://www.beri-open-systems.org/legal/license-1-0.txt
 *
 * Unless required by applicable law or agreed to in writing, Work distributed
 * under the License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * @BERI_LICENSE_HEADER_END@
 */

/*
 * Fuzz test for floating point instructions.
 *
 * This program will create a raw test containing randomly-generated
 * floating point instructions. Many of the FP instructions will be
 * invalid instructions. The purpose of this fuzzer is to catch CPU bugs
 * in which a malformed FP instruction locks up the pipeline.
 */

#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv)
{
int i;
unsigned int r;

  srandom(time(0));

  printf("".set mips64\n"");
  printf("".set noreorder\n"");
  printf("".set nobopt\n"");
  printf("".set noat\n"");
  printf(""\n"");

  printf(""\t\t.text\n"");
  printf(""\t\t.global start\n"");
  printf(""\t\t.ent start\n"");
  printf(""start:\n""); 

  printf(""\t\tmfc0 $t0, $12\n"");
  printf(""\t\tli $t1, 1 << 29\n"");
  printf(""\t\tor $t0, $t0, $t1\n"");
  printf(""\t\tmtc0 $t0, $12\n"");
  printf(""\t\tnop\n"");
  printf(""\t\tnop\n"");
  printf(""\t\tnop\n"");

  for (i=0; i<1024; i++)
  {
    r = (unsigned int) random();
    r = r & 0x00bfffff;
    r = r | 0x46000000;
    printf(""\t\t.word 0x%08x\n"", r);
  }

  printf(""\t\tmtc0 $at, $26\n"");
  printf(""\t\tnop\n"");
  printf(""\t\tnop\n"");
  printf(""\t\tmtc0 $at, $23\n"");
  printf(""end:\n"");
  printf(""\t\tb end\n"");
  printf(""\t\tnop\n"");
  printf("".end start\n"");

  return 0;
}
"
014-27968,mariosal/algo,euler/50.c,36,5,30,10060231.55059665,22504181.0,0.4470383081259433,1361.0,1339.0,2421171.0,2214104.0,559453.0,694377.0,1343.0,21125.0,1500000000,0.0067068210337311,1082014363648.0,0.0001199777054761,0.275344612779177,"#include <stdio.h>
#include <stdlib.h>

#define N 1000000

int main() {
  char *num;
  int i, j, q, sum, maxSum, maxLen, *prime;

  num = ( char* )calloc( N - 2, 1 );
  prime = ( int* )malloc( ( N - 2 )  * sizeof( int ) );

  for ( i = 2; i * i < N; ++i ) {
    if ( !num[ i - 2 ] ) {
      for ( j = i * i; j < N; j += i ) {
        num[ j - 2 ] = 1;
      }
    }
  }

  q = 0;
  for ( i = 2; i < N; ++i ) {
    if ( !num[ i - 2 ] ) {
      prime[ q ] = i;
      ++q;
    }
  }

  maxLen = 0;
  for ( i = 0; i < q; ++i ) {
    sum = 0;
    for ( j = i; j < q; ++j ) {
      sum += prime[ j ];
      if ( sum >= N ) {
        break;
      }
      if ( !num[ sum - 2 ] && maxLen < j - i + 1 ) {
        maxLen = j - i + 1;
        maxSum = sum;
      }
    }
  }
  printf( ""%d\n"", maxSum );

  return 0;
}
"
073-23014,ensemblr/llvm-project-boilerplate,include/llvm/projects/test-suite/SingleSource/Benchmarks/BenchmarkGame/nsieve-bits.c,25,3,33,610641574.7199206,3599174611.0,0.169661558551153,1382.0,1357.0,287696844.0,76187048.0,66500174.0,140692.0,1350.0,80595.0,1500000000,0.4070943831466138,1082014363648.0,7.610078131883111e-07,0.1833629145639675,"/*
** The Great Computer Language Shootout
** http://shootout.alioth.debian.org/
** contributed by Mike Pall
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef unsigned int bits;
#define BBITS		(sizeof(bits) * 8)
#define BSIZE(x)	(((x) / 8) + sizeof(bits))
#define BMASK(x)	(1 << ((x) % BBITS))
#define BTEST(p, x)	((p)[(x) / BBITS] & BMASK(x))
#define BFLIP(p, x)	(p)[(x) / BBITS] ^= BMASK(x)

int main(int argc, char **argv)
{
  unsigned int m, sz = 10000 << 12;
  bits *primes = (bits *)malloc(BSIZE(sz));
  if (!primes) return 1;
  for (m = 0; m <= 2; m++) {
    unsigned int i, j, count = 0, n = sz >> m;
    memset(primes, 0xff, BSIZE(n));
    for (i = 2; i <= n; i++)
      if (BTEST(primes, i)) {
	count++;
	for (j = i + i; j <= n; j += i)
	  if (BTEST(primes, j)) BFLIP(primes, j);
      }
    printf(""Primes up to %8d %8d\n"", n, count);
  }
  free(primes);
  return 0;
}"
112-20950,eriknstr/ThinkPad-FreeBSD-setup,FreeBSD/contrib/mdocml/test-getsubopt.c,27,1,33,1336383.05123895,170916.0,7.818946148985466,1153.0,1144.0,38940.0,12889.0,1592.0,589.0,1330.0,547.0,1500000000,0.0008909220341593,1082014363648.0,0.0134393503241358,0.0782959347083679,"/*	$Id: test-getsubopt.c,v 1.4 2015/10/06 18:32:20 schwarze Exp $	*/
/*
 * Copyright (c) 2011 Kristaps Dzonsons <kristaps@bsd.lv>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#if defined(__linux__) || defined(__MINT__)
#define _GNU_SOURCE /* getsubopt() */
#endif

#include <stdlib.h>

int
main(void)
{
	char buf[] = ""k=v"";
	char *options = buf;
	char token0[] = ""k"";
	char *const tokens[] = { token0, NULL };
	char *value = NULL;
	return ! (getsubopt(&options, tokens, &value) == 0
	    && value == buf+2 && options == buf+3);
}
"
127-18355,SummerWish/C_homework,Homework3/P3/P3/main.c,22,1,21,2456752.5833844002,173273.0,14.164249479145626,1290.0,1275.0,39281.0,13314.0,1617.0,634.0,1340.0,592.0,1500000000,0.0016378350555896,1082014363648.0,0.0148032295856827,0.0795322749310771,"//
//  main.c
//  P3
//
//  Created by Breezewish on 13-11-14.
//  Copyright (c) 2013年 Breezewish. All rights reserved.
//

#include <stdio.h>

int main(int argc, const char * argv[])
{
    int i=0;
    char a[]=""abm"", b[]=""aqid"", c[10];
    
    while (a[i]!='\0' && b[i]!='\0') {
        if (a[i]>=b[i])
            c[i]=a[i]-32 ;
        else
            c[i]=b[i]-32 ;
        i++;
    }
    
    c[i]='\0';
    puts(c);
    
    return 0;
}

"
365-17559,arjona00/mpitutorial,mpiPractica3/entrega/sec_multmatrixseq.c,69,9,53,1723218.01073835,201977.0,8.531753615510677,1445.0,1420.0,45774.0,17562.0,1649.0,642.0,1369.0,597.0,1500000000,0.0011488120071589,1082014363648.0,0.0141847834159334,0.0672129594543387,"#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

void print_matrix(int size1, int size2, double *matrix) {
  int i, j;

  for (i = 0; i < size1; i++) {
    for (j = 0; j < size2; j++) {
      printf(""%.0lf "", matrix[i*size2+j]);
    }

    printf(""\n"");
  }


}

void multiply(int size1, int size2, int size3,
              double *matrix1, double *matrix2,
              double *result) {
  int i, j, k;
  
  for (k = 0; k < size3; k++) {
    for (i = 0; i < size1; i++) {
      double sum = 0;

      for (j = 0; j < size2; j++) {
        sum += matrix1[i*size2+j]*matrix2[j*size3+k];
      }

      result[i*size3+k] = sum;
    }

  }
  
}

double *new_matrix(int size1, int size2) {
  double *m = (double *)malloc(size1*size2*sizeof(double));
  assert (m != NULL);
  return m;
}

void free_matrix(double *matrix) {
  if (matrix != NULL) {
    free(matrix);
  }
}

int main(int argc, char *argv[]) {
  double *matrix1;
  double *matrix2;
  double *result;
  const int SIZE1=3;
  const int SIZE2=2;
  const int SIZE3=3;

  int i, j;

  matrix1 = new_matrix(SIZE1, SIZE2);
  matrix2 = new_matrix(SIZE2, SIZE3);
  result = new_matrix(SIZE1, SIZE3);

  // Init matrixes
  for(i = 0; i < SIZE1; i++) {
    for (j = 0; j < SIZE2; j++) {
      matrix1[i*SIZE2+j] = i;
    }
  }
  
  for(i = 0; i < SIZE2; i++) {
    for (j = 0; j < SIZE3; j++) {
      matrix2[i*SIZE3+j] = j;
    }
  }

  printf(""Matrix1:\n"");
  print_matrix(SIZE1, SIZE2, matrix1);
  printf(""Matrix2:\n"");
  print_matrix(SIZE2, SIZE3, matrix2);
  
  // Apply the matrix multiplication
  multiply(SIZE1, SIZE2, SIZE3, matrix1, matrix2, result);
  printf(""Matrix3:\n"");
  print_matrix(SIZE1, SIZE3, result);

  // Free the matrix
  free_matrix(matrix1);
  free_matrix(matrix2);
  free_matrix(result);
  
  return 0;
}

"
079-31705,tmerrifi/consequence,tests/condvar-broadcast.c,70,8,48,333139749.12744015,1252030617.0,0.4345966053959526,1637.0,1582.0,1001157223.0,87255.0,1802.0,986.0,1409.0,930.0,1500000000,0.2220931660849601,1082014363648.0,2.5710233889591854e-06,5.120627491740334e-06,"
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <stdio.h>
#include <signal.h>
#include <assert.h>


#define PRODUCER_THREADS 1
#define CONSUMER_THREADS 5

#define ITERATIONS 50

pthread_mutex_t mutex;
pthread_cond_t cond;

int avail=0;
int consumed=0;

int __attribute__((optimize(0))) pause_thread(int pause_count){
    int total=0;
    for(int i=0;i<pause_count;++i){
        total++;
    }
    return total;
}

void * produce(void * arg){
    int id = *((int *)arg);
    for(int i=0;i<ITERATIONS;++i){
        pause_thread(5000000);
        pthread_mutex_lock(&mutex);
        avail+=CONSUMER_THREADS;
        printf(""PRODUCED: thread %d pid: %d val %d\n"", id, getpid(), avail);
        pthread_mutex_unlock(&mutex);
        pthread_cond_broadcast(&cond);
    }
    return NULL;
}

void * consume(void * arg){
    int id = *((int *)arg);
    for(int i=0;i<ITERATIONS;++i){
        pause_thread(1000);
        pthread_mutex_lock(&mutex);
        while(avail<=0){
            pthread_cond_wait(&cond, &mutex);
        }
        avail--;
        ++consumed;
        printf(""CONSUMED: thread %d pid %d val %d consumed %d\n"", id, getpid(), avail, consumed);
        pthread_mutex_unlock(&mutex);
    }
    return NULL;
}


int main(){
    pthread_mutex_init(&mutex, NULL);
    pthread_cond_init(&cond, NULL);
    //create producers
    pthread_t producers[PRODUCER_THREADS];
    int producer_ids[PRODUCER_THREADS];
    for (int i=0;i<PRODUCER_THREADS;++i){
        producer_ids[i]=i;
        pthread_create(&producers[i], NULL, produce, &producer_ids[i]);
    }

    //create consumers
    pthread_t consumers[CONSUMER_THREADS];
    int consumer_ids[CONSUMER_THREADS];
    for (int i=0;i<CONSUMER_THREADS;++i){
        consumer_ids[i]=i+PRODUCER_THREADS;
        pthread_create(&consumers[i], NULL, consume, &consumer_ids[i]);
    }


    //join producers
    for (int i=0;i<PRODUCER_THREADS;++i){
        pthread_join(producers[i],NULL);
    }

    //kill off consumers
    for (int i=0;i<CONSUMER_THREADS;++i){
        pthread_join(consumers[i],NULL);
    }

    if (consumed==CONSUMER_THREADS*ITERATIONS && avail==0){
        fprintf(stderr, ""condvar_broadcast: SUCCEEDED\n"");
    }
    else{
        fprintf(stderr, ""condvar_broadcast: FAILED, consumed %d, avail %d\n"", consumed, avail);     
    }
}
"
103-29882,ensemblr/llvm-project-boilerplate,include/llvm/projects/test-suite/SingleSource/Benchmarks/Shootout/random.c,17,1,29,2563858486.711979,5200176097.0,0.4930330123780037,1423.0,1399.0,39952.0,13765.0,1639.0,641.0,1355.0,598.0,1500000000,1.7092389911413193,1082014363648.0,5.426739301440238e-07,0.0788018690544892,"/* -*- mode: c -*-
 * $Id: random.c 36673 2007-05-03 16:55:46Z laurov $
 * http://www.bagley.org/~doug/shootout/
 */

#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#define inline static

#define IM 139968
#define IA 3877
#define IC 29573

inline double gen_random(double max) {
  static long last = 42;
    
  last = (last * IA + IC) % IM;
  return( max * last / IM );
}

int main(int argc, char *argv[]) {
#ifdef SMALL_PROBLEM_SIZE
#define LENGTH 40000000
#else
#define LENGTH 400000000
#endif
  int N = ((argc == 2) ? atoi(argv[1]) : LENGTH) - 1;
    
  while (N--) {
    gen_random(100.0);
  }
  printf(""%.9f\n"", gen_random(100.0));
  return(0);
}
"
267-16028,leiverandres/HPC_assignments,openmpi/vec_sum/seq_vec_sum.c,31,3,35,350974032.0732816,1517593923.0,0.2312700562915999,1239.0,1224.0,380039679.0,170013492.0,1251668.0,1875650.0,1342.0,1875595.0,1500000000,0.2339826880488544,1082014363648.0,1.6229637999150053e-06,0.0090977659321593,"#include <stdio.h>
#include <stdlib.h>
#define N 10000000
#define MASTER 0

void seqSum(int *a, int *b, int *c) {
  for (int i = 0; i < N; i++)
    c[i] = a[i] + b[i];
}

void fillRandomVec(int *x) {
  for (int i = 0; i < N; i++)
    x[i] = rand() % 50;
}

void showVec(int *x) {
  for (int i = 0; i < N; i++)
    printf(""%d "", x[i]);
}

int main() {
  int *a, *b, *c;
  a = (int *) malloc(N * sizeof(int));
  b = (int *) malloc(N * sizeof(int));
  c = (int *) malloc(N * sizeof(int));
  fillRandomVec(a);
  fillRandomVec(b);
  seqSum(a, b, c);
  // printf(""A\n"");
  // showVec(a);
  // printf(""B\n"");
  // showVec(b);
  // printf(""C\n"");
  // showVec(c);
  free(a);
  free(b);
  free(c);
  return 0;
}
"
016-34754,abhinav-upadhyay/unix-systems-programming,chapter02/env2.c,101,7,64,2708570.7988589997,196369.0,13.793266757991333,1320.0,1302.0,45912.0,16407.0,1759.0,697.0,1411.0,654.0,1500000000,0.001805713865906,1082014363648.0,0.0133524130590877,0.0725460934867375,"#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define _GNU_SOURCE /* Required for asprintf on GNU platform */
extern char **environ;

static void
print_env(void)
{
    int i;
    for (i = 0; environ[i] != NULL; i++) {
        printf(""%s\n"", environ[i]);
    }
}

static void
set_environment(char **env_list, size_t env_list_len, int replace)
{
    char *clearenv[1] = {NULL};
    int i;
    if (replace) {
        environ = clearenv;
    }

    for (i = 0; i < env_list_len; i++) {
        putenv(env_list[i]);
    }
}

static int
run_cmd(const char *cmd)
{
    return system(cmd);
}

int
main(int argc, char **argv)
{
    int i;
    int j;
    int flag_i = 0; /* -i specified or not */
    char **var_list = NULL; /* The environment variable list */
    char *cmd = NULL;
    char *cmd_args;
    size_t cmd_args_len;
    int env_var_pos_list[argc];
    size_t nvars = 0;
    size_t equals_pos;
    int cmd_args_index = 0;
    int exit_status;
    
    if (argc == 1) {
        print_env();
        return 0;
    }

    memset((void *) env_var_pos_list, 0, argc * sizeof(int));

    for (i = 1; argv[i] != NULL; i++) {
        if (strcmp(argv[i], ""-i"") == 0) {
            flag_i++;
            continue;
        }

        if (strchr(argv[i], '=') != NULL) {
            env_var_pos_list[i] = 1;
            nvars++;
            continue;
        }

        if (cmd == NULL) {
            cmd = argv[i];
            continue;
        }

        if (cmd != NULL) {
            cmd_args_index = i;
            break;
        }
    }

    if (nvars) {
        var_list = malloc(nvars * sizeof(char *));
        if (var_list == NULL) {
            err(EXIT_FAILURE, ""malloc failed"");
        }

        for (i = 1, j = 0; i < argc; i++) {
            if (env_var_pos_list[i] == 0) {
                continue;
            }
            
            var_list[j++] = argv[i];
        }
    }
    set_environment(var_list, nvars, flag_i);
    if (!cmd) {
        print_env();
        return 0;
    }
    free(var_list);

    cmd_args_len = strlen(cmd);
    for (i = cmd_args_index; i && argv[i] != NULL; i++) {
        cmd_args_len++; /* For space between two tokens */
        cmd_args_len += strlen(argv[i]);
    }
    cmd_args_len++; /* NUL byte */

    if ((cmd_args = malloc(cmd_args_len)) == NULL)  {
        err(EXIT_FAILURE, ""malloc failed"");
    }
    strncpy(cmd_args, cmd, strlen(cmd) + 1);

    for (i = cmd_args_index; i && argv[i] != NULL; i++) {
        strncat(cmd_args, "" "", 1);
        strncat(cmd_args, argv[i], strlen(argv[i]) + 1);
    }
    exit_status = run_cmd(cmd_args);
    free(cmd_args);
    return exit_status;
}
"
110-15771,begeekmyfriend/leetcode,0213_house_robber_ii/robber.c,37,2,29,1767378.06759765,174465.0,10.130272547502363,1350.0,1330.0,39577.0,13490.0,1627.0,636.0,1346.0,593.0,1500000000,0.0011782520450651,1082014363648.0,0.015361247241567,0.0791829197052782,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static inline int max(int a, int b)
{
    return a > b ? a : b;
}

static int _rob(int* nums, int numsSize)
{
    int i;
    int taken = 0;
    int untaken = 0;
    /* Record max profits of nums[0...i] respectively */
    for (i = 0; i < numsSize; i++) {
        int tmp_taken = taken;
        /* Taken or untaken nums[i] */
        taken = untaken + nums[i];
        untaken = max(tmp_taken, untaken);
    }

    return max(taken, untaken);
}

static int rob(int* nums, int numsSize)
{
    if (numsSize == 1) {
        return nums[0];
    } else {
        /* The first and the last element are adjacent */
        return max(_rob(nums + 1, numsSize - 1), _rob(nums, numsSize - 1));
    }
}

int main(int argc, char **argv)
{
    int i, count = argc - 1;
    int *nums = malloc(count * sizeof(int));
    for (i = 0; i < count; i++) {
        nums[i] = atoi(argv[i + 1]);
    }
    printf(""%d\n"", rob(nums, count));
    return 0;
}
"
201-19057,ch3nkula/My-C-Source-Codes,Natural.c,31,1,28,4504705738.392658,185587.0,24272.74398530069,1419.0,1394.0,40140.0,13890.0,1641.0,645.0,1360.0,601.0,1500000000,3.003137158928439,1082014363648.0,0.0151573116651489,0.0786044789931519,"/* FILE: Natural.c
   Program: Add all the natural numbers below one thousand that are multiples of 3 or 5.
   Date and Time: Sat 24th Aug, 2013 & 3:28pm.
 */


/* Library Includes */
#include<stdio.h>
#include<stdlib.h>

/* This is the subroutine prototype. */
int is_Multiple_of(int);

/* Macros include */
#define N 1000

//here is the definition of the main function
int main(void)
{
	int number, i = 0;
	long int sum = 0;
	
	printf(""Adding all Natural numbers below one thousand that are multiples of 3 and 5.\n"");
	printf(""\nAdding the numbers..."");
	printf(""\n"");
	system(""sleep 3"");
	
	for(i =1 ; i <= N; i++)
		sum+= is_Multiple_of(i); //calls the subroutine here.
	printf(""\nThe sum of all the natural numbers is: %ld.\n"", sum);
	printf(""This is cool huh......\n"");
	return 0;
}

//redeclaration of the subroutine.
int is_Multiple_of(int n)
{
	if(n % 3 == 0 || n % 5 == 0)
		return n;
	else
		return 0;
}
"
256-31658,kostya/crystal-benchmarks-game,meteor/meteor.c,525,35,405,72508366.1964162,211369189.0,0.3430413218834842,1496.0,1470.0,32568791.0,19732087.0,603816.0,71422.0,1400.0,7559.0,1500000000,0.0483389107976108,1082014363648.0,1.4032319535464556e-05,0.0130819409953309,"/* The Computer Language Benchmarks Game
 * http://benchmarksgame.alioth.debian.org/
 *
 * contributed by Christian Vosteen
 */

#include <stdlib.h>
#include <stdio.h>
#define TRUE 1
#define FALSE 0

/* The board is a 50 cell hexagonal pattern.  For    . . . . .
 * maximum speed the board will be implemented as     . . . . .
 * 50 bits, which will fit into a 64 bit long long   . . . . .
 * int.                                               . . . . .
 *                                                   . . . . .
 * I will represent 0's as empty cells and 1's        . . . . .
 * as full cells.                                    . . . . .
 *                                                    . . . . .
 *                                                   . . . . .
 *                                                    . . . . .
 */

unsigned long long board = 0xFFFC000000000000ULL;

/* The puzzle pieces must be specified by the path followed
 * from one end to the other along 12 hexagonal directions.
 *
 *   Piece 0   Piece 1   Piece 2   Piece 3   Piece 4
 *
 *  O O O O    O   O O   O O O     O O O     O   O
 *         O    O O           O       O       O O
 *                           O         O         O
 *
 *   Piece 5   Piece 6   Piece 7   Piece 8   Piece 9
 *
 *    O O O     O O       O O     O O        O O O O
 *       O O       O O       O       O O O        O
 *                  O       O O
 *
 * I had to make it 12 directions because I wanted all of the
 * piece definitions to fit into the same size arrays.  It is
 * not possible to define piece 4 in terms of the 6 cardinal
 * directions in 4 moves.
 */

#define E     0
#define ESE   1
#define SE    2
#define S     3
#define SW    4
#define WSW   5
#define W     6
#define WNW   7
#define NW    8
#define N     9
#define NE    10
#define ENE   11
#define PIVOT 12

char piece_def[10][4] = {
   {  E,  E,  E, SE},
   { SE,  E, NE,  E},
   {  E,  E, SE, SW},
   {  E,  E, SW, SE},
   { SE,  E, NE,  S},
   {  E,  E, SW,  E},
   {  E, SE, SE, NE},
   {  E, SE, SE,  W},
   {  E, SE,  E,  E},
   {  E,  E,  E, SW}
};


/* To minimize the amount of work done in the recursive solve function below,
 * I'm going to allocate enough space for all legal rotations of each piece
 * at each position on the board. That's 10 pieces x 50 board positions x
 * 12 rotations.  However, not all 12 rotations will fit on every cell, so
 * I'll have to keep count of the actual number that do.
 * The pieces are going to be unsigned long long ints just like the board so
 * they can be bitwise-anded with the board to determine if they fit.
 * I'm also going to record the next possible open cell for each piece and
 * location to reduce the burden on the solve function.
 */
unsigned long long pieces[10][50][12];
int piece_counts[10][50];
char next_cell[10][50][12];

/* Returns the direction rotated 60 degrees clockwise */
char rotate(char dir) {
   return (dir + 2) % PIVOT;
}

/* Returns the direction flipped on the horizontal axis */
char flip(char dir) {
   return (PIVOT - dir) % PIVOT;
}


/* Returns the new cell index from the specified cell in the
 * specified direction.  The index is only valid if the
 * starting cell and direction have been checked by the
 * out_of_bounds function first.
 */
char shift(char cell, char dir) {
   switch(dir) {
      case E:
         return cell + 1;
      case ESE:
         if((cell / 5) % 2)
            return cell + 7;
         else
            return cell + 6;
      case SE:
         if((cell / 5) % 2)
            return cell + 6;
         else
            return cell + 5;
      case S:
         return cell + 10;
      case SW:
         if((cell / 5) % 2)
            return cell + 5;
         else
            return cell + 4;
      case WSW:
         if((cell / 5) % 2)
            return cell + 4;
         else
            return cell + 3;
      case W:
         return cell - 1;
      case WNW:
         if((cell / 5) % 2)
            return cell - 6;
         else
            return cell - 7;
      case NW:
         if((cell / 5) % 2)
            return cell - 5;
         else
            return cell - 6;
      case N:
         return cell - 10;
      case NE:
         if((cell / 5) % 2)
            return cell - 4;
         else
            return cell - 5;
      case ENE:
         if((cell / 5) % 2)
            return cell - 3;
         else
            return cell - 4;
      default:
         return cell;
   }
}

/* Returns wether the specified cell and direction will land outside
 * of the board.  Used to determine if a piece is at a legal board
 * location or not.
 */
char out_of_bounds(char cell, char dir) {
   char i;
   switch(dir) {
      case E:
         return cell % 5 == 4;
      case ESE:
         i = cell % 10;
         return i == 4 || i == 8 || i == 9 || cell >= 45;
      case SE:
         return cell % 10 == 9 || cell >= 45;
      case S:
         return cell >= 40;
      case SW:
         return cell % 10 == 0 || cell >= 45;
      case WSW:
         i = cell % 10;
         return i == 0 || i == 1 || i == 5 || cell >= 45;
      case W:
         return cell % 5 == 0;
      case WNW:
         i = cell % 10;
         return i == 0 || i == 1 || i == 5 || cell < 5;
      case NW:
         return cell % 10 == 0 || cell < 5;
      case N:
         return cell < 10;
      case NE:
         return cell % 10 == 9 || cell < 5;
      case ENE:
         i = cell % 10;
         return i == 4 || i == 8 || i == 9 || cell < 5;
      default:
         return FALSE;
   }
}

/* Rotate a piece 60 degrees clockwise */
void rotate_piece(int piece) {
   int i;
   for(i = 0; i < 4; i++)
      piece_def[piece][i] = rotate(piece_def[piece][i]);
}

/* Flip a piece along the horizontal axis */
void flip_piece(int piece) {
   int i;
   for(i = 0; i < 4; i++)
      piece_def[piece][i] = flip(piece_def[piece][i]);
}

/* Convenience function to quickly calculate all of the indices for a piece */
void calc_cell_indices(char *cell, int piece, char index) {
   cell[0] = index;
   cell[1] = shift(cell[0], piece_def[piece][0]);
   cell[2] = shift(cell[1], piece_def[piece][1]);
   cell[3] = shift(cell[2], piece_def[piece][2]);
   cell[4] = shift(cell[3], piece_def[piece][3]);
}

/* Convenience function to quickly calculate if a piece fits on the board */
int cells_fit_on_board(char *cell, int piece) {
   return (!out_of_bounds(cell[0], piece_def[piece][0]) &&
         !out_of_bounds(cell[1], piece_def[piece][1]) &&
         !out_of_bounds(cell[2], piece_def[piece][2]) &&
         !out_of_bounds(cell[3], piece_def[piece][3]));
}

/* Returns the lowest index of the cells of a piece.
 * I use the lowest index that a piece occupies as the index for looking up
 * the piece in the solve function.
 */
char minimum_of_cells(char *cell) {
   char minimum = cell[0];
   minimum = cell[1] < minimum ? cell[1] : minimum;
   minimum = cell[2] < minimum ? cell[2] : minimum;
   minimum = cell[3] < minimum ? cell[3] : minimum;
   minimum = cell[4] < minimum ? cell[4] : minimum;
   return minimum;
}

/* Calculate the lowest possible open cell if the piece is placed on the board.
 * Used to later reduce the amount of time searching for open cells in the
 * solve function.
 */
char first_empty_cell(char *cell, char minimum) {
   char first_empty = minimum;
   while(first_empty == cell[0] || first_empty == cell[1] ||
         first_empty == cell[2] || first_empty == cell[3] ||
         first_empty == cell[4])
      first_empty++;
   return first_empty;
}

/* Generate the unsigned long long int that will later be anded with the
 * board to determine if it fits.
 */
unsigned long long bitmask_from_cells(char *cell) {
   unsigned long long piece_mask = 0ULL;
   int i;
   for(i = 0; i < 5; i++)
      piece_mask |= 1ULL << cell[i];
   return piece_mask;
}

/* Record the piece and other important information in arrays that will
 * later be used by the solve function.
 */
void record_piece(int piece, int minimum, char first_empty,
      unsigned long long piece_mask) {
   pieces[piece][minimum][piece_counts[piece][minimum]] = piece_mask;
   next_cell[piece][minimum][piece_counts[piece][minimum]] = first_empty;
   piece_counts[piece][minimum]++;
}


/* Fill the entire board going cell by cell.  If any cells are ""trapped""
 * they will be left alone.
 */
void fill_contiguous_space(char *board, int index) {
   if(board[index] == 1)
      return;
   board[index] = 1;
   if(!out_of_bounds(index, E))
      fill_contiguous_space(board, shift(index, E));
   if(!out_of_bounds(index, SE))
      fill_contiguous_space(board, shift(index, SE));
   if(!out_of_bounds(index, SW))
      fill_contiguous_space(board, shift(index, SW));
   if(!out_of_bounds(index, W))
      fill_contiguous_space(board, shift(index, W));
   if(!out_of_bounds(index, NW))
      fill_contiguous_space(board, shift(index, NW));
   if(!out_of_bounds(index, NE))
      fill_contiguous_space(board, shift(index, NE));
}


/* To thin the number of pieces, I calculate if any of them trap any empty
 * cells at the edges.  There are only a handful of exceptions where the
 * the board can be solved with the trapped cells.  For example:  piece 8 can
 * trap 5 cells in the corner, but piece 3 can fit in those cells, or piece 0
 * can split the board in half where both halves are viable.
 */
int has_island(char *cell, int piece) {
   char temp_board[50];
   char c;
   int i;
   for(i = 0; i < 50; i++)
      temp_board[i] = 0;
   for(i = 0; i < 5; i++)
      temp_board[((int)cell[i])] = 1;
   i = 49;
   while(temp_board[i] == 1)
      i--;
   fill_contiguous_space(temp_board, i);
   c = 0;
   for(i = 0; i < 50; i++)
      if(temp_board[i] == 0)
         c++;
   if(c == 0 || (c == 5 && piece == 8) || (c == 40 && piece == 8) ||
         (c % 5 == 0 && piece == 0))
      return FALSE;
   else
      return TRUE;
}


/* Calculate all six rotations of the specified piece at the specified index.
 * We calculate only half of piece 3's rotations.  This is because any solution
 * found has an identical solution rotated 180 degrees.  Thus we can reduce the
 * number of attempted pieces in the solve algorithm by not including the 180-
 * degree-rotated pieces of ONE of the pieces.  I chose piece 3 because it gave
 * me the best time ;)
 */
 void calc_six_rotations(char piece, char index) {
   char rotation, cell[5];
   char minimum, first_empty;
   unsigned long long piece_mask;

   for(rotation = 0; rotation < 6; rotation++) {
      if(piece != 3 || rotation < 3) {
         calc_cell_indices(cell, piece, index);
         if(cells_fit_on_board(cell, piece) && !has_island(cell, piece)) {
            minimum = minimum_of_cells(cell);
            first_empty = first_empty_cell(cell, minimum);
            piece_mask = bitmask_from_cells(cell);
            record_piece(piece, minimum, first_empty, piece_mask);
         }
      }
      rotate_piece(piece);
   }
}

/* Calculate every legal rotation for each piece at each board location. */
void calc_pieces(void) {
   char piece, index;

   for(piece = 0; piece < 10; piece++) {
      for(index = 0; index < 50; index++) {
         calc_six_rotations(piece, index);
         flip_piece(piece);
         calc_six_rotations(piece, index);
      }
   }
}



/* Calculate all 32 possible states for a 5-bit row and all rows that will
 * create islands that follow any of the 32 possible rows.  These pre-
 * calculated 5-bit rows will be used to find islands in a partially solved
 * board in the solve function.
 */
#define ROW_MASK 0x1F
#define TRIPLE_MASK 0x7FFF
char all_rows[32] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
      17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31};
int bad_even_rows[32][32];
int bad_odd_rows[32][32];
int bad_even_triple[32768];
int bad_odd_triple[32768];

int rows_bad(char row1, char row2, int even) {
   /* even is referring to row1 */
   int i, in_zeroes, group_okay;
   char block, row2_shift;
   /* Test for blockages at same index and shifted index */
   if(even)
      row2_shift = ((row2 << 1) & ROW_MASK) | 0x01;
   else
      row2_shift = (row2 >> 1) | 0x10;
   block = ((row1 ^ row2) & row2) & ((row1 ^ row2_shift) & row2_shift);
   /* Test for groups of 0's */
   in_zeroes = FALSE;
   group_okay = FALSE;
   for(i = 0; i < 5; i++) {
      if(row1 & (1 << i)) {
         if(in_zeroes) {
            if(!group_okay)
               return TRUE;
            in_zeroes = FALSE;
            group_okay = FALSE;
         }
      } else {
         if(!in_zeroes)
            in_zeroes = TRUE;
         if(!(block & (1 << i)))
            group_okay = TRUE;
      }
   }
   if(in_zeroes)
      return !group_okay;
   else
      return FALSE;
}

/* Check for cases where three rows checked sequentially cause a false
 * positive.  One scenario is when 5 cells may be surrounded where piece 5
 * or 7 can fit.  The other scenario is when piece 2 creates a hook shape.
 */
int triple_is_okay(char row1, char row2, char row3, int even) {
   if(even) {
      /* There are four cases:
       * row1: 00011  00001  11001  10101
       * row2: 01011  00101  10001  10001
       * row3: 011??  00110  ?????  ?????
       */
      return ((row1 == 0x03) && (row2 == 0x0B) && ((row3 & 0x1C) == 0x0C)) ||
            ((row1 == 0x01) && (row2 == 0x05) && (row3 == 0x06)) ||
            ((row1 == 0x19) && (row2 == 0x11)) ||
            ((row1 == 0x15) && (row2 == 0x11));
   } else {
      /* There are two cases:
       * row1: 10011  10101
       * row2: 10001  10001
       * row3: ?????  ?????
       */
      return ((row1 == 0x13) && (row2 == 0x11)) ||
            ((row1 == 0x15) && (row2 == 0x11));
   }
}


void calc_rows(void) {
   int row1, row2, row3;
   int result1, result2;
   for(row1 = 0; row1 < 32; row1++) {
      for(row2 = 0; row2 < 32; row2++) {
         bad_even_rows[row1][row2] = rows_bad(row1, row2, TRUE);
         bad_odd_rows[row1][row2] = rows_bad(row1, row2, FALSE);
      }
   }
   for(row1 = 0; row1 < 32; row1++) {
      for(row2 = 0; row2 < 32; row2++) {
         for(row3 = 0; row3 < 32; row3++) {
            result1 = bad_even_rows[row1][row2];
            result2 = bad_odd_rows[row2][row3];
            if(result1 == FALSE && result2 == TRUE
                  && triple_is_okay(row1, row2, row3, TRUE))
               bad_even_triple[row1+(row2*32)+(row3*1024)] = FALSE;
            else
               bad_even_triple[row1+(row2*32)+(row3*1024)] = result1 || result2;

            result1 = bad_odd_rows[row1][row2];
            result2 = bad_even_rows[row2][row3];
            if(result1 == FALSE && result2 == TRUE
                  && triple_is_okay(row1, row2, row3, FALSE))
               bad_odd_triple[row1+(row2*32)+(row3*1024)] = FALSE;
            else
               bad_odd_triple[row1+(row2*32)+(row3*1024)] = result1 || result2;
         }
      }
   }
}



/* Calculate islands while solving the board.
 */
int boardHasIslands(char cell) {
   /* Too low on board, don't bother checking */
   if(cell >= 40)
      return FALSE;
   int current_triple = (board >> ((cell / 5) * 5)) & TRIPLE_MASK;
   if((cell / 5) % 2)
      return bad_odd_triple[current_triple];
   else
      return bad_even_triple[current_triple];
}


/* The recursive solve algorithm.  Try to place each permutation in the upper-
 * leftmost empty cell.  Mark off available pieces as it goes along.
 * Because the board is a bit mask, the piece number and bit mask must be saved
 * at each successful piece placement.  This data is used to create a 50 char
 * array if a solution is found.
 */
short avail = 0x03FF;
char sol_nums[10];
unsigned long long sol_masks[10];
signed char solutions[2100][50];
int solution_count = 0;
int max_solutions = 2100;

void record_solution(void) {
   int sol_no, index;
   unsigned long long sol_mask;
   for(sol_no = 0; sol_no < 10; sol_no++) {
      sol_mask = sol_masks[sol_no];
      for(index = 0; index < 50; index++) {
         if(sol_mask & 1ULL) {
            solutions[solution_count][index] = sol_nums[sol_no];
            /* Board rotated 180 degrees is a solution too! */
            solutions[solution_count+1][49-index] = sol_nums[sol_no];
         }
         sol_mask = sol_mask >> 1;
      }
   }
   solution_count += 2;
}

void solve(int depth, int cell) {
   int piece, rotation, max_rots;
   unsigned long long *piece_mask;
   short piece_no_mask;

   if(solution_count >= max_solutions)
      return;

   while(board & (1ULL << cell))
      cell++;

   for(piece = 0; piece < 10; piece++) {
      piece_no_mask = 1 << piece;
      if(!(avail & piece_no_mask))
         continue;
      avail ^= piece_no_mask;
      max_rots = piece_counts[piece][cell];
      piece_mask = pieces[piece][cell];
      for(rotation = 0; rotation < max_rots; rotation++) {
         if(!(board & *(piece_mask + rotation))) {
            sol_nums[depth] = piece;
            sol_masks[depth] = *(piece_mask + rotation);
            if(depth == 9) {
               /* Solution found!!!!!11!!ONE! */
               record_solution();
               avail ^= piece_no_mask;
               return;
            }
            board |= *(piece_mask + rotation);
            if(!boardHasIslands(next_cell[piece][cell][rotation]))
               solve(depth + 1, next_cell[piece][cell][rotation]);
            board ^= *(piece_mask + rotation);
         }
      }
      avail ^= piece_no_mask;
   }
}


/* qsort comparator - used to find first and last solutions */
int solution_sort(const void *elem1, const void *elem2) {
   signed char *char1 = (signed char *) elem1;
   signed char *char2 = (signed char *) elem2;
   int i = 0;
   while(i < 50 && char1[i] == char2[i])
      i++;
   return char1[i] - char2[i];
}


/* pretty print a board in the specified hexagonal format */
void pretty(signed char *b) {
   int i;
   for(i = 0; i < 50; i += 10) {
      printf(""%c %c %c %c %c \n %c %c %c %c %c \n"", b[i]+'0', b[i+1]+'0',
            b[i+2]+'0', b[i+3]+'0', b[i+4]+'0', b[i+5]+'0', b[i+6]+'0',
            b[i+7]+'0', b[i+8]+'0', b[i+9]+'0');
   }
   printf(""\n"");
}

int main(int argc, char **argv) {
   if(argc > 1)
      max_solutions = atoi(argv[1]);
   calc_pieces();
   calc_rows();
   solve(0, 0);
   printf(""%d solutions found\n\n"", solution_count);
   qsort(solutions, solution_count, 50 * sizeof(signed char), solution_sort);
   pretty(solutions[0]);
   pretty(solutions[solution_count-1]);
   return 0;
}
"
227-28565,lubosz/gst-plugins-vr,tools/gst-play-vr.c,29,1,32,1827573.0544701,169057.0,10.81039531045742,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0012183820363134,1082014363648.0,0.0134155935572026,0.0785563462891999,"/* GStreamer
 *
 * Copyright (C) 2016 Lubosz Sarnecki <lubosz.sarnecki@collabora.co.uk>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA 02110-1301, USA.
 */

/**
 * SECTION:gstvr
 * @short_description: GStreamer VR
 *
 */

#include <string.h>


int
main (int argc, char *argv[])
{
  return 0;
}
"
008-4370,Amztion/Algorithm,Archived/algorithms/ReplaceBlank.c,31,2,32,2082122.72264055,174491.0,11.932546664297872,1296.0,1279.0,39417.0,13411.0,1620.0,638.0,1341.0,594.0,1500000000,0.0013880818150937,1082014363648.0,0.0147572081081545,0.079370788218369,"#include <stdio.h>

void ReplaceBlank(char str[], int N){
    int originalLength = 0, currentLength = 0, amountOfSpace = 0;
    char *orginalEnd, *newEnd;
    if(str == NULL && 0 == N){
        return;
    }
    while(str[originalLength]){
        if(str[originalLength++] == ' ') ++amountOfSpace;
    }
    currentLength = originalLength + 2 * amountOfSpace;
    if(currentLength > N) return;

    orginalEnd = str + originalLength;
    newEnd = str + currentLength;

    while(orginalEnd != (str - 1)){
        if(*(orginalEnd) == ' '){
            *(newEnd--) = '0';
            *(newEnd--) =  '2';
            *(newEnd--) = '%';
            --orginalEnd;
         }else{
             *(newEnd--) = *(orginalEnd--);
         }
    }


}

int main(int argc, const char *argv[])
{
    char str[100] = ""Hooray! Oh My Zsh has been update and/or is at the current version."";

    ReplaceBlank(str, 100);

    puts(str);

    return 0;
}
"
175-25483,emezav/udc_sistop,classical_sync_problems/threads.c,48,4,45,12004994371.323847,234543.0,51184.62018052127,1576.0,1536.0,53892.0,22291.0,1734.0,830.0,1389.0,777.0,1500000000,8.003329580882564,1082014363648.0,0.0132683559091509,0.0620873423204651,"#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define N 5

typedef void * (*thread_start_func)(void * arg);

typedef struct {
  pthread_t id;
  pthread_attr_t attr;
  thread_start_func start_func;
  void * arg;
}Thread;


Thread * start_thread(thread_start_func func, void * arg) {
  Thread* t;
  t=(Thread*)malloc(sizeof(Thread));
  t->start_func=func;
  t->arg = arg;
  pthread_attr_init(&(t->attr));
  pthread_create(&(t->id), &(t->attr), (void*)t->start_func, t->arg);  
  
  return t;
}

void * funcion(void *param) {
  int i;
  int * id;
 
  id = (int*)param;
	
  printf(""Thread %d created\n"", (int)*id);
  fflush(stdout);
   for (i=0; i<5; i++) {
	printf(""\t[%d] %d\n"", (int)*id, 5-i);
	fflush(stdout);
	sleep(rand() % 3); //Simular una demora aleatoria en la llegada  
  }
  printf(""Thread %d finished\n"", (int)*id);
  fflush(stdout);
  //pthread_exit(0);
}


Thread * hilos[N];
int id[N];

int main(int argc, char * argv[]) {
  printf(""Main Started\n"");
  char c;
  int i;

  for (i=0; i<N; i++) { 
    id[i] = i;
    hilos[i] = start_thread(funcion, (void*)&id[i]);
  }

  printf(""Waiting for threads to finish...\n"" );

  //Esperar hasta que terminen todos los hilos
  for (i=0; i<N; i++) {
     pthread_join(hilos[i]->id, NULL);  
  }

  printf(""Main Finished\n"");
}



"
316-21581,tendoasan/ProgrammingInC,chapter11/exce7.c,26,4,29,2414750.8665918,196124.0,12.312363606697804,1361.0,1338.0,44357.0,16697.0,1644.0,639.0,1359.0,596.0,1500000000,0.0016098339110612,1082014363648.0,0.0137617017805062,0.0694139614112097,"// 使用重写sort函数
#include <stdio.h>

void sort (int  *a, int  n){
   int  *aptr1, *aptr2, temp;

   for ( aptr1 = a;  aptr1 < a + n - 1;  ++aptr1 )
       for ( aptr2 = aptr1 + 1;  aptr2 < a + n;  ++aptr2 )
           if ( *aptr1 > *aptr2 ) {
              temp = *aptr1;
              *aptr1 = *aptr2;
              *aptr2 = temp;
           }
}

int main(void){
	int i;
	int array[16] = {34, -5, 6, 0, 12, 100, 56, 22,
		44, -3, -9, 12, 17, 22, 6, 11};
	void sort(int *a, int n);
	
	printf(""The array before the sort:\n"");
	
	for(i = 0; i < 16; ++i)
		printf(""%i "", array[i]);
		
	sort(array, 16);
		
	printf(""\n\nThe array after the sort:\n"");
	
	for(i = 0; i < 16; ++i)
		printf(""%i "", array[i]);
	
	printf(""\n"");
	
	return 0;
}
"
070-32207,EvtimPavlov/c-programming-2014-2015-homework,A/02_Andrea_Georgieva/homework_3/task_1.c,24,3,21,2005382.9066454002,223879.0,8.952469860951675,1335.0,1316.0,49661.0,20663.0,1618.0,643.0,1340.0,600.0,1500000000,0.0013369219377636,1082014363648.0,0.0118412178006869,0.0597377851089244,"#include <stdio.h>
int main()
{
char c;
int a; 
c=96;
for (a=97; a<=122;a++)
	{
		c++;
		printf(""%c - %d\n"",c,a);
	}
c=64;
for (a=65;a<=90;a++)
{
	c++;
	printf(""%c - %d\n"",c,a);
}
c=47;
for(a=48;a<=57;a++)
{
	c++;
	printf(""%c - %d\n"",c,a);
}
return 0;
}
"
357-6533,EvtimPavlov/c-programming-2014-2015-homework,A/14_Ivan-Asen_Ovedenski/Homework_4/christmas_tree.c,49,9,33,1728108.1527471,188436.0,9.170795389416035,1273.0,1256.0,45680.0,16113.0,1604.0,642.0,1331.0,598.0,1500000000,0.0011520721018314,1082014363648.0,0.0134210023562376,0.0675642872169986,"#include <stdio.h>

int main ()
{
	int current_row;
	int max_rows = 4;
	for (current_row = 0;current_row < max_rows;current_row++)
	{	
		int i;
		for (i = 0;i < max_rows - current_row - 1;i++)
		{
			printf("" "");
		}
		for (i = 0;i < 1 +	2 * current_row;i++)
		{
			printf(""*"");
		}	
		printf(""\n"");
	}
	printf(""\n"");
	max_rows = 7;
	for (current_row = 0;current_row < max_rows;current_row++)
	{	
		int i;
		for (i = 0;i < max_rows - current_row - 1;i++)
		{
			printf("" "");
		}
		for (i = 0;i < 1 +	2 * current_row;i++)
		{
			printf(""*"");
		}	
		printf(""\n"");
	}
	printf(""\n"");
	max_rows = 11;
	for (current_row = 0;current_row < max_rows;current_row++)
	{	
		int i;
		for (i = 0;i < max_rows - current_row - 1;i++)
		{
			printf("" "");
		}
		for (i = 0;i < 1 +	2 * current_row;i++)
		{
			printf(""*"");
		}	
		printf(""\n"");
	}
	return 0 ;
}
"
253-10788,bigown/SOpt,C/Function/Performance2.c,26,3,23,1788843.07388205,177882.0,10.056346341957028,1435.0,1410.0,40228.0,13971.0,1638.0,638.0,1355.0,594.0,1500000000,0.0011925620492547,1082014363648.0,0.0159937486648452,0.0779534677761582,"#include <stdio.h>
#include <time.h>

void minhafuncao() {
    int x = 0;
    x++;
//    return x;
}

int main () {
    clock_t begin, end;
    double time_spent;
    int x;
    begin = clock();
    for (int i = 0; i < 300000000; i++);
    end = clock();
    time_spent = (double)(end - begin) / CLOCKS_PER_SEC;
    printf (""Tempo gasto %.2lf segundos.\n"", time_spent);
    begin = clock();
    for (int i = 0; i < 300000000; i++) minhafuncao();
    end = clock();
    time_spent = (double)(end - begin) / CLOCKS_PER_SEC;
    printf (""Tempo gasto %.2lf segundos.\n"", time_spent);
    begin = clock();
    for (int i = 0; i < 300000000; i++) x++;
    end = clock();
    time_spent = (double)(end - begin) / CLOCKS_PER_SEC;
    printf (""Tempo gasto %.2lf segundos.\n"", time_spent);
    x++;
}
"
169-26047,ColinIanKing/stress-ng,test/test-asm-nop.c,24,1,24,1670957.89220175,169062.0,9.879978942636429,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0011139719281345,1082014363648.0,0.0134151967917095,0.0785563462891999,"/*
 * Copyright (C) 2017-2021 Canonical, Ltd.
 * Copyright (C)      2022 Colin Ian King.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 */

int main(void)
{
	__asm__ __volatile__(""nop;"");

	return 0;
}

"
013-6163,zhangrxiang/learn-c,basic/2017/11/14/bytetostring.c,32,1,34,1768083.19520205,173360.0,10.19890978311029,1286.0,1271.0,39283.0,13323.0,1618.0,637.0,1340.0,593.0,1500000000,0.0011787221301347,1082014363648.0,0.0147496538994,0.0796106907957267,"//
// Created by zhangrongxiang on 2017/11/14 14:33
// File bytetostring
//

#include <stdio.h>
#include <string.h>

void byteToString(unsigned char *buffer, int len, unsigned char *string);

int main() {

    unsigned char *str = ""hello"";
    char buf[20];
    byteToString(str, sizeof(str), buf);
    printf(""%s\n"", buf);
}

void byteToString(unsigned char *buffer, int len, unsigned char *string) {
    int i = 0;
    int tmp;
    for (i = 0; i < len; i++) {
        tmp = buffer[i] >> 4;
        if (tmp >= 0 && tmp <= 9)
            string[i * 2] = tmp + '0';
        else if (tmp >= 10 && tmp <= 15)
            string[i * 2] = tmp - 10 + 'A';
        else
            string[i * 2] = 'F';

        tmp = buffer[i] & 0xF;
        if (tmp >= 0 && tmp <= 9)
            string[i * 2 + 1] = tmp + '0';
        else if (tmp >= 10 && tmp <= 15)
            string[i * 2 + 1] = tmp - 10 + 'A';
        else
            string[i * 2 + 1] = 'F';
    }
    string[i * 2] = '\0';
}
"
376-10864,jindal25/interview-questions,knowledge_based/linux_internals/sleep/sleep1.c,45,4,43,7503115123.487078,176181.0,42587.538514368745,1363.0,1345.0,40018.0,13679.0,1650.0,637.0,1362.0,594.0,1500000000,5.002076748991385,1082014363648.0,0.0153705564164126,0.0790174497644188,"/* A simple, yet highly unreliable implementation of sleep(3).
 *
 * First and foremost, this implementation uses signal(2).
 *
 * The exact semantics of signal(2) are platform-dependent, which hinders code portability.
 * For example, the behavior of signal(2) with interrupted syscalls varies among platforms.
 *
 * Perhaps even worse than that, signal(2) is obsolescent due to its unreliable semantics:
 * - We can't simply check a signal's disposition without changing it
 * - When a signal is caught, the default action is restarted. We can always set the handler again
 *   once we catch the signal, but there is a window of time between entering the handler and
 *   calling signal(2) where the signal could be raised again, without having set the correct
 *   handler. Thus, a process that always catches SIGTERM can still end up being terminated
 *   unproperly.
 * - There is no way to block signals for later delivery. Sometimes, critical code regions need
 *   to block a certain signal from being raised, while still remembering if that signal occurred
 *   for later delivery. This is not possible with signal(2).
 *
 * Further problems with this version of sleep(3) include:
 * - A race condition between alarm(2) and pause(2). It is possible, though unlikely in most cases,
 *   that the specified amount of seconds elapses before the call to pause(2), which might put the
 *   process to sleep forever.
 * - It changes the disposition of SIGALRM. We should save the previous action and restore it before
 *   returning.
 * - If there was an active alarm(2) in progress from user code, that alarm is canceled. If an alarm
 *   is in progress, we should wait only that amount of time.
 *
 */

#include <stdio.h>
#include <unistd.h>
#include <signal.h>

void sigalrm(int signo) {
	/* Nothing to do here */
}

unsigned int sleep1(unsigned int seconds) {
	if (signal(SIGALRM, sigalrm) == SIG_ERR) {
		return seconds;
	}
	alarm(seconds);
	pause();
	return alarm(0);
}

int main(void) {
	printf(""Going to sleep for 5 seconds.\n"");
	unsigned int sleep_left = sleep1(5);
	printf(""Woke up after %u seconds.\n"", 5-sleep_left);
	return 0;
}
"
046-29606,wuzhouhui/leetcode,46_permutations.c,88,5,36,1559013.0351483,179749.0,8.67327773728922,1360.0,1333.0,40818.0,14151.0,1643.0,653.0,1359.0,609.0,1500000000,0.0010393420234322,1082014363648.0,0.014982002681517,0.0775709945605705,"#include <stdlib.h> 
#include <string.h>

#define MAXN	512
#define STEP	16

static int	**res;
static int	perm[MAXN];
static int	p, maxp;
static char	occupy[MAXN];

#define initial() do {				\
	res = NULL;				\
	bzero(occupy, sizeof(occupy));		\
	p = maxp = 0;				\
} while (0)

static int avail(int n)
{
	int	i;

	for (i = 0; i < p; i++) {
		if (!memcmp(res[i], perm, n * sizeof(perm[0])))
			return(0);
	}
	return(1);
}

static void add_res(int n)
{
	if (!maxp) {
		maxp = STEP;
		res = malloc(maxp * sizeof(int *));
	}
	if (p >= maxp) {
		maxp += STEP;
		res = realloc(res, maxp * sizeof(int *));
	}
	res[p] = malloc(n * sizeof(int));
	memcpy(res[p], perm, n * sizeof(int));
	p++;
}

static void bktrack(int *nums, int n, int lev)
{
	int	i;

	if (!lev) {
		for (i = 0; i < n; i++) {
			perm[0] = nums[i];
			occupy[i] = 1;
			bktrack(nums, n, lev + 1);
			occupy[i] = 0;
		}
		return;
	}
	if (lev == (n - 1)) {
		for (i = 0; i < n; i++) {
			if (!occupy[i])
				break;
		}
		perm[lev] = nums[i];
		if (avail(n))
			add_res(n);
		return;
	}
	for (i = 0; i < n; i++) {
		if (occupy[i])
			continue;
		perm[lev] = nums[i];
		occupy[i] = 1;
		bktrack(nums, n, lev + 1);
		occupy[i] = 0;
	}
}

int **permute(int *nums, int numsSize, int *returnSize)
{
	initial();
	if (!numsSize) {
		*returnSize = 0;
		return(NULL);
	}
	if (numsSize == 1) {
		*returnSize = 1;
		res = malloc(sizeof(int *));
		res[0] = malloc(sizeof(int));
		res[0][0] = nums[0];
		return(res);
	}
	bktrack(nums, numsSize, 0);
	*returnSize = p;
	return(res);
}

#include <stdio.h>

int main(void)
{
	int	**ret, n;
	int	x[] = { 1, 2, 3 };

	permute(x, sizeof(x) / sizeof(x[0]), &n);
	printf(""%d\n"", n);
	return(0);
}
"
128-1243,NationalSecurityAgency/ghidra,Ghidra/Debug/Framework-Debugging/src/expCloneSpin/c/expCloneSpin.c,26,2,27,15003675685.613417,180637.0,83025.59371003725,1479.0,1447.0,41175.0,14505.0,1655.0,675.0,1362.0,628.0,1500000000,10.00245045707561,1082014363648.0,0.0161982318129729,0.0775862068965517,"/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <pthread.h>
#include <unistd.h>
#include <stdio.h>

pthread_t thread;

void* work(void* param) {
    printf(""I'm PID: %d\n"", getpid());
    for (int i = 0; i < 10; i++) {
        sleep(1);
    }
}

int main() {
    pthread_create(&thread, NULL, work, NULL);
    work(NULL);
}
"
117-1334,sos22/FT,massif/tests/basic.c,15,2,18,1575866.94695055,185729.0,8.48476005362652,1249.0,1233.0,42267.0,15055.0,1614.0,669.0,1345.0,626.0,1500000000,0.0010505779646337,1082014363648.0,0.0133635565797479,0.0742123443006175,"#include <stdlib.h>

// Allocate some memory and then deallocate it, to get a nice up-then-down
// graph.

int main(void)
{
   // N=36 gives us 72 snapshots, which fills the text graph nicely.
   #define N   36
   int i;
   int* a[N];

   for (i = 0; i < N; i++) {
      a[i] = malloc(200);  // 200 is divisible by 8 -- so no slop.
   }
   for (i = 0; i < N-1; i++) {
      free(a[i]);
   }
   
   return 0;
}
"
293-15482,zguangyu/euler,11.c,39,2,35,1541027.915664,182650.0,10.07351218176841,1343.0,1321.0,42822.0,13312.0,1643.0,635.0,1366.0,593.0,1500000000,0.001027351943776,1082014363648.0,0.0145852723788666,0.0754801011864467,"#include <stdio.h>

int a[20][20] = {{ 8,  2, 22, 97, 38, 15,  0, 40,  0, 75,  4,  5,  7, 78, 52, 12, 50, 77, 91,  8}, 
		 {49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48,  4, 56, 62,  0}, 
		 {81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30,  3, 49, 13, 36, 65}, 
		 {52, 70, 95, 23,  4, 60, 11, 42, 69, 24, 68, 56,  1, 32, 56, 71, 37,  2, 36, 91}, 
		 {22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80}, 
		 {24, 47, 32, 60, 99,  3, 45,  2, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50}, 
		 {32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70}, 
		 {67, 26, 20, 68,  2, 62, 12, 20, 95, 63, 94, 39, 63,  8, 40, 91, 66, 49, 94, 21}, 
		 {24, 55, 58,  5, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72}, 
		 {21, 36, 23,  9, 75,  0, 76, 44, 20, 45, 35, 14,  0, 61, 33, 97, 34, 31, 33, 95}, 
		 {78, 17, 53, 28, 22, 75, 31, 67, 15, 94,  3, 80,  4, 62, 16, 14,  9, 53, 56, 92}, 
		 {16, 39,  5, 42, 96, 35, 31, 47, 55, 58, 88, 24,  0, 17, 54, 24, 36, 29, 85, 57}, 
		 {86, 56,  0, 48, 35, 71, 89,  7,  5, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58}, 
		 {19, 80, 81, 68,  5, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77,  4, 89, 55, 40}, 
		 { 4, 52,  8, 83, 97, 35, 99, 16,  7, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66}, 
		 {88, 36, 68, 87, 57, 62, 20, 72,  3, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69}, 
		 { 4, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18,  8, 46, 29, 32, 40, 62, 76, 36}, 
		 {20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74,  4, 36, 16}, 
		 {20, 73, 35, 29, 78, 31, 90,  1, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57,  5, 54}, 
		 { 1, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52,  1, 89, 19, 67, 48}};

int main()
{
  int i, j, max=0, tmp;
  for (i=0; i<17; i++) {
    for (j=0; j<17; j++) {
      tmp = a[i][j]*a[i][j+1]*a[i][j+2]*a[i][j+3];
      max = tmp > max ? tmp : max;
      tmp = a[i][j]*a[i+1][j]*a[i+2][j]*a[i+3][j];
      max = tmp > max ? tmp : max;
      tmp = a[i][j]*a[i+1][j+1]*a[i+2][j+2]*a[i+3][j+3];
      max = tmp > max ? tmp : max;
      if (i >= 3) {
	tmp = a[i][j]*a[i-1][j+1]*a[i-2][j+2]*a[i-3][j+3];
	max = tmp > max ? tmp : max;
      }
    }
  }
  printf(""%d\n"", max);
}
"
099-12180,acarno/slicer,valgrind/gdbserver_tests/self_invalidate.c,35,1,30,1866049.4824870501,169061.0,11.037726027883426,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0012440329883247,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* Based on reproducer done by Dejan Jevtic */
int main (void)
{
#if defined(VGA_amd64)
   /* Note that small changes in the code below 
      caused the bug not to be triggered anymore.
      E.g. removing the dec %%eax avoids the assert
      while this removal causes one more loop to be
      executed. */
__asm__ __volatile__
   (""mov $30, %%eax\n\t""
    ""top:\n\t""
    ""mov $-4, %%ebx\n\t""
    ""add %%ebx, %%eax\n\t""
    ""dec %%eax\n\t""
    ""cmp    $0x0,%%eax\n\t""
    ""jne top\n\t""
    ""mov $60, %%eax\n\t""
    ""mov $0, %%rdi\n\t""
    ""syscall\n\t""
    : : : ""eax"", ""ebx"", ""rdi""
    );
#elif defined(VGA_mips32) || defined(VGA_mips64)
__asm__ __volatile__
   (""li $t0, 42\n\t""
    ""top:\n\t""
    ""li $t1, -4\n\t""
    ""addu $t0, $t0, $t1\n\t""
    ""li $t2, -2\n\t""
    ""addu $t0, $t0, $t2\n\t""
    ""addiu $t0, $t0, -1\n\t""
    ""bnez $t0, top\n\t""
    ""nop\n\t""
    : : : ""t0"", ""t1""
    );
#endif
 return 0;
}
"
200-26874,csampez/analisis-numerico-computo-cientifico,MNO/entrega_tareas_de_C/tarea4/116754/4b.c,30,1,26,1752992.9755255498,176758.0,16.1985369827674,1312.0,1294.0,40258.0,13767.0,1628.0,636.0,1356.0,593.0,1500000000,0.0011686619836837,1082014363648.0,0.0147433213772502,0.0779824155483572,"#include<stdio.h>
#include<stdlib.h>
#include<string.h>

char *duplica_string(char *s){  
    char *p;
    p = malloc(strlen(s)+1); /* sumamos uno para almacenar el caracter '\0'*/
        if(p!=NULL)
        strcpy(p,s);
    return p;
}

char *voltea_string(char *s){
    int length = strlen(s);
    char *p;
    int i=0;
    p = malloc(length);
    while(length != 0){
        *(p+i) = *(s+length-1);
        i++, length--;
        *(p+i)='\0';
    }
    return p;
}
    

int main(void){
    char *s = ""Campos verdes"";
    char *s_duplicado = malloc(strlen(s));
    char *s_volteado = malloc(strlen(s));
    s_duplicado = duplica_string(s);
    s_volteado = voltea_string(s_duplicado);
    printf(""%s\n"", s_volteado);
    free(s_volteado);
    free(s_duplicado);
    return 0;
}
"
168-21113,Gurgel100/gcc,gcc/testsuite/gcc.dg/tree-ssa/fnsplit-1.c,20,1,32,1644482.95254255,176624.0,9.310637285986047,1141.0,1133.0,39907.0,12870.0,1652.0,586.0,1395.0,546.0,1500000000,0.0010963219683617,1082014363648.0,0.0128748075006794,0.0791822195274456,"/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-tree-fnsplit"" } */
#include <stdio.h>
int a[1000];

void
t(int a)
{
  if (a)
    printf (""I Am Completely Operational,""),
    printf (""And All My Circuits Are Functioning Perfectly\n"");
}
int
main(void)
{
  int i;
  for (i = 0; i < 1000; i++)
    t(a[i]);
  return 0;
}
/* { dg-final { scan-tree-dump-times ""Splitting function at:"" 1 ""fnsplit""} } */
/* { dg-final { scan-tree-dump-times ""Invalid sum"" 0 ""fnsplit""} } */

"
004-32098,acarno/slicer,valgrind/callgrind/tests/threads.c,32,5,24,1505563104.059547,16203777.0,92.91433126980208,1387.0,1360.0,4041593.0,15768.0,1683.0,869.0,1360.0,823.0,1500000000,1.003708736039698,1082014363648.0,0.0001695283760076,0.0011670147172016,"/* A simple example with 4 threads */

#include <pthread.h>
#include <unistd.h>

double a[1000];

static void init()
{
	int i;
	for(i=0;i<1000;i++) a[i] = (double)i;
}

static void *th(void *v)
{
	double sum = 0.0;
	int i,j;

	for(j=0;j<1000;j++)
		for(i=0;i<1000;i++)
			sum += a[i];

	*( (double*)v ) = sum;

	/* make sure that no threads is so fast that it finishes
         * before last thread is created, thus reusing the TID */
	sleep(1);

	return 0;
}

int main()
{
	pthread_t t[4];
	double sum[4];
	int i;

	init();

	for(i=0;i<4;i++)
		pthread_create(&t[i], NULL, th, &sum[i]);	

	for(i=0;i<4;i++)
		pthread_join(t[i], NULL);

	return 0;
}
"
074-33235,ecolitan/learnC,learnCthehardway/ex11.c,39,6,36,2175347.9959443,190782.0,11.402265412879622,1363.0,1340.0,42868.0,15658.0,1636.0,640.0,1352.0,599.0,1500000000,0.0014502319972962,1082014363648.0,0.0141680032707488,0.0722243105628267,"#include <stdio.h>

int main(int argc, char *argv[])
{
    // go through each string in argv

    int i = (argc - 1);
    while (i >= 0) {
        printf(""arg: %d: %s\n"", i, argv[i]);
        i--;
    }

    // lets make our own array of strings
    char *states[] = {
        ""California"", ""Oregon"",
        ""Washington"", ""Texas""
    };

    int num_states = 4;
    i = 0;
    while (i < num_states) {
        printf(""state: %d: %s\n"", i, states[i]);
        i++;
    };

    // copy argv[] into another states
    for (i = 0; i < argc; i++) {
        states[i] = argv[i];
    };

    // initialise new array
    char *newarray[4] = {};

    for (i = 0; i < num_states; i++) {
        printf(""state: %d: %s\n"", i, states[i]);
        // copy states into a new array
        newarray[i] = states[i];
    };

    for (i = 0; i < num_states; i++) {
        printf(""newarray: %d: %s\n"", i, newarray[i]);
    };

    states[1] = ""I HAVE CHANGED!"";

    for (i = 0; i < num_states; i++) {
        printf(""newarray: %d: %s\n"", i, newarray[i]);
    };

    return 0;
}
"
054-34632,SanDisk-Open-Source/SSD_Dashboard,uefi/gcc/gcc-4.6.3/gcc/testsuite/gcc.c-torture/execute/pure-1.c,71,2,63,1623605.72721795,169083.0,9.598167763760992,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010824038181453,1082014363648.0,0.0134490161636592,0.0785049652044725,"
/* Origin: Kaveh Ghazi <ghazi@caip.rutgers.edu> 2002-05-27.  */

/* Use a different function for each test so the link failures
   indicate which one is broken.  */
extern void link_error0 (void);
extern void link_error1 (void);
extern void link_error2 (void);
extern void link_error3 (void);
extern void link_error4 (void);
extern void link_error5 (void);
extern void link_error6 (void);
extern void link_error7 (void);

extern int i;

extern int func0 (int) __attribute__ ((__pure__));
extern int func1 (int) __attribute__ ((__const__));

/* GCC should automatically detect attributes for these functions.
   At -O3 They'll be inlined, but that's ok.  */
static int func2 (int a) { return i + a; } /* pure */
static int func3 (int a) { return a * 3; } /* const */
static int func4 (int a) { return func0(a) + a; } /* pure */
static int func5 (int a) { return a + func1(a); } /* const */
static int func6 (int a) { return func2(a) + a; } /* pure */
static int func7 (int a) { return a + func3(a); } /* const */

int main ()
{
  int i[10], r;

  i[0] = 0;
  r = func0(0);
  if (i[0])
    link_error0();

  i[1] = 0;
  r = func1(0);
  if (i[1])
    link_error1();

  i[2] = 0;
  r = func2(0);
  if (i[2])
    link_error2();

  i[3] = 0;
  r = func3(0);
  if (i[3])
    link_error3();

  i[4] = 0;
  r = func4(0);
  if (i[4])
    link_error4();

  i[5] = 0;
  r = func5(0);
  if (i[5])
    link_error5();

  i[6] = 0;
  r = func6(0);
  if (i[6])
    link_error6();

  i[7] = 0;
  r = func7(0);
  if (i[7])
    link_error7();

  return r;
}

int func0 (int a) { return a - i; } /* pure */
int func1 (int a) { return a - a; } /* const */

int i = 2;

#ifndef __OPTIMIZE__
/* Avoid link failures when not optimizing. */
void link_error0() {}
void link_error1() {}
void link_error2() {}
void link_error3() {}
void link_error4() {}
void link_error5() {}
void link_error6() {}
void link_error7() {}
#endif /* ! __OPTIMIZE__ */
"
091-34390,jstralko/data-structures-and-algorithms,heap.c,139,3,55,2157079.63798185,184961.0,11.66234503489925,1352.0,1333.0,41640.0,14880.0,1627.0,637.0,1347.0,595.0,1500000000,0.0014380530919879,1082014363648.0,0.0145165737641989,0.074416135881104,"#include <stdio.h>

int heap_array[20];
int next_index = 0;
/*
 * Heaps are simple.
 *
 * parents must be higher order
 * than its children. Weak ordering.
 *
 * Max item is at the root.
 *
 * To traverse the heap:
 * (where x is zero based counting)
 * parent = (x - 1) / 2
 * left   = (2*x + 1
 * right  = (2*x + 2)
 */

int get_parent_index(int i)
{
	return (i - 1) >> 1;
}

int get_left_index(int i)
{
	return (i << 1) + 1;
}

int get_right_index(int i)
{
	return (i << 1) + 2;
}

void swap(int i, int j)
{
	int tmp;

	tmp = heap_array[i];
	heap_array[i] = heap_array[j];
	heap_array[j] = tmp;
}

void heapify(int i)
{
	int p;

	if (i == 0)
		return;
	
	p = get_parent_index(i);
	if (heap_array[p] < heap_array[i]) {
		swap(i, p);
		heapify(p);
	}	
}

/*
 * This is a slightly faster version of heapify 
 * (no recursion, and fewer copies)
 */
void trickle_up(int i)
{
	int saved, parent;

	saved = heap_array[i];
	parent = get_parent_index(i);

	while (i > 0 && 
		saved > heap_array[parent]) {
		
		heap_array[i] = heap_array[parent];
		i = parent;
		parent = get_parent_index(parent);
	}
	heap_array[i] = saved; 
}

void insert(int v)
{
	heap_array[next_index] = v;
	//heapify(next_index);
	trickle_up(next_index);
	next_index++;
}

void trickle_down(int i)
{
	int saved, left, right, parent;

	saved = heap_array[i];

	while (i < next_index/2) {
		left = get_left_index(i);
		right = get_right_index(i);
		
		if (right < next_index && 
			heap_array[right] > heap_array[left])
			parent = right;
		else
			parent = left;

		if (saved >= heap_array[parent])
			break;
		
		heap_array[i] = heap_array[parent];
		i = parent;
	}

	heap_array[i] = saved;
}

/*
 * remove is declared in stdio.h so
 * I had to name it remove_from_heap
 */
int remove_from_heap()
{
	int r;

	r = heap_array[0];
	heap_array[0] = heap_array[--next_index];
	trickle_down(0);

	return r;	
}

/*
 * Simple function to change the priority
 * of a index.
 */
void change(int index, int v)
{
	int old;

	if (index < 0 || index >= next_index)
		return;

	old = heap_array[index];
	heap_array[index] = v;

	if (old > v)
		trickle_down(index);
	else
		trickle_up(index);
}

void display_heap()
{
	int i;

	for(i = 0; i < next_index; i++) {
		printf(""a[%d]: %d\n"", i, heap_array[i]);
	}
}

int main(int argv, char *argc[])
{
	insert(10);
	insert(23);
	insert(1);
	insert(9);
	insert(33);
	insert(2);

	printf(""Before the remove_from_heap\n"");
	display_heap();
	
	remove_from_heap();

	printf(""After the remove_from_heap\n"");
	display_heap();

	return 0;
}
"
334-8694,Gigalomaniac/CPrimerPlus,ch10/6.c,25,2,20,1564802.83476405,169037.0,9.25715671716843,1138.0,1128.0,38451.0,12696.0,1570.0,580.0,1319.0,544.0,1500000000,0.0010432018898427,1082014363648.0,0.0134053491247478,0.0784601247384988,"#include <stdio.h>

void copy_arr(double [], double [], int);
void copy_ptr(double *, double *, int);

int main(void)
{
    double source[2][5] = {
        {1.1, 2.2, 3.3, 4.4, 5.5},
        {6.6, 7.7, 8.8, 9.9, 1.1}
    };
    double target1[2][5], target2[2][5];
    copy_arr(source[0], target1[0], 5);
    copy_arr(source[1], target1[1], 5);
    copy_ptr(*source, *target2, 5);
    copy_ptr(*(source + 1), *(target2 + 1), 5);
    return 0;
}

void copy_arr(double source[], double target[], int n)
{
    for (int i = 0; i < n; i++)
        target[i] = source[i];
}

void copy_ptr(double * source, double * target, int n)
{
    while (n--)
        *target++ = *source++;
}
"
164-22504,ColinIanKing/stress-ng,test/test-posix-fallocate.c,31,1,27,1504261.3958938501,171915.0,8.750027629933397,1156.0,1147.0,39247.0,13030.0,1598.0,585.0,1341.0,544.0,1500000000,0.0010028409305959,1082014363648.0,0.0133961550766367,0.0778162480632018,"/*
 * Copyright (C) 2013-2021 Canonical, Ltd.
 * Copyright (C)      2022 Colin Ian King
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 */

#include <unistd.h>
#include <fcntl.h>

int main(void)
{
	static const char filename[] = ""/tmp/test-msync.tmp"";
	int fd, ret;

	fd = open(filename, O_RDWR | O_CREAT, 0666);
	if (fd < 0)
		return 1;
	(void)unlink(filename);

	ret = posix_fallocate(fd, 4096, 512);
	(void)close(fd);

	return ret;
}
"
312-4052,ztuowen/chill-dev,Manual/test-cases/examples/chill/jacobi2.c,12,3,14,1478853.0534132002,169083.0,8.746313940490765,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0009859020356088,1082014363648.0,0.0134490161636592,0.0785049652044725,"#define N 512

int main() {
	double a[N];
	double b[N];
	int t, i;
	for (t = 1; t <= 100; t++) {
		for (i = 2; i <= N - 1; i++)
			b[i] = (double) 0.25 * (a[i - 1] + a[i + 1]) + (double) 0.5 * a[i];

		for (i = 2; i <= N - 1; i++)
			a[i] = b[i];
	}
	return 0;
}
"
076-1255,totalspectrum/binutils-propeller,gdb/testsuite/gdb.threads/execl1.c,19,1,19,1323228.00345705,169083.0,7.825907986018701,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0008821520023047,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2008-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* Test handling thread control across an execl.  */

/* New exec image that doesn't load any thread library.  */

int
main (int argc, char* argv[])
{
  return 0;
}
"
199-1286,rhuitl/uClinux,user/threaddemos/thdm.c,24,6,19,1508924921.9745398,5866158.0,257.2254141467039,2310.0,1802.0,1783373.0,457918.0,2248.0,1010.0,1638.0,902.0,1500000000,1.0059499479830265,1082014363648.0,0.0007009698681828,0.0025869019239358,"#include <stdio.h>
#include <unistd.h>
#include <pthread.h>

#define THREADS 4
#define LOOPTIME 1

pthread_t t[THREADS];
int cnt[THREADS];
int loop;

void* thread_code(void* arg) {
  int idx = (int)arg;
  while(loop) {
    cnt[idx]++;
    sched_yield();
  };
  pthread_exit(0);
  return 0;
};

int main(int argc, char* argv[]) {
  int i;
#ifdef FSUTHREADS
  pthread_init();
#endif

  for(i=0;i<THREADS;i++) cnt[i]=0;

  loop=1;
  for(i=0;i<THREADS;i++) pthread_create(&t[i],0,thread_code,(void*)i);

  for(i=0;i<LOOPTIME;i++) sleep(1);

  loop=0;
  for(i=0;i<THREADS;i++) pthread_join(t[i],0);

  for(i=0;i<THREADS;i++) printf(""thread %i runs: %i\n"",i,cnt[i]/LOOPTIME);

  return 0;
};
"
084-2085,anishkshah/eopi,data_struct/quick_sort.c,81,6,59,2488084.4866855503,204943.0,12.140370737229375,1377.0,1355.0,46212.0,18141.0,1630.0,640.0,1350.0,595.0,1500000000,0.0016587229911237,1082014363648.0,0.0133305358075172,0.0654981119761316,"/*
 * 	Quicksort has a reputation as the fastest sort. One often contrasts quicksort with merge sort,
 *  because both sorts have an average time of O(nlog n).
 *  
 *  ""On average, mergesort does fewer comparisons than quicksort, so it may be better when 
 *  complicated comparison routines are used. Mergesort also takes advantage of pre-existing order,
 *  so it would be favored for using sort() to merge several sorted arrays.
 *  On the other hand, quicksort is often faster for small arrays, and on arrays of a few distinct values,
 *  repeated many times."" — http://perldoc.perl.org/sort.html
 *  Quicksort is at one end of the spectrum of divide-and-conquer algorithms, with merge sort at the opposite end.
 *  Quicksort is a conquer-then-divide algorithm, which does most of the work during the partitioning and the recursive calls.
 *  The subsequent reassembly of the sorted partitions involves trivial effort.
 *  Merge sort is a divide-then-conquer algorithm. The partioning happens in a trivial way, by splitting 
 *  the input array in half. Most of the work happens during the recursive calls and the merge phase.
 */

#include <stdlib.h>
#include <stdio.h>
#include <assert.h>

void print_array(int *elements, int size, char *info)
{
	int iter = 0;
	printf(""%s : "", info);
	for(iter = 0; iter < size; iter++) {
		printf(""%d "", elements[iter]);
	}
	printf(""\n"");
	return;
}

void swap(int *a, int *b)
{
	int temp = *b;
	*b = *a;
	*a = temp; 
}

/* Returns the piovot element which is in the correct position */
int partion(int *elements, int low , int high)
{
	int l = low + 1;
	int h =  high;
	int pivot = low;

	while(h > l) {
		while(elements[l] <= elements[pivot]) {
			if(l == high) break;
			l++;
		}
		while(elements[h] >= elements[pivot]) {
			if(h == low) break;
			h--;
		}
		if(elements[l] >= elements[h] && l < h) {
			swap(&elements[l], &elements[h]);
		}
	}
	/* swap pivot elemet to its correct position the h*/
	if(elements[low] > elements[h])
	{
		swap(&elements[low], &elements[h]);
	}
	return h;
}

void quick_sort(int *elements, int low, int high)
{
	int pivot = 0;
	if(high < low)  return;
	pivot =  partion(elements, low, high);
	quick_sort(elements, low , pivot-1);
	quick_sort(elements, pivot+1, high);
}


int main()
{
	int test1[7] = {4, 5, 1, 8, 9, 0, 1};
	int test2[7] = {1, 1, 1, 2, 2, 0, 1};
	int test3[7] = {4, 0, -1, -8, -9, 0, 1};

	print_array(test1, 7, ""Before"");
	quick_sort(test1, 0, 6);
	print_array(test1, 7, ""After"");

	print_array(test2, 7, ""Before"");
	quick_sort(test2, 0, 6);
	print_array(test2, 7, ""After"");

	print_array(test3, 7, ""Before"");
	quick_sort(test3, 0, 6);
	print_array(test3, 7, ""After"");

	return 0;
}"
225-15006,AllenDowney/ExercisesInC,exercises/ex05/find_track_oo.c,59,2,52,2243989.4964918,169061.0,13.273250483553271,1140.0,1130.0,38452.0,12696.0,1568.0,588.0,1317.0,547.0,1500000000,0.0014959929976612,1082014363648.0,0.0134271061924394,0.0785954485023852,"/* Example code for Exercises in C.

Modified version of an example from Chapter 2.5 of Head First C.

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <regex.h>

#define NUM_TRACKS 5

char tracks[][80] = {
    ""So What"",
    ""Freddie Freeloader"",
    ""Blue in Green"",
    ""All Blues"",
    ""Flamenco Sketches""
};


typedef regex_t Regex;


/* Returns a new Regex that matches the given pattern.
*
* pattern: string regex
* flags: flags passed to regcomp
* returns: new Regex
*/
Regex *make_regex(char *pattern, int flags) {
    // FILL THIS IN!
    return NULL;
}

/* Checks whether a regex matches a string.
*
* regex: Regex pointer
* s: string
* returns: 1 if there's a match, 0 otherwise
*/
int regex_match(Regex *regex, char *s) {
    // FILL THIS IN!
    return 0;
}

/* Frees a Regex.
*
* regex: Regex pointer
*/
void regex_free(Regex *regex) {
    // FILL THIS IN!
}


/* Finds all tracks that match the given pattern.
*
* Prints track number and title.
*/
void find_track_regex(char pattern[])
{
    int i;

    Regex *regex = make_regex(pattern, REG_EXTENDED | REG_NOSUB);

    for (i=0; i<NUM_TRACKS; i++) {
        if (regex_match(regex, tracks[i])) {
            printf(""Track %i: '%s'\n"", i, tracks[i]);
        }
    }

    regex_free(regex);
}


int main (int argc, char *argv[])
{
    char *pattern = ""F.*F.*"";
    find_track_regex(pattern);

    return 0;
}
"
146-28170,smileboywtu/The-C-Programming-Language-2nd,Chapter-2/exercise-2-8/right-rotate.c,60,2,43,1512385.5555429,178417.0,8.476686638605067,1341.0,1320.0,40181.0,14067.0,1620.0,646.0,1342.0,601.0,1500000000,0.0010082570370286,1082014363648.0,0.0149144980579204,0.0775881138475151,"#include ""stdio.h""
#include ""stdlib.h""

/**

	right rotate the number.
	1111_1010	rightrot	4 = 1010_1111

*/
#define BIT_BUFFER_SIZE	64

/*  get the bit string. */
char* getbitstr(unsigned x){
	
	int cursor;
	int length;
	char *bits;

	bits = (char*)malloc(BIT_BUFFER_SIZE);	

	length = sizeof(x)*8-1;
	for(cursor=0; cursor<=length; cursor++){

		if(x & (1<<(length-cursor))){
			bits[cursor] = '1';
		}else{
			bits[cursor] = '0';
		}
	}

	bits[cursor] = '\0';

	return bits;
}

/* right rotate */
unsigned rightrot(unsigned x, int n){
	return	(~0<<n | x)<<(sizeof(x)*8-n) | (x>>n); 
}

/* do not rely on sizeof(). */
unsigned rightrot2(unsigned x, int n){
	while(n>0){
		if ((x & 1) == 1)
    	x = (x >> 1) | ~(~0U >> 1);
    else         
	 		x = (x >> 1);
   	n--;	
	}
	return x;
}


int main(){

	unsigned int a, b;
	char* p, *q, *r, *s;

	a = 0x55;
	b = 0x00;
	p = getbitstr(a);
	q = getbitstr(~0);
	r = getbitstr(b);
	s = getbitstr(rightrot(a, 3));

	printf(""the bit string of ~0 is %s.\n"", q);
	printf(""the bit string of a is %s.\n"", p);
	printf(""the bit string of b is %s.\n"", r);
	// test
	printf(""rightrot(a, 3) is: %s.\n"", s);

	free((char*)p);
	free((char*)q);
	free((char*)r);
	free((char*)s);
	p = NULL;
	q = NULL;
	r = NULL;
	s = NULL;
	return 0;
}
	
"
308-10554,EliteTK/c-stuff,intfloatprint.c,14,2,20,2120928.1403571,175534.0,12.08271901739834,1393.0,1373.0,39660.0,13641.0,1624.0,639.0,1343.0,594.0,1500000000,0.0014139520935714,1082014363648.0,0.015757631000262,0.0787977711487589,"/*
 * Copyright (C) 2014  Tomasz Kramkowski <tk@the-tk.com>
 *
 * This program is free software. It is licensed under version 3 of the
 * GNU General Public License.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see [http://www.gnu.org/licenses/].
 */

#include <stdio.h>

int main(int argc, char **argv)
{
        printf(""Int for float: %f, Float for float: %f\n"", 1.0, 1.0);
        return 0;
}
"
120-14020,dyladan/euler,c/9.1.c,17,3,22,390511552.45397234,1334349746.0,0.2926605660702093,1429.0,1405.0,40907.0,14349.0,1634.0,642.0,1352.0,599.0,1500000000,0.2603410349693149,1082014363648.0,2.123880945378469e-06,0.0764984798030983,"#include <stdio.h>
#include <tgmath.h>

int main(int argc, char *argv[]){
  double a,b,c;
  int sum = 1000;
  for(a = 0; a < sum; a++){
    for(b = a + 1; b < sum; b++){
      for(c = b + 1; c < sum; c++){
        if(a + b + c == sum){
          if(pow(a,2) + pow(b,2) == pow(c,2)){
            printf(""%.0f + %.0f + %.0f is a triplet.\n"",a,b,c);
            printf(""The product a*b*c is %.0f\n"", a*b*c);
          }
        }
      }
    }
  }
  return 0;
}
"
079-28474,cr88192/bgbtech_engine2,smalltest/tst_pxt1.c,32,6,23,13683398.95270755,65217618.0,0.2098113733623328,1369.0,1347.0,18535955.0,2605733.0,1873.0,1212.0,1363.0,1080.0,1500000000,0.0091222659684717,1082014363648.0,4.164518857465785e-05,0.0002614739182604,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

typedef unsigned long long u64;
typedef signed long long s64;


int main()
{
	int pxt[4096];
	int pxd[4096];
	int cvx;
	int i, j, k, l;

	for(i=0; i<16; i++)
		for(j=0; j<16; j++)
			for(k=0; k<16; k++)
	{
		l=(i*16+j)*16+k;
		pxt[l]=l;
		pxd[l]=i*i+j*j+k*k;
	}

	for(i=0; i<4096; i++)
		for(j=i+1; j<4096; j++)
	{
		if(pxd[j]<pxd[i])
		{
			k=pxt[i]; pxt[i]=pxt[j]; pxt[j]=k;
			k=pxd[i]; pxd[i]=pxd[j]; pxd[j]=k;
		}
	}

	for(i=0; i<4096; i++)
	{
		if(i && !(i&7))
			printf(""\n"");
		printf(""0x%03X, "", pxt[i]);
	}
}
"
339-17630,socrocket/trap-gen,software/benchmarks/io_less/bcnt.c,89,3,59,2879195.9630325,10539089.0,0.2731920187788527,1151.0,1141.0,4923461.0,1942698.0,1588.0,585.0,1337.0,546.0,1500000000,0.001919463975355,1082014363648.0,0.0002174761025359,0.0005907232850273,"/******* PowerStone Benchmark *******/

#ifdef STATIC_SIZE
unsigned char poptab[] = {0, 1};
unsigned long src[] = {  0x00005678,0x12340000 };
unsigned long dst[2];
#else
volatile unsigned char poptab[256] =
{
    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8,
};

volatile unsigned long src[1024] =
{
    0x00005678,0x12340000,0x02040608,0x00000001,
        0x12345678,0x12345678,0x12345678,0x12345678,
        0x00005678,0x12340000,0x02040608,0x00000001,
        0x12345678,0x12345678,0x12345678,0x12345678,
        0x00005678,0x12340000,0x02040608,0x00000001,
        0x12345678,0x12345678,0x12345678,0x12345678,
        0x00005678,0x12340000,0x02040608,0x00000001,
        0x12345678,0x12345678,0x12345678,0x12345678,
        0x00005678,0x12340000,0x02040608,0x00000001,
        0x12345678,0x12345678,0x12345678,0x12345678,
        0x00005678,0x12340000,0x02040608,0x00000001,
        0x10101010,0x12345678,0x10101010,0x12345678,
        0x00005678,0x12340000,0x02040608,0x00000001,
        0x10101010,0x12345678,0x10101010,0x12345678,
        0x00005678,0x12340000,0x02040608,0x00000001,
        0x10101010,0x12345678,0x10101010,0x12345678,
        0
};

volatile unsigned long dst[1024];
#endif

int main()
{
    #ifdef TSIM_DISABLE_CACHE
    /*Now I can disable the caches*/
    #ifdef LEON3_CACHE
    asm(""sta %g0, [%g0] 2"");
    #else
    asm(""sethi %hi(0xfd800000), %g1"");
    asm(""or %g1,%lo(0xfd800000),%g1"");
    asm(""sethi %hi(0x80000014), %g2"");
    asm(""or %g2,%lo(0x80000014),%g2"");
    asm(""st %g1, [%g2]"");
    #endif
    #endif

    volatile unsigned long   *s, *d;
    volatile unsigned long   x;
    volatile int k, t=0;
    int i = 0;

    #ifdef SHORT_BENCH
    for(i = 0; i < 50; i++){
    #else
    for(i = 0; i < 5000; i++){
    #endif
        t = 0;
        for (s = src, d = dst, t = 0 ; *s ; s += 4, d += 4)
        {       x  = s[0] ^ d[0];
        k  = poptab[x & 0xff];
        k += poptab[(x >>  8) & 0xff];
        k += poptab[(x >> 16) & 0xff];
        k += poptab[x >> 24];
        t += k;
        x  = s[1] ^ d[1];
        k = poptab[x & 0xff];
        k += poptab[(x >>  8) & 0xff];
        k += poptab[(x >> 16) & 0xff];
        k += poptab[x >> 24];
        t += k;
        x  = s[2] ^ d[2];
        k  = poptab[x & 0xff];
        k += poptab[(x >>  8) & 0xff];
        k += poptab[(x >> 16) & 0xff];
        k += poptab[x >> 24];
        t += k;
        x  = s[3] ^ d[3];
        k  = poptab[x & 0xff];
        k += poptab[(x >>  8) & 0xff];
        k += poptab[(x >> 16) & 0xff];
        k += poptab[x >> 24];
        t += k;
        }
    }

    return 0;
}
"
279-23564,epicsdeb/rtems-gdb,gdb/testsuite/gdb.base/step-break.c,24,2,25,1080576180.0147593,9663845478.0,0.1117622569047456,1139.0,1129.0,3221263925.0,2147496345.0,1567.0,588.0,1316.0,547.0,1500000000,0.7203841200098395,1082014363648.0,2.3468918301344558e-07,7.484036905972708e-07,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2008, 2009, 2010, 2011 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

int
main ()
{
    volatile int i = 1;

    while (i > 0) /* place1 */
      {
	i++; /* place2 */
	i++; /* place3, set breakpoint here  */
      }

    return 0;
}
"
287-26959,Siarkowy/CP,Sem1/array_transpose.c,30,7,27,1841853.02350665,200877.0,9.169058677698294,1372.0,1349.0,45507.0,17443.0,1646.0,643.0,1360.0,598.0,1500000000,0.0012279020156711,1082014363648.0,0.0135456025328932,0.0674662430500397,"#include <stdio.h>

#define SIZE 4

void dump_array(int nums[][SIZE])
{
    unsigned i, j;

    for (i = 0; i < SIZE; ++i)
    {
        for (j = 0; j < SIZE; ++j)
            printf("" %5d"", nums[i][j]);

        printf(""\n"");
    }
}

int main()
{
    int nums[SIZE][SIZE], another[SIZE][SIZE];
    unsigned i, j;

    // fill nums
    for (i = 0; i < SIZE; ++i)
        for (j = 0; j < SIZE; ++j)
            nums[i][j] = i * SIZE + j; // can be any other value

    // dump to screen
    printf(""Contents of nums:\n"");
    dump_array(nums);

    // transpose
    for (i = 0; i < SIZE; ++i)
        for (j = 0; j < SIZE; ++j)
            another[j][i] = nums[i][j]; // watch out for order of coordinates!

    // dump transposed
    printf(""\nTransposed array:\n"");
    dump_array(another);

    return 0;
}
"
332-34202,evan886/learn-c,mysrc/pointer/c-.c,24,1,25,1410212.9498496,179675.0,7.848682343119521,1347.0,1329.0,40560.0,14159.0,1628.0,638.0,1347.0,597.0,1500000000,0.0009401419665664,1082014363648.0,0.0148935578127174,0.076938540543504,"#include <stdio.h>
const int MAX = 3;
int main()
{
	int var[] = {10,100,200};
	int i, *ptr;
	/* 指针中最后一个元素的地址 */
	ptr = &var[MAX-1]; 
	for ( i = MAX ;  i>0;  i-- )
  {
	printf(""存储地址：var[%d] = %x \n"", i -1, ptr);
	printf(""存储值：var[%d] = %d \n"", i-1, *ptr);
        
        /* 移动到下一个位置 */
	ptr --;
}
	return 0;
}
/*
存储地址：var[2] = eb45ea88 
存储值：var[2] = 200 
存储地址：var[1] = eb45ea84 
存储值：var[1] = 100 
存储地址：var[0] = eb45ea80 
存储值：var[0] = 10 
*/
"
000-1178,fengbohello/practice,clang/algorithm/select-sort.c,102,6,85,266494347.131811,1435520609.0,0.1856429962267438,1493.0,1465.0,180148937.0,179294665.0,6050095.0,1987.0,1369.0,1670.0,1500000000,0.177662898087874,1082014363648.0,2.0605764775892536e-06,0.0168458166074131,"/*
 * =====================================================================================
 *
 *       Filename:  select-sort.c
 *
 *    Description:  
 *
 *        Version:  1.0
 *        Created:  12/23/2016 04:47:42 PM
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  YOUR NAME (), 
 *   Organization:  
 *
 * =====================================================================================
 */
#include <stdio.h>
#include <stdlib.h>

int icomp = 0;
int iswap = 0;

int cmp_fun(int a, int b) {
    icomp++;
    return a > b;
}

int swap(int * a, int * b) {
    *a = *a ^ *b;
    *b = *a ^ *b;
    *a = *a ^ *b;
    iswap ++;

    return 1;
}

int select_sort(int *pList, int len) {
    if(NULL == pList || len < 0) {
        return -1;
    }
    int i = 0;
    for(i = 0; i < len; i++) {
        int iTop = pList[i];
        int iPos = i;
        int j = 0;
        for(j = i + 1; j < len; j++) {
            if(cmp_fun(iTop, pList[j])) {
                iTop = pList[j];
                iPos = j;
            }
        }
        if(i != iPos) {
            swap(&pList[i], &pList[iPos]);
        }
    }

    return 0;
}

int get_list(int *list, int len) {
    srand(374676);
    int i = 0;
    for(i = 0; i < len; i++) {
        list[i] = rand() % (len * 20);
    }

    return 0;
}

int check_list(int *list, int len) {
    int i;
    int iCnt = 0;
    for(i = 0; i < len - 1; i++) {
        if(cmp_fun(list[i], list[i + 1])) {
            iCnt++;
        }
    }

    return iCnt;
}

void show_list(int *pList, int len) {
    int i = 0;
    for(i = 0; i < len; i++) {
        printf(""%d "", pList[i]);
    }
    printf(""\n"");
}

int test_sort(int n) {
    icomp = 0;
    iswap = 0;
    int *pList = (int*)malloc(sizeof(int) * n);
    get_list(pList, n);
    //show_list(pList, n);
    select_sort(pList, n);
    int iThro = n * (n + 1) / 2;
    printf(""n = %d, tcmp = %d, rcmp = %d, dc = %lf\n"", n, iThro, icomp, (double)icomp / iThro);
    printf(""n = %d, tswp = %d, rswp = %d, ds = %lf\n"", n, n - 1, iswap, (double)iswap / (n - 1));
    int iT = check_list(pList, n);
    if(iT) {
        printf(""sort faild, [%d]\n"", iT);
    }
    //show_list(pList, n);
    free(pList);
    printf(""\n"");

    return 0;
}

int main() {
    int i = 0;
    for(i = 16; i <= 1024 * 16; i *= 2) {
        test_sort(i);
    }

    return 0;
}

"
092-33234,begeekmyfriend/leetcode,0179_largest_number/largest_number.c,42,3,35,1715898.1645479002,179013.0,9.585326205359388,1314.0,1295.0,40768.0,13978.0,1650.0,642.0,1367.0,597.0,1500000000,0.0011439321096986,1082014363648.0,0.0145743605213029,0.0777408395133891,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct object {
    char buf[16];
};

static int compare(const void *o1, const void *o2)
{
    char p1[32] = { '\0' };
    char p2[32] = { '\0' };
    strcat(p1, ((struct object *) o1)->buf);
    strcat(p1, ((struct object *) o2)->buf);
    strcat(p2, ((struct object *) o2)->buf);
    strcat(p2, ((struct object *) o1)->buf);
    return strcmp(p1, p2);
}

static char* largestNumber(int* nums, int numsSize)
{
    int i;
    struct object *objs = malloc(numsSize * sizeof(*objs));
    memset(objs, 0, sizeof(*objs));
    for (i = 0; i < numsSize; i++) {
        sprintf(objs[i].buf, ""%d"", nums[i]);
    }

    qsort(objs, numsSize, sizeof(*objs), compare);
    if (objs[numsSize - 1].buf[0] == '0') {
        return ""0"";
    }

    char *result = malloc(numsSize * 16);
    result[0] = '\0';
    for (i = numsSize - 1; i >= 0; i--) {
        strcat(result, objs[i].buf); 
    }

    return result;
}

int main(int argc, char **argv)
{
    int i, count = argc - 1;
    int *nums = malloc(count * sizeof(int));
    for (i = 0; i < count; i++) {
        nums[i] = atoi(argv[i + 1]);
    }
    printf(""%s\n"", largestNumber(nums, count));
    return 0;
}
"
059-963,ColinIanKing/stress-ng,test/test-atomic_load_double.c,23,1,24,1570262.9461884,170441.0,9.212935854635916,1145.0,1137.0,38726.0,12789.0,1583.0,586.0,1327.0,544.0,1500000000,0.0010468419641256,1082014363648.0,0.0133887972964251,0.0784237600698825,"/*
 * Copyright (C) 2021-2022 Colin Ian King
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

int main(int argc, char **argv)
{
	double val = 0.0, var = 5.0;

	__atomic_load(&var, &val, __ATOMIC_CONSUME);

	return 0;
}
"
098-27452,Mikescher/Project-Euler_Befunge,compiled/C/Euler_Problem-084.c,340,3,188,268669840.414077,1057174983.0,0.2541394228206022,1472.0,1444.0,304853219.0,143595469.0,1729.0,2920.0,1375.0,2836.0,1500000000,0.179113226942718,1082014363648.0,2.758294555670544e-06,1.975699837480626e-05,"/* transpiled with BefunCompile v1.3.0 (c) 2017 */
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#define int64 long long
char* _g = ""v   XX{ }  i{=}  H    v      <     v<{ }  2{?}  H v<<   v<<<|-\""!\"":<|-+98:<{ }  *>040p\"";};}@\""**58*v{ }  -v   _v# -1<  v<10   v 10""
           ""> v    <    <|<{ }  ,v{ }  +<{ }  20    |:+<2?^#*4<2?^#$<{ }  )^<{ }  ->1-:2+0\\1pv{ }  <{^3<    }  \""{ }  +-{ }  ,|:{ }  (<     >""
           "">>v >>>v v<{ }  ){>>>v   }  \"" >>>v{ }  (2{ }  )v $<{ }  /12 v 12 v #^p04<+55$<{01 v   }  \"" 01 v >v     :{ }  )>40g::2+1g1+\\2+1p>""
           ""#^?3>#^?3>++58*%:40p>#^?2>{4*#^?2>+}  \""|>:56*-{|{ }  )}  \""{ }  *>4^v<>4^ #v<{ }  'v<{>3^    }  \"" >3^{ }  2>$58vv{ }  -<v $<|-*94""
           "":<|-+*294:<|-7:  <    v p04+55${<      }  \""   #v *<{  >>>v }  \""^{    <  }  \""      <{ }  D:    ${ 01 v  }  \""#>v{   >v }  \""{  >v }""
           ""  # #{>v   }  #> v{ }  '-    >#^?2>4*#^?2>+ :|>1-:|>1 {-:|>1}  '-:| #{ }  '1>1-::2v>3^    >3^   >55+v>56 +v>64*v>\""'\""v>5v  >0v  v""
           ""    <    v    >40g3-   v |:p2+ <>::1+2g2+1g\\ 2+2g 2+1 g \\`{ }  9v>v{ }  '#  >62*v >$v    ^_v#:<-1p2\\g 05+2 :-1 p 2+2\\ g2+1 :: p ""
           ""05 g    2+2:_^#>40g492*+-|{ }  '>0>:58* \\`|  >$22 g.32 g.4 2 g.@{ }  1>40g6%1+2/2*5*5+v$  >74*v     ^+1  <  >#<^#{ }  '># {   >#""
           ""}  # >#   >#{ }  )#<      >{ }  'v^<{ }  2{<{ }  (}  \""{ }  -<{ }  1<  $p04<"";
int t=0;int z=0;
int64 g[1540];
int d(){int s,w,i,j,h;h=z;for(;t<1099;t++)if(_g[t]==';')g[z++]=_g[++t];else if(_g[t]=='}')return z-h;else if(_g[t]=='{'){t++;s=z;w=d();for(i=1;i<_g[t+1]*9025+_g[t+2]*95+_g[t+3]-291872;i++)for(j=0;j<w;g[z++]=g[s+j++]);t+=3;}else g[z++]=_g[t];return z-h;}
int64 gr(int64 x,int64 y){if(x>=0&&y>=0&&x<77&&y<20){return g[y*77+x];}else{return 0;}}
void gw(int64 x,int64 y,int64 v){if(x>=0&&y>=0&&x<77&&y<20){g[y*77+x]=v;}}
int rd(){return rand()%2==0;}
int64 td(int64 a,int64 b){ return (b==0)?0:(a/b); }
int64 tm(int64 a,int64 b){ return (b==0)?0:(a%b); }
int64*s;int q=16384;int y=0;
int64 sp(){if(!y)return 0;return s[--y];}
void sa(int64 v){if(q-y<8)s=(int64*)realloc(s,(q*=2)*sizeof(int64));s[y++]=v;}
int64 sr(){if(!y)return 0;return s[y-1];}
int main(void)
{
    int64 t0,t1,t2;
    d();
    srand(time(NULL));
    s=(int64*)calloc(q,sizeof(int64));
    gw(4,0,0);
    gw(41,1,0);
    sa(1000000);
    sa(39);
    sa(39);
_1:
    if(sp()!=0)goto _98;else goto _2;
_2:
    sp();
_3:
    sa(gr(4,0));
    gw(gr(4,0)+2,1,gr(gr(4,0)+2,1)+1);
    if(rd()){if(rd()){goto _97;}else{goto _96;}}else{if(rd()){goto _95;}else{goto _5;}}
_5:
    sa(2);
_6:
    if(rd()){if(rd()){goto _94;}else{goto _93;}}else{if(rd()){goto _92;}else{goto _7;}}
_7:
    sa(sp()+3LL);
_8:
    sa(sp()+sp());

    sa(sp()%40LL);

    sa(sr());
    gw(4,0,sp());
    if(rd()){if(rd()){goto _91;}else{goto _90;}}else{if(rd()){goto _89;}else{goto _10;}}
_10:
    sa(8);
_11:
    if(rd()){if(rd()){goto _88;}else{goto _87;}}else{if(rd()){goto _86;}else{goto _12;}}
_12:
    sa(sp()+2LL);
_13:
    sa(sp()*4LL);
    if(rd()){if(rd()){goto _85;}else{goto _84;}}else{if(rd()){goto _83;}else{goto _15;}}
_15:
    sa(sp()+2LL);
_16:
    if(sp()!=0)goto _29;else goto _17;
_17:
    gw(4,0,10);
    sp();
_18:
    sa(sp()-1LL);

    sa(sr());

    if(sp()!=0)goto _3;else goto _19;
_19:
    gw(41,2,39);
    sp();
    sa(39);
    sa(39);
_20:
    if(sp()!=0)goto _28;else goto _21;
_21:
    sp();
    sa(0);
    sa(1);
_22:
    if(sp()!=0)goto _23;else goto _27;
_23:
    sa(sr());

    if(sp()!=0)goto _24;else goto _26;
_24:
    sa(sr());
    t0=gr(gr(sr()+1,2)+2,1);
    sa(sp()+2LL);

    sa(2);
    {int64 v0=sp();sa(gr(sp(),v0));}
    sa(sp()+2LL);

    sa(1);
    {int64 v0=sp();t1=gr(sp(),v0);}
    t2=t0<t1?1:0;

    if((t2)!=0)goto _25;else goto _26;
_25:
    gw(5,0,gr(sr()+2,2));
    sa(sr());
    sa(gr(sr()+1,2));
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    sa(sp()+2LL);

    sa(2);
    {int64 v0=sp();int64 v1=sp();gw(v1,v0,sp());}
    sa(sp()-1LL);

    sa(sr()+2);
    sa(gr(5,0));
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    sa(2);
    {int64 v0=sp();int64 v1=sp();gw(v1,v0,sp());}
    sa(sp()-1LL);
    goto _23;
_26:
    sa(sp()+1LL);

    sa(sr()<40?1:0);
    goto _22;
_27:
    printf(""%lld "", gr(2,2));
    printf(""%lld "", gr(3,2));
    printf(""%lld "", gr(4,2));
    sp();
    return 0;
_28:
    sa(sp()-1LL);

    sa(sr());
    sa(sr()+2);
    sa(2);
    {int64 v0=sp();int64 v1=sp();gw(v1,v0,sp());}
    sa(sr());
    goto _20;
_29:
    if(sr()!=30)goto _30;else goto _17;
_30:
    if(sr()!=2)goto _45;else goto _31;
_31:
    sp();
    if(rd()){if(rd()){goto _44;}else{goto _43;}}else{if(rd()){goto _42;}else{goto _33;}}
_33:
    sa(8);
_34:
    if(rd()){if(rd()){goto _41;}else{goto _40;}}else{if(rd()){goto _39;}else{goto _35;}}
_35:
    sa(sp()+2LL);
_36:
    sa(sr());

    if(sp()!=0)goto _37;else goto _17;
_37:
    sa(sp()-1LL);


    if(sp()!=0)goto _18;else goto _38;
_38:
    gw(4,0,0);
    goto _18;
_39:
    sa(sp()+1LL);
    goto _36;
_40:
    sa(sp()+0LL);
    goto _36;
_41:
    sa(sp()+3LL);
    goto _36;
_42:
    sa(4);
    goto _34;
_43:
    sa(0);
    goto _34;
_44:
    sa(12);
    goto _34;
_45:
    if(sr()!=17)goto _46;else goto _31;
_46:
    if(sr()!=33)goto _47;else goto _31;
_47:
    if(sr()!=7)goto _81;else goto _48;
_48:
    sp();
    if(rd()){if(rd()){goto _80;}else{goto _79;}}else{if(rd()){goto _78;}else{goto _50;}}
_50:
    sa(8);
_51:
    if(rd()){if(rd()){goto _77;}else{goto _76;}}else{if(rd()){goto _75;}else{goto _52;}}
_52:
    sa(sp()+2LL);
_53:
    sa(sr());

    if(sp()!=0)goto _54;else goto _74;
_54:
    sa(sp()-1LL);

    sa(sr());

    if(sp()!=0)goto _55;else goto _73;
_55:
    sa(sp()-1LL);

    sa(sr());

    if(sp()!=0)goto _56;else goto _72;
_56:
    sa(sp()-1LL);

    sa(sr());

    if(sp()!=0)goto _57;else goto _71;
_57:
    sa(sp()-1LL);

    sa(sr());

    if(sp()!=0)goto _58;else goto _70;
_58:
    sa(sp()-1LL);

    sa(sr());

    if(sp()!=0)goto _59;else goto _69;
_59:
    sa(sp()-1LL);

    sa(sr());

    if(sp()!=0)goto _60;else goto _68;
_60:
    sa(sp()-1LL);

    sa(sr());

    if(sp()!=0)goto _61;else goto _68;
_61:
    sa(sp()-1LL);

    sa(sr());

    if(sp()!=0)goto _62;else goto _65;
_62:
    sa(sp()-1LL);

    sa(sr());

    if(sp()!=0)goto _63;else goto _64;
_63:
    sp();
    goto _18;
_64:
    gw(4,0,gr(4,0)-3);
    goto _63;
_65:
    if(gr(4,0)!=22)goto _66;else goto _67;
_66:
    gw(4,0,12);
    goto _63;
_67:
    gw(4,0,28);
    goto _63;
_68:
    gw(4,0,(10*(((gr(4,0)%6)+1)/2))+5);
    goto _63;
_69:
    gw(4,0,0);
    goto _63;
_70:
    gw(4,0,5);
    goto _63;
_71:
    gw(4,0,39);
    goto _63;
_72:
    gw(4,0,24);
    goto _63;
_73:
    gw(4,0,11);
    goto _63;
_74:
    gw(4,0,10);
    goto _63;
_75:
    sa(sp()+1LL);
    goto _53;
_76:
    sa(sp()+3LL);
    goto _53;
_77:
    sa(sp()+0LL);
    goto _53;
_78:
    sa(4);
    goto _51;
_79:
    sa(12);
    goto _51;
_80:
    sa(0);
    goto _51;
_81:
    if(sr()!=22)goto _82;else goto _48;
_82:
    if(sr()!=36)goto _63;else goto _48;
_83:
    sa(sp()+1LL);
    goto _16;
_84:
    sa(sp()+3LL);
    goto _16;
_85:
    sa(sp()+0LL);
    goto _16;
_86:
    sa(sp()+1LL);
    goto _13;
_87:
    sa(sp()+3LL);
    goto _13;
_88:
    sa(sp()+0LL);
    goto _13;
_89:
    sa(4);
    goto _11;
_90:
    sa(12);
    goto _11;
_91:
    sa(0);
    goto _11;
_92:
    sa(sp()+2LL);
    goto _8;
_93:
    sa(sp()+4LL);
    goto _8;
_94:
    sa(sp()+1LL);
    goto _8;
_95:
    sa(3);
    goto _6;
_96:
    sa(4);
    goto _6;
_97:
    sa(1);
    goto _6;
_98:
    sa(sp()-1LL);

    sa(sr()+2);
    sa(0);
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    sa(1);
    {int64 v0=sp();int64 v1=sp();gw(v1,v0,sp());}
    sa(sr());
    goto _1;
}
"
098-33307,asheemchhetri/C-programming,programs/ch1/q34.c,14,1,21,1503318.0825410997,174962.0,8.592254318080498,1306.0,1288.0,39611.0,13638.0,1616.0,636.0,1339.0,593.0,1500000000,0.0010022120550274,1082014363648.0,0.0148260765194728,0.0785742455257375,"/* Program solution for question 34, from the book.
*  Author: Asheem Chhetri
*  Date: Aug 11, 2015
*  Change log:
*  <Date>: Change description
*/

#define STAR '*'
#include <stdio.h>
#include <stdlib.h>

int main(int argc,char **argv)
{
	printf(""%c\n"",STAR);
	printf(""%c%c\n"",STAR,STAR);
	printf(""%c%c%c\n"",STAR,STAR,STAR);
	printf(""%c%c%c%c\n"",STAR,STAR,STAR,STAR);
	return 0;
}
"
195-2756,selmentdev/selment-toolchain,source/gcc-latest/gcc/testsuite/gcc.dg/tree-ssa/vrp90.c,32,1,26,1438106.8758666,169115.0,8.50371640599592,1142.0,1132.0,38461.0,12697.0,1568.0,585.0,1317.0,546.0,1500000000,0.0009587379172444,1082014363648.0,0.013446471336073,0.0785018960866335,"/* { dg-do link } */
/* { dg-options ""-O2 -fdump-tree-vrp1"" } */
/* { dg-final { scan-tree-dump-not ""link_error"" ""vrp1""} } */

extern void link_error (void);

__attribute__((noinline, noclone)) int
foo (unsigned int n, int r)
{
  int i;
  if (n > 0)
    {
      asm ("""");
      if (n < 10)
	{
	  asm ("""");
	  do
	    {
	      --n;
	      r *= 2;
	      if (n >= 9)
		link_error ();
	    }
	  while (n > 0);
	}
    }
  return r + n;
}

int
main ()
{
  foo (7, 2);
  return 0;
}
"
136-11015,ensc/dietlibc,test/stdlib/tst-environ.c,143,1,96,1468007.9184472498,211374.0,6.945068929953542,1328.0,1305.0,47544.0,14886.0,1716.0,651.0,1372.0,606.0,1500000000,0.0009786719456315,1082014363648.0,0.0124565935261668,0.0695979497036681,"/* Copyright (C) 1999 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#define VAR ""FOOBAR""

char putenv_val[100] = VAR ""=some longer value"";

int
main (void)
{
  int result = 0;
  const char *valp;

  /* First test: remove entry FOOBAR, whether it exists or not.  */
  unsetenv (VAR);

  /* Now getting the value should fail.  */
  if (getenv (VAR) != NULL)
    {
      printf (""There should be no `%s' value\n"", VAR);
      result = 1;
    }

  /* Now add a value, with the replace flag cleared.  */
  if (setenv (VAR, ""one"", 0) != 0)
    {
      printf (""setenv #1 failed: %m\n"");
      result = 1;
    }

  /* Getting this value should now be possible.  */
  valp = getenv (VAR);
  if (valp == NULL || strcmp (valp, ""one"") != 0)
    {
      puts (""getenv #2 failed"");
      result = 1;
    }

  /* Try to replace without the replace flag set.  This should fail.  */
  if (setenv (VAR, ""two"", 0) != 0)
    {
      printf (""setenv #2 failed: %m\n"");
      result = 1;
    }

  /* The value shouldn't have changed.  */
  valp = getenv (VAR);
  if (valp == NULL || strcmp (valp, ""one"") != 0)
    {
      puts (""getenv #3 failed"");
      result = 1;
    }

  /* Now replace the value using putenv.  */
  if (putenv (putenv_val) != 0)
    {
      printf (""putenv #1 failed: %m\n"");
      result = 1;
    }

  /* The value should have changed now.  */
  valp = getenv (VAR);
  if (valp == NULL || strcmp (valp, ""some longer value"") != 0)
    {
      printf (""getenv #4 failed (is \""%s\"")\n"", valp);
      result = 1;
    }

  /* Now one tricky check: changing the variable passed in putenv should
     change the environment.  */
  strcpy (&putenv_val[sizeof VAR], ""a short one"");

  /* The value should have changed again.  */
  valp = getenv (VAR);
  if (valp == NULL || strcmp (valp, ""a short one"") != 0)
    {
      puts (""getenv #5 failed"");
      result = 1;
    }

  /* It should even be possible to rename the variable.  */
  strcpy (putenv_val, ""XYZZY=some other value"");

  /* Now a lookup using the old name should fail.  */
  if (getenv (VAR) != NULL)
    {
      puts (""getenv #6 failed"");
      result = 1;
    }

  /* But using the new name it should work.  */
  valp = getenv (""XYZZY"");
  if (valp == NULL || strcmp (valp, ""some other value"") != 0)
    {
      puts (""getenv #7 failed"");
      result = 1;
    }

  /* Create a new variable with the old name.  */
  if (setenv (VAR, ""a new value"", 0) != 0)
    {
      printf (""setenv #3 failed: %m\n"");
      result = 1;
    }

  /* At this point a getenv call must return the new value.  */
  valp = getenv (VAR);
  if (valp == NULL || strcmp (valp, ""a new value"") != 0)
    {
      puts (""getenv #8 failed"");
      result = 1;
    }

  /* Black magic: rename the variable we added using putenv back.  */
  strcpy (putenv_val, VAR ""=old name new value"");

  /* This is interesting.  We have two variables with the same name.
     Getting a value should return one of them.  */
  valp = getenv (VAR);
  if (valp == NULL
      || (strcmp (valp, ""a new value"") != 0
	  && strcmp (valp, ""old name new value"") != 0))
    {
      puts (""getenv #9 failed"");
      result = 1;
    }

  /* More fun ahead: we are now removing the variable.  This should remove
     both values.  The cast is ok: this call should never put the string
     in the environment and it should never modify it.  */
  putenv ((char *) VAR);

  /* Getting the value should now fail.  */
  if (getenv (VAR) != NULL)
    {
      printf (""getenv #10 failed (\""%s\"" found)\n"", getenv (VAR));
      result = 1;
    }

  /* Now a test with an environment variable that's one character long.
     This is to test a special case in the getenv implementation.  */
  strcpy (putenv_val, ""X=one character test"");
  if (putenv (putenv_val) != 0)
    {
      printf (""putenv #2 failed: %m\n"");
      result = 1;
    }

  valp = getenv (""X"");
  if (valp == NULL || strcmp (valp, ""one character test"") != 0)
    {
      puts (""getenv #11 failed"");
      result = 1;
    }

  return result;
}
"
111-10727,fergul/Cache,src/lftocr.c,55,1,48,2218023.05895825,176173.0,12.590027983856777,1291.0,1269.0,40054.0,13661.0,1637.0,636.0,1349.0,593.0,1500000000,0.0014786820393055,1082014363648.0,0.0145311710648056,0.0784697012007819,"/*
 * Copyright (c) 2016, University of Oregon
 * All rights reserved.

 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * - Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * - Neither the name of the University of Glasgow nor the names of its
 *   contributors may be used to endorse or promote products derived from this
 *   software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * reads file specified as an argument (or stdin if not specified),
 * removes occurrences of \r
 * converts occurrences of \n to \r
 */
#include <stdio.h>

int main(int argc, char *argv[]) {
   int c;
   FILE *fd;

   if (argc > 2) {
      fprintf(stderr, ""usage: %s [file]\n"", argv[0]);
      return -1;
   }
   if (argc == 1)
      fd = stdin;
   else if (! (fd = fopen(argv[1], ""r""))) {
      fprintf(stderr, ""%s: unable to open file %s\n"", argv[0], argv[1]);
      return -2;
   }
   while ((c = fgetc(fd)) != EOF)
      if (c == '\r')
         continue;
      else if (c == '\n')
         fputc('\r', stdout);
      else
         fputc(c, stdout);
   return 0;
}
"
237-16682,ILyoan/gdb,gdb/testsuite/gdb.threads/manythreads.c,48,5,31,11621932556.969114,543319304.0,21.390612242998824,1603.0,1536.0,140714246.0,92499909.0,5586699.0,8200970.0,1632.0,9805.0,1500000000,7.747955037979409,1082014363648.0,5.777449792212794e-06,0.0591692472525949,"/* Manythreads test program.
   Copyright 2004, 2006-2012 Free Software Foundation, Inc.

   Written by Jeff Johnston <jjohnstn@redhat.com> 
   Contributed by Red Hat

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <pthread.h>
#include <stdio.h>
#include <limits.h>

void *
thread_function (void *arg)
{
  int x = * (int *) arg;

  printf (""Thread <%d> executing\n"", x);

  return NULL;
}

int 
main (int argc, char **argv)
{
  pthread_attr_t attr;
  pthread_t threads[256];
  int args[256];
  int i, j;

  pthread_attr_init (&attr);

#ifdef PTHREAD_STACK_MIN
  pthread_attr_setstacksize (&attr, 2*PTHREAD_STACK_MIN);
#endif

  /* Create a ton of quick-executing threads, then wait for them to
     complete.  */
  for (i = 0; i < 1000; ++i) 
    {
      for (j = 0; j < 256; ++j)
	{
	  args[j] = i * 1000 + j;
	  pthread_create (&threads[j], &attr, thread_function, &args[j]);
	}

      for (j = 0; j < 256; ++j)
	{
	  pthread_join (threads[j], NULL);
	}
    }

  pthread_attr_destroy (&attr);

  return 0;
}
"
393-24370,bright-tools/ccsm,test/src/paths.c,482,15,187,3207876.2305898997,169083.0,18.972197086637923,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0021385841537266,1082014363648.0,0.0134490161636592,0.0785049652044725,"
void path_001_expected_1(void) {
}

void path_002_expected_2(int a) {
    if (a) {
        // a = true
    }
}

void path_003_expected_4(int a, int b) {
    if (a) {
        // a = true
    }
    //
    if (b) {
        // b = true
    }
}

void path_004_expected_3(int a, int b) {
    if (a) {
        // a = true
        return;
    }
    //
    if (b) {
        // b = true
    }
}

void path_005_expected_4(int a, int b) {
    if (a) {
        // a = true
    }
    //
    if (b) {
        // b = true
        return;
    }
}

void path_006_expected_5(int a, int b, int c) {
    if (a) {
        // a = true
        return;
    }
    //
    if (b) {
        // b = true
    }
    //
    if (c) {
        // c = true
    }
}

// ab, !ab,  a!bc, a!b!c,  !a!bc, !a!b!c
void path_007_expected_6(int a, int b, int c) {
    if (a) {
        // a = true
    }
    //
    if (b) {
        // b = true
        return;
    }
    //
    if (c) {
        // c = true
    }
}

void path_008_expected_8(int a, int b, int c) {
    if (a) {
        // a = true
    }
    //
    if (b) {
        // b = true
    }
    //
    if (c) {
        // c = true
        return;
    }
}

void path_009_expected_4(int a, int b, int c) {
    if (a) {
        // a = true
    }
    //
    else if (b) {
        // b = true
    }
    //
    else if (c) {
        // c = true
    }
}

void path_010_expected_3(int a) {
    switch (a) {
        case 0:
            break;
        case 1:
            break;
    }
}

void path_011_expected_6(int a, int b) {
    switch (a) {
        case 0:
            break;
        case 1:
            break;
    }
    if (b) {
        // b = true
    }
}

void path_012_expected_5(int a, int b) {
    switch (a) {
        case 0:
            return;
        case 1:
            break;
    }
    if (b) {
        // b = true
    }
}

void path_013_expected_5(int a, int b) {
    while (a) {
        if (b == 1) {
            return;
        }
        if (b == 2) {
            return;
        }
        if (b == 3) {
            return;
        }
        a--;
    }
}

void path_014_expected_4(int a, int b, int c) {
    if (a) {
        return;
    } else {
        if (b) {
            return;
        } else {
            if (c) {
                // c = true
            } else {
                // c = false
            }
        }
    }
}

void path_015_expected_3(int a, int b, int c) {
    int i;
    for (i = 0; i < 10; i++) {
        if (i > 5) {
            return;
        }
    }
}

void path_016_expected_8(int a, int b) {
    switch (a) {
        case 0:
            if (a > 0) {
                return;
            }
            break;
        case 1:
            if (a > 10) {
                return;
            }
            break;
        default:
            break;
    }
    if (b) {
        // b = true
    }
}

void path_017_expected_5(int a, int b) {
    switch (a) {
        case 0:
            return;
        case 1:
            if (a > 10) {
                return;
            }
            break;
        case 2:
            return;
        default:
            break;
    }
}

void path_018_expected_7(int a, int b) {
    switch (a) {
        case 0:
            return;
        case 1:
            if (a > 10) {
                return;
            }
            break;
        case 2:
            return;
        default:
            break;
    }

    if (b) {
        // b = true
    }
}

void path_019_expected_4(int a, int b) {
    if (a > 10) {
        while (a) {
            if (b == 1) {
                break;
            }
        }
    }
}

void path_020_expected_7(int a, int b) {
    if (a > 10) {
        while (a) {
            if (b == 1) {
                continue;
            }
            if (b == 2) {
                continue;
            }
            if (b == 3) {
                continue;
            }

            if (b == 2) {
                break;
            }

            return;
        }
    }
}

void path_021_expected_7(int a, int b) {
    while (b) {
        switch (a) {
            case 0:
                return;
            case 1:
                switch (a) {
                    case 0:
                        return;
                    default:
                        break;
                }
                break;
            default:
                break;
        }
        if (b > 0) {
            b--;
        }
    }
}

void path_022_expected_10(int a, int b) {
    switch (a) {
        case 0:
            if (b)
                break;
            break;
        case 1:
            if (b)
                break;
            break;
        default:
            break;
    }
    if (b > 0) {
        b--;
    }
}

void path_023_expected_3(int a, int b, int c) {
    switch (a) {
        case 0:
            if (b) {
            }
            break;
    }
}

void path_024_expected_5(int a, int b, int c) {
    switch (a) {
        case 0:
            if (b) {
            }
            if (c) {
            }
            break;
        case 1:
        default:
            break;
    }
}

void path_025_expected_5(int a, int b, int c) {
    switch (a) {
        case 0: {
            if (b) {
            }
            if (c) {
            }
            break;
        }
        default:
            break;
    }
}

void path_026_expected_9(int a, int b, int c) {
    switch (a) {
        case 0:
            return;
        case 1:
            return;
        case 2:
            return;
        case 3:
            return;
        case 4:
            return;
        default:
            break;
    }
    if (b) {

    } else {
    }
    if (c) {

    } else {
    }
}

void path_027_expected_24(int a, int b, int c) {
    switch (a) {
        case 0:
            break;
        case 1:
            break;
        case 2:
            break;
        case 3:
            break;
        case 4:
            break;
        default:
            break;
    }
    if (b) {

    } else {
    }
    if (c) {

    } else {
    }
}

int path_028_expected_2(int y) {
    int x;
    for (x = 0; x < y; x++)
        ;
    /* Summary: path count = 2 (1 + for body) */
    return x;
}

int path_029_expected_2(int y) {
    int x;
    while (++x < y)
        ;
    /* Summary: path count = 2 (1 + while body) */
    return x;
}

int path_030_expected_6(int y) {
    int x = 0;
    switch (y) {
        case 10:
        case 9:
        case 0:
            x = 1;
        /* Fall-thru */
        case 1:
            if (y) {
            }
            x++;
            break;
        case 2:
            x = 17;
    }
    /* Summary: path count = 6 (3 different cases, two (due to fall-through)
     * with conditions + implicit default) */

    return x;
}

int path_031_expected_1(int y) {
    int x = 0;
    switch (y)
        ;
    /* Summary: path count = 1 */

    return x;
}

int path_032_expected_1(int y) {
    int x = 0;
    switch (y)
        x++;
    /* Summary: path count = 1 */

    return x;
}

/* TODO: This function doesn't give the expected test result */
int path_033_expected_2(int y) {
    int x = 0;
    switch (y)
    case 0:
        x++;

    /* Summary: path count = 2 (1 case + implicit default) */

    return x;
}

int path_034_expected_2(int y) {
    int x = y;
    if (x) {
        /* Block 1, path count: 1 */
    } else {
        /* Block 2, path count: 1 */
    }
    /* Summary: path count = 2 (Block 1 + Block 2) */

    return x;

    /* This code is inaccessible, so should not be counted */
    if (x) {
    } else {
    }
}

int path_035_expected_2(int y) {
    int x;
    for (x = 0; x < y; x++) {
        /* Block 1, path count: 1 */
        continue;

        /* This code is inaccessible, so should not be counted */
        if (x) {
        } else {
        }
    }
    /* Summary: path count = 2 ( Function body + Block 1) */

    return x;
}

int path_036_expected_2(int y) {
    int x;
    for (x = 0; x < y; x++) {
        /* Block 1, path count: 1 */
        break;

        /* This code is inaccessible, so should not be counted */
        if (x) {
        } else {
        }
    }
    /* Summary: path count = 2 ( Function body + Block 1) */

    return x;
}

#define NEST_MACRO(x, y, z)                                                    \
    do {                                                                       \
        if (x) {                                                               \
            if (y) {                                                           \
                z = 0;                                                         \
            }                                                                  \
        }                                                                      \
    } while (0)

int path_037_expected_3(int y) {
    unsigned x = 0;

    NEST_MACRO(1, 5, x);
    return x;
}

void path_038_expected_1(int y) {
    do {
        y++;
    } while (0);
}

void path_039_expected_1(int y) {
    while (0) {
        y++;
    }
}

void path_040_expected_1(int y) {
    do {
        y++;
    } while (1 - 1);
}

int main(int argc, char **argv) {
    return 0;
}
"
134-31079,acarno/slicer,valgrind/drd/tests/memory_allocation.c,28,3,24,10283466.0792723,76973019.0,0.1335983196917351,1259.0,1242.0,17039208.0,10113243.0,1597.0,637.0,1329.0,594.0,1500000000,0.0068556440528482,1082014363648.0,3.2491904728330845e-05,0.0001530985176991,"/**
 * @brief Repeatedly allocate and free memory. Tests whether drd really frees
 *        memory allocated by a client. See also
 *        http://bugs.kde.org/show_bug.cgi?id=161036.
 */

#include <assert.h>
#include <stdlib.h>

int main()
{
  int i;
  void* p;

  for (i = 0; i < 100000; i++)
    free(malloc(40960));

  for (i = 0; i < 100000; i++)
  {
    p = realloc(NULL, 40960);
    p = realloc(p, 50000);
    p = realloc(p, 40000);
    p = realloc(p, 0);
    /*
     * glibc returns a NULL pointer when the size argument passed to realloc()
     * is zero, while Darwin's C library returns a non-NULL pointer. Both are
     * allowed by POSIX.
     */
#if defined(VGO_darwin)
    if (p)
      free(p);
#else
    assert(! p);
#endif
  }

  return 0;
}
"
260-11248,swigger/gdb-ios,gdb/testsuite/gdb.base/step-resume-infcall.c,35,1,30,1648773.0899824498,169064.0,9.752360052997682,1140.0,1130.0,38453.0,12697.0,1568.0,584.0,1318.0,544.0,1500000000,0.0010991820599883,1082014363648.0,0.0134268679316708,0.0784750733137829,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2005-2016 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <stdio.h>

volatile int cond_hit;

int
cond (void)
{
  cond_hit++;

  return 1;
}

int
func (void)
{
  return 0;	/* in-func */
}

int
main (void)
{
  /* Variable is used so that there is always at least one instruction on the
     same line after FUNC returns.  */
  int i = func ();	/* call-func */

  /* Dummy calls.  */
  cond ();
  func ();
  return 0;
}
"
370-7306,Traviis/bitcascade-server,src/snippets/xorpad.c,32,2,24,2274648.05357145,180953.0,12.585621680767934,1421.0,1392.0,40880.0,14369.0,1638.0,639.0,1355.0,595.0,1500000000,0.0015164320357143,1082014363648.0,0.0155454731339077,0.0765081720936125,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void padit(unsigned char** memtobepadded,int memsize, unsigned char* pad,int size)
{
unsigned char* padme = *memtobepadded;

int i = 0;
int current = 0;
for(i = 0; i < memsize; i++)
{
	if(current >= size)
	{
		current = 0;
	}
	padme[i] = padme[i] ^ pad[current++];
}

}


char* tohex(unsigned char* num_buf, int size)
{
char* str_buf = calloc(2*size + 1,0);   // X is the number of bytes to be converted
int i;
for(i = 0; i < size;i++)
	sprintf(&str_buf[i*2],""%02X"",num_buf[i]);
return str_buf;

}


int main()
{

unsigned char* memory;
memory = (unsigned char*)calloc(5,1);
unsigned char pad[] = { 0x02, 0x03, 0x04 };
padit(&memory,5,pad,3);

char* hex = tohex(memory,5);

printf(""String: \""%s\""\n"",hex);
free(hex);


}
"
120-5452,thewazir/learning_c,hard_way/ex10.c,15,2,16,1730719.464831,177148.0,9.76990426084404,1356.0,1335.0,40064.0,13831.0,1627.0,636.0,1345.0,595.0,1500000000,0.001153812976554,1082014363648.0,0.0151906880122835,0.0779849707765098,"#include <stdio.h>

int main(int argc, char *argv[]){
    int i = 0;

    //go through each string in argv
    //why skip argv[0]?
    for(i = 1; i < argc; i++){
        printf(""arg %d: %s\n"",i, argv[i]);
    }

    //let’s make our own array of strings
    char *states[] = { ""Colorado"",""California"",""Arizona"",""Oregon"" };
    int num_of_states = 4;

    for(i = 0; i < num_of_states; i++){
        printf(""states %d: %s\n"",i, states[i]);
    }

    return 0;
}"
031-15476,ComputoCienciasUniandes/MetodosComputacionalesLaboratorio,2017-1/lab10_C/rand_decay_average.c,59,4,34,9144946.58354655,40712659.0,0.2246216833933642,1554.0,1523.0,9019470.0,5768656.0,15544.0,7066.0,2618.0,1983.0,1500000000,0.0060966310556977,1082014363648.0,7.557845828738428e-05,0.0018400573541231,"#include <stdio.h>
#include <stdlib.h>
#include <math.h>

float delta_n_step(float n, float lambda, float dt);
void single_decay(float N0, float lambda, float dt);

int main(){

	float N_0 = 100.0;
	float Lambda = 1.0/2.0;
	float Dt = 0.001;

	srand48(1);
	
	single_decay(N_0, Lambda, Dt);
		
	return 0;
}

float delta_n_step(float n, float lambda, float dt){
	
	float rand_num = drand48();
	if(rand_num < lambda*n*dt){
		return -1.0;
	} else {
		return 0.0;
	}
}
	
void single_decay(float N0, float lambda, float dt){

    
    
	float t_total = 5.0/lambda;
	int n_points = (int)t_total/dt;
	int i;
    int j;
    int k;
	
    float M=5.0;
	float t = 0.0;
	float n = N0;
    
    float *array_n=malloc(n_points*sizeof(float));
    float *array_t=malloc(n_points*sizeof(float));

    
    FILE *out=fopen(""data_rand_average.txt"",""w+"");
    
	fprintf(out,""%f %f\n"", t, n);
    
    array_n[0]=n;
    array_t[0]=t;
    
    float *array_n_temp=malloc(n_points*sizeof(float));
    float *array_t_temp=malloc(n_points*sizeof(float));
        
    for(j=0;j<M;j++){

        array_n_temp[0]=N0;
        array_t_temp[0]=0.0;
        n=N0;
        t=0.0;
        
        for(i=1;i<(n_points);i++){
            t += dt;
		    float delta_n = delta_n_step(n, lambda, dt);
		    n +=delta_n;
            array_n_temp[i]=n;
            array_t_temp[i]=t;
	    }
        
        for(i=1;i<(n_points);i++){
            array_n[i]=array_n[i]+array_n_temp[i];
            array_t[i]=array_t[i]+array_t_temp[i];
	    }
        
    }
    for(k=1;k<(n_points);k++){
        array_n[k]=array_n[k]/M;
        array_t[k]=array_t[k]/M;
        fprintf(out,""%f %f\n"", array_t[k], array_n[k]);
    }
    fclose(out);
}
"
386-12150,ShooShoSha/Course-Work,COP3014/Chapters/5/Exercises/4/ex5-4.c,13,1,17,1756142.8248882,187141.0,9.384058009735975,1361.0,1340.0,42145.0,15197.0,1629.0,638.0,1349.0,596.0,1500000000,0.0011707618832588,1082014363648.0,0.0144329676554042,0.0734540127655122,"#include <stdio.h>

int main ()
{
	int n, factorial = 1;

	printf(""Table of Factorials\n"");
	printf("" n  Factorial\n"");
	printf(""--- ---------\n"");
	
	for(n = 1; n <= 10; ++n)
	{
		factorial *= n;
		printf(""%3i %9i\n"", n, factorial);
	}

	return 0;
}
"
073-35087,Gurgel100/gcc,gcc/testsuite/gcc.dg/ipa/vrp2.c,30,1,33,1628479.45466625,169083.0,9.627721296641294,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010856529697775,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-ipa-cp-details"" } */

static __attribute__((noinline, noclone))
int foo (int i)
{
  if (i < 4)
    __builtin_abort ();
  return 0;
}

static __attribute__((noinline, noclone))
int bar (int j)
{
  if (j > 8)
    return foo (j + 2);
  else if (j > 2)
    return foo (j + 3);

  return 0;
}

int main ()
{
  foo (100);
  for (unsigned int i = 0; i < 12; ++i)
    {
      bar (i);
    }
  foo (4);
  return 0;
}

/* { dg-final { scan-ipa-dump ""Setting value range of param 0 \\(now 0\\) \\\[4,"" ""cp"" } } */
/* { dg-final { scan-ipa-dump ""Setting value range of param 0 \\(now 0\\) \\\[0, 11\\\]"" ""cp"" } } */
"
167-17823,EvtimPavlov/c-programming-2014-2015-homework,B/06_Valentin_Stoyanov/homework_4/reverse_number.c,43,5,30,1730147.74918545,178591.0,9.683281912302412,1343.0,1322.0,40096.0,13933.0,1618.0,639.0,1339.0,594.0,1500000000,0.0011534318327903,1082014363648.0,0.0149223645088498,0.0775509448629439,"#include <stdio.h>
int main () {
int num1,num,mun1=0;
num1=5170984;
num=num1;
while (num1 != 0) {
	mun1=(mun1 *10) + (num1 % 10);
	num1=num1 /10;
}
printf(""%d\t\t%d\n"",num,mun1);
num1=406567;
num=num1;
mun1=0;
while (num1 != 0) {
	mun1=(mun1 *10) + (num1 % 10);
	num1=num1 /10;
}
printf(""%d\t\t%d\n"",num,mun1);
num1=368750;
num=num1;
mun1=0;
while (num1 != 0) {
	mun1=(mun1 *10) + (num1 % 10);
	num1=num1 /10;
}
printf(""%d\t\t%d\n"",num,mun1);
num1=2369510;
num=num1;
mun1=0;
while (num1 != 0) {
	mun1=(mun1 *10) + (num1 % 10);
	num1=num1 /10;
}
printf(""%d\t\t%d\n"",num,mun1);
num1=2183293;
num=num1;
mun1=0;
while (num1 != 0) {
	mun1=(mun1 *10) + (num1 % 10);
	num1=num1 /10;
}
printf(""%d\t\t%d\n"",num,mun1);
return 0;
}
"
325-26168,Chrinkus/learn-cpp,chapter27/ch27_drill.c,32,1,37,2024644.5201336,176789.0,11.452318865992794,1352.0,1331.0,40004.0,13831.0,1626.0,638.0,1345.0,594.0,1500000000,0.0013497630134224,1082014363648.0,0.0151762835923049,0.078071886319309,"/*
 * Stroustrup - Programming Principles & Practice
 *
 * Chapter 27 Drill
 *
 * 1. Write the Hello World in C
 *
 * 2. Define variables for Hello and World and concatenate them to output.
 * Using the provided cat() function felt like cheating so I used printf with
 * arguments.
 *
 * 3. Define a C function that takes a char* and an int and prints their values
 * in provided format.
 */

#include <stdlib.h>
#include <stdio.h>

void print_out(const char* p, const int x)
{
    printf(""p is\""%s\"" and x is %i\n"", p, x);
}

int main()
{
    /* Ex 1 */
    printf(""Hello World!\n"");

    /* Ex 2 */
    char* first = ""Hello"";
    char* last = ""World!"";
    printf(""%s %s\n"", first, last);

    /* Ex 3 */
    print_out(""May"", 6);
    print_out(""Chris"", 39);
    print_out(""C"", 89);
    return 0;
}
"
171-32038,kkmonlee/Project-Euler-Solutions,CCPP/p404.c,24,1,38,744233400.0952542,6203545908.0,0.1199690323948836,1347.0,1328.0,843563952.0,843538071.0,99350.0,98726.0,1342.0,11606.0,1500000000,0.4961556000635028,1082014363648.0,4.312049978626514e-07,0.0001250807580828,"#include <stdio.h>
#define N (100ll*1000*1000*1000*1000*1000)
typedef long long LL;
LL sum = 0;

void testing(LL b, LL c, LL x) {
	LL a, i;
	if (b < 0) b = -b;
	if (x >= c || x >= b) return;

	a = b * c / 2;
	for (i = N / a; i; i /= -25) sum += i;
}

void gen(LL a, LL b, LL c) {
	if (c * c >= N) return;
	testing(2 * a - b, 2 * b + a, c);
	testing(2 * b - a, 2 * a + b, c);

	LL d, e, f, g;
	g = 2 * (a + b + c); gen(d = g - a, e = g - b, f = g + c);
	g = 2 * (a *= 2); gen(d - a, e - g, f - g);
	g = 2 * (b *= 2); gen(d - g, e - b, f - g);
}

int main() {
	sum = 0;
	gen(3, 4, 5);
	printf(""%lld\n"", sum);

	return 0;
}
"
266-35386,evan886/learn-c,mysrc/pointer/a2a.c,27,1,27,1658026.3618378502,175319.0,9.457195169947353,1428.0,1403.0,39706.0,13643.0,1630.0,636.0,1349.0,593.0,1500000000,0.0011053509078919,1082014363648.0,0.0161477078924702,0.0788768299312077,"#include <stdio.h>
/* 函数声明 */
double getAverage (int *arr, int size);
int main()
{
	/* 带有 5 个元素的整型数组  */
	int balance[5] = {1000,2,3,17,50};
	double avg;
	/* 传递一个指向数组的指针作为参数 */
	avg = getAverage (balance,5);
	 /* 输出返回值  */
	printf ( ""Average  value is : %f\n"",avg);
	return 0;
}

double getAverage (int *arr, int size)
{
	int i, sum =0;
	double avg;

	for (i=0; i < size; ++i)
	{
		sum += arr[i];
	}
	avg=(double)sum / size;
	return avg;
	
}
/*
Average  value is : 214.400000
*/"
380-3754,iamroot9C-arm/linux,debug_with_qemu/test_code/address_space.c,30,3,28,1582878.0597075,169061.0,9.362762553161286,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.001055252039805,1082014363648.0,0.0134152761429306,0.0785563462891999,"#if 0
	usage:
		sparse address_space.c -D__CHECK__
#endif
#define NULL 0

#ifdef __CHECK__
# define __noderef __attribute__((noderef))
# define __percpu   __attribute__((noderef, address_space(3)))
#else
# define __noderef 
# define __percpu
#endif

#if 0
// for test gcc warning
// # gcc address_space.c -Wall
// address_space.c:39:2: warning: unused variable ‘__vpp_verify’ [-Wunused-variable]
    (void)__vpp_verify;

#define __verify_pcpu_ptr(ptr)  do {                    \
    void __percpu *__vpp_verify = (typeof(ptr))NULL; \
} while (0)
#else
#define __verify_pcpu_ptr(ptr)  do {                    \
    const void __percpu *__vpp_verify = (typeof(ptr))NULL;      \
	    (void)__vpp_verify;                     \
} while (0)
#endif

struct per_cpu_pageset {
	int x;
};

int main(int argc, char **argv)
{
#if 1
	void * __percpu boot_pageset;
#else
	int *boot_pageset = (int *)0x1234567;
	/* address_space.c:37:9: warning: Using plain integer as NULL pointer */
	// int boot_pageset = 0x1234567;
#endif

	__verify_pcpu_ptr (boot_pageset);
#if 0
	int a = 3;
	int __noderef *pa_noderef;
	int *pa;

	pa_noderef = (int __noderef *)&a;
	pa = &a;

	*pa = 0;
	*pa_noderef = 0;
#endif

	return 0;
}
"
390-19316,ColinIanKing/stress-ng,test/test-swapcontext.c,37,1,30,1471007.9412906,172507.0,8.52723077904085,1173.0,1162.0,39371.0,13087.0,1601.0,591.0,1340.0,548.0,1500000000,0.0009806719608604,1082014363648.0,0.013535682609981,0.0777765069198215,"/*
 * Copyright (C) 2013-2021 Canonical, Ltd.
 * Copyright (C)      2022 Colin Ian King.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 */
#include <ucontext.h>

void func(void)
{
	/* Just return */
}


int main(void)
{
	static unsigned char stack[63336];

	ucontext_t u1, u2;
	if (getcontext(&u2) < 0)
		return -1;
	u2.uc_stack.ss_sp = stack;
	u2.uc_stack.ss_size = sizeof(stack);
	u2.uc_link = &u1;

	makecontext(&u2, func, 0);

	if (swapcontext(&u1, &u2) < 0)
		return -1;
	return 0;
}
"
062-9037,zhangrxiang/learn-c,linux/unistd/ctermid.c,14,1,24,1566092.9493606,174089.0,8.995927370482914,1295.0,1280.0,39511.0,13411.0,1626.0,634.0,1345.0,591.0,1500000000,0.0010440619662404,1082014363648.0,0.0147912849174847,0.0792864971089528,"//
// Created by zhangrongxiang on 2018/2/26 13:36
// File ctermid
//

//ctermid - generate a pathname for controlling terminal

#include <stdio.h>

int main() {
    char string[16];
    char *rs = ctermid(string);
    if (rs) {
        printf(""%s\n"", rs);//  /dev/tty
        printf(""%s\n"", string);// /dev/tty
    }
    return 0;
}"
041-22551,legumbre/gdb-z80,gdb/testsuite/gdb.python/py-breakpoint.c,34,2,28,1871869.6665018,169062.0,11.072085980291254,1139.0,1129.0,38453.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0012479131110012,1082014363648.0,0.0134151967917095,0.0785548104557273,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see  <http://www.gnu.org/licenses/>.
*/


int result = 0;

int multiply (int i)
{
  return i * i;
}

int add (int i)
{
  return i + i; 
}


int main (int argc, char *argv[])
{
  int foo = 5;
  int bar = 42;
  int i;

  for (i = 0; i < 10; i++)
    {
      result += multiply (foo);  /* Break at multiply. */
      result += add (bar); /* Break at add. */
    }

  return 0; /* Break at end. */
}
"
161-22747,Pelagicore/softwarecontainer,servicetest/timingprofiling/simple.c,21,1,24,15002224258.496424,170089.0,102014.43109783702,1154.0,1144.0,38691.0,12795.0,1575.0,586.0,1322.0,546.0,1500000000,10.001482838997616,1082014363648.0,0.0135105738760296,0.0782542827176319,"
/*
 * Copyright (C) 2016-2017 Pelagicore AB
 *
 * Permission to use, copy, modify, and/or distribute this software for
 * any purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR
 * BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES
 * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 *
 * For further information see LICENSE
 */


#include <unistd.h>

int main(int argc, char **argv) {
    sleep(10);
}
"
218-6095,Elitos/ls2,Practicas/mutex.c,31,3,32,4427272.3607718,3112608.0,1.422367352393877,1573.0,1531.0,963807.0,256192.0,1691.0,833.0,1379.0,787.0,1500000000,0.0029515149071812,1082014363648.0,0.0009972344734704,0.0038442654461192,"#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

int * enteroCompartido;
pthread_mutex_t * semaforo;

void * procedimiento(void * in)
{
	int tid = (int) in, i;
	for(i = 0; i < 10000; i++)
	{
		pthread_mutex_lock(semaforo);
		enteroCompartido[0]++;
		if(!(i+1 < 10000))
			printf(""Hola soy la hebra %d y el ultimo numero que deje fue %d\n"", tid, *enteroCompartido);
		pthread_mutex_unlock(semaforo);
	}
}

int main(int argc, char * argv[])
{
	// reserva memoria para enteroCompartido
	enteroCompartido = (int*) malloc(sizeof(int));

	// reserva memoria para semaforo
	semaforo = (pthread_mutex_t*) malloc(sizeof(pthread_mutex_t));
	
	// Inicializo el semáforo
	pthread_mutex_init(semaforo, NULL);

	int i, j = 4;
	pthread_t * hebra1 = (pthread_t*) malloc(sizeof(pthread_t) * 4);
	for(i = 0; i < j; i++)
		pthread_create(&hebra1[i], NULL, &procedimiento, (void*) i);
	
	for(i = 0; i < j; i++)
		pthread_join(hebra1[i], NULL);
	printf(""Hebra padre ha terminado de esperar por sus hijas\n"");
	printf(""- Finalmente enteroCompartido= %d\n"", *enteroCompartido);
}
"
023-30037,ilee/projects,daily/pe/pe18.c,36,2,32,1714338.0828201,292271.0,5.8655768105628,1347.0,1328.0,63326.0,29268.0,1636.0,688.0,1357.0,645.0,1500000000,0.0011428920552134,1082014363648.0,0.0091524646646434,0.0467200898546342,"/* Project Euler
** 18
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <inttypes.h>

static long long euler = 0;

int triangle[15][15] =
{{75},{95,64},{17,47,82},{18,35,87,10},{20,4,82,47,65},{19,1,23,75,3,34},{88,2,77,73,7,63,67},{99,65,4,28,6,16,70,92},{41,41,26,56,83,40,80,70,33},{41,48,72,33,47,32,37,16,94,29},{53,71,44,65,25,43,91,52,97,51,14},{70,11,33,28,77,73,17,78,39,68,17,57},{91,71,52,38,17,14,91,43,58,50,27,29,48},{63,66,4,68,89,53,67,30,73,16,69,87,40,31},{4,62,98,27,23,9,70,98,73,93,38,53,60,4,23}};

void trisum(void) {
	int row = 14;
	int column = 0;

	for(row = 14; row > 0; row--) {
		printf(""Comparing row %d\n"", row+1);

		for(column = 0; column < row; column++) {
			printf(""Comparing column %d against %d\n"", column, column+1);
			if(triangle[row][column] >= triangle[row][column+1]) {
				triangle[row-1][column]+=triangle[row][column];
			} else {
				triangle[row-1][column]+=triangle[row][column+1];
			}
		}
	}

}



int main(int argc, char** argv) {
	printf(""row 1 = %d\nrow 1, column 1 = %d\n"", triangle[0][0], triangle[1][0]);

	trisum();

	/*
	if(triangle[1][0] >= triangle[1][1]) {
		euler = triangle[0][0]+triangle[1][0];
	}
	else {
		euler = triangle[0][0]+triangle[1][1];
	}
	*/

	euler = triangle[0][0];
	printf(""%llu\n"", euler);

return 0;
}

"
014-19985,lzhouAlan/ccode_test,C_api_test/fopen/fopen.c,64,2,48,15049540643.929506,173052.0,86965.4245140189,1298.0,1277.0,39262.0,13367.0,1609.0,637.0,1339.0,597.0,1500000000,10.033027095953004,1082014363648.0,0.0148799204863278,0.079461893632788,"#include <unistd.h>
#include <stdio.h>

#define FILE_NAME 	""test.txt""
char *read_file(const char *filename, size_t *len)
{
	size_t size;
	char *buf = NULL;
	FILE *fp = NULL;
	
	if (!filename)
		return NULL;

	fp = fopen(filename, ""r"");
	if (!fp) {
		printf(""Failed to open file %s\n"", filename);
		return NULL;
	}

	size = 0;
	printf(""feof(fp) = %d\n"", feof(fp));
	printf(""ftell(fp) = %d\n"", ftell(fp));
    fread(size, 1, 1, fp);
    printf(""feof(fp) = %d\n"", feof(fp));
	printf(""ftell(fp) = %d\n"", ftell(fp));    
    
	while (!feof(fp) && !ferror(fp)) {
		buf = realloc(buf, size + 4096);
		if (!buf) {
			free(buf);
			fclose(fp);
			return NULL;
		}
		size += fread(buf + size, 1, 4096, fp);
	}

	*len = size;
	fclose(fp);
	return buf;	
}

void fopen_write_file_test()
{
    int i = 0,j = 0;
    FILE *fp1 = fopen(""test.txt"", ""w"");

    fprintf(fp1, ""pid is %d\n"", getpid());
#if 1
    /* check if we can dump the file just  written */
	size_t len;
	char *buf;

	buf = read_file(FILE_NAME, &len);
	printf(""buf is %s(%s)\n"", buf ? buf : ""null"", buf ? ""not null"" : ""null"");
	printf(""len = %d\n"", len);
#endif
    for (j = 0;j < 1000; j++) {
        fprintf(fp1, ""fp1 wirte %d.. \n"", i);i++;
    }

    fprintf(fp1, ""fp1 write %d.. \n"", i);i++;

    sleep(10);
    FILE *fp2 = fopen(""test.txt"", ""w"");
    fprintf(fp2, ""fp2 write %d.. \n"", i);i++;

    fprintf(fp1, ""fp1 write %d.. \n"", i);i++;
    fprintf(fp2, ""fp2 write %d.. \n"", i);i++;
    fclose(fp2);
    //fclose(fp1);
    fclose(fp1);
}

int main()
{
#if 0
	size_t len;
	char *buf;

	buf = read_file(FILE_NAME, &len);
	printf(""buf is %s(%s)\n"", buf ? buf : ""null"", buf ? ""not null"" : ""null"");
	printf(""len = %d\n"", len);
#else
    fopen_write_file_test();
#endif
}
"
183-27420,ilee/projects,daily/pe/pe23.c,90,7,68,640234600.5197614,2047724365.0,0.312595975288891,1342.0,1320.0,24378064.0,24317095.0,1435887.0,5754401.0,1344.0,2786.0,1500000000,0.4268230670131743,1082014363648.0,1.2999796483839758e-06,0.147744008803832,"/* Project Euler
** 23
** Non-abundant sums
** Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers.
** Any numbers greater than 28,123 have been proven to be the sum of 2 abundants.
*/

#include <stdio.h>
#define UPPER 28125

unsigned long long euler = 0;
int abundantArray[UPPER] = {0};
int arrayMarked[UPPER] = {0};

int abundant(int a);
unsigned long sumDivisors(int number);
int noSum(int number);

int abundant(int a)
{
	int flag;
	int temp;

	temp = sumDivisors(a);
	if(temp > a) {
		flag = 1; // abundant
	} else {
		flag = 0; // not abundant
	}

	return flag;
}


unsigned long sumDivisors(int number)
{
	int i = 1;
	unsigned long sum = 0;

	for(i = 1; i <= number/2; i++) {
		if(number % i == 0) {
			sum+=i;
		}
	}
	return sum;
}

/*
int noSum(int number)
{
	int i,j;


	for(i = 0; i < UPPER; i++) {
		// printf(""Checking %d against %d...\n"", abundantArray[i], number);
		if(abundantArray[i] > number || abundantArray[i] == 0) break; // end of array, quit both loops
		for(j = 0; j < UPPER; j++) {
			if(((abundantArray[j]+abundantArray[i]) > number) || abundantArray[j] == 0) break; // end of array
			else {
				if(abundantArray[i] + abundantArray[j] == number) {
					return 0;
				}
			}
		}
	}
	printf(""%d is not a sum of two abundants!\n"", number);
	return number;
}
*/


int main(int argc, char** argv)
{
	int i, j, temp;
	int counter = 0;

	// get array of all abundant values
	for(i = 0; i < UPPER; i++) {
		if(abundant(i)) {
			abundantArray[counter] = i;
			counter++;
		}
	}

	// mark all numbers that CAN be summed by two abundants
	for(i = 0; i < UPPER; i++) {
		if(abundantArray[i] == 0) break;
		for(j = 0; j < UPPER; j++) {
			if(abundantArray[j] == 0) break;
			else if(abundantArray[i] + abundantArray[j] <= UPPER) {
				temp = abundantArray[i] + abundantArray[j];
				arrayMarked[temp] = 1;
			}
			else {
				break;
			}
		}
	}

	// find numbers that aren't sum of two abundants
	for(i = 4; i < UPPER; i++) {
		if(arrayMarked[i] == 0) {
			euler+=i;
		}
	}

	euler+= 1 + 2 + 3; // these aren't sum of two abundants

	printf(""euler = %llu\n"", euler);

	return 0;
}
"
255-20634,jnuyens/linux-c-programming,3_1_memory_management/linked_list1.c,35,1,35,1608874.5323939999,172430.0,9.330592124340312,1213.0,1201.0,39090.0,13200.0,1603.0,635.0,1333.0,592.0,1500000000,0.001072583021596,1082014363648.0,0.0139998840109029,0.0796136928667049,"#include <stdio.h>
#include <stdlib.h>

struct node {
  int data;
  struct node *next;
};

int main()
{
    struct node *rootnode;       
    /* This will point to each node as it traverses the list */
    struct node *nextnode;  

    rootnode = malloc( sizeof(struct node) );   
/* this allocates the rootnode memory */
    rootnode->next = 0;   
    rootnode->data = 666;
/* now we use the  nextnode struct to go over the linked list */
    nextnode = rootnode; 
/*now we traverse the list */
    if ( nextnode != 0 ) {
        while ( nextnode->next != 0)
        {
            nextnode = nextnode->next;
        }
    }
    /* Creates a node at the end of the list */
    nextnode->next = malloc( sizeof(struct node) );  

    nextnode = nextnode->next; 

    if ( nextnode == 0 )
    {
        printf( ""Out of memory"" );
        return 0;
    }
    /* add the nextnode at the end of the (small) list */
    nextnode->next = 0;         
    nextnode->data = 42;

    return 0;
}
"
232-6927,anqurvanillapy/cppl,mem/malloc_hook.c,46,1,34,1988747.9720637,175278.0,11.34624425198827,1366.0,1346.0,39648.0,13612.0,1621.0,653.0,1343.0,596.0,1500000000,0.0013258319813758,1082014363648.0,0.0154725635847054,0.0791025159594442,"/**
 *  malloc hook
 *  ===========
 *
 *  - Notes:
 *      + __builtin_return_address only works with gcc
 *      + __libc_malloc only works with glibc
 */

#include <stdio.h>
#include <stdlib.h>

#ifdef __GNUC__

extern void* __libc_malloc(size_t size);
int is_malloc_hook_enabled = 1;

void*
malloc_hook(size_t size, void* caller)
{
	void* p;

	is_malloc_hook_enabled = 0;
	p = malloc(size);

	// User-defined behavior.
	printf(""caller=%p, size=%lu\n"", caller, size);

	is_malloc_hook_enabled = 1;

	return p;
}

void*
malloc(size_t size)
{
	void* caller = __builtin_return_address(0);

	if (is_malloc_hook_enabled) {
		return malloc_hook(size, caller);
	}

	return __libc_malloc(size);
}
int
main()
{
	int* p = (int*)malloc(sizeof(int));
	*p = 42;
	printf(""%d\n"", *p);
	free(p);
	p = NULL;
	return 0;
}

#else

int
main()
{
	fprintf(stderr, ""snippet not workable for your compiler\n"");
	return 1;
}

#endif /* __GNUC__ */
"
205-10802,AndrewLaing/CHowToProgramExercises,Chapter4/ex04_27.c,37,3,35,271135712.8573581,2506138338.0,0.1081886454106828,1348.0,1324.0,697633.0,444667.0,1620.0,699.0,1340.0,656.0,1500000000,0.1807571419049054,1082014363648.0,1.066182165399682e-06,0.003777466514926,"/*
 * Filename:    ex04_27.c
 * Author:      Andrew Laing
 * Email:       parisianconnections@gmail.com
 * Date:        22/04/2017
 */

#include <stdio.h>

int isValidRATriangle( float, float, float );


int main()
{
    int a, b, c;
    
    for(a=1; a<=500; a++)
    {
        for(b=1; b<=500; b++)
        {
            for(c=1; c<=500; c++)
            {
                if( isValidRATriangle(a, b, c) )
                    printf(""A=%d B=%d C=%d\n"", a, b, c);
            }   
        }
    }

    return 0;
}


int isValidRATriangle(float a, float b, float c)
{
    if(a>b)
    {
        if(a>c)
            return ( (c*c)+(b*b) == (a*a) );
        else
            return ( (a*a)+(b*b) == (c*c) );
    }
    else if(b>c)
        return ( (a*a)+(c*c) == (b*b) );
    else
        return ( (a*a)+(b*b) == (c*c) );
}

"
374-18319,Determinant/cibic,compile_data/custom_struct2.c,41,2,30,2460889.40184555,248570.0,9.900185058534818,1347.0,1324.0,55309.0,24813.0,1612.0,655.0,1338.0,612.0,1500000000,0.0016405929345637,1082014363648.0,0.0107454640543911,0.0526322358403434,"struct A {
    int x, y;
} sa;
struct A print(struct A a, struct A b) {
    a.x++;
    a.y++;
    b.x--;
    b.y--;
    printf(""args: %d %d\n"", a.x, a.y);
    printf(""args: %d %d\n"", b.x, b.y);
    return a;
}
int main() {
    int i;
    int t;
    int *a, *b;
    struct A sb, sc;
    a = malloc(sizeof(int) * 100);
    for (i = 0; i < 100; i++)
        a[i] = i;
    b = malloc(sizeof(int) * 100);
    memcpy(b, a, sizeof(int) * 100);
    for (i = 0; i < 100; i++)
        printf(""%d "", b[i]);
    sb.x = 1;
    sb.y = 2;
    sa = sb;
    sc = sa;
    printf(""\n%d %d\n"", sa.x, sa.y);
    printf(""%d %d\n"", sc.x, sc.y);
    sa.x = 1;
    sa.y = 2;
    sb.x = 1;
    sb.y = 2;
    sa = print(sa, sb);
    sb = print(sa, sb);
    sa = print(sa, sb);
    sb = print(sa, sb);
    printf(""%d %d\n"", sa.x, sa.y);
    printf(""%d %d\n"", sb.x, sb.y);
}
"
337-34808,zhuyehang001/leetcode,229.c,55,3,40,1507667.94104115,177252.0,8.505782727416333,1367.0,1341.0,40196.0,13781.0,1635.0,638.0,1352.0,595.0,1500000000,0.0010051119606941,1082014363648.0,0.0152776837496897,0.0781814476536302,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int* majorityElement(int* nums, int numsSize, int* returnSize);

int main(void){
	//int nums[] = {1,2,2,3,2,1,1,3};
	int nums[] = {1,1,1,3,3,2,2,2};
	int numsSize = sizeof(nums)/sizeof(nums[0]);
	int returnSize;

	int * value = majorityElement(nums, numsSize, &returnSize);
	int i;	
	for(i = 0; i < returnSize; i++){
		printf(""%d\n"", value[i]);
	}
	free(value);

	return 0;
}

int* majorityElement(int* nums, int numsSize, int* returnSize) {
	int *result = (int *)malloc(2*sizeof(int));
	if(numsSize <= 1){
		memcpy(result, nums, sizeof(int)*numsSize);
		*returnSize = numsSize;
		return result;
	}

	result[0] = 0;
	result[1] = 0;

	int i, count1 = 0, count2 = 0;
	for(i = 0;  i < numsSize; i++){
		if(result[0] == nums[i]) ++count1;
		else if(result[1] == nums[i]) ++count2;
		else if(count1 == 0) {
			result[0] = nums[i];
			count1 = 1;
		}
		else if(count2 == 0) {
			result[1] = nums[i];
			count2 = 1;
		}
		else{
			--count1;
			--count2;
		}
	}

	count1 = 0;
	count2 = 0;
	int a = result[0];
	int b = result[1];

	for(i = 0; i < numsSize; i++){
		if(a == nums[i])
			++count1;
		else if(b == nums[i])
			++count2;
	}

	int judge1 = (count1 > numsSize / 3);
	int judge2 = (count2 > numsSize / 3);
	*returnSize = judge1 + judge2;

	return result + 1 - judge1;
}
"
012-6739,heiher/gst-ffmpeg,gst-libs/ext/libav/tools/qt-faststart.c,268,7,215,1608752.994798,181766.0,8.850676144053343,1306.0,1289.0,41724.0,14348.0,1693.0,640.0,1397.0,596.0,1500000000,0.001072501996532,1082014363648.0,0.014276597383449,0.0771508061064345,"/*
 * qt-faststart.c, v0.2
 * by Mike Melanson (melanson@pcisys.net)
 * This file is placed in the public domain. Use the program however you
 * see fit.
 *
 * This utility rearranges a Quicktime file such that the moov atom
 * is in front of the data, thus facilitating network streaming.
 *
 * To compile this program, start from the base directory from which you
 * are building Libav and type:
 *  make tools/qt-faststart
 * The qt-faststart program will be built in the tools/ directory. If you
 * do not build the program in this manner, correct results are not
 * guaranteed, particularly on 64-bit platforms.
 * Invoke the program with:
 *  qt-faststart <infile.mov> <outfile.mov>
 *
 * Notes: Quicktime files can come in many configurations of top-level
 * atoms. This utility stipulates that the very last atom in the file needs
 * to be a moov atom. When given such a file, this utility will rearrange
 * the top-level atoms by shifting the moov atom from the back of the file
 * to the front, and patch the chunk offsets along the way. This utility
 * presently only operates on uncompressed moov atoms.
 */

#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
#include <string.h>

#ifdef __MINGW32__
#define fseeko(x,y,z)  fseeko64(x,y,z)
#define ftello(x)      ftello64(x)
#endif

#define BE_16(x) ((((uint8_t*)(x))[0] << 8) | ((uint8_t*)(x))[1])
#define BE_32(x) ((((uint8_t*)(x))[0] << 24) | \
                  (((uint8_t*)(x))[1] << 16) | \
                  (((uint8_t*)(x))[2] << 8) | \
                   ((uint8_t*)(x))[3])
#define BE_64(x) (((uint64_t)(((uint8_t*)(x))[0]) << 56) | \
                  ((uint64_t)(((uint8_t*)(x))[1]) << 48) | \
                  ((uint64_t)(((uint8_t*)(x))[2]) << 40) | \
                  ((uint64_t)(((uint8_t*)(x))[3]) << 32) | \
                  ((uint64_t)(((uint8_t*)(x))[4]) << 24) | \
                  ((uint64_t)(((uint8_t*)(x))[5]) << 16) | \
                  ((uint64_t)(((uint8_t*)(x))[6]) << 8) | \
                  ((uint64_t)((uint8_t*)(x))[7]))

#define BE_FOURCC( ch0, ch1, ch2, ch3 )             \
        ( (uint32_t)(unsigned char)(ch3) |          \
        ( (uint32_t)(unsigned char)(ch2) << 8 ) |   \
        ( (uint32_t)(unsigned char)(ch1) << 16 ) |  \
        ( (uint32_t)(unsigned char)(ch0) << 24 ) )

#define QT_ATOM BE_FOURCC
/* top level atoms */
#define FREE_ATOM QT_ATOM('f', 'r', 'e', 'e')
#define JUNK_ATOM QT_ATOM('j', 'u', 'n', 'k')
#define MDAT_ATOM QT_ATOM('m', 'd', 'a', 't')
#define MOOV_ATOM QT_ATOM('m', 'o', 'o', 'v')
#define PNOT_ATOM QT_ATOM('p', 'n', 'o', 't')
#define SKIP_ATOM QT_ATOM('s', 'k', 'i', 'p')
#define WIDE_ATOM QT_ATOM('w', 'i', 'd', 'e')
#define PICT_ATOM QT_ATOM('P', 'I', 'C', 'T')
#define FTYP_ATOM QT_ATOM('f', 't', 'y', 'p')
#define UUID_ATOM QT_ATOM('u', 'u', 'i', 'd')

#define CMOV_ATOM QT_ATOM('c', 'm', 'o', 'v')
#define STCO_ATOM QT_ATOM('s', 't', 'c', 'o')
#define CO64_ATOM QT_ATOM('c', 'o', '6', '4')

#define ATOM_PREAMBLE_SIZE 8
#define COPY_BUFFER_SIZE 1024

int main(int argc, char *argv[])
{
    FILE *infile  = NULL;
    FILE *outfile = NULL;
    unsigned char atom_bytes[ATOM_PREAMBLE_SIZE];
    uint32_t atom_type = 0;
    uint64_t atom_size = 0;
    uint64_t atom_offset = 0;
    uint64_t last_offset;
    unsigned char *moov_atom = NULL;
    unsigned char *ftyp_atom = NULL;
    uint64_t moov_atom_size;
    uint64_t ftyp_atom_size = 0;
    uint64_t i, j;
    uint32_t offset_count;
    uint64_t current_offset;
    uint64_t start_offset = 0;
    unsigned char copy_buffer[COPY_BUFFER_SIZE];
    int bytes_to_copy;

    if (argc != 3) {
        printf (""Usage: qt-faststart <infile.mov> <outfile.mov>\n"");
        return 0;
    }

    if (!strcmp(argv[1], argv[2])) {
        fprintf(stderr, ""input and output files need to be different\n"");
        return 1;
    }

    infile = fopen(argv[1], ""rb"");
    if (!infile) {
        perror(argv[1]);
        goto error_out;
    }

    /* traverse through the atoms in the file to make sure that 'moov' is
     * at the end */
    while (!feof(infile)) {
        if (fread(atom_bytes, ATOM_PREAMBLE_SIZE, 1, infile) != 1) {
            break;
        }
        atom_size = (uint32_t)BE_32(&atom_bytes[0]);
        atom_type = BE_32(&atom_bytes[4]);

        /* keep ftyp atom */
        if (atom_type == FTYP_ATOM) {
            ftyp_atom_size = atom_size;
            free(ftyp_atom);
            ftyp_atom = malloc(ftyp_atom_size);
            if (!ftyp_atom) {
                printf (""could not allocate %""PRIu64"" byte for ftyp atom\n"",
                        atom_size);
                goto error_out;
            }
            fseeko(infile, -ATOM_PREAMBLE_SIZE, SEEK_CUR);
            if (fread(ftyp_atom, atom_size, 1, infile) != 1) {
                perror(argv[1]);
                goto error_out;
            }
            start_offset = ftello(infile);
        } else {

        /* 64-bit special case */
        if (atom_size == 1) {
            if (fread(atom_bytes, ATOM_PREAMBLE_SIZE, 1, infile) != 1) {
                break;
            }
            atom_size = BE_64(&atom_bytes[0]);
            fseeko(infile, atom_size - ATOM_PREAMBLE_SIZE * 2, SEEK_CUR);
        } else {
            fseeko(infile, atom_size - ATOM_PREAMBLE_SIZE, SEEK_CUR);
        }
    }
        printf(""%c%c%c%c %10""PRIu64"" %""PRIu64""\n"",
               (atom_type >> 24) & 255,
               (atom_type >> 16) & 255,
               (atom_type >>  8) & 255,
               (atom_type >>  0) & 255,
               atom_offset,
               atom_size);
        if ((atom_type != FREE_ATOM) &&
            (atom_type != JUNK_ATOM) &&
            (atom_type != MDAT_ATOM) &&
            (atom_type != MOOV_ATOM) &&
            (atom_type != PNOT_ATOM) &&
            (atom_type != SKIP_ATOM) &&
            (atom_type != WIDE_ATOM) &&
            (atom_type != PICT_ATOM) &&
            (atom_type != UUID_ATOM) &&
            (atom_type != FTYP_ATOM)) {
            printf (""encountered non-QT top-level atom (is this a Quicktime file?)\n"");
            break;
        }
        atom_offset += atom_size;

        /* The atom header is 8 (or 16 bytes), if the atom size (which
         * includes these 8 or 16 bytes) is less than that, we won't be
         * able to continue scanning sensibly after this atom, so break. */
        if (atom_size < 8)
            break;
    }

    if (atom_type != MOOV_ATOM) {
        printf (""last atom in file was not a moov atom\n"");
        free(ftyp_atom);
        fclose(infile);
        return 0;
    }

    /* moov atom was, in fact, the last atom in the chunk; load the whole
     * moov atom */
    fseeko(infile, -atom_size, SEEK_END);
    last_offset = ftello(infile);
    moov_atom_size = atom_size;
    moov_atom = malloc(moov_atom_size);
    if (!moov_atom) {
        printf (""could not allocate %""PRIu64"" byte for moov atom\n"",
            atom_size);
        goto error_out;
    }
    if (fread(moov_atom, atom_size, 1, infile) != 1) {
        perror(argv[1]);
        goto error_out;
    }

    /* this utility does not support compressed atoms yet, so disqualify
     * files with compressed QT atoms */
    if (BE_32(&moov_atom[12]) == CMOV_ATOM) {
        printf (""this utility does not support compressed moov atoms yet\n"");
        goto error_out;
    }

    /* close; will be re-opened later */
    fclose(infile);
    infile = NULL;

    /* crawl through the moov chunk in search of stco or co64 atoms */
    for (i = 4; i < moov_atom_size - 4; i++) {
        atom_type = BE_32(&moov_atom[i]);
        if (atom_type == STCO_ATOM) {
            printf ("" patching stco atom...\n"");
            atom_size = BE_32(&moov_atom[i - 4]);
            if (i + atom_size - 4 > moov_atom_size) {
                printf ("" bad atom size\n"");
                goto error_out;
            }
            offset_count = BE_32(&moov_atom[i + 8]);
            for (j = 0; j < offset_count; j++) {
                current_offset = BE_32(&moov_atom[i + 12 + j * 4]);
                current_offset += moov_atom_size;
                moov_atom[i + 12 + j * 4 + 0] = (current_offset >> 24) & 0xFF;
                moov_atom[i + 12 + j * 4 + 1] = (current_offset >> 16) & 0xFF;
                moov_atom[i + 12 + j * 4 + 2] = (current_offset >>  8) & 0xFF;
                moov_atom[i + 12 + j * 4 + 3] = (current_offset >>  0) & 0xFF;
            }
            i += atom_size - 4;
        } else if (atom_type == CO64_ATOM) {
            printf ("" patching co64 atom...\n"");
            atom_size = BE_32(&moov_atom[i - 4]);
            if (i + atom_size - 4 > moov_atom_size) {
                printf ("" bad atom size\n"");
                goto error_out;
            }
            offset_count = BE_32(&moov_atom[i + 8]);
            for (j = 0; j < offset_count; j++) {
                current_offset = BE_64(&moov_atom[i + 12 + j * 8]);
                current_offset += moov_atom_size;
                moov_atom[i + 12 + j * 8 + 0] = (current_offset >> 56) & 0xFF;
                moov_atom[i + 12 + j * 8 + 1] = (current_offset >> 48) & 0xFF;
                moov_atom[i + 12 + j * 8 + 2] = (current_offset >> 40) & 0xFF;
                moov_atom[i + 12 + j * 8 + 3] = (current_offset >> 32) & 0xFF;
                moov_atom[i + 12 + j * 8 + 4] = (current_offset >> 24) & 0xFF;
                moov_atom[i + 12 + j * 8 + 5] = (current_offset >> 16) & 0xFF;
                moov_atom[i + 12 + j * 8 + 6] = (current_offset >>  8) & 0xFF;
                moov_atom[i + 12 + j * 8 + 7] = (current_offset >>  0) & 0xFF;
            }
            i += atom_size - 4;
        }
    }

    /* re-open the input file and open the output file */
    infile = fopen(argv[1], ""rb"");
    if (!infile) {
        perror(argv[1]);
        goto error_out;
    }

    if (start_offset > 0) { /* seek after ftyp atom */
        fseeko(infile, start_offset, SEEK_SET);
        last_offset -= start_offset;
    }

    outfile = fopen(argv[2], ""wb"");
    if (!outfile) {
        perror(argv[2]);
        goto error_out;
    }

    /* dump the same ftyp atom */
    if (ftyp_atom_size > 0) {
        printf ("" writing ftyp atom...\n"");
        if (fwrite(ftyp_atom, ftyp_atom_size, 1, outfile) != 1) {
            perror(argv[2]);
            goto error_out;
        }
    }

    /* dump the new moov atom */
    printf ("" writing moov atom...\n"");
    if (fwrite(moov_atom, moov_atom_size, 1, outfile) != 1) {
        perror(argv[2]);
        goto error_out;
    }

    /* copy the remainder of the infile, from offset 0 -> last_offset - 1 */
    printf ("" copying rest of file...\n"");
    while (last_offset) {
        if (last_offset > COPY_BUFFER_SIZE)
            bytes_to_copy = COPY_BUFFER_SIZE;
        else
            bytes_to_copy = last_offset;

        if (fread(copy_buffer, bytes_to_copy, 1, infile) != 1) {
            perror(argv[1]);
            goto error_out;
        }
        if (fwrite(copy_buffer, bytes_to_copy, 1, outfile) != 1) {
            perror(argv[2]);
            goto error_out;
        }

        last_offset -= bytes_to_copy;
    }

    fclose(infile);
    fclose(outfile);
    free(moov_atom);
    free(ftyp_atom);

    return 0;

error_out:
    if (infile)
        fclose(infile);
    if (outfile)
        fclose(outfile);
    free(moov_atom);
    free(ftyp_atom);
    return 1;
}
"
096-7537,dk00/old-stuff,csie/13parllel-programming/omp3-2-1.c,31,8,24,494785550.8653447,950293754.0,0.5206658971684665,1346.0,1323.0,50039305.0,50013402.0,3126699.0,3125673.0,1340.0,3125593.0,1500000000,0.3298570339102298,1082014363648.0,2.808605222085885e-06,0.0937436405393809,"#include<stdio.h>

#ifndef N
#define N 5000
#endif
#define M 1000000000

int a[N][N], b[N][N];

int main() {
  int i, j, sum;
  #pragma omp parallel sections private(i, j)
  {
    #pragma omp section
    {
      for (i = 0; i < N; i++)
        for (j = 0; j < N; j++)
          a[i][j] = i + j;
    }
    #pragma omp section
    {
      for (i = 0; i < N; i++)
        for (j = 0; j < N; j++)
          b[i][j] = i - j;
    }
  }
  sum = 0;
  for (i = 0; i < N; i++)
    for (j = 0; j < N; j++) {
      sum += a[i][j];
      sum %= M;
    }
  printf(""%d\n"", sum);
  sum = 0;
  for (i = 0; i < N; i++)
    for (j = 0; j < N; j++) {
      sum += b[i][j];
      sum %= M;
    }
  printf(""%d\n"", sum);
  return 0;
}

"
177-6116,sampost/ddd,ddd/sample.c,34,6,27,1776678.1384125,175215.0,10.139988014724766,1291.0,1273.0,39857.0,13575.0,1625.0,636.0,1348.0,593.0,1500000000,0.001184452092275,1082014363648.0,0.0146334503324487,0.078642012277287,"/* sample.c -- Sample C program to be debugged with DDD */

#include <stdio.h>
#include <stdlib.h>

static void shell_sort(int a[], int size)
{
    int i, j;
    int h = 1;
    do {
        h = h * 3 + 1;
    } while (h <= size);
    do {
        h /= 3;
        for (i = h; i < size; i++)
        {
            int v = a[i];
            for (j = i; j >= h && a[j - h] > v; j -= h)
                a[j] = a[j - h];
            if (i != j)
                a[j] = v;
        }
    } while (h != 1);
}

int main(int argc, char *argv[])
{
    int *a;
    int i;

    a = (int *)malloc((argc - 1) * sizeof(int));
    for (i = 0; i < argc - 1; i++)
        a[i] = atoi(argv[i + 1]);

    shell_sort(a, argc);

    for (i = 0; i < argc - 1; i++)
        printf(""%d "", a[i]);
    printf(""\n"");

    free(a);

    return 0;
}
"
092-6137,AreaScout/vice-gles2,src/arch/amigaos/x64ns.c,29,2,31,5137628.8756728005,170922.0,30.058318999309627,1211.0,1198.0,38875.0,13009.0,1575.0,593.0,1322.0,552.0,1500000000,0.0034250859171152,1082014363648.0,0.0140941482079545,0.07790455631794,"/*
 * x64ns.c - No Sound x64 launcher.
 *
 * Written by
 *  Marco van den Heuvel <blackystardust68@yahoo.com>
 *
 * This file is part of VICE, the Versatile Commodore Emulator.
 * See README for copyright notice.
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 *  02111-1307  USA.
 *
 */

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    return system(""x64.exe -sounddev dummy"");
}
"
214-29055,limadanillo/Lista_Estrutura_Dados_I,filaApontador.c,50,2,35,1874419.51129575,184255.0,10.17296138503704,1359.0,1337.0,41694.0,14972.0,1618.0,645.0,1341.0,600.0,1500000000,0.0012496130075305,1082014363648.0,0.0146318960136766,0.0741891081071542,"#include <stdio.h>
#include <stdlib.h>

#define true 1
#define false 0

typedef struct listasimples{
	int chave;
	struct listasimples *prox;
}lista;

typedef struct fila{
	lista *inicio;
	lista *fim;
}fila, *pfila;

void inicializar(fila *l);
_Bool enfileira(fila *l, int x);
_Bool desenfileira(fila *l, int *x);


int main(void) {
	fila topo;
	int i,x;

	inicializar(&topo);

	for(i=0; i < 11; i++)
		enfileira(&topo, i);

	for(i=0; i < 11; i++){
		desenfileira(&topo, &x);
		printf(""desempilhei %d\n"",x);
	}



	return EXIT_SUCCESS;
}


void inicializar(fila *l){
	l->inicio=NULL;
	l->fim=NULL;
}




_Bool enfileira(fila *l, int x){
	lista *novo;

	if(!(novo=(lista*)malloc(sizeof(lista))))
		return false;
	novo->chave=x;
	novo->prox=NULL;
	if(l->fim)
		l->fim->prox=novo;
	else
		l->inicio=novo;
	l->fim=novo;
	return true;
}

_Bool desenfileira(fila *l, int *x){
	lista *p;
	if(!(l->inicio))
		return false;
	p=l->inicio;
	*x=p->chave;
	l->inicio=p->prox;
	free(p);
	return true;
}

"
396-18017,nci-australia/ipm_nci,utest/flop.c,19,2,19,2699539.29819165,4170635.0,0.6472728972926185,1143.0,1135.0,38910.0,12872.0,1592.0,586.0,1332.0,546.0,1500000000,0.0017996928654611,1082014363648.0,0.0005461997993111,0.0783283766559808,"#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

unsigned long long int flags=0;

#define VERBOSE (1<<0)

int main(int argc, char *argv[]) {

 int i,n=1000000;
 double x=0.1;

 while(--argc && argv++) {
  if(!strcmp(""-v"",*argv)) {
   flags |= VERBOSE;
   printf(""VERBOSE "");
  } else if(!strcmp(""-n"",*argv)) {
    --argc; argv++;
    n = atoi(*argv);
  }
 }

 for(i=0;i<n;i++) {
  x+= 0.111111111111112;
 }
 
 if((int)(x)%32571 == 511) printf(""%d\n"", n);
 return 0;
}

"
290-12102,syntheticpp/metashell,3rd/templight/llvm/projects/compiler-rt/test/asan/TestCases/sleep_before_dying.c,8,1,17,1612683.05964765,172317.0,9.358815438987447,1233.0,1216.0,39072.0,13209.0,1592.0,630.0,1328.0,589.0,1500000000,0.0010751220397651,1082014363648.0,0.0142121787171317,0.0791683403148371,"// RUN: %clang_asan -O2 %s -o %t
// RUN: env ASAN_OPTIONS=""$ASAN_OPTIONS:sleep_before_dying=1"" not %run %t 2>&1 | FileCheck %s

#include <stdlib.h>
int main() {
  char *x = (char*)malloc(10 * sizeof(char));
  free(x);
  return x[5];
  // CHECK: Sleeping for 1 second
}
"
124-24511,dataBaseError/os_examples,bounded_notify.c,84,5,74,4475662.48476495,311195.0,14.382178376901942,1615.0,1578.0,69706.0,32996.0,1727.0,876.0,1398.0,831.0,1500000000,0.0029837749898433,1082014363648.0,0.0102604476292999,0.0470487429650834,"
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>

#include <pthread.h>

pthread_mutex_t mutex;
pthread_cond_t cond;

#define MAX_LENGTH 10
int buffer[MAX_LENGTH];

int duration = 20;
int length = 0;

void *producer(void *arg)
{
    char *str;

    str=(char*)arg;
    for(int i = 0; i < duration; i++) {

        // Request lock
        pthread_mutex_lock(&mutex);

        while(length == MAX_LENGTH) {
            printf(""Producer %s buffer full\n"", str);
            pthread_cond_wait(&cond, &mutex);
        }

        // Add an element to the buffer safely.
        buffer[length] = i;
        length++;
        printf(""Producer %s length %d\n"",str, length);

        // Signal the consumer thread a new element is available
        pthread_cond_signal(&cond);

        // Yield the lock.
        pthread_mutex_unlock(&mutex);

        // Simulate work.
        //usleep(1);
    }

    return NULL;
}

void *consumer(void *arg)
{
    char *str;

    str=(char*)arg;
    for(int i = 0; i < duration; i++) {

        // Request lock
        pthread_mutex_lock(&mutex);

        // Check if there elements in the buffer.
        while(length == 0) {
            printf(""Consumer %s buffer empty\n"", str);
            pthread_cond_wait(&cond, &mutex);
        }

        // Decrease the count.
        length--;

        // Add an element to the buffer safely.
        int temp = buffer[length];
        printf(""Consumer %s value %d\n"",str, temp);

        if(length+1 == MAX_LENGTH) {
            // Signal the producer thread that the buffer is not full anymore.
            printf(""Consumer %s buffer no longer full\n"", str);
            pthread_cond_signal(&cond);
        }

        // Yield the lock.
        pthread_mutex_unlock(&mutex);

        // Simulate work
        usleep(3);
    }

    return NULL;
}

/**
 * Example with two threads incrementing a shared variable
 * with a mutex.
 */
int main(int argc, char *argv[]) {

    pthread_t producer_thread;
    pthread_t producer_thread2;
    pthread_t consumer_thread;
    pthread_t consumer_thread2;

    // Initialize the mutex
    pthread_mutex_init(&mutex, NULL);

    // Create threads.
    pthread_create(&producer_thread, 0, producer, (void *) ""1"");
    pthread_create(&producer_thread2, 0, producer, (void *) ""2"");
    pthread_create(&consumer_thread, 0, consumer, (void *) ""1"");
    pthread_create(&consumer_thread2, 0, consumer, (void *) ""2"");

    //void ** retval;

    // wait for our thread to finish before continuing
    pthread_join(producer_thread, 0);
    pthread_join(producer_thread2, 0);
    pthread_join(consumer_thread, 0);
    pthread_join(consumer_thread2, 0);

    // Clean up the mutex
    pthread_mutex_destroy(&mutex);

    return 0;
}"
279-29319,mickael-guene/binutils,gdb/testsuite/gdb.base/step-break.c,24,2,26,1073465272.6678178,9663845478.0,0.1110805501230097,1139.0,1129.0,3221263925.0,2147496345.0,1567.0,588.0,1316.0,547.0,1500000000,0.7156435151118785,1082014363648.0,2.3468918301344558e-07,7.484036905972708e-07,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2008-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

int
main ()
{
    volatile int i = 1;

    while (i > 0) /* place1 */
      {
	i++; /* place2 */
	i++; /* place3, set breakpoint here  */
      }

    return 0;
}
"
108-21557,crystax/android-toolchain-gcc-5,gcc/testsuite/gcc.dg/graphite/isl-codegen-loop-dumping.c,12,3,37,1602047.8215067498,169056.0,9.47642792920689,1140.0,1130.0,38452.0,12696.0,1566.0,584.0,1317.0,544.0,1500000000,0.0010680318810045,1082014363648.0,0.0134275033125118,0.0784194885430515,"/* { dg-options ""-O2 -fgraphite-identity -fdump-tree-graphite-all"" } */

int
main (int n, int *a)
{
  int i, j;

  for (i = 0; i < n - 1; i++)
    for (j = 0; j < n; j++)
      a[j] = i + n;

  return 0;
}

/* { dg-final { scan-tree-dump-times ""ISL AST generated by ISL: \nfor \\(int c1 = 0; c1 < n - 1; c1 \\+= 1\\) {\n  S_10\\(c1\\);\n  for \\(int c3 = 0; c3 < n; c3 \\+= 1\\)\n    S_4\\(c1, c3\\);\n}"" 1 ""graphite""} } */
/* { dg-final { cleanup-tree-dump ""graphite"" } } */
"
366-21230,alexhilton/miscellaneous,linux/advanced-prog-in-unix/chap06/eg0601.c,16,1,27,1654683.0302103,171417.0,9.65296907541259,1145.0,1136.0,39101.0,12945.0,1594.0,586.0,1334.0,545.0,1500000000,0.0011031220201402,1082014363648.0,0.0133067315377121,0.0779887023018099,"/*
 * eg0601.c
 * implementation of getpwuid.
 * Using getpwent, setpwent and endpwent.
 */
#include <stdio.h>
#include <pwd.h>
#include <stdlib.h>

int main( int argc, char **argv ) {
  struct passwd *p;
  int uid;
  while ( --argc > 0 ) {
    uid = atoi( *++argv );
    p = getpwuid( uid );
    printf( ""%s, %d, %d, %s, %s, %s\n"", p->pw_name, p->pw_uid, p->pw_gid, p->pw_gecos,
	p->pw_dir, p->pw_shell );
  }
  return 0;
}
"
056-12867,Gurgel100/gcc,gcc/testsuite/gcc.dg/store_merging_27.c,23,1,43,1523221.61011395,170809.0,8.914225831191565,1138.0,1130.0,38910.0,12869.0,1587.0,589.0,1331.0,547.0,1500000000,0.0010154810734093,1082014363648.0,0.0132779888647553,0.0782942891905985,"/* PR tree-optimization/88709 */
/* { dg-do run } */
/* { dg-require-effective-target store_merge } */
/* { dg-options ""-O2 -fdump-tree-store-merging-details"" } */
/* { dg-final { scan-tree-dump ""New sequence of \[12] stores to replace old one of 3 stores"" ""store-merging"" } } */

struct S { char buf[8]; };

__attribute__((noipa)) void
bar (struct S *x)
{
  int i;
  for (i = 0; i < 8; i++)
    if (x->buf[i] != ((i == 1) + (i == 3) * 2))
      __builtin_abort ();
}

int
main ()
{
  __attribute__((aligned(8))) struct S s = {};
  s.buf[1] = 1;
  s.buf[3] = 2;
  bar (&s);
  return 0;
}
"
047-10569,mattstock/binutils-bexkat1,gdb/testsuite/gdb.base/save-bp.c,27,2,34,1310581.4578010999,169083.0,7.751110401400496,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0008737209718674,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* Copyright 2011-2020 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

void
break_me (void)
{
}

int
main (void)
{
  int i;
  break_me (); /* BREAK HERE.  */
  break_me (); /* Try a thread-specific breakpoint.  */

  for (i = 0; i < 5; i++)
    break_me (); /* Try a condition-specific breakpoint.  */

  break_me (); /* Finally, try a breakpoint with commands.  */
  return 0; /* Return line. */
}

"
384-12376,ericherman/code-snips,c/complex.c,26,1,51,1513983.00658905,187810.0,8.061248069857836,1471.0,1443.0,42357.0,15348.0,1638.0,640.0,1356.0,597.0,1500000000,0.0010093220043927,1082014363648.0,0.0155156807411745,0.0733212026687462,"/* complex.c
   Copyright (C) 2016, 2018 Eric Herman <eric@freesa.org>

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation, either version 3 of the
   License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

	https://www.gnu.org/licenses/lgpl-3.0.txt
	https://www.gnu.org/licenses/gpl-3.0.txt
 */
/* gcc -o complex complex.c -lm */
#include <stdio.h>
#include <complex.h>

char *url1 = ""https://mitpress.mit.edu/sicp/full-text/sicp/book/node43.html"";
char *url2 = ""http://en.cppreference.com/w/c/numeric/complex"";
int main(void)
{
	complex float z = 23.0 + 5.0 * I;

	printf(""z = %.1f + %.1fI\n"", creal(z), cimag(z));
	printf(""magnitue(z) = %f\n"", cabs(z));
	printf(""phase angle(z) = %f\n"", carg(z));
	printf(""thus %.1f%+.1fi cartesian as polar becomes rho=%f theta=%f\n"",
	       creal(z), cimag(z), cabs(z), carg(z));

	printf(""\nSee also:\n%s\n%s\n"", url1, url2);
}
"
323-9628,arvinddoraiswamy/Csec,cert_c_coding_standard/9_fileIO/31/fio31.c,25,1,32,4430227.6801317,176783.0,25.051181391875915,1378.0,1354.0,40176.0,13926.0,1624.0,648.0,1352.0,606.0,1500000000,0.0029534851200878,1082014363648.0,0.0154539746468834,0.0781856493290451,"//https://www.securecoding.cert.org/confluence/display/seccode/FIO31-C.+Do+not+open+a+file+that+is+already+open

#include <stdio.h>
 
void do_stuff(void) {
  /* Apparently opening a file, while it is already open can cause a problem. On Linux it does not seem to be a problem at all.
     So I'm not sure what exactly will happen.
  */
  FILE *logfile = fopen(""log"", ""a"");
  if (logfile == NULL) {
    printf(""Could not open file\n"");
  }
 
  /* Write logs pertaining to do_stuff() */
  fprintf(logfile, ""do_stuff\n"");
}
 
int main(void) {
  FILE *logfile = fopen(""log"", ""a"");
  if (logfile == NULL) {
    printf(""Could not open file\n"");
  }
 
  /* Write logs pertaining to main() */
  fprintf(logfile, ""main\n"");
 
  do_stuff();
 
  if (fclose(logfile) == EOF) {
    printf(""Could not close file\n"");
  }
  return 0;
}
"
231-22917,jeremiedecock/snippets,science/maths_c/estimating_pi_with_monte_carlo/pi.c,25,1,25,23730103.5085692,137924751.0,0.1720510845801708,1416.0,1391.0,40041812.0,15014040.0,1641.0,638.0,1360.0,595.0,1500000000,0.0158200690057128,1082014363648.0,2.0351677125739385e-05,7.690372315008402e-05,"/* 
 * Copyright (c) 2013 Jérémie Decock
 *
 * Usage: gcc pi.c
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

const unsigned long num_random_points = 1000000;

/*
 * Main
 */
int main(int argc, char * argv[])
{
    unsigned long inside_circle = 0;

    srand(getpid());

    unsigned long i;
    for(i=0 ; i<num_random_points ; i++) {
        double x = (double) rand() / (double) RAND_MAX;
        double y = (double) rand() / (double) RAND_MAX;

        if((x*x + y*y) <= 1.0) {
            inside_circle++;
        }
    }

    double pi = (double) inside_circle / (double) num_random_points * 4.0;
    printf(""pi=%f\n"", pi);

    return 0;
}
"
384-976,ColinIanKing/stress-ng,test/test-getresuid.c,24,1,24,1776842.9825081998,170790.0,10.403665319983606,1141.0,1132.0,38913.0,12868.0,1588.0,589.0,1330.0,547.0,1500000000,0.0011845619883388,1082014363648.0,0.0133087417296094,0.0782912651358606,"/*
 * Copyright (C) 2013-2021 Canonical, Ltd.
 * Copyright (C)      2022 Colin Ian King
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 */

#define _GNU_SOURCE
#include <unistd.h>

int main(void)
{
	gid_t ruid, euid, suid;

	return getresuid(&ruid, &euid, &suid);
}
"
082-18781,tendoasan/ProgrammingInC,chapter07/exce7.c,18,3,17,2536236.0756843,199240.0,12.729552298735191,1341.0,1321.0,44165.0,17359.0,1626.0,645.0,1345.0,602.0,1500000000,0.0016908240504562,1082014363648.0,0.0133607709295322,0.0685586112736493,"// °£À­ÍÐÉ«ÄáÉ¸Íø·¨(Sieve of Erastosthenes)²úÉú150ÒÔÄÚËùÓÐµÄÖÊÊý 
// ×¢ÒânºÍÊý×é³¤¶ÈÓ¦¸Ã·Ö¿ª¶¨Òå 
#include <stdio.h>

int main(void){
	int i, j, n = 150; 
	int P[151];
	
	// ³õÊ¼»¯Êý×é£¬ÖÊÊý´Ó2¿ªÊ¼ 
	for(i = 2; i < n; ++i){
		P[i] = 0;
	}

	for(i = 2; i < n; ++i){
		if(P[i] == 0)
			printf(""%i "", i);
		
		// É¸³ýµôËùÓÐ¿ÉÒÔ·Ö½â³ÉÁ½¸öÊýÏà³ËµÄÕûÊý£¬¼´É¸³ýËØÊý 
		for(j = 1; i * j <= n; ++j)
			P[i * j]  = 1;	
	}
	
	return 0;
}
"
302-32951,Gurgel100/gcc,gcc/testsuite/gcc.dg/pr93820.c,23,1,28,1787674.49688165,170815.0,10.465556303603314,1141.0,1133.0,38921.0,12873.0,1588.0,587.0,1332.0,547.0,1500000000,0.0011917829979211,1082014363648.0,0.0133126481866346,0.0782716144727188,"/* PR tree-optimization/93820 */
/* { dg-do run } */
/* { dg-options ""-O2 -fno-tree-dse"" } */

typedef int v4si __attribute__((vector_size(4 * sizeof (int))));
int a[10];

__attribute__((noipa)) int
foo (int *p)
{
  a[6] = *p;
  a[4] = 1;
  *(((v4si *)&a[0]) + 1) = (v4si) { 0, 0, 0, 0 };
  a[3] = 0;
}

int
main ()
{
  int i = 0;
  foo (&i);
  for (i = 0; i < 10; i++)
    if (a[i])
      __builtin_abort ();
  return 0;
}
"
257-13192,chr1573r/is213,ex3.c,26,4,32,2137623.145245,175798.0,12.15954106417593,1294.0,1277.0,39922.0,13580.0,1639.0,637.0,1357.0,594.0,1500000000,0.00142508209683,1082014363648.0,0.0146247397581314,0.0790063922844005,"#include <stdio.h> // we are doing input/output operations
#include <unistd.h> // POSIX, we are running this on a posix compliant system
#include <poll.h> //we want this for multiplexing blocks for stdin and stout
#define TIMEOUT 5 /* poll timeout, in seconds */
int main (void)
{
	 struct pollfd fds[2];
	 int ret;

	 /* watch stdin for input */
	 fds[0].fd = STDIN_FILENO;
	 fds[0].events = POLLIN;

	 /* watch stdout for ability to write (almost always true) */
	 fds[1].fd = STDOUT_FILENO;
	 fds[1].events = POLLOUT;

	 /* All set, block! */
	 ret = poll (fds, 2, TIMEOUT * 1000); // activate poll, timeout set if nothing happens with our fds
	 if (ret == -1) {
		 perror (""poll"");
		 return 1;
	 }
	 if (!ret) {
		 printf (""%d seconds elapsed.\n"", TIMEOUT);
		 return 0;
	 }
	 
	 if (fds[0].revents & POLLIN) // stdin is not blocked and available
	 	printf (""stdin is readable\n"");
	 if (fds[1].revents & POLLOUT) // stdout is not blocked and available
	 	printf (""stdout is writable\n"");

	 return 0;
}
"
124-33771,Heatwave/The-C-Programming-Language-2nd-Edition,chapter-5-pointers-and-arrays/21.atoi.c,23,2,30,1975189.5451916999,177521.0,11.126508976402793,1358.0,1334.0,40149.0,13885.0,1625.0,636.0,1345.0,594.0,1500000000,0.0013167930301278,1082014363648.0,0.0151644030847054,0.0777288373986749,"#include <stdio.h>
#include <ctype.h>

int main()
{
	printf(""%d\n"", atoi(""123""));
	printf(""%d\n"", atoi(""+1""));
	printf(""%d\n"", atoi(""-0""));
	printf(""%d\n"", atoi(""-123""));
	printf(""%d\n"", atoi(""asd345""));
	printf(""%d\n"", atoi(""789asd345""));

	return 0;
}

int atoi(char *s)
{
	int sign, n;

	while (isspace(*s))
		s++;

	sign = (*s == '-') ? -1 : 1;

	if (*s == '+' || *s == '-')
		s++;

	n = 0;
	while (isdigit(*s))
		n = 10 * n + (*s++ - '0');

	return sign * n;
}
"
384-29437,jindal25/interview-questions,recursion_dp/stairs_penalty/tests_generator.c,20,4,35,3277330.4264991,7249338.0,0.4520867974427458,1373.0,1352.0,1600583.0,1057234.0,1648.0,703.0,1363.0,658.0,1500000000,0.0021848869509994,1082014363648.0,0.0003758963921947,0.0016449590020682,"/* Tests generator for ""Stairs Penalty"" */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAX_N 5000
#define MIN_N 500
#define MAX_COST 10

int main(void) {
	srand(time(NULL));

	int n = (rand()%(MAX_N-MIN_N+1))+MIN_N;

	printf(""%d\n"", n);

	int i;

	printf(""%d"", (rand()%MAX_COST)+1);
	for (i = 1; i < n; i++)
		printf("" %d"", (rand()%MAX_COST)+1);
	printf(""\n"");

	printf(""%d"", (rand()%MAX_COST)+1);
	for (i = 1; i < n-1; i++)
		printf("" %d"", (rand()%MAX_COST)+1);
	printf(""\n"");

	printf(""%d"", (rand()%MAX_COST)+1);
	for (i = 1; i < n-1; i++)
		printf("" %d"", (rand()%MAX_COST)+1);
	printf(""\n\n"");

	return 0;
}
"
094-25350,bg1bgst333/Sample,c/rand/rand/src/rand/rand.c,20,1,75,1785062.8355517,247893.0,7.200937501260625,1371.0,1348.0,55683.0,23968.0,1636.0,640.0,1356.0,597.0,1500000000,0.0011900418903678,1082014363648.0,0.0109684420294239,0.0530941231120764,"/* ヘッダファイルのインクルード */
#include <stdio.h> /* 標準入出力 */
#include <stdlib.h> /* 標準ユーティリティ */

/* main関数の定義 */
int main(void){

  /* 変数の宣言 */
  int i; /* ループ用int型変数i */
  int r; /* 疑似乱数を格納するint型変数r.

  /* 0から99までの擬似乱数を発生させる. */
  for (i = 1; i <= 100; i++){ /* iが1から100まで繰り返す. */

    /* 0から99までの疑似乱数を取得. */
    r = rand() % 100; /* randの戻り値を100で割った余りをrに格納.(rは0から99までのどれかになる.) */

    /* rを出力. */
    printf(""%2d "", r); /* printfでrを2桁で出力し, 後ろにスペースを空ける. */

    /* iが10の倍数の時, 改行する. */
    if (i % 10 == 0){ /* 10の倍数の時. */
      printf(""\n""); /* printfで""\n""を出力して, 改行する. */
    }

  }

  /* プログラムの終了 */
  return 0; /* 0を返して正常終了. */

}
"
362-23373,heineman/algorithms-nutshell-2ed,Code/Chapter3/example3-3/sample.c,25,1,38,1854872.91309975,180854.0,10.25618454665089,1354.0,1334.0,40964.0,14375.0,1635.0,641.0,1354.0,598.0,1500000000,0.0012365819420665,1082014363648.0,0.0148628175213155,0.0764018142720323,"/**
 * @file sample.c    Program to show addresses in memory
 * @brief 
 *    Small program to show internal memory addresses.
 * 
 * @author George Heineman
 * @date 6/15/08
 */

#include <stdlib.h>

int f(char *newArray) {
  char temp[132];
  int i;

  for (i=0; i<132; i++) {
    newArray[i] = temp[i];
  }

  printf (""-----\n"");
  printf ("" newArray [%u] i [%u] j[%u]\n"", &newArray, &temp, &i);
}

int main (int argc, char **argv) {
  char *newArray  = (char *) malloc(132);
  int i = 17, j;

  f (newArray);

  printf (""-----\n"");
  printf ("" argc [%u] argv [%u]\n"", &argc, &argv);
  printf ("" newArray [%u] i [%u] j[%u]\n"", newArray, &i, &j);

}
"
163-23210,bg1bgst333/Sample,unixsyscall/difftime/difftime/src/difftime/difftime.c,26,1,101,109524999.16311345,741233401.0,0.1477604744365803,1433.0,1410.0,149055561.0,103981536.0,1638.0,698.0,1353.0,655.0,1500000000,0.0730166661087423,1082014363648.0,3.835499042763724e-06,1.7167443238569878e-05,"/* ヘッダファイルのインクルード */
#include <stdio.h> /* 標準入出力 */
#include <time.h> /* UNIX時間 */

/* main関数の定義 */
int main(void){

  /* 変数の宣言 */
  time_t start; /* 開始時刻start */
  time_t end; /* 終了時刻end */
  double elapsed; /* 経過時間elapsed */
  long i; /* ループ用変数i */

  /* 開始時刻のセット */
  start = time(NULL); /* timeで開始時刻を取得し, startに格納. */

  /* iが1000000になるまでループする. */
  for (i = 0; i != 1000000; i++){ /* iを0から足し続けて, 1000000になるまでループ. */

    /* iを出力 */
    printf(""i = %ld\n"", i); /* printfでiを出力. */

  }

  /* iが1000000の時. */
  printf(""i = %ld\n"", i); /* printfでi( = 1000000)を出力. */

  /* 終了時刻のセット */
  end = time(NULL); /* timeで終了時刻を取得し, endに格納. */

  /* 経過時間の計算 */
  elapsed = difftime(end, start); /* difftimeでstartとendの差である経過時間を計算し, elapsedに格納. */

  /* 経過時間の出力 */
  printf(""elapsed = %lf\n"", elapsed); /* printfで経過時間elapsedを出力. */

  /* プログラムの終了 */
  return 0;

}
"
149-1294,SanDisk-Open-Source/SSD_Dashboard,uefi/gcc/gcc-4.6.3/gcc/testsuite/gcc.dg/cpp/vararg1.c,12,2,20,1515981.0427575,169083.0,8.965898404925392,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.001010654028505,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* { dg-do run } */
/* { dg-options -w } */

/* count() used to give 1 owing to a buggy test for varargs.  */
#define count(y...)  count1 ( , ##y)
#define count1(y...) count2 (y,1,0)
#define count2(_,x0,n,y...) n
#if count() != 0 || count(A) != 1
#error Incorrect vararg argument counts
#endif

/* Test for changed behavior of the GNU varargs extension.
   ##args, where args is a rest argument which received zero tokens,
   used to delete the previous sequence of nonwhitespace characters.
   Now it deletes the previous token.  */

#include <string.h>

#define S(str, args...) ""  "" str ""\n"", ##args

int
main()
{
  const char *s = S(""foo"");
  return strchr (s, '\n') == NULL;
}
"
027-28157,crystax/android-toolchain-gcc-5,gcc/testsuite/gcc.dg/tree-prof/val-prof-6.c,20,1,35,1669802.93579385,255927.0,6.522023858365862,1153.0,1144.0,60946.0,31281.0,1599.0,606.0,1341.0,563.0,1500000000,0.0011132019571959,1082014363648.0,0.0089752155888202,0.0445531135133962,"/* { dg-options ""-O2 -fdump-tree-optimized"" } */
char a[1000];
char b[1000];
int size=1000;
__attribute__ ((noinline)) void
t(int size)
{
  __builtin_memcpy(a,b,size);
}
int
main()
{
  int i;
  for (i=0; i < size; i++)
    t(i);
  return 0;
}
/* { dg-final-use { scan-tree-dump ""Average value sum:499500"" ""optimized""} } */
/* { dg-final-use { scan-tree-dump ""IOR value"" ""optimized""} } */
/* { dg-final-use { cleanup-tree-dump ""optimized"" } } */
"
204-16834,anqurvanillapy/cppl,kwd/restrict.c,22,2,24,2095804.4333382,172248.0,12.16736333658446,1151.0,1144.0,39263.0,13027.0,1597.0,587.0,1336.0,546.0,1500000000,0.0013972029555588,1082014363648.0,0.0133238121777901,0.0777586536622681,"/**
 *  restrict
 *  ========
 *
 *  Like `register`, a dedicated keyword for optimization.
 */

#include <stdio.h>
#include <string.h>
#include <assert.h>

void
foo(int n, char* restrict src, char* restrict dst)
{
	while (n-- > 0) *dst++ = *src++;
}

int
main()
{
	char s[100];

	memset(s, 42, 50);
	memset(s + 50, 69, 50);

	foo(50, s, s + 50);
	// foo(50, s + 1, s);
	assert(s[50] == 42);

	return 0;
}
"
302-30255,Gurgel100/gcc,gcc/testsuite/gcc.misc-tests/gcov-1a.c,14,1,42,1498742.9603934,169083.0,8.863942560754186,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0009991619735956,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* Test Gcov basics.  */

/* { dg-options ""-fprofile-arcs -ftest-coverage -fprofile-abs-path"" } */
/* { dg-do run { target native } } */

void noop ()
{
}

int main ()
{
  int i;

  for (i = 0; i < 10; i++)	/* count(11) */
    noop ();			/* count(10) */

  return 0;			/* count(1) */
}

/* { dg-final { run-gcov gcov-1a.c } } */
"
220-9546,xinchoubiology/gcc,gcc/testsuite/gcc.dg/tree-prof/merge_block.c,21,2,44,1916058.01228425,169057.0,11.333798659623676,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0012773720081895,1082014363648.0,0.0134155935572026,0.0785563462891999,"
/* { dg-options ""-O2 -fno-ipa-pure-const -fdump-tree-optimized-blocks-details -fno-early-inlining"" } */
int a[8];
int t()
{
	int i;
	for (i = 0; i < 3; i++)
		if (a[i])
			break;
	return i;
}
int
main ()
{
  int i;
  /* The loop will be optimized away after ipa-inline.  */
  for (i = 0; i < 1000; i++)
    t ();
  return 0;
}
/* { dg-final-use { scan-tree-dump-not ""Invalid sum"" ""optimized""} } */
/* { dg-final-use { cleanup-tree-dump ""optimized"" } } */
"
101-103,zjcers/libsimplec,tests/math/fabsnegative.c,23,2,28,1443781.42431375,169061.0,8.540000354901485,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0009625209495425,1082014363648.0,0.0134152761429306,0.0785563462891999,"/*
 * tests/math/fabsnegative.c
 * Copyright 2016 Zane J Cersovsky
 * This file is part of Project Paxico.

 * Project Paxico is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.

 * Project Paxico is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with Project Paxico.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * Tests if fabs() works as expected for x<0.0
 */
#include <math.h>
int main(int argc, char const *argv[]) {
	if (fabs(-2.0) == 2.0) {
		return 0;
	}
	return 1;
}
"
374-20172,SanDisk-Open-Source/SSD_Dashboard,uefi/gcc/gcc-4.6.3/gcc/testsuite/gcc.misc-tests/gcov-9.c,10,1,32,1421435.9689503,169083.0,8.406729239485934,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0009476239793002,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* Test gcov block mode.  */

/* { dg-options ""-fprofile-arcs -ftest-coverage"" } */
/* { dg-do run { target native } } */

int main ()
{
  unsigned ix;
  
  for (ix = 10; ix--;); /* count(11) */

  return 0;
}

/* { dg-final { run-gcov { -a gcov-9.c } } } */
"
010-20618,AOSC-Dev/Anthon-Starter,testing/cpuid.c,25,3,37,2252327.7439176,173861.0,12.954756961020584,1272.0,1259.0,39542.0,13416.0,1616.0,634.0,1341.0,592.0,1500000000,0.0015015518292784,1082014363648.0,0.0145576063637043,0.0789871218701612,"#include <stdio.h>
 
int main() {
    int i;
    unsigned int index = 0;
    unsigned int regs[4];
    int sum;
    __asm__ __volatile__(
#if defined(__x86_64__) || defined(_M_AMD64) || defined (_M_X64)
        ""pushq %%rbx     \n\t"" /* save %rbx */
#else
        ""pushl %%ebx     \n\t"" /* save %ebx */
#endif
        ""cpuid            \n\t""
        ""movl %%ebx ,%[ebx]  \n\t"" /* write the result into output var */
#if defined(__x86_64__) || defined(_M_AMD64) || defined (_M_X64)
        ""popq %%rbx \n\t""
#else
        ""popl %%ebx \n\t""
#endif
        : ""=a""(regs[0]), [ebx] ""=r""(regs[1]), ""=c""(regs[2]), ""=d""(regs[3])
        : ""a""(index));
    for (i=4; i<8; i++) {
        printf(""%c"" ,((char *)regs)[i]);
    }
    for (i=12; i<16; i++) {
        printf(""%c"" ,((char *)regs)[i]);
    }
    for (i=8; i<12; i++) {
        printf(""%c"" ,((char *)regs)[i]);
    }
    printf(""\n"");
}"
058-8305,zhangrxiang/learn-c,linux/string/strchr.c,25,1,45,1739852.9453202,178853.0,9.7278323539443,1370.0,1345.0,40588.0,14097.0,1641.0,639.0,1357.0,596.0,1500000000,0.0011599019635468,1082014363648.0,0.0151800640749665,0.0774069671756423,"//
// Created by zing on 2018/2/12.
//

#include <string.h>
#include <stdio.h>

/* Find the first occurrence of C in S.  */
int main() {
    char str[] = ""I love this world!"";
    char *p = strchr(str, 'I');
    printf(""%s\n"", p);//字符串 I love this world!
    printf(""%c\n"", *p);//字符值 I
    printf(""%d\n"", (int) (p - str));//索引 0
    p = strchr(str, 'l');
    printf(""%s\n"", p);//字符串 love this world!
    printf(""%c\n"", *p);//字符值 l
    printf(""%d\n"", (int) (p - str));//索引 2

    const char *str2 = ""Try not. Do, or do not. There is no try."";
    char target = 'T';
    const char *result = str2;

    while ((result = strchr(result, target)) != NULL) {
        //Found 'T' starting at 'Try not. Do, or do not. There is no try.'
        //Found 'T' starting at 'There is no try.'
        printf(""Found '%c' starting at '%s'\n"", target, result);
        ++result;
    }
    return 0;
}"
245-28302,luisedware/Learning-C,CPrimerPlus/10/10.1/day_mon1.c,17,2,21,2323009.53939555,200252.0,11.600428460140224,1362.0,1342.0,44705.0,16778.0,1637.0,643.0,1355.0,601.0,1500000000,0.0015486730262637,1082014363648.0,0.0135029862373409,0.0688970935055218,"/* day_mon1.c -- 打印每月的天数 */
#include <stdio.h>
#define MONTHS 12

/* 使用只读数组，不向数组写入数据，可以使用关键字const进行初始化 */
const int months[MONTHS] = {31,28,31,30,31,30,31,31,30,31,30,31};

int main(int argc, char const *argv[])
{
	int days[MONTHS] = {31,28,31,30,31,30,31,31,30,31,30,31};
	int index;

	for(index = 0;index < MONTHS; index++){
		printf(""Month %d has %2d days\n"",index+1,days[index] );
	}

	printf(""==========分割线==========\n"");

	for (int i = 0; i < MONTHS; i++)
	{
		printf(""Months %d has %2d days\n"",i+1,months[i] );
	}
	return 0;
}
"
377-26933,Hellybean/SaberMod_ROM_Toolchain,gcc/testsuite/c-c++-common/ubsan/shift-1.c,27,6,62,1878858.07827105,169089.0,11.111651260578748,1142.0,1132.0,38461.0,12699.0,1568.0,585.0,1317.0,546.0,1500000000,0.0012525720521807,1082014363648.0,0.013448538935117,0.0784988272087568,"/* { dg-do run } */
/* { dg-options ""-fsanitize=shift -w"" } */

typedef const unsigned long long int CULLI;
typedef volatile int VI;
struct s { signed long int a; };

int
main (void)
{
  int a = 1;
  struct s s = { .a = 400 };
  CULLI culli = 42;
  VI vi = 370;
  volatile int shiftcount = 153;

  a <<= 152;
  1 << shiftcount;
  1 << 154;
  culli << 524;
  1 << vi++;
  (long) 1 << (s.a + 2);

  return 0;
}
/* { dg-output ""shift exponent 152 is too large for \[^\n\r]*-bit type int(\n|\r\n|\r)"" } */
/* { dg-output ""\[^\n\r]*shift exponent 153 is too large for \[^\n\r]*-bit type int(\n|\r\n|\r)"" } */
/* { dg-output ""\[^\n\r]*shift exponent 154 is too large for \[^\n\r]*-bit type int(\n|\r\n|\r)"" } */
/* { dg-output ""\[^\n\r]*shift exponent 524 is too large for \[^\n\r]*-bit type long long unsigned int(\n|\r\n|\r)"" } */
/* { dg-output ""\[^\n\r]*shift exponent 370 is too large for \[^\n\r]*-bit type int(\n|\r\n|\r)"" } */
/* { dg-output ""\[^\n\r]*shift exponent 402 is too large for \[^\n\r]*-bit type long int(\n|\r\n|\r)"" } */
"
283-26441,goblint/analyzer,tests/regression/00-sanity/26-strict-loop-enter.c,18,2,26,1795606.57124955,169101.0,10.6185415816583,1142.0,1132.0,38461.0,12697.0,1567.0,584.0,1317.0,544.0,1500000000,0.0011970710474997,1082014363648.0,0.0134475845796299,0.078423706947105,"//PARAM: --disable ana.int.def_exc --enable ana.int.interval --sets solver slr3tp --enable dbg.debug
// dbg.debug manually enabled since update_suite only enables it when it sees normal assertion (without NOWARN)
#include <assert.h>

int g = 0;

int main() {
  int x;

  for(x=0; x < 50; x++){
    g = 1;
  }
  // x = [50, 50] after narrow
  if(x>50){ // live after widen, but dead after narrow
    // node after Pos(x>50) is marked dead at the end
    // but the loop is not with x = [51,2147483647]
    for(int i=0; i<=0; i--){
      g = 57;
    }
    assert(1); // NOWARN (unreachable)
  }
}"
048-13106,endlessm/chromium-browser,third_party/llvm/llvm/test/tools/llvm-cov/binary-formats.c,9,1,93,1843098.08537355,169061.0,10.901970294745684,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0012287320569157,1082014363648.0,0.0134152761429306,0.0785563462891999,"// Checks for reading various formats.

// CHECK: [[@LINE+1]]| 100|int main
int main(int argc, const char *argv[]) {}

// RUN: llvm-profdata merge %S/Inputs/binary-formats.proftext -o %t.profdata
// RUN: llvm-cov show %S/Inputs/binary-formats.macho32l -instr-profile %t.profdata -path-equivalence=/tmp,%S %s | FileCheck %s
// RUN: llvm-cov show %S/Inputs/binary-formats.macho64l -instr-profile %t.profdata -path-equivalence=/tmp,%S %s | FileCheck %s
// RUN: llvm-cov show %S/Inputs/binary-formats.macho32b -instr-profile %t.profdata -path-equivalence=/tmp,%S %s | FileCheck %s
// RUN: llvm-cov show %S/Inputs/binary-formats.v3.macho64l -instr-profile %t.profdata -path-equivalence=/tmp,%S %s | FileCheck %s

// RUN: llvm-cov export %S/Inputs/binary-formats.macho64l -instr-profile %t.profdata | FileCheck %S/Inputs/binary-formats.canonical.json
"
362-20135,Rapier-Foundation/rapier-script,src/rapierlang/test/CodeGen/debug-info-gline-tables-only2.c,11,1,32,1539051.18349935,169049.0,9.104170980011713,1138.0,1128.0,38452.0,12696.0,1568.0,580.0,1319.0,544.0,1500000000,0.0010260341223329,1082014363648.0,0.0134043975415412,0.0784194885430515,"// RUN: %clang_cc1 %s -gline-tables-only -S -emit-llvm -o - | FileCheck %s
// Checks that clang with ""-gline-tables-only"" emits metadata for
// compile unit, subprogram and file.

int main() {
  // CHECK: ret i32 0, !dbg
  return 0;
}

// CHECK: !llvm.dbg.cu = !{!0}
// CHECK: DW_TAG_compile_unit
// CHECK: {{.*main.* DW_TAG_subprogram}}
// CHECK: DW_TAG_file_type
"
323-15077,Izalena/ProgI.2016.Manh-,tabela.c,12,1,68,1947002.9510557498,251543.0,7.740235267926359,1347.0,1328.0,55551.0,24756.0,1626.0,648.0,1346.0,606.0,1500000000,0.0012980019673705,1082014363648.0,0.010634364701065,0.0526230590110451,"#include<stdio.h>

int main()
{
   char num;
   printf(""\n********************************\n"");
   printf(""\nTABELA ASCII\n"");
   printf(""\n********************************\n"");
   
   for(num = 33; num <= 126; num++)
   {
      printf(""\n %d \t %c"", num, num);
   }
   return 0;
}"
008-29214,krichter722/gcc,gcc/testsuite/gcc.dg/ipa/vrp1.c,26,1,33,1682718.05159745,169083.0,9.952023562392435,1142.0,1132.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0011218120343983,1082014363648.0,0.0134490161636592,0.0785049652044725,"/* { dg-do compile } */
/* { dg-options ""-O2 -fdump-ipa-cp-details"" } */

static __attribute__((noinline, noclone))
int foo (int i)
{
  if (i < 5)
    __builtin_abort ();
  return 0;
}

static __attribute__((noinline, noclone))
int bar (int j)
{
  if (j > 8)
    return foo (j + 2);
  else if (j > 2)
    return foo (j + 3);

  return 0;
}

int main ()
{
  for (unsigned int i =0; i < 1000; ++i)
    bar (i);

  return 0;
}

/* { dg-final { scan-ipa-dump ""Setting value range of param 0 \\\[6,"" ""cp"" } } */
/* { dg-final { scan-ipa-dump ""Setting value range of param 0 \\\[0, 999\\\]"" ""cp"" } } */
"
138-21420,ShooShoSha/Course-Work,COP3014/Chapters/5/Exercises/3/ex5-3.c,13,1,25,2065369.7429224502,187366.0,11.0231792320912,1360.0,1339.0,42163.0,15224.0,1629.0,639.0,1349.0,597.0,1500000000,0.0013769131619483,1082014363648.0,0.0144049614124227,0.0734312649206266,"#include <stdio.h>

int main ()
{
	int n, triangularNumber;
	
	printf(""Table of Triangular Numbers\n"");
	printf("" n  Triangular Value\n"");
	printf(""--- ----------------\n"");

	for (n = 5; n <= 50; n+=5)
	{
		triangularNumber = n * (n + 1) / 2;
		printf(""%3i %16i\n"", n, triangularNumber);
	}

	return 0;
}
"
109-6537,Surge1223/gcc-4.9.3-bionic,gcc/testsuite/gcc.target/i386/patch-functions-8.c,25,4,48,1533319.3587138,169061.0,9.06634291764511,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0010222129058092,1082014363648.0,0.0134152761429306,0.0785563462891999,"/* Verify -mpatch-functions-for-instrumentation works.  */
/* { dg-do run } */
/* { dg-require-effective-target lp64 } */

/* -O2 forces a sibling call for foo from bar.  */
/* { dg-options ""-O2 -mpatch-functions-for-instrumentation --param function-patch-min-instructions=0"" } */

__attribute__ ((noinline))
int foo()
{
  /* Dummy loop.  */
  int x = 10;
  int y = 100;
  while (--x)
    ++y;
  return y;
}

__attribute__ ((noinline))
int bar()
{
  return foo();
}

int main()
{
  bar();
  return 0;
}
"
381-1411,TixLo/BasicSample,src/reverse-string-bitwise/reverse-bitwise.c,18,1,34,2899132.668972,175821.0,16.489111084568965,1328.0,1309.0,39822.0,13596.0,1628.0,639.0,1348.0,594.0,1500000000,0.001932755112648,1082014363648.0,0.0149982084051393,0.0787936650567224,"#include <stdio.h>
#include <string.h>

void reverse_string_bitwise(char *input)
{
	int i = 0;
	for (i=0 ; i<strlen(input)/2 ; i++)
	{
		*(input + i) = *(input + i) ^ *(input + strlen(input) - i - 1);
		*(input + strlen(input) - i - 1) = *(input + i) ^ *(input + strlen(input) - i - 1);
		*(input + i) = *(input + i) ^ *(input + strlen(input) - i - 1);
	}
}

int main(int argc, char **argv)
{
	 char input[] = ""the sky is blue"";

	printf(""[before] input : %s\n"",input);
	reverse_string_bitwise(input);
	printf(""[after]  input : %s\n"",input);

	return 0;
}"
244-3752,bg1bgst333/Sample,unixsyscall/handler/handler/src/handler/handler.c,19,1,71,15002532420.214266,176940.0,84788.81213970837,1310.0,1292.0,40298.0,13863.0,1632.0,642.0,1350.0,599.0,1500000000,10.001688280142844,1082014363648.0,0.0147055499039222,0.0779712339137017,"/* ヘッダファイルのインクルード */
#include <stdio.h> /* 標準入出力 */
#include <unistd.h> /* UNIX標準 */
#include <signal.h> /* シグナル */

/* シグナルハンドラhandlerの定義 */
void handler(int sig){

  /* 受け取ったシグナル定数を出力. */
  printf(""sig = %d\n"", sig); /* sigを出力. */

}
 
/* main関数の定義 */
int main(){

  /* 変数の宣言 */
  int i; /* ループ用変数i. */

  /* シグナルハンドラをセット. */
  signal(SIGINT, handler); /* signalでhandlerをセット. */
  for (i = 0; i < 10; i++){ /* 10回繰り返す. */
    printf(""process running...(signal(SIGINT, handler))\n""); /* ""process running...(signal(SIGINT, handler))""を出力. */
    sleep(1); /* 1秒休止. */
  }

  /* プログラムの終了. */
  return 0; /* 0を返して正常終了. */

}
"
384-8346,zhuyue1314/pathgrind,valgrind-r12356/memcheck/tests/pdb-realloc.c,23,7,40,1686033.0943017001,176354.0,12.662854259047144,1232.0,1216.0,40057.0,13210.0,1609.0,636.0,1342.0,594.0,1500000000,0.0011240220628678,1082014363648.0,0.0138811708268596,0.0784913736459721,"// This test-case exposes a bug that was present in the compressed V bit
// handling for a while.  The problem was that when
// copy_address_range_state() copied a VA_BITS2_OTHER value, it failed to
// also copy the corresponding entry in the sec-V-bits table.  Then later on
// when we searched for the sec-V-bits entry for the copied-to location, it
// failed to find it:
//
//   Memcheck: mc_main.c:766 (get_sec_vbits8): Assertion 'n' failed.
//   Memcheck: get_sec_vbits8: no node for address 0x4017440 (0x4017441)

#include <stdlib.h>

int main(void)
{
   int i, t;
   char* x = malloc(1000);

   // Write some PDBs (partially defined bytes)
   for (i = 0; i < 1000; i++)
      x[i] &= (i & 0xff);

   // realloc them, invoking copy_address_range_state()
   x = realloc(x, 10000);

   // Read the PDBs -- this caused a sec-V-bits lookup failure.
   for (i = 0; i < 1000; i++)
      t += x[i];
   
   return 0;
}

"
176-25465,sfrankl85/DynamoRIO-ARM,functional_tests/ft_1/fib.c,27,1,165,1535788.5276898502,172998.0,8.877489913178188,1333.0,1315.0,39163.0,13297.0,1617.0,636.0,1340.0,593.0,1500000000,0.0010238590184599,1082014363648.0,0.0153065353356686,0.0797941288600838,"/******************************************************************************

   MSc Adv. Computer Science: Computer Systems Engineering,
   Steven Frankl: 7247890,
   Functional Test 1: ft_1

   Test program based on Bruening fib.c program. Removed recursion and
   put fib function into a loop. Should test program loading and execution.

******************************************************************************/
   
#include <stdio.h>

int fib(int n) 
{
  double prev = -1;
  double result = 1;
  double sum;
  int i;
        
  for(i = 0;i <= n;++ i)
  {
    sum = result + prev;
    prev = result;
    result = sum;
  }
        
  return result;
}

int
main(int argc, char** argv) 
{
  int i, t;
    
  printf( ""%d\n"" , fib(5));

}

"
376-14507,asheemchhetri/C-programming,programs/ch1/q33.c,14,1,35,1771082.8687995,177023.0,10.004812933912543,1307.0,1290.0,40018.0,13927.0,1616.0,636.0,1339.0,593.0,1500000000,0.001180721912533,1082014363648.0,0.0146704100597097,0.0775604782648994,"/* Program solution for question 33, from the book.
*  Author: Asheem Chhetri
*  Date: Aug 11, 2015
*  Change log:
*  <Date>: Change description
*/

#define STAR '*'
#include <stdio.h>
#include <stdlib.h>

int main(int argc,char **argv)
{
	printf(""%c%c%c%c%c%c\n"",STAR,STAR,STAR,STAR,STAR,STAR);
	printf(""%c%c%c%c%c%c\n"",STAR,STAR,STAR,STAR,STAR,STAR);
	printf(""%c%c%c%c%c%c\n"",STAR,STAR,STAR,STAR,STAR,STAR);
	printf(""%c%c%c%c%c%c\n"",STAR,STAR,STAR,STAR,STAR,STAR);
	return 0;
}
"
396-12547,canercandan/myproof,plugin/test/t-timer1.c,38,1,41,198715696.4605674,170853.0,1163.0799342124517,1157.0,1149.0,38831.0,12899.0,1577.0,586.0,1323.0,546.0,1500000000,0.1324771309737116,1082014363648.0,0.0134969827863719,0.0779431664411366,"// -*- mode: c++; c-indent-level: 4; c++-member-init-indent: 8; comment-column: 35; -*-

/* This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2
 * as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 * Authors:
 * Caner Candan <caner@candan.fr>, http://caner.candan.fr
 * Aurèle Mahéo <aurele.maheo@gmail.com>
 */

#pragma myproof instrumente (func1, func2, func3)
#pragma myproof instrumente (func4, func5)
#pragma myproof instrumente func6
#pragma myproof instrumente (func11, func111)
#pragma myproof instrumente (func21, func22)

void func111() { usleep(100000); }
void func11() { usleep(5000); func111(); }
void func1() { usleep(10000); func11(); }

void func22() { usleep(3000); }
void func21() { usleep(3000); }
void func2() { usleep(1000); func21(); func22(); }

void func3() { usleep(5000); }
void func4() { usleep(1000); }
void func5() { usleep(2000); }
void func6() { usleep(3); }

int main(void)
{
    func1();
    func2();
    func3();
    func4();
    func5();
    func6();

    return 0;
}
"
335-19931,ashishkrishan1995/dataStructures,Sorting/countingSort.c,30,4,26,1523461.54209225,180023.0,8.462590891163908,1362.0,1339.0,40781.0,14211.0,1633.0,641.0,1353.0,596.0,1500000000,0.0010156410280615,1082014363648.0,0.0150036384239791,0.0767929880709921,"#include <stdlib.h>
#include <stdio.h>

// sort an array of int
void countingSort
    (int *vector,       // vector
     int len,           // vector size
     int maxElement)    // the biggest element of the vector
{
    int *count, i, j;
    count = (int*) malloc(sizeof(int) * (maxElement + 1));

    if (count == NULL) { 
        return;
    }

    for (i = 0; i < len; i++) {
        count[vector[i]]++;
    }

    for (j = 0, i = 0; i < len; j++) {
        while (count[j]-- > 0) {
            vector[i++] = j;
        }
    }
    free(count);
}

int main() {
    int vector[] = {20,12,7,2,10,35}, len = 6, max = 35, i;
    countingSort(vector, len, max);
    for (i = 0; i < len; i++) {
        printf(""%d "", vector[i]);
    }
    printf(""\n"");
    return 0;
}"
048-33667,mattstock/binutils-bexkat1,gdb/testsuite/gdb.base/foll-vfork.c,37,1,33,2308669.5000528,178172.0,12.957529802662595,1331.0,1311.0,40566.0,13877.0,1658.0,659.0,1371.0,595.0,1500000000,0.0015391130000352,1082014363648.0,0.0148283680937521,0.0786694340870268,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 1997-2020 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <stdio.h>
#include <unistd.h>

#include <limits.h>
#include <string.h>

int
main (int argc, char ** argv)
{
  int  pid;

  /* A statement before vfork to make sure a breakpoint on main isn't
     set on vfork below.  */
  pid = 1 + argc;
  pid = vfork (); /* VFORK */
  if (pid == 0) {
    char prog[PATH_MAX];
    int len;

    strcpy (prog, argv[0]);
    len = strlen (prog);
    /* Replace ""foll-vfork"" with ""vforked-prog"".  */
    memcpy (prog + len - 10, ""vforked-prog"", 12);
    prog[len + 2] = 0;

    printf (""I'm the child!\n"");
    execlp (prog, prog, (char *) 0);
    perror (""exec failed"");
    _exit (1);
  }
  else {
    printf (""I'm the proud parent of child #%d!\n"", pid);
  }
}
"
031-6688,acarno/slicer,valgrind/massif/tests/deep.c,32,3,53,1827992.8481205,169083.0,10.811211062022794,1143.0,1133.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.001218661898747,1082014363648.0,0.0134608446739175,0.0785049652044725,"// This is a test for complicated stack traces.
//
// - In deep-A.vgtest, the stack trace is larger than the asked-for depth
//   (12 vs. 8) so not all of the trace is shown.
// - In deep-B.vgtest, we have --alloc-fn=a6..a12, which means that get_XCon
//   needs to redo the IP getting, because 7 functions get removed from the
//   trace, which is more than the initial overestimate of 3.
// - In deep-C.vgtest, we have --alloc-fn=a3..a12, which means that get_XCon
//   ends up with an empty stack trace after removing all the alloc-fns.
//   It then redoes it. 
// - In deep-D.vgtest, we have --alloc-fn=main..a12, which means we have a
//   stack trace with a single ""(below main)"" entry.

#include <stdlib.h>

void a12(int n) { malloc(n); }
void a11(int n) { a12(n); }
void a10(int n) { a11(n); }
void a9 (int n) { a10(n); }
void a8 (int n) { a9 (n); }
void a7 (int n) { a8 (n); }
void a6 (int n) { a7 (n); }
void a5 (int n) { a6 (n); }
void a4 (int n) { a5 (n); }
void a3 (int n) { a4 (n); }
void a2 (int n) { a3 (n); }
void a1 (int n) { a2 (n); }

int main(void)
{
   int i;

   // This one exceeds the default --depth.
   for (i = 0; i < 10; i++)
      a1(400);    // divisible by 16 -- no slop

   return 0;
}
"
061-22741,srjek/gdb-dcpu16,gdb/testsuite/gdb.arch/i386-pseudo.c,40,2,52,1599911.8331818501,172479.0,15.332063613541358,1290.0,1272.0,39025.0,13225.0,1605.0,637.0,1332.0,593.0,1500000000,0.0010666078887879,1082014363648.0,0.0148539822239229,0.0797511961722488,"/* Test program for byte registers.

   Copyright 2010-2012 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <stdio.h>

int data[] = {
  0x14131211,
  0x24232221,
  0x34333231,
  0x44434241,
};

int
main (int argc, char **argv)
{
  asm (""mov 0(%0), %%eax\n\t""
       ""mov 4(%0), %%ebx\n\t""
       ""mov 8(%0), %%ecx\n\t""
       ""mov 12(%0), %%edx\n\t""
       : /* no output operands */
       : ""r"" (data) 
       : ""eax"", ""ebx"", ""ecx"", ""edx"");
  asm (""nop""); /* first breakpoint here */

  asm (""mov %%eax, 0(%0)\n\t""
       ""mov %%ebx, 4(%0)\n\t""
       ""mov %%ecx, 8(%0)\n\t""
       ""mov %%edx, 12(%0)\n\t""
       : /* no output operands */
       : ""r"" (data) 
       : ""eax"", ""ebx"", ""ecx"", ""edx"");
  puts (""Bye!""); /* second breakpoint here */

  return 0;
}
"
105-4320,Gurgel100/gcc,gcc/testsuite/gcc.dg/pr97459-5.c,32,3,46,19956453.0048519,72316673.0,0.2759592245069128,1692.0,1661.0,13051384.0,9690347.0,2044.0,820.0,1507.0,778.0,1500000000,0.0133043020032346,1082014363648.0,4.6365517949090383e-05,0.0002264119648587,"/* PR rtl-optimization/97459 */
/* { dg-do run } */
/* { dg-options ""-O2"" } */
/* { dg-additional-options ""-DEXPENSIVE"" { target run_expensive_tests } } */

#ifdef __SIZEOF_INT128__
typedef __uint128_t T;
#else
typedef unsigned long long T;
#endif

T __attribute__((noipa)) foo (T x, T n, T *r) { *r = x % n; return x / n; }
#define C(n) T __attribute__((noipa)) foo##n (T x, T *r) { *r = x % (n - 10000); return x / (n - 10000); }

#define C1(n) C(n##1) C(n##3) C(n##5) C(n##7) C(n##9)
#define C2(n) C1(n##0) C1(n##1) C1(n##2) C1(n##3) C1(n##4) \
	      C1(n##5) C1(n##6) C1(n##7) C1(n##8) C1(n##9)
#ifdef EXPENSIVE
#define C3(n) C2(n##0) C2(n##1) C2(n##2) C2(n##3) C2(n##4) \
	      C2(n##5) C2(n##6) C2(n##7) C2(n##8) C2(n##9)
#define C4(n) C3(n##0) C3(n##1) C3(n##2) C3(n##3) C3(n##4) \
	      C3(n##5) C3(n##6) C3(n##7) C3(n##8) C3(n##9)
#else
#define C3(n) C2(n##0) C2(n##4) C2(n##9)
#define C4(n) C3(n##0) C3(n##3) C3(n##7)
#endif
#define TESTS C4(1) C1(10010) C1(10012) C1(16144)

TESTS

struct S { T x; T (*foo) (T, T *); };

#undef C
#define C(n) { n - 10000, foo##n },

struct S tests[] = {
TESTS
  { 0, 0 }
};

int
main ()
{
  int i, j, k;
  for (k = 0; tests[k].x; k++)
    for (i = 0; i < sizeof (T) * __CHAR_BIT__; i++)
      for (j = -5; j <= 5; j++)
	{
	  T x = ((T) 1 << i) + j;
	  T r1, r2;
	  if (foo (x, tests[k].x, &r1) != tests[k].foo (x, &r2)
	      || r1 != r2)
	    __builtin_abort ();
	}
  return 0;
}
"
033-912,GHackAnonymous/Ejercicios-SistemasOperativos,Demos/01creatingThreads/01creatingThreads.c,38,3,36,15002975420.909933,207069.0,72453.99079533874,1521.0,1486.0,47644.0,18960.0,1672.0,742.0,1375.0,697.0,1500000000,10.001983613939956,1082014363648.0,0.0145217294718185,0.0673533121133865,"#include <stdio.h>
#include <unistd.h>
#include <pthread.h>

void* threadMainFunction1(void*);
void* threadMainFunction2(void*);

int main()
{
  pthread_t idThread1, idThread2, idThread3; //creamos las variables para los hilos

  printf(""creating threads ......\n"");
  pthread_create(&idThread1, NULL, threadMainFunction1, (void*) 1); //creamos los hilos y les decimos en que variable tiene que estar
  pthread_create(&idThread2, NULL, threadMainFunction1, (void*)2); // el (void*)2 es el atributo que se le pasa al a funcion que se crea abajo
  pthread_create(&idThread3, NULL, threadMainFunction2, (void*)""kuku"");
  pthread_join (idThread1, NULL); // es buena practica cerrar los hilos, sobre todo en esta clase
  pthread_join (idThread2, NULL);
  pthread_join (idThread3, NULL);
  printf(""Threads finished. Main going to finish \n"");
  return 0;
}

void *threadMainFunction1 (void *arg) // este argumeto no es un void real ya que luego se castea a int. Realmente es un int
{
  int i, j,  n = (int) arg;
  
  for (i=0;i<10;i++)
  {
    sleep(1); //en segundos
    for(j=0;j<n;j++) printf(""\t\t"");
    printf ("" ...... %d ...........\n"", n);
  }
  return NULL;
}

void *threadMainFunction2 (void *arg) 
// este argumeto no es un void real ya que luego se castea a char (string). tiene que ser del tipo del dato que le pones cuando lo creas
{
  int i;
  char* pStr= (char*)arg;
  
  for(i=0;i<5;i++)
  {
    sleep(2);
    printf(""%s\n"", pStr);
  }
  return NULL;
}
"
024-5866,execunix/vinos,sys/external/bsd/compiler_rt/dist/test/builtins/Unit/extebdsfdf2vfp_test.c,35,2,198,1806932.96715615,172488.0,10.472241547238069,1289.0,1271.0,39023.0,13223.0,1607.0,633.0,1334.0,591.0,1500000000,0.0012046219781041,1082014363648.0,0.0148416121701219,0.0797190215518891,"//===-- extendsfdf2vfp_test.c - Test __extendsfdf2vfp ---------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file tests __extendsfdf2vfp for the compiler_rt library.
//
//===----------------------------------------------------------------------===//

#include <stdio.h>
#include <stdlib.h>
#include <math.h>


extern double __extendsfdf2vfp(float a);

#if __arm__
int test__extendsfdf2vfp(float a)
{
    double actual = __extendsfdf2vfp(a);
    double expected = a;
    if (actual != expected)
        printf(""error in test__extendsfdf2vfp(%f) = %f, expected %f\n"",
               a, actual, expected);
    return actual != expected;
}
#endif

int main()
{
#if __arm__
    if (test__extendsfdf2vfp(0.0))
        return 1;
    if (test__extendsfdf2vfp(1.0))
        return 1;
    if (test__extendsfdf2vfp(-1.0))
        return 1;
    if (test__extendsfdf2vfp(3.1415926535))
        return 1;
#else
    printf(""skipped\n"");
#endif
    return 0;
}
"
223-23617,execunix/vinos,sys/external/bsd/compiler_rt/dist/test/builtins/Unit/floatunssisfvfp_test.c,37,2,195,1539527.9042422501,172527.0,8.923397497203336,1291.0,1274.0,39032.0,13223.0,1606.0,633.0,1333.0,591.0,1500000000,0.0010263519361615,1082014363648.0,0.0148672381714166,0.0796670175102861,"//===-- floatunssisfvfp_test.c - Test __floatunssisfvfp -------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file tests __floatunssisfvfp for the compiler_rt library.
//
//===----------------------------------------------------------------------===//

#include <stdio.h>
#include <stdlib.h>
#include <math.h>


extern float __floatunssisfvfp(unsigned int a);

#if __arm__
int test__floatunssisfvfp(unsigned int a)
{
    float actual = __floatunssisfvfp(a);
    float expected = a;
    if (actual != expected)
        printf(""error in test__floatunssisfvfp(%u) = %f, expected %f\n"",
               a, actual, expected);
    return actual != expected;
}
#endif

int main()
{
#if __arm__
    if (test__floatunssisfvfp(0))
        return 1;
    if (test__floatunssisfvfp(1))
        return 1;
    if (test__floatunssisfvfp(0x7FFFFFFF))
        return 1;
    if (test__floatunssisfvfp(0x80000000))
        return 1;
    if (test__floatunssisfvfp(0xFFFFFFFF))
        return 1;
#else
    printf(""skipped\n"");
#endif
    return 0;
}
"
159-6660,sdruix/AutomaticParallelization,omp2mpiExamples/polybench/Dynamic/bicg.c,38,8,32,580418233.6432859,1208473079.0,0.8036961591264375,1443.0,1435.0,201383323.0,134387446.0,25176735.0,8415891.0,8397222.0,8393842.0,1500000000,0.3869454890955239,1082014363648.0,2.381517677151333e-06,0.1500538303261294,"#include <string.h>
#include <math.h>


/* Default problem size. */
#ifndef NX
# define NX 8192
#endif
#ifndef NY
# define NY 8192
#endif
#ifndef M_PI
# define M_PI 3.14159265358979323846
#endif


double A[NX][NY];
double r[NX];
double s[NX];
double p[NX];
double q[NX];

static void init_array() {
  int i, j;

  for (i = 0; i < NX;i++) {
    r[i] = i * M_PI;
    p[i] = i * M_PI;
    for (j = 0; j < NY;j++) {
      A[i][j] = ((double)i * j) / NX;
    }
  }
}


int main(int argc, char** argv) {
  int i, j;
  int nx = NX;
  int ny = NY;

  /* Initialize array. */
  init_array();

  #pragma omp parallel for check
  for (i = 0; i < ny; i++)
    s[i] = 0;
  #pragma omp parallel for private (j) check
  for (i = 0; i < nx; i++) {
    q[i] = 0;
    for (j = 0; j < ny; j++) {
      s[j] = s[j] + r[i] * A[i][j];
      q[i] = q[i] + A[i][j] * p[j];
    }
  }

double total = 0;
  for (int iter = 0; iter < nx; iter++) {
            total+=q[iter];
        }
  
 printf(""total=%f\n"",total);



  return 0;
}
"
131-10076,Bomfim/Algorithm-Analisis,Trabalho1/merge.c,37,4,40,3493836.0331579503,5157534.0,0.6774237455342029,1325.0,1302.0,1130787.0,686470.0,4457.0,3586.0,1358.0,1772.0,1500000000,0.0023292240221053,1082014363648.0,0.0005093519499822,0.0061482773212594,"#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define TAM 10000 // Declara o tamanho do vetor;

void merge (int *vetor, int tam, int metade) {
        int i, j, k;
        int *x = malloc(tam * sizeof (int));
        for (i = 0, j = metade, k = 0; k < tam; k++) {
                x[k] =  j == tam ? vetor[i++] : i == metade ? vetor[j++] : vetor[j] < vetor[i] ? vetor[j++] : vetor[i++];
        }
        for (i = 0; i < tam; i++) {
                vetor[i] = x[i];
        }
        free(x);
}

void mergeSort (int *vetor, int tam) {
        if (tam < 2)
                return;
        int metade = tam / 2;
        mergeSort(vetor, metade);
        mergeSort(vetor + metade, tam - metade);
        merge(vetor, tam, metade);
}

int main(int argc, char const *argv[]) {

        int vetor[TAM];
        int i;

        //srand(time(NULL));
        for (i=0; i < TAM; i++) {
                vetor[i] = (rand() % 10000) + 1; // Preenche o vetor com valores aleatórios;
                //printf("" %d\n,"",vetor[i]);
        }

        mergeSort(vetor, TAM);

        /*
           printf(""\n\n"");
           for (i=0; i < TAM; i++)    {
           printf("" %d\n,"",vetor[i]);
           }
           printf(""\n\n "");
         */

        return 0;
}
"
222-17864,bg1bgst333/Sample,unixsyscall/write/write/src/write/fwrite_1.c,29,1,107,3869377.42587165,478850.0,8.0774960843688,1447.0,1418.0,116198.0,54936.0,1654.0,772.0,1366.0,728.0,1500000000,0.0025795849505811,1082014363648.0,0.005983084473217,0.0264120513749459,"/* ヘッダファイルのインクルード */
#include <stdio.h> /* 標準入出力 */

/* main関数の定義 */
int main(void){

  /* 変数の宣言 */
  FILE *fp; /* ファイルポインタfp */
  int i; /* ループ用変数i */

  /* 高水準入出力関数で使われるバッファサイズを出力. */
  printf(""BUFSIZ = %d\n"", BUFSIZ); /* printfでBUFSIZの値を出力. */

  /* ファイルtest_1.txtを開く. */
  fp = fopen(""test_1.txt"", ""wb""); /* fopenで""test_1.txt""を""wb""で開く. */
  if (fp == NULL){ /* NULLの時はエラー. */

    /* エラー処理 */
    printf(""fopen error!\n""); /* ""fopen error!""と出力. */
    return -1; /* -1を返す. */

  }

  /* 書込開始 */
  printf(""fwrite start\n""); /* ""fwrite start""と出力. */

  /* test_1.txtに""ABCD""4バイトを2048回書きこむ.(4 * 2048 = 8192でBUFSIZと同じ.) */
  for (i = 0; i < 2048; i++){ /* 2048回繰り返す. */

    /* 4バイト書きこむ. */
    fwrite(""ABCD"", 4, 1, fp); /* fwriteで4バイトずつtest_1.txtに書きこむ.(純粋にfwriteだけ呼びたいので出力とかはしない.) */

  }

  /* 書込終了 */
  printf(""fwrite end\n""); /* ""fwrite end""と出力. */

  /* 閉じる */
  fclose(fp); /* fcloseでfpを閉じる. */

  /* プログラムの終了 */
  return 0;

}
"
219-27892,execunix/vinos,sys/external/bsd/compiler_rt/dist/test/builtins/Unit/negdf2vfp_test.c,35,2,209,1748568.0291429,172488.0,10.13733129261166,1289.0,1271.0,39023.0,13223.0,1606.0,637.0,1332.0,593.0,1500000000,0.0011657120194286,1082014363648.0,0.0148416121701219,0.079776442215672,"//===-- negdf2vfp_test.c - Test __negdf2vfp -------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file tests __negdf2vfp for the compiler_rt library.
//
//===----------------------------------------------------------------------===//

#include <stdio.h>
#include <stdlib.h>
#include <math.h>


extern double __negdf2vfp(double a);

#if __arm__
int test__negdf2vfp(double a)
{
    double actual = __negdf2vfp(a);
    double expected = -a;
    if (actual != expected)
        printf(""error in test__negdf2vfp(%f) = %f, expected %f\n"",
               a, actual, expected);
    return actual != expected;
}
#endif

int main()
{
#if __arm__
    if (test__negdf2vfp(1.0))
        return 1;
    if (test__negdf2vfp(HUGE_VALF))
        return 1;
    if (test__negdf2vfp(0.0))
        return 1;
    if (test__negdf2vfp(-1.0))
        return 1;
#else
    printf(""skipped\n"");
#endif
    return 0;
}
"
287-23108,paranoiacblack/gcc,gcc/testsuite/gcc.dg/goacc/nested-function-2.c,38,7,32,2287517.7673995,176468.0,12.962786454201328,1145.0,1137.0,38733.0,12802.0,1581.0,590.0,1325.0,547.0,1500000000,0.001525011844933,1082014363648.0,0.0129315229956706,0.0784515377898515,"/* Exercise nested function decomposition, gcc/tree-nested.c.  */

int
main (void)
{
  int j = 0, k = 6, l = 7, m = 8;
  void simple (void)
  {
    int i;
#pragma acc parallel
    {
#pragma acc loop
      for (i = 0; i < m; i+= k)
	j = (m + i - j) * l;
    }
  }
  void collapse (void)
  {
    int x, y, z;
#pragma acc parallel
    {
#pragma acc loop collapse (3)
      for (x = 0; x < k; x++)
	for (y = -5; y < l; y++)
	  for (z = 0; z < m; z++)
	    j += x + y + z;
    }
  }
  void reduction (void)
  {
    int x, y, z;
#pragma acc parallel reduction (+:j)
    {
#pragma acc loop reduction (+:j) collapse (3)
      for (x = 0; x < k; x++)
	for (y = -5; y < l; y++)
	  for (z = 0; z < m; z++)
	    j += x + y + z;
    }
  }
  simple();
  collapse();
  reduction();
  return 0;
}
"
092-17301,robbriggs/masters-project-mercurium,tests/07_phases_ompss.dg/c/success_atomic_01.c,35,2,165,1747353.00242895,169061.0,10.335636249637703,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0011649020016193,1082014363648.0,0.0134152761429306,0.0785563462891999,"/*--------------------------------------------------------------------
  (C) Copyright 2006-2013 Barcelona Supercomputing Center
                          Centro Nacional de Supercomputacion
  
  This file is part of Mercurium C/C++ source-to-source compiler.
  
  See AUTHORS file in the top level directory for information
  regarding developers and contributors.
  
  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 3 of the License, or (at your option) any later version.
  
  Mercurium C/C++ source-to-source compiler is distributed in the hope
  that it will be useful, but WITHOUT ANY WARRANTY; without even the
  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
  PURPOSE.  See the GNU Lesser General Public License for more
  details.
  
  You should have received a copy of the GNU Lesser General Public
  License along with Mercurium C/C++ source-to-source compiler; if
  not, write to the Free Software Foundation, Inc., 675 Mass Ave,
  Cambridge, MA 02139, USA.
--------------------------------------------------------------------*/



/*
<testinfo>
test_generator=config/mercurium-ompss
</testinfo>
*/

int main(int argc, char* argv[])
{
    int a = 0xFE70, b = 0x07EF;

#pragma omp parallel
    {
#pragma omp atomic
        a &= b;

#pragma omp atomic
        a |= b;

#pragma omp atomic
        a ^= b;
    }

    return 0;
}
"
132-2594,konstantin-psu/ParallelProgramming,labs/2/condvar-pthd.c,31,1,163,1502947258.7630153,187629.0,8010.207686445059,1548.0,1514.0,42831.0,15247.0,1689.0,747.0,1388.0,702.0,1500000000,1.0019648391753435,1082014363648.0,0.0163194388927084,0.0779296807741313,"//------------------------------------------------------------------------- 
// This is supporting software for CS415/515 Parallel Programming.
// Copyright (c) Portland State University
//------------------------------------------------------------------------- 

// Condition variable exercise.
//
#include <stdio.h>
#include <pthread.h>

pthread_mutex_t lock;
pthread_cond_t cond;

void sender() {
  printf(""Sender starts ...\n"");
  sleep(1);
  pthread_mutex_lock(&lock);
  pthread_cond_signal(&cond);
  pthread_mutex_unlock(&lock);

}

void receiver() {
  printf(""Receiver starts ...\n"");
  pthread_mutex_lock(&lock);
  pthread_cond_wait(&cond, &lock);
  pthread_mutex_unlock(&lock);

  printf(""Signal received!\n"");
}

int main(int argc, char **argv) {
  pthread_t tid1, tid2;

  pthread_mutex_init(&lock, NULL);
  pthread_cond_init(&cond, NULL);
  pthread_create(&tid1, NULL, (void *)sender, NULL);
  pthread_create(&tid2, NULL, (void *)receiver, NULL);
  pthread_join(tid1, NULL);
  pthread_join(tid2, NULL);
}
"
102-19803,jprice-stmarytx/eg1302,WorksheetAssignment08/aalokran.c,36,1,47,1682404.7779663499,175779.0,9.57113193271096,1329.0,1308.0,39802.0,13687.0,1626.0,637.0,1344.0,596.0,1500000000,0.0011216031853109,1082014363648.0,0.0150017920229378,0.0785769036624352," /*
 * Name: Ahmed Al Okran
 * Course: EG 1302A - Spring 2014
 * Date Created: 2/04/2014
 * Assignment: Worksheet for lecture 07
 */
 // Example program #1 from Chapter 6 of
    // Absolute Beginner's Guide to C, 3rd edition
    // File Chapter6ex1.c
    // This program pairs three kids with their favorite superhero-


#include <stdio.h>
#include <string.h>

int main()
{


    char Kid1[12];
    // Kid1 can hold an 11-character name
    // Kid2 will be 7 characters (Maddie plus null 0)
    char Kid2[] = ""Maddie"";
    // Kid3 is also 7 characters , but specifically defined
    char Kid3[7] = ""Andrew"";
    // Hero1 will be 7 characters (adding null 0!)
    char Hero1[] = ""Batman"";
    // Hero2 will have extra room just in case
    char Hero2[34] = ""Spiderman"";
    char Hero3[25];

    Kid1[0] = 'K'; //Kid1 is being defined character-by-character
    Kid1[1] = 'a'; //Not efficient, but does work
    Kid1[2] = 't';
    Kid1[3] = 'i';
    Kid1[4] = 'e';
    Kid1[5] = '\0'; // Never forget the null 0 so C knows when the
                   // string ends

    strcpy(Hero3, ""The Incredible Hulk"");

    printf(""%s\'s favorite hero is %s.\n"", Kid1, Hero1);
    printf(""%s\'s favorite hero is %s.\n"", Kid2, Hero2);
    printf(""%s\'s favorite hero is %s.\n"", Kid3, Hero3);
    return 0;
}
"
047-10949,Gurgel100/gcc,gcc/testsuite/gcc.dg/tree-prof/val-prof-4.c,32,2,60,1506858.03964725,186067.0,8.098469906001602,1140.0,1130.0,39455.0,14696.0,1567.0,651.0,1316.0,610.0,1500000000,0.0010045720264315,1082014363648.0,0.0121999064852983,0.0765267492751749,"/* { dg-options ""-O2 -fdump-tree-optimized -fdump-ipa-profile-optimized"" } */
unsigned int a[1000];
unsigned int b = 999;
unsigned int c = 1002;
unsigned int d = 1003;
int
main ()
{
  int i;
  unsigned int n;
  for (i = 0; i < 1000; i++)
    {
	    a[i]=1000+i;
    }
  for (i = 0; i < 1000; i++)
    {
      if (i % 2)
	n = b;
      else if (i % 3)
	n = c;
      else
	n = d;
      a[i] %= n;
    }
  return 0;
}
/* autofdo does not do value profiling so far */
/* { dg-final-use-not-autofdo { scan-ipa-dump ""Transformation done: mod subtract"" ""profile"" } } */
/* This is part of code checking that n is greater than the divisor so we are sure that it
   didn't get optimized out.  */
/* { dg-final-use-not-autofdo { scan-tree-dump ""if \\(n_\[0-9\]* \\>"" ""optimized""} } */
/* { dg-final-use { scan-tree-dump-not ""Invalid sum"" ""optimized""} } */
"
136-24694,guonaihong/recycle_bin,leetcode/string-to-integer-atoi/atoi.c,37,2,40,1479468.0755584498,171706.0,14.242682259210511,1151.0,1141.0,39001.0,12882.0,1589.0,586.0,1329.0,546.0,1500000000,0.0009863120503723,1082014363648.0,0.0133483978428243,0.0780602509492512,"#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <limits.h>
#include <assert.h>

int myatoi(char *str) {
    char     *p    = str;
    int64_t   v    = 0;
    int       sign = '+';

    while(*p && isspace(*p)) {
        p++;
    }

    sign = (*p == '-' || *p == '+') ? *p++ : '+';

    while(*p) {
        if (*p < '0' || *p > '9')
            goto done;

        v = v * 10 +  (*p - '0');

        //printf(""str(%s) v(%ld) v >= INT_MAX(%d)\n"", str, v, );
        if (sign == '+' && v >= INT_MAX) {
            return INT_MAX;
        }

        if (sign == '-' && v >= -((int64_t)INT_MIN)) {
            return INT_MIN;
        }

        p++;
    }

done:
    return (sign == '-') ? -v : v;
}

int main() {

    int i;

    i = myatoi(""-2147483649"");
    assert(i == INT_MIN);
    //printf(""i = %d\n"", i);

    i = myatoi(""2147483648"");
    assert(i == INT_MAX);

    i = myatoi(""-2147483648"");
    assert(i == INT_MIN);

    i = myatoi(""      -11919730356x"");
    assert(i == INT_MIN);

    return 0;
}
"
066-25753,artcz/euler,problems/06/6.c,31,1,46,1561201.7596139999,175242.0,8.908828933703107,1448.0,1423.0,39665.0,13598.0,1639.0,629.0,1356.0,590.0,1500000000,0.001040801173076,1082014363648.0,0.0163830588557537,0.0791168353265869,"
// The sum of the squares of the first ten natural numbers is,
// 
// 12 + 22 + ... + 102 = 385
// 
// The square of the sum of the first ten natural numbers is,
// 
// (1 + 2 + ... + 10)2 = 552 = 3025
// 
// Hence the difference between the sum of the squares of the first ten natural
// numbers and the square of the sum is 3025 − 385 = 2640.
// 
// Find the difference between the sum of the squares of the first one hundred
// natural numbers and the square of the sum.

#include <stdio.h>
#include <time.h>


int solve() {

    int sum = 0,
        sum_of_squares = 0,
        N = 100;

    for(int i=0; i<=N; i++){
        sum += i;
        sum_of_squares += i*i;
    }

    int result = sum_of_squares - sum*sum;
    return result > 0 ? result : -result; // return abs(result)
}


int main() {
    clock_t begin = clock();
    int result = solve();
    clock_t end = clock();
    double time = (double)(end - begin) / CLOCKS_PER_SEC;
    printf(""%d [in %f seconds]"", result, time);
}
"
389-3355,yigezhe/algorithm-summary,permutation_and_combination/choose/choose_idea6_other1.c,30,5,36,5146343.95949535,7220680.0,0.7127227629530737,1340.0,1320.0,2046859.0,1020602.0,1725.0,64285.0,1347.0,63218.0,1500000000,0.0034308959729969,1082014363648.0,0.0003683863569636,0.0425677783678423,"//http://my.oschina.net/baoer1024/blog/62826
/*interface*/
/*interface implementation*/
#define MAXN 1000
int C[MAXN+1][MAXN+1];
void initial() {
    int i,j;
    for(i=0; i<=MAXN; ++i) {
        C[0][i] = 0;
        C[i][0] = 1;
    }
    for(i=1; i<=MAXN; ++i) {
        for(j=1; j<=MAXN; ++j)
            C[i][j] = (C[i-1][j] + C[i-1][j-1]);
    }
}
int choose(int n, int k) {
	return C[n][k];
}
/*client*/
#include<stdio.h>
int main() {
    int n,k;
    initial();
    for(n=0; n<10; n++) {
        for(k=0; k<=n; k++) {
            printf("" %d"",choose(n,k));
        }
        printf(""\n"");
    }
    return 0;
}
"
208-33239,danielmapar/TheCProgrammingLanguage,src/Chapter-1/Exercices/Exercise-1-3.c,32,2,37,2529273.15887055,232353.0,10.885475978360512,1465.0,1436.0,52683.0,21373.0,1643.0,641.0,1358.0,596.0,1500000000,0.0016861821059137,1082014363648.0,0.0124853132948573,0.0572269633790644,"/*
 ============================================================================
 Name        : Exercise-1-3.c
 Author      : Daniel Marchena Parreira
 Email       : danielmapar@gmail.com
 Date        : 13/11/2013
 Version     : 0.1
 Copyright   : GNU General Public License Version 2
 Description : Modify the temperature conversion program to print
 	 	 	   a heading above the table.
 ============================================================================
 */

#include <stdio.h>

/* print Fahrenheit-Celsius table
   for fahr = 0, 20, ..., 300; floating-point version */

int main(void)
{
	float fahr, celsius;
	float lower, upper, step;

	lower = 0; /* lower limit of temperature scale */
	upper = 300; /* upper limit */
	step  = 20; /* step size */

	/* Print table header */
	printf(""Fahrenheit-Celsius table\n"");

	fahr = lower;
	while(fahr <= upper)
	{
		celsius = (5.0/9.0) * (fahr-32.0);
		printf(""%3.0f %6.1f\n"", fahr, celsius);
		fahr = fahr + step;
	}

	return 0;
}
"
204-1731,deekej/predator,tests/gcc-adapter/C/28-Operators-other-plus-calls-types.c,38,1,46,1798803.21957165,169058.0,10.640153083557122,1139.0,1129.0,38452.0,12696.0,1565.0,585.0,1316.0,546.0,1500000000,0.0011992021463811,1082014363648.0,0.0134155142022264,0.0784390396496441,"/* Test case: #28
 *
 * Copyright NOTE: This file is part of predator's test suite.
 *
 * predator is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * any later version.
 *
 * predator is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with predator. If not, see <http://www.gnu.org/licenses/>.
 */

struct test {
  int value;
  int array[42];
};

int initval(struct test t)
{
  return t.value;                 /* Call by value. */
}

int retval(struct test *t_ptr)
{
  return t_ptr->value;            /* Call by reference. */
}


int main(void)
{
  struct test t, *t_ptr = &t;
  
  t.value = 0;                    /* Access by '.' notation. */

  /* Structure member access via pointer + array member access. */
  t_ptr->array[0] = 89;
  t_ptr->array[1] = retval(&t);

  return retval(t_ptr);
}
"
236-21318,Gurgel100/gcc,gcc/testsuite/gcc.dg/tree-prof/section-attr-2.c,37,4,73,50683643.9017206,400289067.0,0.1266176050718867,1141.0,1131.0,58452.0,100032698.0,21611.0,12510598.0,1316.0,1798.0,1500000000,0.0337890959344804,1082014363648.0,5.6758982128282805e-06,0.1252390745835171,"/* Checks for a bug where static data with a section attribute within a
   function would stop the function being partitioned into hot and cold
   blocks.  */
/* { dg-require-effective-target freorder } */
/* { dg-options ""-O2 -fno-profile-reorder-functions -freorder-blocks-and-partition -save-temps"" } */

#ifdef FOR_AUTOFDO_TESTING
#define MAXITER 1000000
#else
#define MAXITER 10000
#endif

#define SIZE 10000

#define NOINLINE __attribute__((noinline)) __attribute__ ((noclone))

const char *sarr[SIZE];
const char *buf_hot;
const char *buf_cold;

void foo (int path);

int
main (int argc, char *argv[])
{
  int i;
  buf_hot =  ""hello"";
  buf_cold = ""world"";
  for (i = 0; i < MAXITER; i++)
    foo (argc);
  return 0;
}

void NOINLINE
foo (int path)
{
#ifdef __APPLE__
  static int i __attribute__ ((section (""__DATA,__data"")));
#else
  static int i __attribute__((section("".data"")));
#endif
  if (path)
    {
      for (i = 0; i < SIZE; i++)
	sarr[i] = buf_hot;
    }
  else
    {
      for (i = 0; i < SIZE; i++)
	sarr[i] = buf_cold;
    }
}

/* { dg-final-use { scan-assembler ""\.section\[\t \]*\.text\.unlikely\[\\n\\r\]+\[\t \]*\.size\[\t \]*foo\.cold"" { target *-*-linux* *-*-gnu* } } } */
/* { dg-final-use { scan-assembler {.section[\t ]*__TEXT,__text_cold[^\n]*[\n\r]+_foo.cold:} { target *-*-darwin* } } } */
"
220-3876,Gurgel100/gcc,gcc/testsuite/gcc.dg/tree-prof/val-profiler-threads-1.c,31,3,32,2342928.0845448,189032.0,12.394345930847686,1400.0,1372.0,43672.0,16110.0,1703.0,836.0,1362.0,778.0,1500000000,0.0015619520563632,1082014363648.0,0.0146641838418892,0.078267705998461,"/* { dg-options ""-O0 -pthread -fprofile-update=atomic"" } */
/* { dg-require-effective-target profile_update_atomic } */

#include <pthread.h>

#define NUM_THREADS	8
#define SIZE 1024
#define ITERATIONS (1000 * 1000)

char buffer[SIZE];
char buffer2[SIZE];

void *copy_memory(char *dst, char *src, unsigned size)
{
   for (unsigned i = 0; i < ITERATIONS; i++)
   {
     dst[size % 10] = src[size % 20];
   }
}

void *foo(void *d)
{
  copy_memory (buffer, buffer2, SIZE);
}

int main(int argc, char *argv[])
{
   pthread_t threads[NUM_THREADS];
   int rc;
   long t;
   for(t=0;t<NUM_THREADS;t++){
     rc = pthread_create(&threads[t], NULL, foo, 0);
     if (rc){
	 return 1;
       }
     }

   void *retval;
   for(t=0;t<NUM_THREADS;t++)
     pthread_join (threads[t], &retval);

   return buffer[10];
}
"
004-25993,selmentdev/selment-toolchain,source/gcc-latest/gcc/testsuite/gcc.dg/tree-prof/val-prof-4.c,31,2,51,1805236.6795017002,186067.0,9.70207505898413,1140.0,1130.0,39455.0,14696.0,1567.0,651.0,1316.0,610.0,1500000000,0.0012034911196678,1082014363648.0,0.0121999064852983,0.0765267492751749,"/* { dg-options ""-O2 -fdump-tree-optimized -fdump-ipa-profile"" } */
unsigned int a[1000];
unsigned int b = 999;
unsigned int c = 1002;
unsigned int d = 1003;
int
main ()
{
  int i;
  unsigned int n;
  for (i = 0; i < 1000; i++)
    {
	    a[i]=1000+i;
    }
  for (i = 0; i < 1000; i++)
    {
      if (i % 2)
	n = b;
      else if (i % 3)
	n = c;
      else
	n = d;
      a[i] %= n;
    }
  return 0;
}
/* { dg-final-use { scan-ipa-dump ""Mod subtract transformation on insn"" ""profile"" } } */
/* This is part of code checking that n is greater than the divisor so we are sure that it
   didn't get optimized out.  */
/* { dg-final-use { scan-tree-dump ""if \\(n_\[0-9\]* \\>"" ""optimized""} } */
/* { dg-final-use { scan-tree-dump-not ""Invalid sum"" ""optimized""} } */
"
168-25017,tmikov/a51,a51/gentbl.c,29,1,39,1969281.0019477499,563864.0,5.704375523175801,1378.0,1358.0,130604.0,77331.0,1669.0,701.0,1371.0,657.0,1500000000,0.0013128540012985,1082014363648.0,0.0048522338719975,0.0211508404068579,"/*
  gentbl.c : generates the character classification table
*/

#include <stdio.h>
#include <ctype.h>

/*
#define CT_DIGIT     1  // 0 - 9
#define CT_XDIGIT    2  // 0-9, a-f, A-F
#define CT_AF_LOW    4  // a-f
#define CT_AF_UP     8  // A-F
#define CT_SPACE    16  // 0x09 - 0x0D, 0x20
#define CT_ID_START 32  // letter, _, ?, $
#define CT_IDENT    64  // CT_ID_START | CT_DIGIT
*/

#define PUT( c, x )  if (c) { if (has++) printf( "" | "" ); printf( x ); }


int main ( void )
{
  int i;
  int has;

  printf( ""BYTE CharTable[256] =\n{\n"" );

  for( i = 0; i < 256; ++i )
  {
    has = 0;

    printf( ""  "" );
    PUT( isdigit( i ), ""CT_DIGIT"" );
    PUT( isxdigit( i ), ""CT_XDIGIT""  );
    PUT( (i >= 'a' && i <= 'f') , ""CT_AF_LOW"" );
    PUT( (i >= 'A' && i <= 'F') , ""CT_AF_UP"" );
    PUT( isspace( i ) , ""CT_SPACE"" );
    PUT( isalpha( i ) || i == '_' || i == '?' || i == '$', ""CT_ID_START"" );
    PUT( isalnum( i ) || i == '_' || i == '?' || i == '$', ""CT_IDENT"" );

    if (!has)
      printf( ""0"" );
    putchar( i == 255 ? ' ' : ',' );
    printf( "" // '%c' = %d\n"", i > 31 && i < 128 ? i : '.', i );
  }
  printf( ""};\n"" );
  return 0; // Signal MAKE that operation completed successfully
};
"
371-15176,jeffhammond/HPCInfo,c/arrays/array2d.c,34,6,39,1609130.87893275,755496.0,2.1298987684911634,1480.0,1452.0,166699.0,96164.0,1642.0,696.0,1358.0,653.0,1500000000,0.0010727539192885,1082014363648.0,0.0038808941410675,0.0165447400356839,"#include <stdio.h>
#include <stdlib.h>

/* Both of these signatures are acceptable.
 * The first one looks more like the cast below.
 * The second format does not work as a cast below. */
#if 1
void print2(int m, int n, double (* const restrict A)[n])
#else
void print2(int m, int n, double (A[restrict])[n])
#endif
{
    for(int i=0; i<m; i++)
        for(int j=0; j<n; j++)
            printf(""(%d,%d)=%lf\n"",i,j,A[i][j]);

}

void print1(int m, int n, double A[])
{
    for(int i=0; i<(m*n); i++)
        printf(""(%d)=%lf\n"",i,A[i]);
}

int main(int argc, char* argv[])
{
    int m = (argc>1) ? atoi(argv[1]) : 10;
    int n = (argc>2) ? atoi(argv[2]) : 5;

    double * restrict A = (double*)malloc(m*n*sizeof(double));
    for(int i=0; i<(m*n); i++)
        A[i] = (double)i;

    double (* const restrict B)[n] = (double (*)[n]) malloc(m*n*sizeof(double));
    for(int i=0; i<m; i++)
        for(int j=0; j<n; j++)
            B[i][j] = (double)(i*n+j);

    print1(m,n,A);
    print2(m,n,(double (*)[n])A);

    print1(m,n,(double * restrict)B);
    print2(m,n,B);

    free(B);
    free(A);

    return 0;
}
"
094-7491,Gurgel100/gcc,gcc/testsuite/gcc.dg/tree-prof/section-attr-1.c,37,4,73,50994249.2935806,400279067.0,0.127396741933547,1141.0,1131.0,58452.0,100022698.0,21612.0,12500598.0,1316.0,1798.0,1500000000,0.0339961661957204,1082014363648.0,5.676040011355378e-06,0.125151679412157,"/* Checks for a bug where a function with a section attribute would prevent
   all later functions from being partitioned into hot and cold blocks.  */
/* { dg-require-effective-target freorder } */
/* { dg-options ""-O2 -fno-profile-reorder-functions -freorder-blocks-and-partition -save-temps"" } */

#ifdef FOR_AUTOFDO_TESTING
#define MAXITER 1000000
#else
#define MAXITER 10000
#endif

#define SIZE 10000

#define NOINLINE __attribute__((noinline)) __attribute__ ((noclone))

const char *sarr[SIZE];
const char *buf_hot;
const char *buf_cold;

void foo (int path);

#ifdef __APPLE__
__attribute__ ((section (""__TEXT,__text"")))
#else
__attribute__((section("".text"")))
#endif
int
main (int argc, char *argv[])
{
  int i;
  buf_hot =  ""hello"";
  buf_cold = ""world"";
  for (i = 0; i < MAXITER; i++)
    foo (argc);
  return 0;
}


void NOINLINE
foo (int path)
{
  int i;
  if (path)
    {
      for (i = 0; i < SIZE; i++)
	sarr[i] = buf_hot;
    }
  else
    {
      for (i = 0; i < SIZE; i++)
	sarr[i] = buf_cold;
    }
}

/* { dg-final-use { scan-assembler ""\.section\[\t \]*\.text\.unlikely\[\\n\\r\]+\[\t \]*\.size\[\t \]*foo\.cold"" { target *-*-linux* *-*-gnu* } } } */
/* { dg-final-use { scan-assembler {.section[\t ]*__TEXT,__text_cold[^\n]*[\n\r]+_foo.cold:} { target *-*-darwin* } } } */
"
246-7854,endlessm/chromium-browser,third_party/llvm/clang/test/Sema/warn-missing-prototypes.c,36,7,114,2110832.83647885,169100.0,12.482743938497933,1142.0,1132.0,38461.0,12696.0,1567.0,584.0,1317.0,544.0,1500000000,0.0014072218909859,1082014363648.0,0.0134476641040804,0.0784252399476122,"// RUN: %clang_cc1 -fsyntax-only -Wdocumentation -Wmissing-prototypes -verify %s
// RUN: %clang_cc1 -fsyntax-only -Wdocumentation -Wmissing-prototypes -fdiagnostics-parseable-fixits %s 2>&1 | FileCheck %s

int f(); // expected-note{{this declaration is not a prototype; add parameter declarations to make it one}}
// CHECK-NOT: fix-it:""{{.*}}"":{[[@LINE-1]]:{{.*}}-[[@LINE-1]]:{{.*}}}:""{{.*}}""

int f(int x) { return x; } // expected-warning{{no previous prototype for function 'f'}}

static int g(int x) { return x; }

int h(int x) { return x; } // expected-warning{{no previous prototype for function 'h'}}
// expected-note@-1{{declare 'static' if the function is not intended to be used outside of this translation unit}}
// CHECK: fix-it:""{{.*}}"":{[[@LINE-2]]:1-[[@LINE-2]]:1}:""static ""

static int g2();

int g2(int x) { return x; }

extern int g3(int x) { return x; } // expected-warning{{no previous prototype for function 'g3'}}
// expected-note@-1{{declare 'static' if the function is not intended to be used outside of this translation unit}}
// CHECK-NOT: fix-it:""{{.*}}"":{[[@LINE-2]]:{{.*}}-[[@LINE-2]]:{{.*}}}:""{{.*}}""

void test(void);

int h3(); // expected-note{{this declaration is not a prototype; add parameter declarations to make it one}}
// CHECK-NOT: fix-it:""{{.*}}"":{[[@LINE-1]]:{{.*}}-[[@LINE-1]]:{{.*}}}:""{{.*}}""
int h4(int);
int h4();

void test(void) {
  int h2(int x);
  int h3(int x);
  int h4();
}

int h2(int x) { return x; } // expected-warning{{no previous prototype for function 'h2'}}
// expected-note@-1{{declare 'static' if the function is not intended to be used outside of this translation unit}}
int h3(int x) { return x; } // expected-warning{{no previous prototype for function 'h3'}}
int h4(int x) { return x; }

int f2(int);
int f2();

int f2(int x) { return x; }

// rdar://6759522
int main(void) { return 0; }

void not_a_prototype_test(); // expected-note{{this declaration is not a prototype; add 'void' to make it a prototype for a zero-parameter function}}
// CHECK: fix-it:""{{.*}}"":{[[@LINE-1]]:27-[[@LINE-1]]:27}:""void""
void not_a_prototype_test() { } // expected-warning{{no previous prototype for function 'not_a_prototype_test'}}
"
248-13749,bueti/betriebssystem,Uebung1/linked_list.c,31,3,27,2806039.4106432,181055.0,15.498268481952998,1338.0,1319.0,40915.0,14535.0,1618.0,642.0,1339.0,598.0,1500000000,0.0018706929404288,1082014363648.0,0.0146750987269061,0.0756898106402164,"#include <stdio.h>
#include <stdlib.h>

/**
 * List Node Struct.
 * Contains a data and a pointer to the next node in the list.
 */
struct list_node {
    int data;
    struct list_node * next;
};

// Type definition of a node
typedef struct list_node node;

int main(int argc, const char *argv[])
{
    node *curr, *head;
    int i;

    head = NULL;

    // create the list. add a new node for each insert
    for (int i = 0; i < 10; i++) {
        curr = (node *)malloc(sizeof(node));
        curr->data = i;
        curr->next = head;
        head = curr;
    }

    curr = head;

    // iterate though the list, print each element.
    while(curr) {
        printf(""%d\n"", curr->data);
        curr = curr->next;
    }

    // all good.
    return 0;
}
"
376-6542,bhagatyj/algorithms,problems/strings/strFunctions/strncmp.c,37,1,34,1622103.2710744499,170458.0,9.516144739466611,1155.0,1143.0,38737.0,12787.0,1574.0,586.0,1321.0,546.0,1500000000,0.0010814021807163,1082014363648.0,0.0134813267784439,0.0781577517273503,"#include <stdio.h>
#include <assert.h>

int mstrncmp( int n, char *p, char *q ) {

    if ( ( n == 0 ) || 
         ( ( p == NULL ) && ( q == NULL) ) ) {
        return 0;
    }
    if ( p == NULL ) { return -1; }
    if ( q == NULL ) { return 1; }

    while ( n ) {

        if ( ( *p == '\0' ) && ( *q == '\0' ) ) { return 0; }
        // The below two commented lines are not needed 
        // as the same test is done by the next two lines.
        //if ( *p == '\0' ) { return -1; }
        //if ( *q == '\0' ) { return 1; }
        if ( *p < *q ) { return -1; }
        if ( *p > *q ) { return 1; }
        if ( *p == *q ) { 
            p++; q++; n--;
        }
    }
    return 0;
}

int main (int argc, char **argv) {

    assert( mstrncmp( 0, """", """") == 0 );
    assert( mstrncmp( 1, """", """") == 0 );
    assert( mstrncmp( 4, ""help"", ""hel"") == 1 );
    assert( mstrncmp( 4, ""hel"", ""help"") == -1 );
    assert( mstrncmp( 3, ""hello"", ""help"") == 0 );
    assert( mstrncmp( 4, ""hello"", ""help"") == -1 );
    assert( mstrncmp( 4, ""help"", ""hello"") == 1 );
    assert( mstrncmp( 2, ""help"", ""help"") == 0 );
    assert( mstrncmp( 9, ""help"", ""help"") == 0 );
    assert( mstrncmp( 0, ""help"", ""help"") == 0 );
    assert( mstrncmp( 0, NULL, ""help"") == 0 );
    assert( mstrncmp( 1, NULL, ""help"") == -1 );
    assert( mstrncmp( 1, ""help"", NULL) == 1 );
    return 0;

}

"
019-30075,beqa2323/learntosolveit,languages/cprogs/alloc_afree.c,29,1,38,1750547.9045211,174310.0,16.599615627330618,1331.0,1312.0,39412.0,13522.0,1611.0,636.0,1336.0,593.0,1500000000,0.0011670319363474,1082014363648.0,0.0151626412712982,0.078890694071863,"#define ALLOCSIZE 1000 /* size of available space */

static char allocbuf[ALLOCSIZE]; /* storage for alloc */
static char *allocp = allocbuf; /* next free position */

char *alloc(int);
void afree(char *);

int main(void)
{
	char *p;
	printf(""%p\n"",allocp);
	
	p=alloc(100);
	printf(""%p\n"",allocp);

	afree(p);
	printf(""%p\n"",allocp);

	return 0;
}
	
	
char *alloc(int n) /* return pointer to n characters */
{
	if( allocbuf + ALLOCSIZE - allocp >= n)
	{
		allocp += n;
		return allocp -n; /* old p */
	}
	else
		return 0;
}

void afree(char *p)	/* free storage pointed to by p */
{
	if(p >= allocbuf && p < allocbuf + ALLOCSIZE)
		allocp = p;
}
	

"
286-11979,Akagi201/akcode,c/ctest/test_mutex/test_mutex.c,35,2,50,176769490.70300895,70190630.0,2.518420051223361,1515.0,1485.0,20043339.0,5015598.0,1676.0,668.0,1379.0,623.0,1500000000,0.1178463271353393,1082014363648.0,4.274074758981362e-05,0.0001734311395571,"#include <stdio.h>
#include <pthread.h>

pthread_mutex_t mutex; /* 创建互斥锁mutex */
int share = 0; /* 共享数据 */

/* 线程入口 */

void *thread_function(void *arg)
{
    int i;
    const int N = 1000000;
    for (i = 0; i < N; ++i)
    {
        /* 访问共享数据 */
        pthread_mutex_lock(&mutex);
        ++share;
        pthread_mutex_unlock(&mutex);
    }
}

int main(void)
{
    int i;
    pthread_mutex_init(&mutex, NULL); /* 初始化互斥锁mutex */
    pthread_t thread_id;
    void *exit_status;
    /* 创建新线程 */
    pthread_create(&thread_id, NULL, thread_function, NULL);
    for (i = 0; i < 10; ++i)
    {
        usleep(10000); /* 延时10ms */
        /* 访问共享数据 */
        pthread_mutex_lock(&mutex);
        printf(""share:%d\n"", share);
        pthread_mutex_unlock(&mutex);
    }
    pthread_join(thread_id, &exit_status); /* 等待线程结束 */
    pthread_mutex_destroy(&mutex); /* 销毁互斥锁 */
    return 0;
}
"
224-7233,INSA-Rennes/TP4INFO,Parallelisme/TP1/delay.c,29,1,62,15004179557.785393,285635.0,52529.20530397185,2194.0,1728.0,67111.0,27537.0,2161.0,783.0,1629.0,702.0,1500000000,10.002786371856928,1082014363648.0,0.0137308102998582,0.055732820556166,"/* TP1 - Question 1 */
/* Damien Crémilleux - Lauriane Holy */

#include <pthread.h>
#include <stdio.h>

/* function to be executed by the new data */
void* do_loop(void * data)
{
    int i;
    int me = *((int*) data); 	/* thread number */
    for(i=0; i<10;i++)
    {
	printf(""%d - step %d\n"", me ,i);
	sleep(1);
    }
  
    /* terminate the thread */
    pthread_exit(NULL);
}

int main(int argc, char* argv[])
{
    int thr_id;			/* thread id */
    pthread_t p_thread;		/* thread's structure */
    int a = 1;			/* thread 1 identifying */
    int b = 2;			/* thread 2 identifying */
    pthread_attr_t attr;       	/* thread attributes */

    /* create a new thread that will execute 'do_loop()' */
    pthread_attr_init(&attr); 
    thr_id = pthread_create(&p_thread, &attr, do_loop, (void*)&a);
  
    /* run 'do_loop()' in the main thread as well */
    do_loop((void*) &b);
  
    return 0;
}
"
244-794,jhonatancasale/c-python-r-diffs,src/modularization_programs/c/sum_prime_numbers/sample_sum_prime_numbers.c,37,3,39,2494777.43636805,195534.0,12.758788752851167,1377.0,1353.0,43760.0,15326.0,1643.0,637.0,1360.0,593.0,1500000000,0.0016631849575787,1082014363648.0,0.0139617662401423,0.0716413363571742,"/*
 * Author: Jhonatan Casale (jhc)
 *
 * Contact : jhonatan@jhonatancasale.com
 *         : casale.jhon@gmail.com
 *         : https://github.com/jhonatancasale
 *         : https://twitter.com/jhonatancasale
 *         : http://jhonatancasale.github.io/
 *
 * Create date Wed 23 Nov 03:54:02 BRST 2016
 *
 */

#include <stdlib.h>
#include <stdio.h>
#include <time.h>

int isPrime ( int );
int sum_primes ( int, int );

int main (int argc, char **argv)
{
  srand(time(NULL));

  int j = ( rand () % 99 ) + 2;

  printf ( ""[2, %d].primes => ["", j );
  for ( int i = 2; i <= j; i++ )
    if ( isPrime ( i ) ) printf ( "" %d,"", i );

  printf ( ""\b ]\n"" );

  printf ( ""[2, %d].sum_primes => %d\n"", j, sum_primes( 2, j ) );

  return (EXIT_SUCCESS);
}

int isPrime ( int n ){
  if ( n <= 1 ) return 0;

  for ( int i = 2; i < n; i++ )
    if ( n % i == 0 ) return 0;

  return 1;
}

int sum_primes( int start, int end ){
  int sum = 0;
  for ( int i = start; i <= end; i++ )
    if ( isPrime ( i ) ) sum += i;

  return sum;
}
"
048-13514,iains/darwin-gcc-4-8,libgomp/testsuite/libgomp.graphite/force-parallel-6.c,31,3,60,90044041.3970499,752674577.0,0.1195929406288423,1141.0,1131.0,125289458.0,125513200.0,8002617.0,8032689.0,17318.0,16673.0,1500000000,0.0600293609313666,1082014363648.0,3.0185688070609565e-06,0.064071478062246,"#define N 500

int X[2*N], Y[2*N], B[2*N];
int A[2*N][2*N], C[2*N][2*N];

int foo(void)
{
  int i, j, k;

  for (i = 0; i < N; i++)
    {
      X[i] = Y[i] + 10;
      for (j = 0; j < N; j++)
	{
	  B[j] = A[j][N];
	  for (k = 0; k < N; k++)
	    {
	      A[j+1][k] = B[j] + C[j][k];
	    }
	  Y[i+j] = A[j+1][N];
	}
    }

  return A[1][5]*B[6];
}

int main(void)
{
  foo();

  return 0;
}

/* Check that parallel code generation part make the right answer.  */
/* { dg-final { scan-tree-dump-times ""1 loops carried no dependency"" 1 ""graphite"" } } */
/* { dg-final { cleanup-tree-dump ""graphite"" } } */
/* { dg-final { scan-tree-dump-times ""loopfn.0"" 5 ""optimized"" } } */
/* { dg-final { cleanup-tree-dump ""parloops"" } } */
/* { dg-final { cleanup-tree-dump ""optimized"" } } */
"
027-26190,lijiaying/InvariantGenerationPaperZILU,invariantsInPapers/invgen/NetBSD_loop.c,37,1,52,1725334.7905351499,169057.0,10.205634785900614,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0011502231936901,1082014363648.0,0.0134155935572026,0.0785563462891999,"#include ""assert.h""

int __BLAST_NONDET;


int main ()
{
  //  int pathbuf[MAXPATHLEN+1];

  int MAXPATHLEN;
  int pathbuf_off;

  /* Char *bound = pathbuf + sizeof(pathbuf)/sizeof(*pathbuf) - 1; */
  int bound_off;

  /* glob2's local vars */
  /* Char *p; */
  int glob2_p_off;
  int glob2_pathbuf_off;
  int glob2_pathlim_off;

  if(MAXPATHLEN > 0); else goto END;

  pathbuf_off = 0;
  bound_off = pathbuf_off + (MAXPATHLEN + 1) - 1;

  /* glob2 (pathbuf, bound); */

  /*
int glob2 (Char *pathbuf, Char *pathlim)
{
*/

  glob2_pathbuf_off = pathbuf_off;
  glob2_pathlim_off = bound_off;

  for (glob2_p_off = glob2_pathbuf_off;
      glob2_p_off <= glob2_pathlim_off;
      glob2_p_off++) {
    /* OK */
    /* *p = 1; */
    assert (0 <= glob2_p_off ); assert (glob2_p_off < MAXPATHLEN + 1);
    //pathbuf[glob2_p_off] = 1;
  }

  /*
  return 0;
}
*/

 END:  return 0;
}
"
157-28022,Gurgel100/gcc,gcc/testsuite/gcc.dg/tree-ssa/pr61839_1.c,40,2,69,1857227.87864505,169992.0,10.92537884135724,1147.0,1138.0,38669.0,12783.0,1577.0,586.0,1323.0,546.0,1500000000,0.0012381519190967,1082014363648.0,0.0134418090263071,0.0783643007074555,"/* PR tree-optimization/61839.  */
/* { dg-do run } */
/* { dg-options ""-O2 -fdump-tree-vrp1 -fdisable-tree-evrp -fdump-tree-optimized"" } */
/* { dg-require-effective-target int32plus } */

__attribute__ ((noinline))
int foo ()
{
  int a = -1;
  volatile unsigned b = 1U;
  int c = 1;
  c = (a + 972195718) >> (1LU <= b);
  if (c == 486097858)
    ;
  else
    __builtin_abort ();
  return 0;
}

__attribute__ ((noinline))
int bar ()
{
  int a = -1;
  volatile unsigned b = 1U;
  int c = 1;
  c = (a + 972195718) >> (b ? 2 : 3);
  if (c == 243048929)
    ;
  else
    __builtin_abort ();
  return 0;
}

int main ()
{
  foo ();
  bar ();
}

/* Scan for c = 972195717) >> [0, 1] in function foo.  */
/* { dg-final { scan-tree-dump-times ""486097858 : 972195717"" 1  ""vrp1"" } } */
/* Scan for c = 972195717) >> [2, 3] in function bar.  */
/* { dg-final { scan-tree-dump-times ""243048929 : 121524464"" 2  ""vrp1"" } } */
/* { dg-final { scan-tree-dump-times ""486097858"" 0  ""optimized"" } } */
"
164-10276,atgreen/gcc,gcc/testsuite/gcc.dg/tree-prof/switch-case-1.c,38,1,53,1899347.9898198002,399064.0,4.758392137601989,1142.0,1132.0,68452.0,32696.0,1568.0,588.0,1317.0,547.0,1500000000,0.0012662319932132,1082014363648.0,0.0056983341017982,0.039743741843635,"/* { dg-options ""-O2 -fdump-rtl-expand-all"" } */
int g;

__attribute__((noinline)) void foo (int  n)
{
  switch (n)
    {
    case 1:
      g++; break;
    case 2:
      g += 2; break;
    case 3:
      g += 1; break;
    case 4:
      g += 3; break;
    case 5:
      g += 4; break;
    case 6:
      g += 5; break;
    case 7:
      g += 6; break;
    case 8:
      g += 7; break;
    case 9:
      g += 8; break;
    default:
      g += 8; break;
   }
}

int main ()
{
 int i;
 for (i = 0; i < 10000; i++)
   foo ((i * i) % 5);
 return 0;
}
/* { dg-final-use { scan-rtl-dump-times "";; basic block\[^\\n\]*count 4000"" 2 ""expand""} } */
/* { dg-final-use { scan-rtl-dump-times "";; basic block\[^\\n\]*count 2000"" 1 ""expand""} } */
/* { dg-final-use { cleanup-rtl-dump ""expand"" } } */
"
332-6806,chggr/puzzles,easy/lonely_integer.c,60,1,53,1943208.04439475,174901.0,11.110330987244213,1351.0,1332.0,39608.0,13477.0,1634.0,638.0,1351.0,593.0,1500000000,0.0012954720295965,1082014363648.0,0.0153401066889268,0.0794197984364698,"#include <stdio.h>

// Task description: Given an array of integers, where each integer except one
// occurs twice, find the unique integer. Can this be done in O(n) runtime and
// O(1) space complexity?
//
// E.g. For given array {6, 4, 9, 5, 6, 9, 4}
//      the output should be: 5
//
// Solution: A brute force approach would be to go through the array of integers
// once and store in a map the occurrence of each value. Then iterate through
// all map entries and return the item with count 1. Both the runtime and space
// complexity of this approach is O(n), which clearly does not satisfy the
// requirements of the problem.
//
// This problem can be solved in O(1) space by making the following observation:
// since all the elements in the array are duplicates except from one, the count
// of bits set to one at each position will be odd if the bit is set to one in
// the unique element or even if it is set to zero. Therefore we can simply
// compute the unique element by XORing all elements in the array.

int find(int array[], int size) {
    int result = 0;
    for (int i = 0; i < size; i++) {
        result ^= array[i];
    }
    return result;
}

int test_empty_array() {
    return 0 == find(NULL, 0);
}

int test_one_element() {
    int array[] = { 4 };
    return 4 == find(array, 1);
}

int test_many_elements() {
    int array[] = {6, 4, 9, 5, 6, 9, 4};
    return 5 == find(array, 7);
}

int test_negative_elements() {
    int array[] = {6, -4, -9, -5, 6, -9, -4};
    return -5 == find(array, 7);
}

int main() {
    int counter = 0;
    if (!test_empty_array()) {
        printf(""Empty array test failed!\n"");
        counter++;
    }
    if (!test_one_element()) {
        printf(""One element test failed!\n"");
        counter++;
    }
    if (!test_many_elements()) {
        printf(""Many elements test failed!\n"");
        counter++;
    }
    if (!test_negative_elements()) {
        printf(""Negative elements test failed!\n"");
        counter++;
    }
    printf(""%d tests failed.\n"", counter);
}

"
380-5630,evaautomation/gcc-linaro,libgomp/testsuite/libgomp.c/pr66199-2.c,46,10,40,1492576.6736267998,194362.0,7.679361192002552,1148.0,1138.0,46656.0,16796.0,1700.0,649.0,1445.0,610.0,1500000000,0.0009950511157512,1082014363648.0,0.011761558329303,0.0694067956880791,"/* PR middle-end/66199 */
/* { dg-do run } */

#pragma omp declare target
int u[1024], v[1024], w[1024];
#pragma omp end declare target

__attribute__((noinline, noclone)) void
f1 (long a, long b)
{
  long d;
  #pragma omp target teams distribute parallel for simd default(none) firstprivate (a, b) shared(u, v, w)
  for (d = a; d < b; d++)
    u[d] = v[d] + w[d];
}

__attribute__((noinline, noclone)) void
f2 (long a, long b, long c)
{
  long d, e;
  #pragma omp target teams distribute parallel for simd default(none) firstprivate (a, b) shared(u, v, w) linear(d) linear(c:5) lastprivate(e)
  for (d = a; d < b; d++)
    {
      u[d] = v[d] + w[d];
      c += 5;
      e = c;
    }
}

__attribute__((noinline, noclone)) void
f3 (long a1, long b1, long a2, long b2)
{
  long d1, d2;
  #pragma omp target teams distribute parallel for simd default(none) firstprivate (a1, b1, a2, b2) shared(u, v, w) lastprivate(d1, d2) collapse(2)
  for (d1 = a1; d1 < b1; d1++)
    for (d2 = a2; d2 < b2; d2++)
      u[d1 * 32 + d2] = v[d1 * 32 + d2] + w[d1 * 32 + d2];
}

__attribute__((noinline, noclone)) void
f4 (long a1, long b1, long a2, long b2)
{
  long d1, d2;
  #pragma omp target teams distribute parallel for simd default(none) firstprivate (a1, b1, a2, b2) shared(u, v, w) collapse(2)
  for (d1 = a1; d1 < b1; d1++)
    for (d2 = a2; d2 < b2; d2++)
      u[d1 * 32 + d2] = v[d1 * 32 + d2] + w[d1 * 32 + d2];
}

int
main ()
{
  f1 (0, 1024);
  f2 (0, 1024, 17);
  f3 (0, 32, 0, 32);
  f4 (0, 32, 0, 32);
  return 0;
}
"
096-14846,armoredsoftware/protocol,measurer/gdb-7.9/gdb/testsuite/gdb.arch/i386-pseudo.c,50,2,69,1722543.2675331002,172479.0,9.986972327065905,1290.0,1272.0,39025.0,13225.0,1605.0,637.0,1332.0,593.0,1500000000,0.0011483621783554,1082014363648.0,0.0148539822239229,0.0797511961722488,"/* Test program for byte registers.

   Copyright 2010-2015 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <stdio.h>

int data[] = {
  0x14131211,
  0x24232221,
  0x34333231,
  0x44434241,
};

int
main (int argc, char **argv)
{
  register int eax asm (""eax"");
  register int ebx asm (""ebx"");
  register int ecx asm (""ecx"");
  register int edx asm (""edx"");

  asm (""mov 0(%0), %%eax\n\t""
       ""mov 4(%0), %%ebx\n\t""
       ""mov 8(%0), %%ecx\n\t""
       ""mov 12(%0), %%edx\n\t""
       : /* no output operands */
       : ""r"" (data) 
       : ""eax"", ""ebx"", ""ecx"", ""edx"");

  asm (""nop"" /* first breakpoint here */
       /* i386-{byte,word}.exp write eax-edx here.
	  Tell gcc/clang they're live.  */
       : ""=r"" (eax), ""=r"" (ebx), ""=r"" (ecx), ""=r"" (edx)
       : /* no inputs */);

  asm (""mov %%eax, 0(%0)\n\t""
       ""mov %%ebx, 4(%0)\n\t""
       ""mov %%ecx, 8(%0)\n\t""
       ""mov %%edx, 12(%0)\n\t""
       : /* no output operands */
       : ""r"" (data),
	 /* Mark these as inputs so that gcc/clang won't try to use them as
	    a temp to build %0.  */
	 ""r"" (eax), ""r"" (ebx), ""r"" (ecx), ""r"" (edx));
  puts (""Bye!""); /* second breakpoint here */

  return 0;
}
"
003-17973,yigezhe/algorithm-summary,sorting/array_sort/insertion_sort.c,42,4,39,1750473.16588455,181081.0,9.666795522445756,1352.0,1331.0,41079.0,14440.0,1640.0,638.0,1357.0,594.0,1500000000,0.0011669821105897,1082014363648.0,0.0148165737984658,0.0761721212557863,"/*interface*/
#include<stdio.h>
void sort(int *,int);
void insertion_sort(int *,int);
void print(int *,int);
/*interface implementation*/
void sort(int *data,int length) {
    insertion_sort(data,length);
}
void insertion_sort(int *data,int length) {
	//感觉作者写的有点复杂了！
     int i;
     for (i = 0; i < length; i++) {
          int j = i;
          //在i左边的比i大的元素
	  //i=1,不会进入while循环！
          while (j > 0 && data[i] < data[j - 1])
               j--;
          int tmp = data[i];
          int k;
          //把比i大的元素都向右统一移动一位！
          for (k = i; k > j; k--)
               data[k] = data[k - 1];
          //把i放在比他大的最左边的那个元素的位置上！
          data[j] = tmp;
     }
}
void print(int *data,int length) {
    int i;
    for(i=0; i<length; i++) {
        printf("" %d"",data[i]);
    }
    printf(""\n"");
}
/*client*/
int main() {
    int data[5]= {2,3,1,8,5};
    int length=5;
    print(data,length);
    sort(data,length);
    print(data,length);
    return 0;
}
"
350-22422,crystax/android-toolchain-gcc-5,libstdc++-v3/testsuite/18_support/bad_exception/23591_thread-1.c,50,1,79,2902579.3774053,188024.0,15.437279283495725,1680.0,1600.0,42998.0,15345.0,1713.0,766.0,1394.0,721.0,1500000000,0.0019350529182702,1082014363648.0,0.0174445815427817,0.0787412371664124,"// { dg-require-sharedlib """" }
// { dg-options ""-g -O2 -pthread -ldl -x c -fvtable-verify=none"" { target *-*-linux* *-*-gnu* } }

// Copyright (C) 2005-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING3.  If not see
// <http://www.gnu.org/licenses/>.

#include <pthread.h>
#include <dlfcn.h>
#include <errno.h>
#include <stdio.h>
#include <string.h>

// NB: This must be compiled and linked as a ""C"" executable.
static void* run(void* arg)
{
  typedef void (*function_type) (void);
  void* lib;
  void (*cb)();

  lib = dlopen(""./testsuite_shared.so"", RTLD_NOW);
  if (!lib)
    {
      printf(""dlopen failed: %s\n"", strerror(errno));
      return 0;
    }
  cb = (function_type) dlsym(lib, ""try_throw_exception"");
  if (!cb)
    {
      printf(""dlsym failed: %s\n"", strerror(errno));
      return 0;
    }
  cb();
  dlclose(lib);
  return 0;
}

// libstdc++/23591
int main(void)
{
  pthread_t pt;

  if (pthread_create(&pt, 0, &run, 0) != 0)
    return 1;
  if (pthread_join(pt, 0) != 0)
    return 1;

  return 0;
}
"
092-2040,chamoysvoice/little-galaxy,CTCI/linked-lists/node_eraser.c,47,3,38,1682133.06460515,199308.0,8.439866939611054,1389.0,1362.0,45564.0,16436.0,1647.0,645.0,1357.0,600.0,1500000000,0.0011214220430701,1082014363648.0,0.0138027575410921,0.0685322580645161,"#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define N 10


struct node {
	struct node *next;
	int data;
};

typedef struct node Node;

void eraseNode(Node* n){
	Node *a;
	a = n->next;
	n->data = a->data;
	n->next = a->next;
	free(a);
}


int main(){
	Node *root = (Node*) malloc(sizeof(Node));

	Node *t = root;
	int i;
	srand(time(NULL));

	//ejemplo

	t->data = rand() % 10;
	for(i = 0; i < N - 1 ; i++){
		printf(""%d\n"", t->data);
		t->next = (Node*) malloc(sizeof(Node));
		t = t->next;
		t->data = rand() % 10;
	}
	printf(""%d\n"", t->data);

	putchar('\n');
	t = root;

	int counter = 0;

	while(t){
		counter++;
		if(counter == 3){
			eraseNode(t);
		}
		t = t->next;
	}

	t = root;
	Node *clear;
	for(i = 0; i < N - 1 ; i++){
		clear = t;
		printf(""%d\n"", t->data);
		if(t->next){
			t = t->next;
		}
		free(clear);
	}

}"
129-11278,jerome-benoit/TD_C,TP_7/exo3/exo3.c,51,4,39,2101341.0296290503,185846.0,11.30689387987904,1364.0,1340.0,43260.0,14368.0,1646.0,640.0,1362.0,599.0,1500000000,0.0014008940197527,1082014363648.0,0.01454968091861,0.0736968140487263,"#include <stdio.h>
#include <ctype.h>

//FIXME: Comment the code !!!

void swap(char* v1, char* v2) {
    if (v1 != v2) {
        char tmp = *v1;
        *v1 = *v2;
        *v2 = tmp;
    }
}

int stringLength(const char* str) {
    int length;

    for(length = 0; str[length] != '\0'; ++length);
    return length;
}

// FIXME: this function have issues with non english characters
void reverseString(char* str) {
    int length = stringLength(str);

    for (int i = length - 1; i >= length/2; --i) {
        swap(&str[i], &str[(length - 1) - i]);
    }
}

// FIXME: this function have issues with non english characters
void permAlphaChar(char* str, int key) {
    char alphabet[26] = ""abcdefghijklmnopqrstuvwxyz"";
    int str_length = stringLength(str);

    for (int i = 0; i < str_length; i++) { 
        //if (str[i] == ' ') continue;
        for (int j = 0; j < 26; j++) {
            if (str[i] == alphabet[j]) {
                str[i] = alphabet[(j+key) % 26];
                break;
             } else if (str[i] == toupper(alphabet[j])) {
                str[i] = toupper(alphabet[(j+key) % 26]);
                break;
            }
        }
    }
}

int main() {
    char rev_msg[] = ""Bonjour le monde"";
    int rev_length = stringLength(rev_msg); 
    char perm_msg[] = ""Bonjour a tous et toutes"";
    int perm_length = stringLength(perm_msg); 

    printf(""La chaine de caracteres a inverser est \""%s\"" et a pour longueur %d caractere(s)\n"", rev_msg, rev_length);
    reverseString(rev_msg);
    printf(""La chaine inversee de caracteres est \""%s\""\n"", rev_msg);

    printf(""\n"");
   
    printf(""La chaine de caracteres a permuter est \""%s\"" et a pour longueur %d caractere(s)\n"", perm_msg, perm_length);
    permAlphaChar(perm_msg, 13);
    printf(""La chaine permutee de caracteres est \""%s\""\n"", perm_msg);

    return 0;
}
"
226-13334,acleland/Game-of-31,game31.c,41,4,50,1720938.1330758003,170015.0,10.12227156427374,1149.0,1141.0,38670.0,12779.0,1571.0,586.0,1319.0,546.0,1500000000,0.0011472920887172,1082014363648.0,0.0134693997588448,0.0781745029057902,"/* Copyright (c) 2014 Andrew Cleland and Gina Fitzgerald 
    Game of 31 Assignment for PSU New Beginnings Fall 2014 */ 

#include <stdio.h>
#include <stdlib.h>

typedef struct node_t {
    int turnNum;
    int sum;
    int cardsLeft[7];  // so that for example, cardsLeft[4] = number of 4s left
    struct node_t* parent;
    struct node_t* child[7];
    } node;


void nodeCreate(node* parent, int cardNum){
    node* nodeNew = (node*)(malloc(sizeof(node)));
    if (parent != NULL){
        // Connect parent and child
        nodeNew->parent = parent;
        parent->child[cardNum] = nodeNew;

        // Update game variables
        nodeNew->turnNum = parent->turnNum + 1;
        nodeNew->sum = parent->sum + cardNum;
        for (int i = 1; i < 7; i++){
            nodeNew->cardsLeft[i] = parent->cardsLeft[i];
        }
        nodeNew->cardsLeft[cardNum] -= 1; 
    }
    else {  // If creating the root node...
        // Then it has no parent
        nodeNew->parent = NULL;
        
        // In the beginning of the game, there are four of each type of card.
        for (int i = 1; i < 7; i++){
            nodeNew->cardsLeft[i] = 4;
        }
        // then player A plays a card
        nodeNew->cardsLeft[cardNum] -= 1;
        nodeNew->sum = cardNum;
        
        // This is turn 0. 
        nodeNew->turnNum = 0; 
    }
}



int main(){

    //FILE* f1 = fopen(""gamedata.txt"", ""r"");
    


    return 0;
}
"
131-17903,LixonClem/7colors,src/7colors.c,43,2,112,2187574.7479497,224255.0,9.754850505005464,1294.0,1279.0,61513.0,22609.0,1631.0,650.0,1356.0,609.0,1500000000,0.0014583831652998,1082014363648.0,0.0114735457403402,0.0504743111195644,"/* Template of the 7 wonders of the world of the 7 colors assigment. */

#include <stdio.h>     /* printf */

/* We want a 30x30 board game by default */
#define BOARD_SIZE 30

/** Represent the actual current board game
 *
 * NOTE: global variables are usually discouraged (plus encapsulation in
 *     an appropriate data structure would also be preferred), but don't worry.
 *     For this first assignment, no dinosaure will get you if you do that.
 */
char board[BOARD_SIZE * BOARD_SIZE] = { 0 }; // Filled with zeros

/** Retrieves the color of a given board cell */
char get_cell(int x, int y)
{
    return board[y * BOARD_SIZE + x];
}

/** Changes the color of a given board cell */
void set_cell(int x, int y, char color)
{
    board[y * BOARD_SIZE + x] = color;
}

/** Prints the current state of the board on screen
 *
 * Implementation note: It would be nicer to do this with ncurse or even
 * SDL/allegro, but this is not really the purpose of this assignment.
 */
void print_board(void)
{
    int i, j;
    for (i = 0; i < BOARD_SIZE; i++) {
        for (j = 0; j < BOARD_SIZE; j++) {
            printf(""%c"", get_cell(i, j));
        }
        printf(""\n"");
    }
}

/** Program entry point */
int main(void)
{
    printf(""\n\nWelcome to the 7 wonders of the world of the 7 colors\n""
	   ""*****************************************************\n\n""
	   ""Current board state:\n"");

    print_board();

    return 0; // Everything went well
}"
180-12269,Felipe31/Shortest_Path,testeGrafo.c,52,8,51,700742992.6889017,5336444992.0,0.1313126984444703,1426.0,1401.0,1150263428.0,813899938.0,504570.0,499861.0,4198.0,248659.0,1500000000,0.4671619951259345,1082014363648.0,5.297534227820257e-07,0.0006401137612908,"#include <stdio.h>
#include <stdlib.h>


int main(void)
{

/* n = numero total de elementos
 * o = origem
 * v = matriz representando o grafo
 * listCm = vetor de vetores de caminhos mínimos
 */

 
    int **v;
    int n = 2000;

    int i;
    int j;


    v = (int**)calloc(n, sizeof(int*));

    for (i = 0; i < n; i++) {

        v[i] = (int*)calloc(n, sizeof(int));
    }


    //verticeDjk ** listCm = (verticeDjk **)malloc(sizeof(verticeDjk *)*n);
    //if(!listCm) return 0;


    for(i = 0; i < n; i++)
    {
      //  listCm[i] = NULL;
    }

    //memset(v, -1, sizeof(v));

    puts(""Matriz sem os valores do grafo"");
    for(i = 0; i < n; i++)
    {
        for(j = 0; j < n; j++)
        {
            printf(""%d "", v[i][j]);
        }
        printf(""\n"");
    }
    printf(""\n\n"");


    // Inserção dos valores das arestas
    // do grafo na matriz
    

    for (i = 0; i < n; ++i)
    {
        for (j = 0; j < n; ++j)
        {
            v[i][j] = rand() % 2000;
        }
    }



    puts(""Matriz com os valores do grafo"");

    for(i = 0; i < n; i++)
    {
        for(j = 0; j < n; j++)
        {
            printf(""%d "", v[i][j]);

        }
        printf(""\n"");
    }
    puts(""\nA primeira vez que cada vértice é a origem (Dijkstra é usado)\n"");
}"
374-14407,krichter722/gcc,gcc/testsuite/gcc.target/s390/md/setmem_long-1.c,50,2,83,2184214.6525158,182622.0,11.960300511438929,1149.0,1141.0,39863.0,13904.0,1582.0,596.0,1328.0,555.0,1500000000,0.0014561431016772,1082014363648.0,0.0125395625937729,0.0755295999404839,"/* Machine description pattern tests.  */

/* { dg-do compile } */
/* { dg-options ""-mmvcle -dP -save-temps"" } */
/* { dg-do run { target { s390_useable_hw } } } */

/* Skip test if -O0 is present on the command line or -O... is missing:

    { dg-skip-if """" { *-*-* } { ""-march=z9*"" ""-O0"" } { """" } }
    { dg-skip-if """" { *-*-* } { ""*"" } { ""-O*"" } }
*/

__attribute__ ((noinline))
void test(char *p, char c, int len)
{
  __builtin_memset(p, c, len);
}

__attribute__ ((noinline))
void test2(char *p, int c, int len)
{
  __builtin_memset(p, (char)c, len);
}

/* Check that the right patterns are used.  */
/* { dg-final { scan-assembler-times {c""?:16 .*{[*]setmem_long_?3?1?z?}} 1 } } */
/* { dg-final { scan-assembler-times {c""?:22 .*{[*]setmem_long_and_?3?1?z?}} 1 } } */

#define LEN 500
char buf[LEN + 2];

void init_buf(void)
{
  int i;

  buf[0] = 0;
  for (i = 1; i <= LEN; i++)
    buf[i] = (0x10 + (i & 0x3f));
  buf[LEN + 1] = 0x7f;
}

void validate_buf(char val)
{
  int i;

  if (buf[0] != 0)
    __builtin_abort();
  for (i = 1; i <= LEN; i++)
    if (buf[i] != val)
      __builtin_abort();
  if (buf[LEN + 1] != 0x7f)
    __builtin_abort();
}

int main(void)
{
  init_buf();
  test(buf + 1, 55, LEN);
  validate_buf(55);
  init_buf();
  test(buf + 1, 66, LEN);
  validate_buf(66);
}
"
193-23155,alicek112/critter2,test/resources/pragma_forLoop.c,56,1,338,1554857.7066509998,169061.0,9.197017644518844,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.001036571804434,1082014363648.0,0.0134152761429306,0.0785563462891999,"typedef int* __WAIT_STATUS;
#pragma critTer:1:../../test/resources/pragma_forLoop.c:

#pragma critTer:2:../../test/resources/pragma_forLoop.c:
int main(int argc, char *argv[]) {
#pragma critTer:3:../../test/resources/pragma_forLoop.c:
  int i;
#pragma critTer:4:../../test/resources/pragma_forLoop.c:
  int k;
#pragma critTer:5:../../test/resources/pragma_forLoop.c:

#pragma critTer:6:../../test/resources/pragma_forLoop.c:
  for (i = 0; i < 10; i++) {
#pragma critTer:7:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:8:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:9:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:10:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:11:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:12:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:13:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:14:../../test/resources/pragma_forLoop.c:
	goto label;
#pragma critTer:15:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:16:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:17:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:18:../../test/resources/pragma_forLoop.c:
	label: k++;
#pragma critTer:19:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:20:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:21:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:22:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:23:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:24:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:25:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:26:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:27:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:28:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:29:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:30:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:31:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:32:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:33:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:34:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:35:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:36:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:37:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:38:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:39:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:40:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:41:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:42:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:43:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:44:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:45:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:46:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:47:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:48:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:49:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:50:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:51:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:52:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:53:../../test/resources/pragma_forLoop.c:
	k++;
#pragma critTer:54:../../test/resources/pragma_forLoop.c:
	k++;  
#pragma critTer:55:../../test/resources/pragma_forLoop.c:
  }
#pragma critTer:56:../../test/resources/pragma_forLoop.c:
  
#pragma critTer:57:../../test/resources/pragma_forLoop.c:
  return 0;
#pragma critTer:58:../../test/resources/pragma_forLoop.c:
}
#pragma critTer:59:../../test/resources/pragma_forLoop.c:

#pragma critTer:60:../../test/resources/pragma_forLoop.c:

"
127-13418,lstorchi/teaching,testflops/mm.3.c,41,7,69,764716371.0789754,8742962576.0,0.0874665039856393,1463.0,1438.0,2189469398.0,1091583154.0,134612732.0,393920.0,1364.0,393811.0,1500000000,0.5098109140526503,1082014363648.0,3.318097240817928e-07,0.0412678019794179,"#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <time.h>

#define N (1024)

double a[N][N]; 
double b[N][N];
double c[N][N];

int main()
{
  int k, i, j, ii, jj;
  double somma;
  float time1, time2, ttime1, ttime2, dub_time;

  ttime1 = clock();
  time1 = clock();
  for (j = 0; j < N; j++) {
    for (i = 0; i < N; i++) {
      a[j][i] = ((double)rand())/((double)RAND_MAX);
      b[j][i] = ((double)rand())/((double)RAND_MAX);
      c[j][i] = 0.0L;		
    }  
  }

  time2 = clock();
  dub_time = (time2 - time1)/(double) CLOCKS_PER_SEC;
  
  printf(""Tempo impiegato per inizializzare %f s.\n"", dub_time);

  time1 = clock();
  for (i=0; i<N; i++)
    for (k=0; k<N; k++)
      for (j=0; j<N; j++)
        c[i][j] = c[i][j] + a[i][k] * b[k][j];
  time2 = clock();
  dub_time = (time2 - time1)/(double) CLOCKS_PER_SEC;

  printf(""Tempo per prodotto classico %f s.\n"", dub_time);

  ttime2 = clock();
  dub_time = (ttime2 - ttime1)/(double) CLOCKS_PER_SEC;
  printf(""Tempo totale %f s.\n\n"", dub_time);
  printf(""Mflops ----------------> %f \n"", 
          2.0*N*N*N/(1000*1000*dub_time));

  /* semplice controllo */
  somma = 0.0L;
  for (i = 0; i < N; i++)
    for (j = 0; j < N; j++)
      somma = somma + c[i][j];
  printf(""Controllo -------------> %f \n"", somma);

  return EXIT_SUCCESS;  
}
"
320-24388,ccilab/binutils,gold/testsuite/plugin_layout_with_alignment.c,50,4,60,1842856.75641135,169049.0,10.901312637164372,1138.0,1128.0,38452.0,12696.0,1567.0,580.0,1318.0,544.0,1500000000,0.0012285711709409,1082014363648.0,0.0134043975415412,0.0783803863298662,"// plugin_layout_with_alignment.cc -- a test case for gold

// Copyright (C) 2016 Free Software Foundation, Inc.
// Written by Than McIntosh <thanm@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

// Verify that plugin interfaces for section size and alignment work
// correctly, and that section ordering via plugins is working
// for .bss/.rodata/.data sections.

// --- Initialized .rodata items

__attribute__ ((section("".rodata.v1_a2""), aligned(2)))
const short rodata_item1 = 101;

__attribute__ ((section("".rodata.v2_a1""), aligned(1)))
const char rodata_item2 = 'a';

__attribute__ ((section("".rodata.v3_a8""), aligned(8)))
const double rodata_item3 = 777.777;

__attribute__ ((section("".rodata.v4_a1""), aligned(1)))
const char rodata_item4[7] = {'1', '2', '3', '4', '5', '6', '7'};

// --- Initialized .data items

__attribute__ ((section("".data.v1_a2""), aligned(2)))
short rwdata_item1 = 101;

__attribute__ ((section("".data.v2_a1""), aligned(1)))
char rwdata_item2 = 'a';

__attribute__ ((section("".data.v3_a8""), aligned(8)))
double rwdata_item3 = 'b';

__attribute__ ((section("".data.v4_a1""), aligned(1)))
char rwdata_item4[3] = {'a', 'b', 'c'};

// --- Uninitialized .data items

__attribute__ ((section("".bss.v1_a2""), aligned(2)))
short bss_item1;

__attribute__ ((section("".bss.v2_a1""), aligned(1)))
char bss_item2;

__attribute__ ((section("".bss.v3_a8""), aligned(8)))
struct blah { union { double d; char c; } u; } bss_item3;

__attribute__ ((section("".bss.v4_a1""), aligned(1)))
char bss_item4[3];

int main (void)
{
  return 0;
}
"
227-19237,acarno/slicer,valgrind/massif/tests/thresholds.c,50,2,48,2164729.52160975,169057.0,12.804728582667384,1139.0,1129.0,38452.0,12696.0,1567.0,588.0,1316.0,547.0,1500000000,0.0014431530144065,1082014363648.0,0.0134155935572026,0.0785563462891999,"// This test is for testing that the --threshold options in both Massif and
// ms_print work as they should.  A threshold of 10% is a good choice for
// this file, because in some parts of the tree it renders all children
// insignificant, and in others parts of the tree it renders only some
// children insignificant.
//
// Also, it's deliberate that the 'malloc(2000)' and 'my_malloc1(500)' calls 
// are in 'main' -- at one point, ms_print was failing to connect some
// children arrows when a more significant child didn't have any children of
// its own, eg:
//
//   |   
//   ->20.00% (2000B) 0x804846A: main (thresholds.c:43)
//   
//   ->13.00% (1300B) 0x80483A4: my_malloc2 (thresholds.c:16)
//
// (There must be a '|' between the '->'s.)

#include <stdlib.h>

void my_malloc1(int n)
{
   malloc(n);
}

void my_malloc2(int n)
{
   malloc(n);
}

void my_malloc3(int n)
{
   malloc(n);
}

void a7550(void)
{
   my_malloc1(48000);
   my_malloc2( 7200);
}

void a450(void)
{
   my_malloc2(2400);
   my_malloc1( 800);
   my_malloc2( 800);
   my_malloc1( 400);
}

int main(void)
{
   a7550(); 
   a450(); 
   my_malloc1(4000);       // All sizes are divisible by 16 -- no slop.
   malloc(16000);
   my_malloc3(400);
   return 0;
}
"
366-28450,CajetanP/coding-exercises,CodeWars/Puzzles/IsMyFriendCheating/IsMyFriendCheating.c,52,2,52,1645892.85850515,191841.0,8.57945903117686,1343.0,1321.0,42551.0,15297.0,1643.0,643.0,1370.0,599.0,1500000000,0.0010972619056701,1082014363648.0,0.0138864997576117,0.0735548333563822,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

typedef struct Pair Pair;

struct Pair {
    long long first;
    long long snd;
};

Pair** removNb(long long n, int* length) {
    Pair** result = malloc(sizeof(Pair*) * 100);
    long long sum = n*(n+1)/2; /* sum of numbers 1...n */

    for (long long a = 1 ; a <= n ; ++a) {
        if ((sum-a)%(a+1) == 0) {
            long long b = (sum-a)/(a+1.0);

            if (b < n && b > 0) {
                result[*length] = malloc(sizeof(Pair));
                result[*length]->first = a;
                result[*length]->snd = b;
                (*length)++;
            }
        }
    }

    return result;
}

// fct  to compare results; sz number of pairs / Pair** arr will be freed
char* array2StringData(Pair** arr, int size) {
    char* result = malloc(size * 7);
    strcpy(result, ""{"");

    char temp[50];
    strcpy(temp, """");
    for (int i = 0 ; i < size ; ++i) {
        sprintf(temp, ""{%lld, %lld}"", arr[i]->first, arr[i]->snd);
        strcat(result, temp);
        strcpy(temp, """");
    }
    strcat(result, ""}"");

    return result;
}


void dotest(long long n, char* sexpr) {
    int lg = 0;
    Pair** act = removNb(n, &lg);
    char* sact = array2StringData(act, lg);
    if(strcmp(sact, sexpr) != 0)
        printf(""Error. Expected %s but got %s\n"", sexpr, sact);
    assert(strcmp(sact, sexpr) == 0);
    if (strcmp(sact, ""{}"") != 0) {
        free(sact); sact = NULL;
    }
}

int main() {
    dotest(26, ""{{15, 21}{21, 15}}"");
    dotest(100 , ""{}"");
    dotest(37 , ""{{21, 31}{31, 21}}"");
    dotest(101 , ""{{55, 91}{91, 55}}"");
}
"
327-21202,cmoser96/ExercisesInC,homework/hw05/find_track_oo.c,61,2,52,3051694.4825649,169061.0,18.05084555278864,1140.0,1130.0,38452.0,12696.0,1568.0,588.0,1317.0,547.0,1500000000,0.0020344629883766,1082014363648.0,0.0134271061924394,0.0785954485023852,"/* Example code for Exercises in C.

Modified version of an example from Chapter 2.5 of Head First C.

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <regex.h>

#define NUM_TRACKS 5

char tracks[][80] = {
    ""So What"",
    ""Freddie Freeloader"",
    ""Blue in Green"",
    ""All Blues"",
    ""Flamenco Sketches""
};


typedef struct {
    regex_t inner_struct[1];
} Regex;


/* Returns a new Regex that matches the given pattern.
 *
 * pattern: string regex
 * flags: flags passed to regcomp
 * returns: new Regex 
 */
Regex *make_regex(char *pattern, int flags) {
    // FILL THIS IN!
    return NULL;
}

/* Checks whether a regex matches a string.
 *
 * regex: Regex
 * s: string
 * returns: 1 if there's a match, 0 otherwise
 */
int regex_match(Regex *regex, char *s) {
    // FILL THIS IN!
    return 0;
}

/* Frees a Regex.
 *
 * regex: Regex
 */
void regex_free(Regex *regex) {
    // FILL THIS IN!
}


/* Finds all tracks that match the given pattern.
 *
 * Prints track number and title.
 */
void find_track_regex(char pattern[])
{
    int i;

    Regex *regex = make_regex(pattern, REG_EXTENDED | REG_NOSUB);

    for (i=0; i<NUM_TRACKS; i++) {
    	if (regex_match(regex, tracks[i])) {
    	    printf(""Track %i: '%s'\n"", i, tracks[i]);
    	}
    }

    regex_free(regex);
}


int main (int argc, char *argv[])
{
    char *pattern = ""F.*F.*"";
    find_track_regex(pattern);

    return 0;
}
"
051-31560,drpicox/mcxx,tests/06_run_cxx.dg/success_006.c,54,2,164,2238333.1088349,170023.0,13.164883574575205,1151.0,1139.0,38682.0,12779.0,1577.0,589.0,1325.0,547.0,1500000000,0.0014922220725566,1082014363648.0,0.0134687659904836,0.0784671887448747,"/*--------------------------------------------------------------------
  (C) Copyright 2006-2012 Barcelona Supercomputing Center
                          Centro Nacional de Supercomputacion
  
  This file is part of Mercurium C/C++ source-to-source compiler.
  
  See AUTHORS file in the top level directory for information
  regarding developers and contributors.
  
  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 3 of the License, or (at your option) any later version.
  
  Mercurium C/C++ source-to-source compiler is distributed in the hope
  that it will be useful, but WITHOUT ANY WARRANTY; without even the
  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
  PURPOSE.  See the GNU Lesser General Public License for more
  details.
  
  You should have received a copy of the GNU Lesser General Public
  License along with Mercurium C/C++ source-to-source compiler; if
  not, write to the Free Software Foundation, Inc., 675 Mass Ave,
  Cambridge, MA 02139, USA.
--------------------------------------------------------------------*/



/*
<testinfo>
test_generator=config/mercurium-run
</testinfo>
*/
#include<assert.h>
#include<string.h>

typedef struct B_t
{
    int z0, z1;
} B;

typedef struct A_t
{
    char name[64];
    B m;

} A;


A a0 = { ""FOO"", {4, 5} };
A a1 = { { ""FOO"" }, {4, 5} };
A a2 = { ""FOO"" ""FAA"" , {4, 5} };
A a3 = { 'F','O','O', {65, 65} };

int main()
{
   assert(strcmp(a0.name, ""FOO"") ==0);
   assert(strcmp(a1.name, ""FOO"") ==0);
   assert(strcmp(a2.name, ""FOOFAA"") ==0);
   assert(strcmp(a3.name, ""FOOA"") ==0);


    assert(a0.m.z0 == 4);
    assert(a1.m.z0 == 4);
    assert(a2.m.z0 == 4);
    assert(a3.m.z0 == 0);


    assert(a0.m.z1 == 5);
    assert(a1.m.z1 == 5);
    assert(a2.m.z1 == 5);
    assert(a3.m.z1 == 0);

    return 0;
}
"
145-19110,myd7349/Ongoing-Study,c/PThreads/producer_consumer/producer_consumer.c,51,4,63,1145787009.1544464,74221483.0,15.437403871329275,2179.0,1710.0,20175790.0,9989513.0,2206.0,886.0,1658.0,808.0,1500000000,0.7638580061029643,1082014363648.0,5.239722844125872e-05,0.0001842514229013,"/* 2014-04-07T18:30+08:00 */
#include <stdio.h>

#include <pthread.h>

#define MAX (100000) /* how many numbers to produce */

pthread_mutex_t the_mutex;
pthread_cond_t cond_c;
pthread_cond_t cond_p;
int buffer = 0; /* buffer used between producer and consumer */

/* produce data */
void *producer(void *ptr)
{
    int i;

    for (i = 1; i <= MAX; ++i) {
        pthread_mutex_lock(&the_mutex); /* get exclusive access to buffer */

        while (buffer != 0) {
            pthread_cond_wait(&cond_p, &the_mutex);
        }

        buffer = i; /* put item in buffer */

        pthread_cond_signal(&cond_c); /* wake up consumer */
        pthread_mutex_unlock(&the_mutex); /* release access to buffer */
    }

    pthread_exit(NULL);
}

/* consume data */
void *consumer(void *ptr)
{
    int i;

    for (i = 1; i <= MAX; ++i) {
        pthread_mutex_lock(&the_mutex); /* get exclusive access to buffer */

        while (buffer == 0) {
            pthread_cond_wait(&cond_c, &the_mutex);
        }

        buffer = 0; /* tack item out of buffer */

        pthread_cond_signal(&cond_p); /* wake up producer */
        pthread_mutex_unlock(&the_mutex); /* release access to buffer */
    }

    pthread_exit(NULL);
}

int main(void)
{
    pthread_t pro_thread;
    pthread_t con_thread;

    pthread_mutex_init(&the_mutex, 0);
    pthread_cond_init(&cond_c, 0);
    pthread_cond_init(&cond_p, 0);

    pthread_create(&con_thread, 0, consumer, 0);
    pthread_create(&pro_thread, 0, producer, 0);

    pthread_join(pro_thread, 0);
    pthread_join(con_thread, 0);

    pthread_cond_destroy(&cond_c);
    pthread_cond_destroy(&cond_p);
    pthread_mutex_destroy(&the_mutex);

    return 0;
}
"
265-3691,chibby0ne/K_R_Exercises,Chapter03/Exercise3-06.c,54,6,54,2379619.5164322,179547.0,13.253460096799166,1369.0,1343.0,40903.0,14105.0,1645.0,639.0,1360.0,595.0,1500000000,0.0015864130109548,1082014363648.0,0.0151046801116142,0.0770615183246073,"#include <stdio.h>
#include <string.h>
#include <limits.h>
#define MAX 100

void itoa(int n, char s[], int b);
void reverse(char s[]);                  //reverses the order of the values of the elements in a array (string)

int main()
{
    char s[MAX];
    int space;
    space=12;
    printf(""%d\n"",INT_MAX);
    itoa(INT_MAX, s, space);
    printf(""%d\n"",INT_MIN);
    itoa(INT_MIN, s, space);
    return 0;
}


void itoa(int n, char s[], int b)
{
    int i,sign;
    if (((sign=n) < 0) && (n != INT_MIN))  // if it's negative and NOT the most negative number
        n=-n;                              // make it positive
    else if (n==INT_MIN)                    // if it's the most negative number
        n=-(n)-1;                             // make it the most positive number
    i=0;
    do {                                    // loop for conversion of int to printable char
        s[i++]=n % 10 + '0';
    } while ((n /= 10) > 0);
    if (sign==INT_MIN)                      // if it was the most negative number
        s[0]=s[0]+1;                        // add one to the number
    if (sign < 0)                           //if it was negative
    {
        s[i] = '-';                       //add a minus sign
        while (i++<b)
            s[i]=' ';
    }
    else
    {
        while (i<b)
            s[i++]=' ';
    }
    s[i] = '\0';                            //and a \0 to terminate string
    reverse(s);                             //reverse the order of the string
    for (i=0; i<strlen(s); i++)             //print each char
        printf(""%c"",s[i]);
    if (i=strlen(s))                        //after printing each char, print nextline
        printf(""\n"");
}

void reverse(char s[])                  //reverses the order of the values of the elements in a array (string)
{
    int c,i,j;
    for (i=0, j=strlen(s)-1; i < j; i++, j--)
    {
        c=s[i];
        s[i]=s[j];
        s[j]=c;
    }
}
"
347-15138,cpjreynolds/vrb,CONFIG/readsymlink.c,41,2,458,1761393.0394871999,173247.0,16.60600760763534,1149.0,1139.0,39631.0,13181.0,1612.0,590.0,1342.0,547.0,1500000000,0.0011742620263248,1082014363648.0,0.0132065778916806,0.0774634552753162,"//-----------------------------------------------------------------------------
// Copyright © 2003 - Philip Howard - All rights reserved
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//-----------------------------------------------------------------------------
// package	vrb
// homepage	http://vrb.slashusr.org/
//-----------------------------------------------------------------------------
// author	Philip Howard
// email	vrb at ipal dot org
// homepage	http://phil.ipal.org/
//-----------------------------------------------------------------------------
// This file is best viewed using a fixed spaced font such as Courier
// and in a display at least 120 columns wide.
//-----------------------------------------------------------------------------

#include <limits.h>
#include <stdio.h>
#include <unistd.h>

int main( int argc, char **argv ) {
    char symdata[ PATH_MAX+1 ];

    while ( ++ argv, -- argc > 0 ) {
	ssize_t len;
	len = (ssize_t) readlink( * argv, symdata, sizeof symdata );
	if ( len >= 0 ) {
	    symdata[ len ] = 0;
	    fputs( symdata, stdout );
	    fputc( '\n', stdout );
	    fflush( stdout );
	}
    }
    return 0;
}
"
070-32825,staropram/c_tutorial,10_dynamic_arrays/array_pointer.c,57,4,66,1864348.65463515,217861.0,8.554481986220571,1361.0,1338.0,47902.0,18898.0,1618.0,651.0,1341.0,606.0,1500000000,0.0012428991030901,1082014363648.0,0.0123886331192824,0.0631137724550898,"#include <stdlib.h>
#include <stdio.h>

/**
 * Function to create an integer array.
 *
 * @param len The length of the array to create
 * @param multiplier The value to multiply the
 * array index by in initial assignment of values.
 *
 * @return An integer array (integer pointer).
 */
int* create_int_array(int len, int multiplier) {
	// allocate memory for the integer array
	int *a = malloc(len*sizeof(int));
	
	// deal with error case
	if(a==NULL) {
		return a;
	}
	
	// populate it according to the multiplier
	for(int i=0; i<len; i++) {
		a[i] = i*multiplier;
	}

	// return the address
	return a;
}

int main() {
	// we will create three integer arrays of array_len
	int array_len = 10;
	// create the three arrays using the function
	// above, using different multipliers so we can
	// tell them apart when we print them
	int *a = create_int_array(array_len,10);
	int *b = create_int_array(array_len,100);
	int *c = create_int_array(array_len,1000);

	// create space to store pointers to these
	// arrays (pointers to integer pointers)
	int** array_pointer = malloc(3*sizeof(int*));
	// and store the addresses of the three arrays
	// in this array
	array_pointer[0] = a;
	array_pointer[1] = b;
	array_pointer[2] = c;

	// we can now print out the elements of this
	// ""matrix"" by iterating indexing into array_pointer
	for(int i=0; i<3; i++) {
		for(int j=0; j<array_len; j++) {
			printf(""array_pointer[%d][%d]: %d\n"",i,j,
				array_pointer[i][j]);
		}
	}

	// to free the memory we first need to free
	// array_pointer and then we need to free
	// the three individual arrays
	free(array_pointer);
	free(a);
	free(b);
	free(c);

	return 0;
}
"
238-5725,arevaloarboled/Clases_2015,tasks/task3_synchronization/jarevalo_gkarlo/Exercise2/3.c,59,6,131,43732156.5113961,65189348.0,0.670848188265359,2529.0,1810.0,19290894.0,5641475.0,103167.0,101469.0,1651.0,101126.0,1500000000,0.0291547710075974,1082014363648.0,6.655995393603262e-05,0.0123298752717802,"// 3. Ejecutar el siguiente codigo varias veces, que observa? 
// Como lo podria arreglar?
//////////////////////////////////////////////////////
//Respuesta
//agregandole los mutex necesarios en el acceso a las variables globales que hay en
//la funcion dotprod, variables que son a y b, que se usan en todos los hilos 
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

/* Define global data where everyone can see them */
#define NUMTHRDS 8
#define VECLEN 100000
int *a, *b; 
long sum=0;
pthread_mutex_t mutex;


void *dotprod(void *arg)
{
	/* 
	 * Each thread works on a different set of data.
	 * The offset is specified by the arg parameter. 
	 * The size of the data for each thread is indicated by VECLEN.
	 */
	int i, start, end, offset, len;
	long tid = (long)arg;
	offset = tid;
	len = VECLEN;
	start = offset*len;
	end   = start + len;

	/* Perform my section of the dot product */
	printf(""thread: %ld starting. start=%d end=%d\n"",tid,start,end-1);
	for (i=start; i<end ; i++){
		pthread_mutex_lock (&mutex);
		sum += (a[i] * b[i]);
		pthread_mutex_unlock (&mutex);
	} 
	printf(""thread: %ld done. Global sum now is=%li\n"",tid,sum);

	pthread_exit((void*) 0);
}

int main (int argc, char *argv[])
{
	long i;
	void *status;
	pthread_t threads[NUMTHRDS];
	 pthread_mutex_init(&mutex, NULL);
	/* Assign storage and initialize values */
	a = (int*) malloc (NUMTHRDS*VECLEN*sizeof(int));
	b = (int*) malloc (NUMTHRDS*VECLEN*sizeof(int));
	  
	for (i=0; i<VECLEN*NUMTHRDS; i++)
	  a[i]= b[i]=1;

	/* Create threads as joinable, each of which will execute the dot product
	 * routine. Their offset into the global vectors is specified by passing
	 * the ""i"" argument in pthread_create().
	 */
	for(i=0; i<NUMTHRDS; i++) 
	   pthread_create(&threads[i], NULL, dotprod, (void *)i); 

	/* Wait on the threads for final result */
	for(i=0; i<NUMTHRDS; i++) 
	  pthread_join(threads[i], &status);

	/* After joining, print out the results and cleanup */
	printf (""Final Global Sum=%li\n"",sum);
	free (a);
	free (b);
	pthread_exit(NULL);
}"
292-20650,ikaustav/algorithm-code,DeleteNodeDLL.c,55,1,47,1582833.0069779998,180651.0,8.76182805520036,1374.0,1351.0,40946.0,14315.0,1636.0,642.0,1353.0,597.0,1500000000,0.001055222004652,1082014363648.0,0.0150843338813513,0.0765096541864968,"#include <stdio.h>
#include <stdlib.h>

struct node{
  int data;
  struct node *prev;
  struct node *next;
};

void traverseLinkedList(struct node *head);
void push(struct node **head, int data);
void deleteNode(struct node **head, struct node *point);

int main(){
  struct node *head = NULL;

  push(&head, 1);
  push(&head, 2);
  push(&head, 3);
  traverseLinkedList(head);

  struct node *point = head;
  while(point->data != 1){
    point = point->next;
  }
  printf(""%s %d\n"", ""Found: "", point->data);
  deleteNode(&head, point);
  printf(""%s\n"", ""After Deletion."");
  traverseLinkedList(head);
}

void deleteNode(struct node **head, struct node *point){
  if(point->next == NULL){
    point->prev->next = NULL;
  }
  else if(point->prev == NULL){
    *head = point->next;
  }
  else{
    struct node *prev = point->prev;
    struct node *next = point->next;

    prev->next = next;
    next->prev = prev;
  }
  free(point);
}

void push(struct node **head, int data){
  struct node *newNode = (struct node *)malloc(sizeof(struct node));

  newNode->data = data;
  newNode->next = (*head);
  newNode->prev = NULL;

  if(*head != NULL){
    (*head)->prev = newNode;
  }

  *head = newNode;
}

void traverseLinkedList(struct node *head){
  if(head == NULL){
    return;
  }

  printf(""Element value= %d \n"", head->data);
  traverseLinkedList(head->next);
}
"
110-2445,sssylvester/geopm,test/no_omp_cpu.c,60,2,54,1846063.5328664999,261093.0,7.0705189338664765,1416.0,1394.0,58134.0,26202.0,1661.0,644.0,1371.0,601.0,1500000000,0.001230709021911,1082014363648.0,0.0107624486294155,0.0507138114209827,"/*
 * Copyright (c) 2015, 2016, 2017, Intel Corporation
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in
 *       the documentation and/or other materials provided with the
 *       distribution.
 *
 *     * Neither the name of Intel Corporation nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY LOG OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#define _GNU_SOURCE
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sched.h>
#include <assert.h>


void no_omp_cpu(int num_cpu, cpu_set_t *no_omp)
{
    int cpu_index, i;

    for (i = 0; i < num_cpu; ++i) {
        CPU_SET(i, no_omp);
    }
    #pragma omp parallel default(shared)
    {
        #pragma omp critical
        {
            cpu_index = sched_getcpu();
            assert(cpu_index < num_cpu);
            CPU_CLR(cpu_index, no_omp);
        } /* end pragma omp critical */
    } /* end pragam omp parallel */
}

int main(int argc, char **argv)
{
    int i, num_cpu = sysconf(_SC_NPROCESSORS_ONLN);
    cpu_set_t *no_omp = CPU_ALLOC(num_cpu);
    no_omp_cpu(num_cpu, no_omp);
    printf(""Free cpu list: "");
    for (i = 0; i < num_cpu; ++i) {
        if (CPU_ISSET(i, no_omp)) {
            printf(""%i "", i);
        }
    }
    printf(""\n\n"");
    CPU_FREE(no_omp);
    return 0;
}
"
163-4110,briankoser/projecteuler,C/euler5.c,60,1,186,1897496219.9572477,15830080870.0,0.1198664892859767,1362.0,1344.0,42213.0,15345.0,1632.0,638.0,1352.0,596.0,1500000000,1.2649974799714985,1082014363648.0,1.7094037751431905e-07,0.0732826018972167,"/***********************************************************
Brian Koser
Project Euler - 5
Find the smallest number evenly divisible by the numbers 1-20
2009.08.10.00.16
***********************************************************/

#include <stdio.h>

int main()
{
   long long int number = 0;
   _Bool success = 0;

   printf(""\n\nThe program finds the smallest number evenly divisible by the numbers 1-20\n\n"");

   while(!success)
   {
      number++;

      if(!(number % 1))      
        if(!(number % 2))
          if(!(number % 3))
            if(!(number % 4))
              if(!(number % 5))      
                if(!(number % 6))
                  if(!(number % 7))
                    if(!(number % 8))
                      if(!(number % 9))
                        if(!(number % 10))
                          if(!(number % 11))
                            if(!(number % 12))
                              if(!(number % 13))
                                if(!(number % 14))
                                  if(!(number % 15))
                                    if(!(number % 16))
                                      if(!(number % 17))
                                        if(!(number % 18))
                                          if(!(number % 19))
                                            if(!(number % 20))                                          
                                              success = 1;
   }

   printf(""\n%lld is divisible by:"", number);
   printf(""\n1: %lld"", number % 1);
   printf(""\n2: %lld"", number % 2);
   printf(""\n3: %lld"", number % 3);
   printf(""\n4: %lld"", number % 4);
   printf(""\n5: %lld"", number % 5);
   printf(""\n6: %lld"", number % 6);
   printf(""\n7: %lld"", number % 7);
   printf(""\n8: %lld"", number % 8);
   printf(""\n9: %lld"", number % 9);
   printf(""\n10: %lld"", number % 10);
   printf(""\n11: %lld"", number % 11);
   printf(""\n12: %lld"", number % 12);
   printf(""\n13: %lld"", number % 13);
   printf(""\n14: %lld"", number % 14);
   printf(""\n15: %lld"", number % 15);
   printf(""\n16: %lld"", number % 16);
   printf(""\n17: %lld"", number % 17);
   printf(""\n18: %lld"", number % 18);
   printf(""\n19: %lld"", number % 19);
   printf(""\n20: %lld"", number % 20);
   printf(""\n\n"");

   return 0;
}
"
140-24028,feliposz/learning-stuff,c/string_test.c,49,1,63,1916537.87624085,189075.0,10.136385032394552,1390.0,1369.0,42792.0,15442.0,1658.0,645.0,1376.0,601.0,1500000000,0.0012776919174939,1082014363648.0,0.0145920930847547,0.073496582752344,"#include <stdio.h>
#include <string.h>
#include <ctype.h>

typedef char String25[25];
typedef char String30[30];

int main()
{
    int i;
    const String25 test1 = ""Hello, world! "";
    const String25 test2 = ""I'm programming! "";
    String30 other, other_caps;

    /* WRONG
    char str[5];
    str = ""hi"";
    */

    printf(""test1 = [%s] (%d)\n"", test1, strlen(test1));
    printf(""test2 = [%s] (%d)\n"", test2, strlen(test2));

    /* other = test1 */
    strncpy(other, test1, sizeof(other) - 1);
    other[sizeof(other)-1] = '\0'; /* paranoia ? */

    printf(""[%s]\n"", other);
    printf(""length of other = %d\n"", strlen(other));

    /* Although cumbersome... this is the only safe way I could find. Is there a better one? */
    strncat(other, test2, sizeof(other) - 1 - strlen(other));
    printf(""[%s]\n"", other);
    printf(""length of other = %d\n"", strlen(other));

    strncpy(other_caps, other, sizeof(other_caps) - 1);
    other_caps[sizeof(other_caps)-1] = '\0';

    /* convert to CAPITAL letters */
    for (i = 0; other_caps[i] != '\0' && i < sizeof(other_caps) - 1; i++) {
            other_caps[i] = toupper(other_caps[i]);
    }

    printf(""[%s]\n"", other_caps);
    printf(""length of other_caps = %d\n"", strlen(other_caps));

    printf(""test1 in comparison to other = %d\n"", strncmp(test1, other, sizeof(test1) - 1));
    printf(""test2 in comparison to other = %d\n"", strncmp(test2, other, sizeof(test2) - 1));
    printf(""test1 in comparison to test2 = %d\n"", strncmp(test1, test2, sizeof(test1) - 1));
    printf(""other in comparison to other = %d\n"", strncmp(other, other_caps, sizeof(other) - 1));

    strncpy(other, test2, sizeof(other) - 1);
    other[sizeof(other)-1] = '\0';
    printf(""[%s]\n"", other);
    printf(""length of other = %d\n"", strlen(other));

    strncat(other, test1, sizeof(other) - 1 - strlen(other));
    printf(""[%s]\n"", other);
    printf(""length of other = %d\n"", strlen(other));

    /* This won't compile... cannot change a const String25! */
    /*
    strcpy(test, other, str_sz);
    puts(test);
    */

    return 0;
}
"
190-33379,tiehuis/euler,c/src/024.c,46,6,34,32027867.739088804,162524166.0,0.1970652598211148,1351.0,1332.0,31126868.0,4100449.0,1630.0,635.0,1351.0,593.0,1500000000,0.0213519118260592,1082014363648.0,1.650831421586867e-05,0.0001194811401617,"#include <stdio.h>

#define swap(x,y)\
    do {\
        typeof(x) _ = x;\
        x = y;\
        y = _;\
    } while (0)

int next_permutation(int *a, int len)
{
    int s = -1;
    int k;
    for (k = 0; k < len - 1; ++k) {
        if (a[k] < a[k+1])
            s = k;
    }

    /* We are done if in order. Indicate end with 0 */
    if (s == -1) return 0;

    int l = 0;
    for (k = 0; k < len; ++k) {
        if (a[s] < a[k]) 
            l = k;
    }

    /* Swap values */
    swap(a[s], a[l]);

    /* Reverse sequence from k + 1 */
    l = len - 1;
    k = s + 1;
    while (k < l) {
        swap(a[k], a[l]);
        ++k;
        --l;
    }

    return 1;
}

int main(void)
{
    int s[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    int slen = sizeof(s) / sizeof(s[0]);
    int perm = 1;

    do {
        next_permutation(s, slen);
    } while (++perm < 1000000);

    int i;
    for (i = 0; i < slen; ++i)
        printf(""%d"", s[i]);
    printf(""\n"");
    return 0;
}
"
339-15920,CloudFeng/APUE,c10/eg10_21.c,46,1,162,15002184541.54674,179322.0,83629.07907562931,1377.0,1353.0,40846.0,14008.0,1662.0,638.0,1374.0,595.0,1500000000,10.00145636103116,1082014363648.0,0.0152240104393214,0.0778247712108506,"/*************************************************************************
	> File Name: eg10_21.c
	> Author:yunfeng 
    > Des: 可靠地处理信号，避免了竞争条件，不能处理设置的闹钟的交互作用
	> Created Time: Thu 11 Jun 2015 09:28:40 AM CST
 ************************************************************************/
#include<stdio.h>
#include<unistd.h>
#include<signal.h>

// nothing to do, just returning wakes up sigsuspend()
static void sig_alrm(int signo)
{

}

unsigned int Sleep(unsigned int nsecs)
{
    struct sigaction newact;
    struct sigaction oldact;
    sigset_t newmask;
    sigset_t oldmask;
    sigset_t suspmask;
    unsigned int unslept;

    // set our handler, save previous information
    newact.sa_handler = sig_alrm;
    sigemptyset(&newact.sa_mask);
    newact.sa_flags = 0;
    sigaction(SIGALRM, &newact, &oldact);

    // block SIGALRM and save current signal mask
    sigemptyset(&newmask);
    sigaddset(&newmask, SIGALRM);
    sigprocmask(SIG_BLOCK, &newmask, &oldmask);
    alarm(nsecs);

    // make sure SIGALRM isn't blocked and wait for any signal to be caught
    suspmask = oldmask;
    sigdelset(&suspmask, SIGALRM);
    sigsuspend(&suspmask);

    // some signal has been caught,SIGALRM is now blocked 
    
    unslept = alarm(0);

    // reset previous action 
    sigaction(SIGALRM, &oldact, NULL);
    
    // reset signal mask, which unblocks SIGALRM
    sigprocmask(SIG_SETMASK, &oldmask, NULL);

    return (unslept);
}

int main(void)
{
    unsigned int unslept = Sleep(10);
    printf(""%u\n"", unslept);

    return 0;
}
"
257-3275,avar/veracity,testsuite/u0078_diff_data/Diff/utf8.c,45,6,62,7788748.71321015,49440629.0,0.1575373970262392,1371.0,1347.0,10853086.0,8017753.0,1631.0,697.0,1350.0,656.0,1500000000,0.0051924991421401,1082014363648.0,5.497502873598149e-05,0.000229666524101,"#include <wchar.h>
#include <stdio.h>

int main(int argc, char ** argv)
{
	int k, j;

	// printable 1-byte range (US-ASCII) -- 0x00 -- 0x7f

	for (k=0x20; k<0x80; k+=0x10)
	{
		printf(""%04x:"",k);
		for(j=0; j<0x10; j++)
			printf("" %c"",k+j);
		printf(""\n"");
	}
	
	// 2-byte range -- 0x80 -- 0x07ff

	for (k=0x80; k<0x800; k+=0x10)
	{
		printf(""%04x:"",k);
		for(j=0; j<0x10; j++)
		{
			int sum = k+j;
			int b0 = 0x80 + ((sum & 0x003f)     );
			int b1 = 0xc0 + ((sum & 0x07c0) >> 6);
			printf("" %c%c"",b1,b0);
		}
		printf(""\n"");
	}

	// 3-byte range -- 0x0800 -- 0xffff

	for (k=0x800; k<0x10000; k+=0x10)
	{
		if (k >= 0xd7a0 && k < 0xe000) /* have some undefined areas */
			continue;
		if (k >= 0xfdd0 && k < 0xfdf0) /* have some undefined areas */
			continue;
		if (k >= 0xfff0 && k < 0x10000) /* have some undefined areas */
			continue;
		
		printf(""%04x:"",k);
		for(j=0; j<0x10; j++)
		{
			int sum = k+j;
			int b0 = 0x80 + ((sum & 0x003f)     );
			int b1 = 0x80 + ((sum & 0x0fc0) >> 6);
			int b2 = 0xe0 + ((sum & 0xf000) >>12);
			printf("" %c%c%c"",b2,b1,b0);
		}
		printf(""\n"");
	}
	
}

"
342-31743,d99kris/stackusage,tests/ex002.c,48,4,288,55346931.098028906,1799759.0,30.752412406327736,1382.0,1355.0,475171.0,321312.0,16465.0,32129.0,2396.0,26784.0,1500000000,0.0368979540653526,1082014363648.0,0.0015207591683108,0.0976467796550585,"/*
 * ex002.c
 *
 * Copyright (C) 2015-2017 Kristofer Berggren
 * All rights reserved.
 * 
 * stackusage is distributed under the BSD 3-Clause license, see LICENSE for details.
 *
 */

/* ----------- Includes ------------------------------------------ */
#include <limits.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>


/* ----------- Defines ------------------------------------------- */
#define NUM_THREADS  (PTHREAD_KEYS_MAX + 1)


/* ----------- Local Function Prototypes ------------------------- */
static pthread_t spawn_thread(void);
static void *thread_start(void *arg);


/* ----------- Global Functions ---------------------------------- */
int main(void)
{
  pthread_t tid[NUM_THREADS];
  int i = 0;

  /* Spawn threads */
  for(i = 0; i < NUM_THREADS; i++)
  {
    tid[i] = spawn_thread();
  }

  /* Wait for threads to complete */
  for(i = 0; i < NUM_THREADS; i++)
  {
    pthread_join(tid[i], NULL);
  }
  
  return 0;
}


/* ----------- Local Functions ----------------------------------- */
static pthread_t spawn_thread(void)
{
  pthread_t tid;
  pthread_attr_t attr;

  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, PTHREAD_STACK_MIN);
  pthread_create(&tid, &attr, &thread_start, NULL);
  pthread_attr_destroy(&attr);

  return tid;
}


static void *thread_start(void *arg)
{
  /* Sleep 1 ms */
  usleep(1000);

  return arg;
}

"
232-28294,mattstock/binutils-bexkat1,gold/testsuite/plugin_layout_with_alignment.c,50,4,61,1578602.9398440002,169049.0,9.338132730746706,1138.0,1128.0,38452.0,12696.0,1567.0,580.0,1318.0,544.0,1500000000,0.001052401959896,1082014363648.0,0.0134043975415412,0.0783803863298662,"// plugin_layout_with_alignment.cc -- a test case for gold

// Copyright (C) 2016-2020 Free Software Foundation, Inc.
// Written by Than McIntosh <thanm@google.com>.

// This file is part of gold.

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
// MA 02110-1301, USA.

// Verify that plugin interfaces for section size and alignment work
// correctly, and that section ordering via plugins is working
// for .bss/.rodata/.data sections.

// --- Initialized .rodata items

__attribute__ ((section("".rodata.v1_a2""), aligned(2)))
const short rodata_item1 = 101;

__attribute__ ((section("".rodata.v2_a1""), aligned(1)))
const char rodata_item2 = 'a';

__attribute__ ((section("".rodata.v3_a8""), aligned(8)))
const double rodata_item3 = 777.777;

__attribute__ ((section("".rodata.v4_a1""), aligned(1)))
const char rodata_item4[7] = {'1', '2', '3', '4', '5', '6', '7'};

// --- Initialized .data items

__attribute__ ((section("".data.v1_a2""), aligned(2)))
short rwdata_item1 = 101;

__attribute__ ((section("".data.v2_a1""), aligned(1)))
char rwdata_item2 = 'a';

__attribute__ ((section("".data.v3_a8""), aligned(8)))
double rwdata_item3 = 'b';

__attribute__ ((section("".data.v4_a1""), aligned(1)))
char rwdata_item4[3] = {'a', 'b', 'c'};

// --- Uninitialized .data items

__attribute__ ((section("".bss.v1_a2""), aligned(2)))
short bss_item1;

__attribute__ ((section("".bss.v2_a1""), aligned(1)))
char bss_item2;

__attribute__ ((section("".bss.v3_a8""), aligned(8)))
struct blah { union { double d; char c; } u; } bss_item3;

__attribute__ ((section("".bss.v4_a1""), aligned(1)))
char bss_item4[3];

int main (void)
{
  return 0;
}
"
298-1086,hanlin-he/UTD,leetcode/c/059.c,42,9,71,1689227.9963940002,388655.0,4.346340584837452,1355.0,1333.0,85980.0,46044.0,1636.0,687.0,1353.0,643.0,1500000000,0.001126151997596,1082014363648.0,0.0069161595759735,0.0327137490153305,"/* 059. Spiral Matrix II. */

#include <stdio.h>
#include <stdlib.h>

/**
 * Return an array of arrays.
 * Note: The returned array must be malloced, assume caller calls free().
 */
int** generateMatrix(int n) {
    if (n == 0)
        return NULL;
    int size = n * n;
    int** ret = (int**)malloc(n * sizeof(int*));
    for (int i = 0; i < n; i++)
        ret[i] = (int*)malloc(n * sizeof(int));

    int round = 0;
    int i = 1;

    while (i < size) {
        for (int j = round; j < n - 1 - round; j++, i++)
            ret[round][j] = i;
        for (int j = round; j < n - 1 - round; j++, i++)
            ret[j][n - 1 - round] = i;
        for (int j = round; j < n- 1 - round; j++, i++)
            ret[n - 1 - round][n - 1 - j] = i;
        for (int j = round; j < n - 1 - round; j++, i++)
             ret[n - 1 - j][round] = i;
        round++;
    }
    if (n / 2 * 2 != n)
        ret[n/2][n/2] = size;
    return ret;
}

int main() {
    int n[] = {3,5,8,10,11};
    for (int k = 0; k < 5; k++) {
        int** m = generateMatrix(n[k]);
        for (int i = 0; i < n[k]; i++) {
            for (int j = 0; j < n[k]; j++)
                printf(""%d\t"", m[i][j]);
            printf(""\n"");
        }
        printf(""\n"");
    }

    return 0;
}
"
262-33085,elvinsys/arm_tq2440,2_app/2-20.pthread/pthread.c,52,2,120,15003718393.50555,286764.0,52320.78780111869,2302.0,1809.0,67772.0,27856.0,2206.0,895.0,1647.0,815.0,1500000000,10.0024789290037,1082014363648.0,0.0143358301599921,0.0581733383527837,"/****************************************
*文件名  ：pthread.c                
*创建者  ：Elvin                    
*创建时间：2015.07.02            
*程序说明：该程序主进程创建两线程，线程各自
          让number自增10次后，主进程退出。
******************************************/

#include <stdio.h>
#include <unistd.h>
#include <pthread.h>

pthread_t workerid[2];
int number = 0;
pthread_mutex_t mutex_lock;

void * worker1()
{
    int i;
    printf(""I am worker1\n"");
    for(i = 0; i < 10; i++)
    {
        pthread_mutex_lock(&mutex_lock);
        number++;
        printf(""The worker1's number is: %d\n"", number);
        pthread_mutex_unlock(&mutex_lock);
        sleep(1);
    }
    pthread_exit(NULL);
}

void * worker2()
{
    int i;
    printf(""I am worker2\n"");
    for(i = 0; i < 10; i++)
    {
        pthread_mutex_lock(&mutex_lock);
        number++;
        printf(""The worker2's number is: %d\n"", number);
        pthread_mutex_unlock(&mutex_lock);
        sleep(1);
    }
    pthread_exit(NULL);
}

int main()
{
    /* 0.初始化线程互斥锁 */
    pthread_mutex_init(&mutex_lock, NULL);
    /* 1.创建线程1 */
    pthread_create(&workerid[0], NULL, worker1, NULL);
    /* 2.创建线程2 */
    pthread_create(&workerid[1], NULL, worker2, NULL);
    /* 3.等待线程1 */
    pthread_join(workerid[0], NULL);
    /* 4.等待线程2 */
    pthread_join(workerid[1], NULL);

    return 0;
}
"
223-27419,drif7walk/passgen,passgen.c,57,5,56,2659444.4643705,209936.0,12.667879734776312,1395.0,1374.0,47044.0,14929.0,1662.0,641.0,1380.0,599.0,1500000000,0.001772962976247,1082014363648.0,0.0131897340141757,0.0690946057153922,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//# Source configuration stuff
static unsigned char deflen = 12; // Default length of string
static char* prgname = ""passgen""; // Name that this program refers to itself by (most useful if collides with actual filename)
static char* validpass = ""01234567890qwertyuiopasdfghjklzxcvbnm-_"";
//# End source configuration stuff

int chkvalid(unsigned char c, char* list)
{
	int l = strlen(list);
	int i = 0;
	while(i < l)
	{
		if (c == list[i])
			return 1; // Return as valid
		i++;
	}
	return 0; //Return as invalid
}
int main(int argc,  char** args)
{
	
	int i = 0; // Declare for later
	int j = 0;
	srand(time(NULL)); // Initialize random	

	// Ruse to count the size of no string
	if (argc == 1) 
	{
		// ""Documentation""
		printf(""Usage: %s [length]\nExample: %s 8\nDefault length: %i\n\nUsing default length:\n"",prgname,prgname,deflen);
		i = deflen;
	}
	else if (argc == 2) // Two arguments means that the user has bothered to specify length
	{
		i = atoi(args[1]); // I knew i t would come in handy later
	}

	// Validate input
	if ( i <= 0 )
	{
		printf(""No funny business!\n"");
		return 1;
	} 
	else if (i > 1024)
	{
		printf(""Are you trying to cause a stack overflow?\n"");
	}
	
	char buf[i+1]; // +1 is the null terminator at the end
	memset(buf,32,i); // Neutralize the buffer
	buf[i] = '\0'; // Null terminator

	while(j < i) // n = 1 not n < i so that the last char would be a null terminator
	{
		unsigned char c = 0;

		while (chkvalid(c, validpass) == 0 || chkvalid(c, buf)) // Trial/Error validity check for password/form safedness and repeating
			c = (unsigned char)(rand() % 176 + 33);

		buf[j] = c;
	
		j++;
	}

	printf(""%s\n"",buf);

	return 0;
}
"
097-13617,zhuyue1314/pathgrind,valgrind-r12356/memcheck/tests/big_blocks_freed_list.c,48,6,38,1605466.5902627998,169100.0,15.507167356593731,1142.0,1132.0,38461.0,12696.0,1567.0,584.0,1317.0,544.0,1500000000,0.0010703110601752,1082014363648.0,0.0134476641040804,0.0784252399476122,"#include <stdlib.h>
/* To be run with --freelist-vol=1000000 --freelist-big-blocks=50000 */
static void jumped(void)
{
   ;
}
int main(int argc, char *argv[])
{
   char *semi_big = NULL;
   char *big = NULL;
   char *small = NULL;
   char *other_small = NULL;
   int i;
   int j;

   /* Verify that access via a dangling pointer to a big block bigger than
      the free list is found by memcheck (still on the free list). */
   semi_big = malloc (900000);
   big = malloc (1000001);
   free(semi_big);
   free(big);
   if (big[1000] > 0x0) jumped();
   if (semi_big[1000] > 0x0) jumped();

   /* Then verify that dangling pointers for small blocks is not hampered
      by doing big alloc/free. */
   small = malloc (10000);
   free(small);

   /* We should still have a nice error msg for the semi_big
      but not for the big block, which has been removed from the free list
      with the malloc of small above. */
   if (big[2000] > 0x0) jumped();
   if (semi_big[2000] > 0x0) jumped();

   big = NULL;

   {
      big = malloc (1000001);
      free(big);
      if (small[10] > 0x0) jumped();
      
      /* Do not common up the below in a loop. We
         want a different error/stack trace for each of
         these. */
      if (big[10] > 0x0) jumped();
   }
   
   
   for (i = 0; i < 100; i++) {
      other_small = malloc(10000);
      for (j = 0; j < 10000; j++)
         other_small[j] = 0x1;
   }
   if (small[10] > 0x0) jumped();
   return 0;
}
"
104-35133,fauxefox/cellular_automata,matrix.c,56,10,82,15047359172.953293,977344.0,15396.1749107786,1440.0,1416.0,198521.0,122253.0,1649.0,755.0,1360.0,653.0,1500000000,10.031572781968862,1082014363648.0,0.0029222054875253,0.0137698192496898,"// On my machine, this code seems to run non-deterministically. 
// That is, it produces different results over time (even though it's entirely self-contained).


#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <unistd.h>

#define Dx 10
#define Dy 10

void initialize(int array[Dx][Dy], int t);
void print(int array[Dx][Dy]);
void play(int array[Dx][Dy], int t);

int main (void) {
    int x[Dx][Dy];
    
    initialize(x, 1);
    print(x);
    play(x, 10);
    return 0;
} // main

void initialize(int array[Dx][Dy], int t) {
    int i,j;
    for (i = 0; i < Dx; i++) {
        for (j = 0; j < Dy; j++) {
            if(i % 2 == 0 && j % 2 == 0)
                array[i][j] = t;
            else
                array[i][j] = 1;
        }
    }
}
    
void print(int array[Dx][Dy]) {
    int i,j;
    for (i = 0; i < Dx; i++) {
        for (j = 0; j < Dy; j++) {
            printf(""%d\t"", array[i][j]);
        }//for
        printf(""\n"");
    }//for
}

void play(int array[Dx][Dy], int t) {
    if (t == 0)
        return;
    
    int final[Dx][Dy];
    
    int i,j;
    for (i = 0; i < Dx; i ++) {
        for (j = 0; j < Dy; j++) {
            final[i][j] = ((array[i][j] + array[(i - 1) % Dx][j]) % 10)\
                * ((array[i][j] + array[(i + 1) % Dx][j]) % 10)\
                * ((array[i][j] + array[(i - 1) % Dx][(j - 1) % Dy]) % 10)\
                * ((array[i][j] + array[(i - 1) % Dx][(j + 1) % Dy]) % 10)\    
                * ((array[i][j] + array[(i + 1) % Dx][(j - 1) % Dy]) % 10)\
                * ((array[i][j] + array[(i + 1) % Dx][(j + 1) % Dy]) % 10)\
                * ((array[i][j] + array[i][(j - 1) % Dx]) % 10)\
                * ((array[i][j] + array[i][(j - 1) % Dx]) % 10); 
            final[i][j] = (final[i][j] % 10) * (final[i][j] % 10);
        }//for
    }//for

    array = final;
    system(""clear"");
    print(array);
    sleep(1);
    play(array, t-1);
}
"
351-1576,lstorchi/teaching,testflops/mm.2.c,41,7,69,188495739.0138879,911630396.0,0.2067677205883775,1467.0,1442.0,260042130.0,4515203.0,111533257.0,343686.0,1364.0,94345.0,1500000000,0.1256638260092586,1082014363648.0,3.1909861855900645e-06,0.4232453159784461,"#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <time.h>

#define N (500)

double a[N][N]; 
double b[N][N];
double c[N][N];

int main()
{
  int k, i, j, ii, jj;
  double somma;
  float time1, time2, ttime1, ttime2, dub_time;

  ttime1 = clock();
  time1 = clock();
  for (j = 0; j < N; j++) {
    for (i = 0; i < N; i++) {
      a[j][i] = ((double)rand())/((double)RAND_MAX);
      b[j][i] = ((double)rand())/((double)RAND_MAX);
      c[j][i] = 0.0L;		
    }  
  }

  time2 = clock();
  dub_time = (time2 - time1)/(double) CLOCKS_PER_SEC;
  
  printf(""Tempo impiegato per inizializzare %f s.\n"", dub_time);

  time1 = clock();
  for (i=0; i<N; i++)
    for (j=0; j<N; j++)
      for (k=0; k<N; k++)
        c[i][j] = c[i][j] + a[i][k] * b[k][j];
  time2 = clock();
  dub_time = (time2 - time1)/(double) CLOCKS_PER_SEC;

  printf(""Tempo per prodotto classico %f s.\n"", dub_time);

  ttime2 = clock();
  dub_time = (ttime2 - ttime1)/(double) CLOCKS_PER_SEC;
  printf(""Tempo totale %f s.\n\n"", dub_time);
  printf(""Mflops ----------------> %f \n"", 
          2.0*N*N*N/(1000*1000*dub_time));

  /* semplice controllo */
  somma = 0.0L;
  for (i = 0; i < N; i++)
    for (j = 0; j < N; j++)
      somma = somma + c[i][j];
  printf(""Controllo -------------> %f \n"", somma);

  return EXIT_SUCCESS;  
}
"
260-29896,lnds/programando.org,hamming/hamming1.c,43,5,35,1878584.9679261001,192313.0,9.76836719306547,1364.0,1343.0,43168.0,15930.0,1622.0,644.0,1343.0,602.0,1500000000,0.0012523899786174,1082014363648.0,0.0140760115020825,0.0712545263799113,"#include <stdio.h>
#include <stdlib.h>
 
typedef unsigned long long ham;
 
size_t alloc = 0, n = 1;
ham *q = 0;
 
void qpush(ham h)
{
	int i, j;
	if (alloc <= n) {
		alloc = alloc ? alloc * 2 : 16;
		q = realloc(q, sizeof(ham) * alloc);
	}
 
	for (i = n++; (j = i/2) && q[j] > h; q[i] = q[j], i = j);
	q[i] = h;
}
 
ham qpop()
{
	int i, j;
	ham r, t;
	/* outer loop for skipping duplicates */
	for (r = q[1]; n > 1 && r == q[1]; q[i] = t) {
		/* inner loop is the normal down heap routine */
		for (i = 1, t = q[--n]; (j = i * 2) < n;) {
			if (j + 1 < n && q[j] > q[j+1]) j++;
			if (t <= q[j]) break;
			q[i] = q[j], i = j;
		}
	}
 
	return r;
}
 
int main()
{
	int i;
	ham h;
 
	for (qpush(i = 1); i <= 21; i++) {
		/* takes smallest value, and queue its multiples */
		h = qpop();
		qpush(h * 7);
		qpush(h * 13);
		qpush(h * 19);
 
			printf(""%llu "", h);
	}
 
	/* free(q); */
	return 0;
}"
292-32802,chrismoulds/Misc.-Projects,projecteuler/C/problem10.c,41,3,37,21405532.49046195,48658267.0,0.4399156262593569,1355.0,1335.0,4039435.0,4361216.0,251850.0,2410304.0,1341.0,125594.0,1500000000,0.0142703549936413,1082014363648.0,5.528351431011713e-05,0.3320086740896628,"/*
* Project Euler Problem #10:
*
* Find the sum of all the primes below two million. 
* 
* Author: Chris Moulds
*/

#include <stdio.h>
#include <stdlib.h>

/*
* Perform the Sieve of Eratosthenes and sum the results. Calloc will initialize
* all of the elements to zero; therefore, we will mark the non-primes as -1 as 
* they are deduced.
*/
long sieve_and_sum(int max)
{
	long sum = 0;
	int * list = calloc(max, sizeof(int));
	long i, j;

	for (i=2; i<max; i++){
		if (list[i] == 0){
			for (j=i; i*j<max; j++){
				list[i*j] = -1;
			}
		}
	}

	/*
	* We now have a list of prime numbers from 2 - 2,000,000. Sum them and
	* return.
	*/
	for (i=2; i<max; i++){
		if (list[i] == 0)
			sum+=i;
	}	
	return sum;
}

int main()
{
	long sum = 0;

	sum = sieve_and_sum(2000000);
		
	printf(""ANSWER: %ld\n"", sum);

	return 0;
}"
369-4807,lugon/LuxCC,src/tests/execute/llvm/methcall.c,72,2,70,478942465.5027687,1750175020.0,0.2736540400399498,1318.0,1297.0,666706418.0,333346918.0,1616.0,635.0,1342.0,593.0,1500000000,0.3192949770018458,1082014363648.0,1.494136283581513e-06,4.1857767474114e-06,"/* -*- mode: c -*-
 * $Id$
 * http://www.bagley.org/~doug/shootout/
 */

#include <stdio.h>
#include <stdlib.h>

#define SMALL_PROBLEM_SIZE
int puts(const char *s);

enum {false, true};

#define TOGGLE \
    char state; \
    char (*value)(struct Toggle *); \
    struct Toggle *(*activate)(struct Toggle *)

#define DESTROY  free

typedef struct Toggle {
    TOGGLE;
} Toggle;

char toggle_value(Toggle *this) {
    return(this->state);
}
Toggle *toggle_activate(Toggle *this) {
    this->state = !this->state;
    return(this);
}
Toggle *init_Toggle(Toggle *this, char start_state) {
    this->state = start_state;
    this->value = toggle_value;
    this->activate = toggle_activate;
    return(this);
}
Toggle *new_Toggle(char start_state) {
    Toggle *this = (Toggle *)malloc(sizeof(Toggle));
    return(init_Toggle(this, start_state));
}


typedef struct NthToggle {
    TOGGLE;
    int count_max;
    int counter;
} NthToggle;

NthToggle *nth_toggle_activate(NthToggle *this) {
    if (++this->counter >= this->count_max) {
	this->state = !this->state;
	this->counter = 0;
    }
    return(this);
}
NthToggle *init_NthToggle(NthToggle *this, int max_count) {
    this->count_max = max_count;
    this->counter = 0;
    this->activate = (Toggle *(*)(Toggle *))nth_toggle_activate;
    return(this);
}
NthToggle *new_NthToggle(char start_state, int max_count) {
    NthToggle *this = (NthToggle *)malloc(sizeof(NthToggle));
    this = (NthToggle *)init_Toggle((Toggle *)this, start_state);
    return(init_NthToggle(this, max_count));
}


int main(int argc, char *argv[]) {
#ifdef SMALL_PROBLEM_SIZE
#define LENGTH 50000000
#else
#define LENGTH 500000000
#endif
    int i, n = ((argc == 2) ? atoi(argv[1]) : LENGTH);
    Toggle *tog;
    NthToggle *ntog;
    char val = true;

    tog = new_Toggle(true);
    for (i=0; i<n; i++) {
	val = tog->activate(tog)->value(tog);
    }
    puts(val ? ""true\n"" : ""false\n"");
    DESTROY(tog);

    val = true;
    ntog = new_NthToggle(val, 3);
    for (i=0; i<n; i++) {
	val = ntog->activate(ntog)->value(ntog);
    }
    puts(val ? ""true\n"" : ""false\n"");
    DESTROY(ntog);
    return 0;
}
"
340-23702,ikaustav/algorithm-code,DoubleLinkedList.c,89,2,75,1483262.9822194502,184321.0,8.04716771284878,1363.0,1340.0,41719.0,14918.0,1638.0,645.0,1353.0,600.0,1500000000,0.0009888419881463,1082014363648.0,0.0146646339809354,0.074792097039038,"#include <stdio.h>
#include <stdlib.h>

struct node{
  int data;
  struct node *prev;
  struct node *next;
};

void traverseLinkedList(struct node *head);
void push(struct node **head, int data);
void insertAfter(struct node *prev, int data);
void insertLast(struct node **head, int data);
void insertBefore(struct node **head, struct node *next, int data);

int main(){
  struct node *head = NULL;

  push(&head, 1);
  push(&head, 2);
  push(&head, 3);

  struct node *point = head;
  while(point->data != 3){
    point = point->next;
  }
  printf(""%s %d\n"", ""Found: "", point->data);
  insertAfter(point, 5);
  insertBefore(&head, point, 7);
  traverseLinkedList(head);
  insertLast(&head, 10);
  printf(""%s\n"", ""After inserting at last."");
  traverseLinkedList(head);
}

void push(struct node **head, int data){
  struct node *newNode = (struct node *)malloc(sizeof(struct node));

  newNode->data = data;
  newNode->next = (*head);
  newNode->prev = NULL;

  if(*head != NULL){
    (*head)->prev = newNode;
  }

  *head = newNode;
}

void insertAfter(struct node *prev, int data){
  if(prev == NULL){
    return;
  }

  struct node *newNode = (struct node *)malloc(sizeof(struct node));
  newNode->data = data;
  newNode->next = prev->next;
  newNode->prev = prev;

  prev->next = newNode;
  struct node *nextNode = prev->next;
  nextNode->prev = newNode;
}

void insertBefore(struct node **head, struct node *next, int data){
  if(next == NULL){
    return;
  }

  struct node *newNode = (struct node *)malloc(sizeof(struct node));
  newNode->data = data;
  newNode->next = next;
  newNode->prev = next->prev;

  struct node *prevNode = next->prev;
  if(prevNode != NULL){
    prevNode->next = newNode;
  }
  else{
    *head = newNode;
  }

  next->prev = newNode;
}

void insertLast(struct node **head, int data){
  struct node *newNode = (struct node *)malloc(sizeof(struct node));
  newNode->data = data;
  newNode->next = NULL;

  if(*head == NULL){
    newNode->prev = NULL;
    *head = newNode;
    return;
  }

  struct node *current = *head;
  while(current->next != NULL){
    current = current->next;
  }

  newNode->prev = current;
  current->next = newNode;
}

void traverseLinkedList(struct node *head){
  if(head == NULL){
    return;
  }

  printf(""Element value= %d \n"", head->data);
  traverseLinkedList(head->next);
}
"
242-11606,EZchip/gcc,libgcc/config/arc/ieee-754/divtab-arc-sf.c,105,11,132,3051649.42983525,241085.0,12.657979550780844,1347.0,1325.0,54715.0,23010.0,1625.0,662.0,1345.0,617.0,1500000000,0.0020344329532235,1082014363648.0,0.0110832279071696,0.054667095529109,"/* Copyright (C) 2008-2012 Free Software Foundation, Inc.  
   Contributor: Joern Rennecke <joern.rennecke@embecosm.com>
		on behalf of Synopsys Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* We use a polynom similar to a Tchebycheff polynom to get an initial
   seed, and then use a newton-raphson iteration step to get an
   approximate result
   If this result can't be rounded to the exact result with confidence, we
   round to the value between the two closest representable values, and
   test if the correctly rounded value is above or below this value.
 
   Because of the Newton-raphson iteration step, an error in the seed at X
   is amplified by X.  Therefore, we don't want a Tchebycheff polynom
   or a polynom that is close to optimal according to the maximum norm
   on the errro of the seed value; we want one that is close to optimal
   according to the maximum norm on the error of the result, i.e. we
   want the maxima of the polynom to increase linearily.
   Given an interval [X0,X2) over which to approximate,
   with X1 := (X0+X2)/2,  D := X1-X0, F := 1/D, and S := D/X1 we have,
   like for Tchebycheff polynoms:
   P(0) := 1
   but then we have:
   P(1) := X + S*D
   P(2) := 2 * X^2 + S*D * X - D^2
   Then again:
   P(n+1) := 2 * X * P(n) - D^2 * P (n-1)
 */

int
main (void)
{
  long double T[5]; /* Taylor polynom */
  long double P[5][5];
  int i, j;
  long double X0, X1, X2, S;
  long double inc = 1./64;
  long double D = inc*0.5;
  long i0, i1, i2;

  memset (P, 0, sizeof (P));
  P[0][0] = 1.;
  for (i = 1; i < 5; i++)
    P[i][i] = 1 << i-1;
  P[2][0] = -D*D;
  for (X0 = 1.; X0 < 2.; X0 += inc)
    {
      X1 = X0 + inc * 0.5;
      X2 = X1 + inc;
      S = D / X1;
      T[0] = 1./X1;
      for (i = 1; i < 5; i++)
	T[i] = T[i-1] * -T[0];
#if 0
      printf (""T %1.8f %f %f %f %f\n"", (double)T[0], (double)T[1], (double)T[2],
(double)T[3], (double)T[4]);
#endif
      P[1][0] = S*D;
      P[2][1] = S*D;
      for (i = 3; i < 5; i++)
	{
	  P[i][0] = -D*D*P[i-2][0];
	  for (j = 1; j < i; j++)
	    P[i][j] = 2*P[i-1][j-1]-D*D*P[i-2][j];
	}
#if 0
      printf (""P3 %1.8f %f %f %f %f\n"", (double)P[3][0], (double)P[3][1], (double)P[3][2],
(double)P[3][3], (double)P[3][4]);
      printf (""P4 %1.8f %f %f %f %f\n"", (double)P[4][0], (double)P[4][1], (double)P[4][2],
(double)P[4][3], (double)P[4][4]);
#endif
      for (i = 4; i > 1; i--)
	{
	  long double a = T[i]/P[i][i];

	  for (j = 0; j < i; j++)
	    T[j] -= a * P[i][j];
	}
#if 0
      printf (""A %1.8f %f %f\n"", (double)T[0], (double)T[1], (double)T[2]);
#endif
#if 0
      i2 = T[2]*512;
      long double a = (T[2]-i/512.)/P[2][2];
      for (j = 0; j < 2; j++)
	T[j] -= a * P[2][j];
#else
      i2 = 0;
#endif
      for (i = 0, i0 = 0; i < 4; i++)
	{
	  long double T0, Ti1;

	  i1 = T[1]*8192. + i0 / (long double)(1 << 19) - 0.5;
	  i1 = - (-i1 & 0x1fff);
	  Ti1 = ((unsigned)(-i1 << 19) | i0) /-(long double)(1LL<<32LL);
	  T0 = T[0] - (T[1]-Ti1)/P[1][1] * P[1][0] - (X1 - 1) * Ti1;
	  i0 = T0 * 512 * 1024 + 0.5;
	  i0 &= 0x7ffff;
	}
#if 0
      printf (""A %1.8f %f %f\n"", (double)T[0], (double)T[1], (double)T[2]);
#endif
      printf (""\t.long 0x%x\n"", (-i1 << 19) | i0);
   }
  return 0;
}
"
231-6843,dllm/practice,LinkedList/rev_k_node.c,68,2,76,1841582.70712935,183248.0,10.6926569457784,1357.0,1336.0,41470.0,14854.0,1627.0,643.0,1346.0,598.0,1500000000,0.0012277218047529,1082014363648.0,0.0146959311970662,0.0748171294652368,"#include<stdio.h>
#include<stdlib.h>

/* Link list node */
struct node
{
	int data;
	struct node* next;
};

struct node *reverse (struct node * head, int k){
	struct node * curr = head;
	struct node * prev = NULL;
	struct node * next = NULL;

	int count = 0;

	while (count < k && curr != NULL) {

		next = curr->next;
		curr->next = prev;
		prev = curr;
		curr = next;
		count++;
	}

	if (next != NULL){
		curr->next = reverse (next, k);

	}

	return prev;
}

/* UTILITY FUNCTIONS */
/* Function to push a node */
void push(struct node** head_ref, int new_data)
{
	/* allocate node */
	struct node* new_node =
		(struct node*) malloc(sizeof(struct node));

	/* put in the data  */
	new_node->data  = new_data;

	/* link the old list off the new node */
	new_node->next = (*head_ref);    

	/* move the head to point to the new node */
	(*head_ref)    = new_node;
}

/* Function to print linked list */
void printList(struct node *node)
{
	while (node != NULL)
	{
		printf(""%d  "", node->data);
		node = node->next;
	}
}    

/* Drier program to test above function*/
int main(void)
{
	/* Start with the empty list */
	struct node* head = NULL;

	/* Created Linked list is 1->2->3->4->5->6->7->8->9 */
	push(&head, 9);
	push(&head, 8);
	push(&head, 7);
	push(&head, 6);
	push(&head, 5);
	push(&head, 4);
	push(&head, 3);
	push(&head, 2);
	push(&head, 1);           

	printf(""\nGiven linked list \n"");
	printList(head);
	head = reverse(head, 3);

	printf(""\nReversed Linked list \n"");
	printList(head);

	return(0);
}
"
086-1847,ITGGoteborg/progolymp2014,C/Linus/gentable.c,63,10,112,170639623.65500626,930950488.0,0.1832961314264867,1405.0,1382.0,164437940.0,125590051.0,503801.0,534312.0,128635.0,243531.0,1500000000,0.1137597491033375,1082014363648.0,2.993714527168281e-06,0.0048625616966743,"// This table generator is for this problem:
//
// http://codereview.stackexchange.com/questions/108074/optimize-program-to-test-for-divisibility-of-numbers-3-0
//
// It creates a table where each number is followed by all other numbers that
// are permutations of that number's digits.  For example, 102 should be
// followed by 120, 201, 210.  However, if a permutation has already been
// used, it should not contain its own entry.  For example, 120 should not
// have its own entry because it was already listed in the entry for 102.
//
// The table lists numbers as negative if they start a permutation sequence.
//
// So the table will look like -1, -2, -3, ..., -12, 21, -13, 31, -14, ...
// -102, 120, 201, 210, -103, ..., -999999, -1000000.
//
// The last entry, -1000000, is a sentinel entry that is used to mark the
// last entry.  The program that will use this table will need to use that
// entry.
//
// This generator should be invoked like this:
//
// ./gentable > table.h
//
// You can then compile permute.c, which includes table.h.
//
#include <stdio.h>
#include <stdlib.h>
#define MAX 1000000

int nums[MAX];
int *permutations[MAX];
int permCount[MAX];

int main()
{
    int i;

    for (i=0;i<MAX;i++) {
        int num=i;
        int j;
        int p[10] = {0};
        while (num>0) {p[num%10]++; num/=10;}

        for(j=1;j<10;j++) if(p[j]>0) {num=j; p[j]--; break;}
        for(j=0;j<10;j++) while (p[j]>0) {num=10*num+j; p[j]--;}

        // i -> num
        if (permutations[num] == NULL) {
            if (num >= 100000)
                permutations[num] = (int *) calloc(720, sizeof(int));
            else if (num >= 10000)
                permutations[num] = (int *) calloc(120, sizeof(int));
            else
                permutations[num] = (int *) calloc(24, sizeof(int));
        }
        // Append permutation.
        permutations[num][permCount[num]++] = i;
    }
    for (i=1;i<MAX;i++) {
        int j;
        if (permutations[i] != NULL) {
            printf(""-%d, "", i);
            for (j=1;j<permCount[i];j++) {
                printf(""%d, "", permutations[i][j]);
            }
            printf(""\n"");
        }
    }
    printf(""-%d\n"", MAX);
    return 0;
}
"
369-29163,chggr/puzzles,easy/array_product.c,92,4,56,1680932.70622185,175415.0,9.582601259869453,1368.0,1348.0,39723.0,13555.0,1633.0,638.0,1350.0,593.0,1500000000,0.0011206218041479,1082014363648.0,0.0154832825014964,0.0790945606066293,"#include <stdio.h>

// Task description: Given an array of N integers, write a method to return an
// output array such that the element at position i will be equal to the product
// of all elements of the input array except the element at i. Can this be done
// in O(N) without using the division operator?
//
// E.g. for input array: {4, 7, 3, 1, 5}
//      the method should return: {105, 60, 140, 420, 84}
//
// Solution: The implementation below first populates the output array from left
// to right so that each position holds the product of all elements at its left.
// Then it goes through the array once more from right to left, keeping track of
// the running product (i.e. product of all elements to the right) and
// populating each position by multiplying the running product with the value
// calculated previously. The runtime complexity of this approach is O(N), where
// N is the number of elements in the input array. The space complexity is O(1).

void calculate(int input[], int output[], int size) {
    int product = 1;
    for (int i = 0; i < size; i++) {
        output[i] = product;
        product *= input[i];
    }

    product = 1;
    for (int i = size - 1; i >= 0; i--) {
        output[i] *= product;
        product *= input[i];
    }
}

int are_equal(int a[], int b[], int size) {
    for (int i = 0; i < size; i++) {
        if (a[i] != b[i]) return 0;
    }
    return 1;
}

int test_zeros() {
    int input[] = {0, 0, 0, 0, 0};
    int expected[] = {0, 0, 0, 0, 0};
    int output[5];

    calculate(input, output, 5);
    return are_equal(output, expected, 5);
}

int test_ones() {
    int input[] = {1, 1, 1, 1, 1};
    int expected[] = {1, 1, 1, 1, 1};
    int output[5];

    calculate(input, output, 5);
    return are_equal(output, expected, 5);
}

int test_positive() {
    int input[] = {4, 7, 3, 1, 5};
    int expected[] = {105, 60, 140, 420, 84};
    int output[5];

    calculate(input, output, 5);
    return are_equal(output, expected, 5);
}

int test_negative() {
    int input[] = {-4, 7, -3, 1, -5};
    int expected[] = {105, -60, 140, -420, 84};
    int output[5];

    calculate(input, output, 5);
    return are_equal(output, expected, 5);
}

int test_one_zero() {
    int input[] = {4, 7, 0, 1, 5};
    int expected[] = {0, 0, 140, 0, 0};
    int output[5];

    calculate(input, output, 5);
    return are_equal(output, expected, 5);
}

int main() {
    int counter = 0;
    if (!test_zeros()) {
        printf(""Zeros test failed!\n"");
        counter++;
    }
    if (!test_ones()) {
        printf(""Ones test failed!\n"");
        counter++;
    }
    if (!test_positive()) {
        printf(""Positive test failed!\n"");
        counter++;
    }
    if (!test_negative()) {
        printf(""Negative test failed!\n"");
        counter++;
    }
    if (!test_one_zero()) {
        printf(""One zero test failed!\n"");
        counter++;
    }
    printf(""%d tests failed.\n"", counter);
}

"
058-22161,chaws/personal,weird_c/branch_preditction.c,109,8,83,17743860.02216475,49556807.0,0.358050913167186,1570.0,1540.0,15131307.0,7996381.0,106621.0,74958.0,1384.0,19339.0,1500000000,0.0118292400147765,1082014363648.0,6.275626272693476e-05,0.0087471778415551,"/**
 *	Got this piece of code out of http://stackoverflow.com/questions/11227809/why-is-processing-a-sorted-array-faster-than-an-unsorted-array?rq=1
 * It looked too interesting, so I had to re-do it myself to prove it
 *
 * In this algorightm, we'll work on two arrays, a sorted one and another one unsorted.
 * The operations we make are make faster using sorted arrays if compared with the unsorted one
 * This is due something called branch prediction, present in modern CPUs 
 * allowing common branches to be chosen by default by the processor
 */
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ARRSIZE 100000

int data[ARRSIZE], sdata[ARRSIZE];

int compare(const void * a, const void * b)
{
	return *(int *)a - *(int *)b;
}

void sorted_if()
{
	printf(""Running %s: "", __func__);
	int i;
	long long sum;
	for(sum = i = 0; i < ARRSIZE; i++)
	{
		if(sdata[i] > 128)
		{
			sum += sdata[i];
		}
	}
	printf(""sum = %llu, took "", sum);
}

void sorted_bitwise()
{
	printf(""Running %s: "", __func__);
	int i, t;
	long long sum;
	for(sum = i = 0; i < ARRSIZE; i++)
	{
		t = (sdata[i] - 128) >> 31;
		sum += ~t & sdata[i];
	}
	printf(""sum = %llu, took "", sum);
}

void sorted_ternary()
{
	printf(""Running %s: "", __func__);
	int i;
	long long sum;
	for(sum = i = 0; i < ARRSIZE; i++)
	{
		sum += (sdata[i] > 192) * sdata[i];
	}
	printf(""sum = %llu, took "", sum);
}

void unsorted_if()
{
	printf(""Running %s: "", __func__);
	int i;
	long long sum;
	for(sum = i = 0; i < ARRSIZE; i++)
	{
		if(data[i] > 128)
		{
			sum += data[i];
		}
	}
	printf(""sum = %llu, took "", sum);
}

void unsorted_bitwise()
{
	printf(""Running %s: "", __func__);
	int i, t;
	long long sum;
	for(sum = i = 0; i < ARRSIZE; i++)
	{
		t = (data[i] - 128) >> 31;
		sum += ~t & data[i];
	}
	printf(""sum = %llu, took "", sum);
}

void unsorted_ternary()
{
	printf(""Running %s: "", __func__);
	int i;
	long long sum;
	for(sum = i = 0; i < ARRSIZE; i++)
	{
		sum += (data[i] > 192) * data[i];
	}
	printf(""sum = %llu, took "", sum);
}

int main(void)
{
	void (*functions[])(void) = {sorted_if, sorted_bitwise, sorted_ternary, unsorted_if, unsorted_bitwise, unsorted_ternary};
	int i = 6, c;
	clock_t elapsed;

	// Fill data
	srand(time(NULL));
	for (c = 0; c < ARRSIZE; c++)
	{
        sdata[c] = data[c] = rand() % 256;
	}

	// Sort
	qsort(sdata, ARRSIZE, sizeof(int), compare);

	// Let the magic begin
	while(i--)
	{	
		elapsed = clock();
		functions[i]();
		printf(""%.f ms\n"", (double)(clock() - elapsed));
	}
}
"
005-21754,ericherman/code-snips,c/itoan.c,86,4,83,1665736.3157718,176804.0,9.384154204656005,1385.0,1360.0,40101.0,13740.0,1647.0,639.0,1355.0,595.0,1500000000,0.0011104908771812,1082014363648.0,0.0155256668401167,0.0786761018554633,"/* itoan.c
   Copyright (C) 2016, 2018 Eric Herman <eric@freesa.org>

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation, either version 3 of the
   License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

	https://www.gnu.org/licenses/lgpl-3.0.txt
	https://www.gnu.org/licenses/gpl-3.0.txt
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*
 * The function ""itoa"" is not a standard function but shows up a lot,
 * so this can be used instead.
 *
 * If ""itoa"" source compatibility is needed, use ""gcc -DNEED_UNSAFE_ITOA=1"".
 *
 * Typically, itoa treats non-base10 calls as unsigned, however this
 * behavior can be altered with ""gcc -DNEED_SIGNED_NON_BASE10_ITOA=1"".
 */

#if NEED_UNSAFE_ITOA
#define itoa(n, buf, base) itoan(n, buf, ((size_t)-1), base)
#endif

char *itoan(int n, char *buf, size_t buflen, unsigned base)
{
	size_t i, j, maxlen;

#if NEED_SIGNED_NON_BASE10_ITOA
	long l;
#else
	unsigned l;
#endif

	char c;

	if (buf == NULL || buflen == 0 || base == 0 || base > 36) {
		return NULL;
	}
	maxlen = buflen - 1;

	/* base is 10; good grief, just use sprintf */
	if (base == 10) {
		snprintf(buf, buflen, ""%d"", n);
		return buf;
	}

	/* cast to long to try to preserve sign-ness of INT_MIN */
#if NEED_SIGNED_NON_BASE10_ITOA
	l = (n < 0) ? -((long)n) : n;
#else
	l = n;
#endif

	/* fill the string in little endian order */
	i = 0;
	do {
		if (i >= maxlen) {
			/* buffer too short, bail out */
			buf[0] = '\0';
			return NULL;
		}

		c = l % base;
		if (c < 10) {
			c = '0' + c;
		} else {
			c = 'A' + (c - 10);
		}
		buf[i++] = c;

		l = l / base;
	} while (l);

#if NEED_SIGNED_NON_BASE10_ITOA
	/* tack on the sign if needed */
	if (n < 0) {
		if (i >= maxlen) {
			/* buffer too short, bail out */
			buf[0] = '\0';
			return NULL;
		}
		buf[i++] = '-';
	}
#endif

	buf[i] = '\0';

	/* reverse the string for big endian */
	for (i = 0, j = (strnlen(buf, buflen) - 1); i < j; ++i, --j) {
		c = buf[i];
		buf[i] = buf[j];
		buf[j] = c;
	}

	return buf;
}

#define BUFLEN 255
int main(int argc, char **argv)
{
	char buf[BUFLEN];
	int i;
	unsigned base;

	i = (argc > 1) ? atoi(argv[1]) : 0;
	base = (argc > 2) ? (unsigned)atoi(argv[2]) : 10;

	printf(""i:%s\n"", itoan(i, buf, BUFLEN, base));

#ifdef NEED_UNSAFE_ITOA
	printf("" :%s\n"", itoa(i, buf, base));
#endif

	return 0;
}
"
004-4020,cogumbreiro/relay,nulltests/pldi_prod_cons1/test.c,83,5,177,2011218.1082366998,376406.0,5.343214507738984,1340.0,1313.0,77142.0,44226.0,1730.0,1206.0,1362.0,1134.0,1500000000,0.0013408120721578,1082014363648.0,0.0070482404637545,0.0447564432140267,"#include<pthread.h>
#include<stdlib.h>
#include<stdio.h>

// PLDI 08 example (safe version)

typedef struct _buffer_list {
  void *data;
  struct _buffer_list *next;
} buffer_list;

#define lock(l) \
  pthread_mutex_lock(l)
#define unlock(l) \
  pthread_mutex_unlock(l)

#define DATA_LEN 100

//////////////////////////////////////////////////////////////
// Safe version

buffer_list * bufs1;
pthread_mutex_t buf_lock1;
int perf_ctr1;

void *makeData1(size_t s) {
  return malloc(s);
}

buffer_list *makeList1(int num) {
  int i;
  buffer_list *result = NULL;
  buffer_list *next = NULL;

  for (i = 0; i < num; i++) {
    next = malloc(sizeof(buffer_list));
    next->next = result;
    result = next;
  }

  return result;
}


int *produce1() {
  int i;
  int *result;
  result = (int *)malloc(sizeof(int) * DATA_LEN);
  for (i = 0; i < DATA_LEN; i++) {
    result[i] = i;
  }
  return result;
}

void consume1(int *data) {
  int i;
  if (data != NULL) {
    for (i = 0; i < DATA_LEN; i++) {
      printf (""%d\n"", data[i]);
    }
  }
}

void *thread_producer1(void *ignore) {
  buffer_list *px;
  int *t;
  px = bufs1;
  
  while (px != NULL) {
    lock(&buf_lock1);
    px->data = makeData1(sizeof(int *));
    
    perf_ctr1++;
    t = produce1();
    
    *((int **)(px->data)) = t;
    unlock(&buf_lock1);
    px = px->next;
  }
  return 0;
}


void *thread_consumer1(void *ignore) {
  buffer_list *cx;
  perf_ctr1 = 0;
  cx = bufs1;
  while(cx != NULL) {
    lock(&buf_lock1);
    if (cx->data != NULL) {
      consume1(*((int **)cx->data));
      free(cx->data);
      cx->data = NULL;
      cx = cx->next;
    }
    unlock(&buf_lock1);
  }
  return 0;
}

//////////////////////////////////////////////////////////////

int main(int argc, char *argv[]) {
  pthread_t thr0, thr1, thr2, thr3;

  pthread_mutex_init(&buf_lock1, 0);

  bufs1 = makeList1(1000);

  pthread_create(&thr0, (void *)0, &thread_consumer1, (void *)0);
  pthread_create(&thr1, (void *)0, &thread_producer1, (void *)0);

  return 0;
}
"
114-19962,selmentdev/selment-toolchain,source/gcc-latest/gcc/testsuite/gcc.dg/torture/builtin-math-7.c,73,7,143,1843771.43159505,170639.0,10.805097310696851,1193.0,1181.0,38769.0,12834.0,1580.0,589.0,1326.0,547.0,1500000000,0.0012291809543967,1082014363648.0,0.0139124115823463,0.0783287793345348,"/* Copyright (C) 2009  Free Software Foundation.

   Verify that folding of complex mul and div work correctly.

   Origin: Kaveh R. Ghazi,  August 13, 2009.  */

/* { dg-do run } */
/* C6X fails due to -freciprocal-math default.  */
/* { dg-skip-if """" { tic6x-*-* } ""*"" """" } */
/* { dg-add-options ieee } */
/* { dg-require-effective-target large_double } */

extern void link_error(int);

/* Evaluate this expression at compile-time.  */
#define COMPILETIME_TESTIT(TYPE,X,OP,Y,RES) do { \
  if ((_Complex TYPE)(X) OP (_Complex TYPE)(Y) != (_Complex TYPE)(RES)) \
    link_error(__LINE__); \
} while (0)

/* Use this error function for cases which only evaluate at
   compile-time when optimizing.  */
#ifdef __OPTIMIZE__
# define ERROR_FUNC(X) link_error(X)
#else
# define ERROR_FUNC(X) __builtin_abort()
#endif

/* Evaluate this expression at compile-time using static initializers.  */
#define STATICINIT_TESTIT(TYPE,X,OP,Y,RES) do { \
  static const _Complex TYPE foo = (_Complex TYPE)(X) OP (_Complex TYPE)(Y); \
  if (foo != (_Complex TYPE)(RES)) \
    ERROR_FUNC (__LINE__); \
} while (0)

/* Evaluate this expression at runtime.  */
#define RUNTIME_TESTIT(TYPE,X,OP,Y,RES) do { \
  volatile _Complex TYPE foo; \
  foo = (_Complex TYPE)(X); \
  foo OP##= (_Complex TYPE)(Y); \
  if (foo != (_Complex TYPE)(RES)) \
    __builtin_abort(); \
} while (0)

/* Evaluate this expression at compile-time and runtime.  */
#define TESTIT(TYPE,X,OP,Y,RES) do { \
  STATICINIT_TESTIT(TYPE,X,OP,Y,RES); \
  COMPILETIME_TESTIT(TYPE,X,OP,Y,RES); \
  RUNTIME_TESTIT(TYPE,X,OP,Y,RES); \
} while (0)

/* Either the real or imaginary parts should be infinity.  */
#define TEST_ONE_PART_INF(VAL) do { \
  static const _Complex double foo = (VAL); \
  if (! __builtin_isinf(__real foo) && ! __builtin_isinf(__imag foo)) \
    ERROR_FUNC (__LINE__); \
  if (! __builtin_isinf(__real (VAL)) && ! __builtin_isinf(__imag (VAL))) \
    __builtin_abort(); \
} while (0)

int main()
{
  /* Test some regular finite values.  */
  TESTIT (double, 3.+4.i, *, 2, 6+8i);
  TESTIT (double, 3.+4.i, /, 2, 1.5+2i);
  TESTIT (int, 3+4i, *, 2, 6+8i);
  TESTIT (int, 3+4i, /, 2, 1+2i);

  TESTIT (double, 3.+4.i, *, 2+5i, -14+23i);
  TESTIT (double, 3.+4.i, /, 5i, .8-.6i);
  TESTIT (int, 3+4i, *, 2+5i, -14+23i);
  TESTIT (int, 30+40i, /, 5i, 8-6i);
  TESTIT (int, 14+6i, /, 7+3i, 2);
  TESTIT (int, 8+24i, /, 4+12i, 2);

  /* Test that we don't overflow.  */
  TESTIT (double,
	  (__DBL_MAX__ * 0.5 + __DBL_MAX__ * 0.5i),
	  /,
	  (__DBL_MAX__ * 0.25 + __DBL_MAX__ * 0.25i),
	  2);

  /* Test for accuracy.  */
  COMPILETIME_TESTIT (double,
		      (1 + __DBL_EPSILON__ + 1i),
		      *,
		      (1 - __DBL_EPSILON__ + 1i),
		      -4.93038065763132378382330353301741393545754021943139377981e-32+2i);

  /* This becomes (NaN + iInf).  */
#define VAL1 ((_Complex double)__builtin_inf() * 1i)

  /* Test some C99 Annex G special cases.  */
  TEST_ONE_PART_INF ((VAL1) * (VAL1));
  TEST_ONE_PART_INF ((_Complex double)1 / (_Complex double)0);
  TEST_ONE_PART_INF ((VAL1) / (_Complex double)1);

  RUNTIME_TESTIT (double, 1, /, VAL1, 0);
  STATICINIT_TESTIT (double, 1, /, VAL1, 0);

  return 0;
}
"
356-15074,avasyukov/gcm-necro,gcm/tools/create_layer.c,82,9,156,1064959054.3471277,6030988678.0,0.1765811728157915,1445.0,1419.0,1055385823.0,683370081.0,1653.0,774.0,1362.0,728.0,1500000000,0.7099727028980851,1082014363648.0,4.748806792570138e-07,2.5978344571590883e-06,"#include <stdio.h>

// Number of points in layer sample
#ifndef Size1
#define Size1 201
#endif
#ifndef Size2
#define Size2 201
#endif
// Number of layers in zone
#ifndef Width
#define Width 10
#endif

#ifndef ZonesPerEdge
#define ZonesPerEdge 2
#endif

// Example:
// If you set Size to 60 and Width to 10
// you will get layer 60x60x10 total

int get_num_in_zone(int i, int j, int k);
int write_tetrs(FILE* file, int num, int i, int j, int k);
int get_absolute_num(int i, int j, int k);

int main()
{
	FILE* file;
	char file_name[] = ""layer.msh"";

	file = fopen(file_name,""w"");

	fprintf(file, ""$MeshFormat\n2 0 8\n$EndMeshFormat\n$Nodes\n%d\n"", Size1*Size2*Width);

	int cur_num;

	for(int k = 0; k < Width; k++)
		for(int j = 0; j < Size2; j++)
			for(int i = 0; i < Size1; i++)
			{
				cur_num = get_num_in_zone(i, j, k);
				if( cur_num >= 0 )
					fprintf(file, ""%d %d %d %d\n"", cur_num, i , j, k);
			}

	fprintf(file, ""$EndNodes\n$Elements\n%d\n"", (Size1-1)*(Size2-1)*(Width-1)*6);

	int tetr_num = 1;

	for(int k = 0; k < Width-1; k++)
		for(int j = 0; j < Size2-1; j++)
			for(int i = 0; i < Size1-1; i++)
			{
				write_tetrs(file, tetr_num, i, j, k);
				tetr_num += 6;
			}

	fprintf(file, ""$EndElements\n"");

/*	fprintf(file, ""$NodeData\n1\n\""Mesh partitions indexes\""\n1\n0.0\n3\n0\n1\n%d\n"", Size*Size*Width);

	int nodes_per_zone_edge;
	if(Size % ZonesPerEdge == 0)
		nodes_per_zone_edge = (int)(Size / ZonesPerEdge);
	else
		nodes_per_zone_edge = (int)(Size / ZonesPerEdge) + 1;

	int zone_num;

	for(int k = 0; k < Width; k++)
		for(int j = 0; j < Size; j++)
			for(int i = 0; i < Size; i++)
			{
				cur_num = get_num_in_zone(i, j, k);
				zone_num = (int)(i/nodes_per_zone_edge) + (int)(j/nodes_per_zone_edge) * ZonesPerEdge;
				fprintf(file, ""%d %d\n"", cur_num, zone_num);
			}
	
	fprintf(file, ""$EndNodeData\n"");*/

	fclose(file);

	return 0;
}

int get_num_in_zone(int i, int j, int k)
{
	return ( k * (Size1) * (Size2) + j * (Size1) + i ) /* Just to start numbers from 1*/ + 1;
}

int write_tetrs(FILE* file, int num, int i, int j, int k) // i,j,k - 'local' i,j,k
{
	fprintf(file, ""%d 4 3 0 1 0 %d %d %d %d\n"", num,
		get_absolute_num(i, j, k), get_absolute_num(i, j+1, k+1), 
		get_absolute_num(i, j+1, k), get_absolute_num(i+1, j+1, k) );

	fprintf(file, ""%d 4 3 0 1 0 %d %d %d %d\n"", num+1,
		get_absolute_num(i, j, k+1), get_absolute_num(i, j+1, k+1),
		get_absolute_num(i+1, j+1, k+1), get_absolute_num(i, j, k) );

	fprintf(file, ""%d 4 3 0 1 0 %d %d %d %d\n"", num+2,
		get_absolute_num(i, j+1, k+1), get_absolute_num(i, j, k),
		get_absolute_num(i+1, j+1, k+1), get_absolute_num(i+1, j+1, k) );

	fprintf(file, ""%d 4 3 0 1 0 %d %d %d %d\n"", num+3,
		get_absolute_num(i, j, k), get_absolute_num(i+1, j, k),
		get_absolute_num(i+1, j+1, k), get_absolute_num(i+1, j+1, k+1) );

	fprintf(file, ""%d 4 3 0 1 0 %d %d %d %d\n"", num+4,
		get_absolute_num(i, j, k+1), get_absolute_num(i+1, j, k),
		get_absolute_num(i+1, j+1, k+1), get_absolute_num(i, j, k) );

	fprintf(file, ""%d 4 3 0 1 0 %d %d %d %d\n"", num+5,
		get_absolute_num(i+1, j, k+1), get_absolute_num(i+1, j+1, k+1),
		get_absolute_num(i, j, k+1), get_absolute_num(i+1, j, k) );

	return 0;
}

int get_absolute_num(int i, int j, int k)
{
	return 1 + k * (Size1) * (Size2) + j * (Size1) + i;
}
"
024-22442,cr88192/bgbtech_bsvm2,naf128tst0.c,99,12,180,9228233155.561611,1410795778.0,6.5411545022358295,1553.0,1509.0,299500322.0,189039498.0,1666.0,702.0,1376.0,656.0,1500000000,6.152155437041074,1082014363648.0,2.170406268397551e-06,9.006430632409861e-06,"#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

int main()
{
	__int128 li, lj, lk, ll;
	__float128 lf, lg, lh;
	time_t t0, t1, t2, t3;
	double dt;
	int n;
	int i, j, k;

#if 1
	printf(""N-Int128 Add:\n"");
	t0=clock(); t1=t0; t2=t0+1*CLOCKS_PER_SEC; n=0; ll=0;
	while(t1<t2)
	{
		li=rand(); lj=rand()+1; lk=0;
		li=li*li*li*li*li*li;
		lj=lj*lj*lj*lj*lj*lj;
		for(i=0; i<100000; i++)
			{ lk+=li+lj; n++; }
		ll+=lk;
		t1=clock();
		dt=(t1-t0)/((double)CLOCKS_PER_SEC);
		printf(""%f %d %.3f M/s  \r"", dt, n, (n/1000000.0)/(dt+0.0001));
	}
	printf(""\n"");

	printf(""N-Int128 Mul:\n"");
	t0=clock(); t1=t0; t2=t0+1*CLOCKS_PER_SEC; n=0; ll=0;
	while(t1<t2)
	{
		li=rand(); lj=rand()+1; lk=0;
		li=li*li*li*li*li*li;
		lj=lj*lj*lj*lj*lj*lj;
		for(i=0; i<100000; i++)
			{ lk+=li*lj; n++; }
		ll+=lk;
		t1=clock();
		dt=(t1-t0)/((double)CLOCKS_PER_SEC);
		printf(""%f %d %.3f M/s  \r"", dt, n, (n/1000000.0)/(dt+0.0001));
	}
	printf(""\n"");

	printf(""N-Int128 Div:\n"");
	t0=clock(); t1=t0; t2=t0+1*CLOCKS_PER_SEC; n=0; ll=0;
	while(t1<t2)
	{
		li=rand(); lj=rand()+1; lk=0;
		li=li*li*li*li*li*li;
		lj=lj*lj*lj*lj*lj*lj;
		for(i=0; i<100000; i++)
			{ lk+=li/lj; n++; }
		ll+=lk;
		t1=clock();
		dt=(t1-t0)/((double)CLOCKS_PER_SEC);
		printf(""%f %d %.3f M/s  \r"", dt, n, (n/1000000.0)/(dt+0.0001));
	}
	printf(""\n"");
#endif


#if 1
	printf(""N-F128 Add:\n"");
	t0=clock(); t1=t0; t2=t0+1*CLOCKS_PER_SEC; n=0; ll=0;
	while(t1<t2)
	{
		li=rand(); lj=rand()+1; lh=0;
		lf=li*li*li*li*li*li;
		lg=lj*lj*lj*lj*lj*lj;
		for(i=0; i<100000; i++)
			{ lh+=lf+lg; n++; }
		ll+=lh;
		t1=clock();
		dt=(t1-t0)/((double)CLOCKS_PER_SEC);
		printf(""%f %d %.3f M/s  \r"", dt, n, (n/1000000.0)/(dt+0.0001));
	}
	printf(""\n"");

	printf(""N-F128 Mul:\n"");
	t0=clock(); t1=t0; t2=t0+1*CLOCKS_PER_SEC; n=0; ll=0;
	while(t1<t2)
	{
		li=rand(); lj=rand()+1; lh=0;
		lf=li*li*li*li*li*li;
		lg=lj*lj*lj*lj*lj*lj;
		for(i=0; i<100000; i++)
			{ lh+=lf*lg; n++; }
		ll+=lh;
		t1=clock();
		dt=(t1-t0)/((double)CLOCKS_PER_SEC);
		printf(""%f %d %.3f M/s  \r"", dt, n, (n/1000000.0)/(dt+0.0001));
	}
	printf(""\n"");

	printf(""N-F128 Div:\n"");
	t0=clock(); t1=t0; t2=t0+1*CLOCKS_PER_SEC; n=0; ll=0;
	while(t1<t2)
	{
		li=rand(); lj=rand()+1; lh=0;
		lf=li*li*li*li*li*li;
		lg=lj*lj*lj*lj*lj*lj;
		for(i=0; i<100000; i++)
			{ lh+=lf/lg; n++; }
		ll+=lh;
		t1=clock();
		dt=(t1-t0)/((double)CLOCKS_PER_SEC);
		printf(""%f %d %.3f M/s  \r"", dt, n, (n/1000000.0)/(dt+0.0001));
	}
	printf(""\n"");
#endif
}"
044-30873,gatieme/AderXCoding,technology/data_structures/sort/heap_sort/heap_sort.c,69,5,57,1433717.9018184,296795.0,4.830664263211982,1386.0,1362.0,66420.0,31903.0,1647.0,651.0,1362.0,608.0,1500000000,0.0009558119345456,1082014363648.0,0.0092589160868613,0.0434079513440395,"#include <stdio.h>
#include <stdlib.h>

#define DEBUG


#ifdef DEBUG
    #define     debug       printf
    #define     __tmain     main
#else
    #define     debug       0 && printf
#endif


//#define swap(a, b) (a) ^= (b) ^= (a) ^= (b)
/*
 * swap - swap value of @a and @b
 */
#define swap(a, b) \
        do { typeof(a) __tmp = (a); (a) = (b); (b) = __tmp; } while (0)

int Large(int left, int right)
{
    return (left > right);
}

int Less(int left, int right)
{
    return (left < right);
}


//  µ÷ÕûµÄ¹ý³Ì
void ShiftAdjust(int *array, int low, int high)
{
    printf(""%d\n"", array[low]);
    // array[low]ÊÇ²»Âú×ã¶ÑµÄÔªËØ,Ò²ÊÇµ÷ÕûµÄ¸ù½Úµã
    for(int father = low, child = 2 * low + 1;  //  i ÊÇ×óº¢×Ó
        child <= high;
        child = 2 * child + 1)                  //  µÝ¹éÆä×óº¢×Ó
    {
        if(child < high
        && array[child] < array[child + 1])   //  ±È½Ï×óº¢×ÓºÍÓÉº¢×Ó
        {
            child++;        //  ÕÒµ½½Ï´óµÄÄÇ¸ö
        }

        if(array[father] >= array[child])
        {
            break;
        }
        printf(""swap %d %d\n"", array[father], array[child]);
        swap(array[father], array[child]);
        father = child;                     //  µÝ¹éµÄ¶Ô×Ó½áµã½øÐÐµ÷Õû
    }
}

void Print(int *array, int length)
{
    for(int i = 0; i < length; i++)
    {
        printf(""%4d"", array[i]);
    }
    printf(""\n"");

}

void HeadSort(int *array, int length)
{
    int i;
    for(i = (length - 2) / 2; i >= 0; i--)
    {
        ShiftAdjust(array, i, length - 1);
    }

#ifdef DEBUG
    printf(""\ninit the heap...\n"");
    Print(array, length);
#endif // DEBUG

    for(int i = length - 1; i > 0; i--)
    {
#ifdef DEBUG
        printf(""\nafter swap (%d, %d)...\n"", array[0], array[i]);
        Print(array, length);
#endif // DEBUG

        swap(array[0], array[i]);

        ShiftAdjust(array, 0, i - 1);

#ifdef DEBUG
        //printf(""\nafter shift ...\n"", array[0], array[i]);
        Print(array, length);
#endif // DEBUG
    }

}



int main(void)
{
    int array[] = { 36, 48, 48, 90, 88, 80, 76, 99 };
    HeadSort(array, 8);


    return EXIT_SUCCESS;
}
"
325-2592,ashgang/RandomAlgos,semThdEg.c,88,2,255,6002696544.164792,186483.0,32188.97456604624,1567.0,1533.0,42512.0,15233.0,1682.0,760.0,1383.0,717.0,1500000000,4.001797696109861,1082014363648.0,0.0166234991929559,0.0786561607065546,"/**************************************************************************
*  Copyright 2015 wonkymind86@gmail.com
*
* Licensed under the Apache License, Version 2.0 (the ""License"");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an ""AS IS"" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and 
* limitations under the License.
***************************************************************************/

/*
 ** This is an example program for sharing a accessing a global variable safely
 ** using semaphore within two threads in a process.
 ** Note that if the semaphore is to be shared between different processes,
 ** the semaphore name must be stored in a shared memory accessible to both
 ** the threads
 */

#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>

void *th_fn1();
void *th_fn2();

/*
 ** This is the semaphore name
 */
sem_t th_shd_sem;
/*
 ** This is the test global variable that the two threads will try to access
 */
static int glb_shared_obj = 0;

int main ()
{
		pthread_t th_id1, th_id2;

		/*
		 ** Here the main thread is initializing the semaphore
		 ** th_shd_sem - Semaphore name
		 ** 0 - Indicates semaphore is used within threads in a process
		 ** 1 - In what state the semaphore is initialized
		 */
		if (sem_init(&th_shd_sem, 0, 1))
		{
				printf (""Sem_init Error\n"");
		}

		/*
		 * In this although both are created one after the another which ever thread runs first will 
		 * get the semaphore.  The order of creation does not ensure the order of execution
		 */
		pthread_create (&th_id1, NULL, (void *)&th_fn1, NULL);
		pthread_create (&th_id2, NULL, (void *)&th_fn2, NULL);

		sleep(1);
		/*
		 ** We may not need a sleep here because the main thread takes the 
		 ** semaphore last, so when only both the threads post the main will get
		 ** the resource
		 */
#if 0
		pthread_join (th_id1, NULL);
		pthread_join (th_id2, NULL);
#endif
		/*
		 ** This will try to acquire the semaphore, if not available it will 
		 ** wait indefinitely to acquire the semaphore
		 */
		sem_wait(&th_shd_sem);
		printf (""Main thread printing the value: %d\n"", glb_shared_obj);
		/*
		 ** Signals that the semaphore is released.  It is always a good
		 ** practice to release any resource before exiting the process.
		 */
		sem_post(&th_shd_sem);
		return 0;
}

void *th_fn1()
{
		printf (""In thread 1\n"");
		sem_wait(&th_shd_sem);
		printf (""Thd 1 incrementing value: %d\n"", ++glb_shared_obj);
		sleep (1);
		sem_post(&th_shd_sem);
}

void *th_fn2()
{
		printf (""In thread 2\n"");
		sem_wait(&th_shd_sem);
		printf (""Thd 2 incrementing value: %d\n"", ++glb_shared_obj);
		sleep (3);
		sem_post(&th_shd_sem);
}
"
312-13860,Mikescher/Project-Euler_Befunge,compiled/C/Euler_Problem-034.c,89,3,96,1283388265.5249908,5417267898.0,0.2369069223018883,1391.0,1370.0,1580991325.0,1005901985.0,1694.0,2754.0,1348.0,2679.0,1500000000,0.8555921770166606,1082014363648.0,5.096665056973338e-07,3.276130471727881e-06,"/* transpiled with BefunCompile v1.3.0 (c) 2017 */
#include <stdio.h>
#include <stdlib.h>
#define int64 long long
char* _g = ""v{ }  L>1:00p1*:10p2*:20p3*:30p4*:40p5*:v{ }  +vp110$p09:*9p08:*8p07:*7p06:*6p05<{ }  1v_v#{ }  ::-1<p11 <>90g7*>::0\\>:55+%0g\\55""
           ""+/:#v_>+#<\\:#<_+-|    +    >3-.$@ |:/+55\\g0%+55: <{ }  ,>:11g^    ^g11<  >{ }  0^{ }  0"";
int t=0;int z=0;
int64 g[315];
int d(){int s,w,i,j,h;h=z;for(;t<215;t++)if(_g[t]==';')g[z++]=_g[++t];else if(_g[t]=='}')return z-h;else if(_g[t]=='{'){t++;s=z;w=d();for(i=1;i<_g[t+1]*9025+_g[t+2]*95+_g[t+3]-291872;i++)for(j=0;j<w;g[z++]=g[s+j++]);t+=3;}else g[z++]=_g[t];return z-h;}
int64 gr(int64 x,int64 y){if(x>=0&&y>=0&&x<45&&y<7){return g[y*45+x];}else{return 0;}}
void gw(int64 x,int64 y,int64 v){if(x>=0&&y>=0&&x<45&&y<7){g[y*45+x]=v;}}
int64 td(int64 a,int64 b){ return (b==0)?0:(a/b); }
int64 tm(int64 a,int64 b){ return (b==0)?0:(a%b); }
int64*s;int q=16384;int y=0;
int64 sp(){if(!y)return 0;return s[--y];}
void sa(int64 v){if(q-y<8)s=(int64*)realloc(s,(q*=2)*sizeof(int64));s[y++]=v;}
int64 sr(){if(!y)return 0;return s[y-1];}
int main(void)
{
    int64 t0,t1;
    d();
    s=(int64*)calloc(q,sizeof(int64));
    gw(0,0,1);
    gw(1,0,1);
    gw(2,0,2);
    gw(3,0,6);
    gw(4,0,24);
    gw(5,0,120);
    gw(6,0,720);
    gw(7,0,5040);
    gw(8,0,40320);
    gw(9,0,362880);
    gw(1,1,0);
    t0=362880;
    sa(gr(9,0)*7);
    sa(gr(9,0)*7);
    sa(0);
    sa(gr((gr(9,0)*7)%10,0));
    sa((gr(9,0)*7)/10);
    sa((gr(9,0)*7)/10);
_1:
    if(sp()!=0)goto _2;else goto _3;
_2:
    sa(gr(sr()%10,0));
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    sa(sp()/10LL);

    sa(sr());

    if(sp()!=0)goto _10;else goto _3;
_3:
    sa(sp()+sp());

    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    sa(sr());

    if(sp()!=0)goto _9;else goto _4;
_4:
    sa(sp()+sp());

    t0=sp();
    sa(sp()-t0);

    t1=sp();

    if((t1)!=0)goto _5;else goto _8;
_5:
    sa(sp()-1LL);

    sa(sr());

    if(sp()!=0)goto _6;else goto _7;
_6:
    sa(sr());
    sa(sr());
    sa(0);
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    sa(gr(sr()%10,0));
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    sa(sp()/10LL);

    sa(sr());
    goto _1;
_7:
    printf(""%lld "", gr(1,1)-3);
    sa(sr());
    sp();
    sp();
    return 0;
_8:
    gw(1,1,sr()+gr(1,1));
    goto _5;
_9:
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    goto _3;
_10:
    sa(gr(sr()%10,0));
    {int64 v0=sp();int64 v1=sp();sa(v0);sa(v1);}
    sa(sp()/10LL);

    sa(sr());
    goto _1;
}
"
211-13538,anaghajoshi/C_DataStructures_Algorithms,Binart_Search_Tree_BST/binary_search_tree.c,100,3,56,2227067.83097235,201671.0,11.04307014890589,1392.0,1367.0,45734.0,17602.0,1643.0,645.0,1360.0,602.0,1500000000,0.0014847118873149,1082014363648.0,0.0136806977701305,0.0671024377920929,"#include <stdio.h>
#include <stdlib.h>

/* This is a code for binary search tree basic implementtion */

//Contains code for PreOrder, InOrder and PostOrder Traversals i.e. Depth First

typedef struct node{
	int data;
	struct node* left;
	struct node* right;
} node;

node* head;

node* create(int data){
	node* temp = (node* ) malloc(sizeof(node));
	temp->data = data;
	temp->left = NULL;
	temp->right = NULL;
	return temp;
}

node* insert(node* current, int data){

	if(head == NULL){
		node* temp;
		temp = create(data);
		head = temp;
		return temp;

	}
	else{
		if(current == NULL){
			node* temp;
			temp = create(data);
			return temp;
		}

		if(data <= current->data){

			current->left = insert(current->left,data);
		}
		else if ( data > current->data){

			current->right = insert(current->right,data);
		}

	}
	return current;

}

void print_preorder(node* temp){
	if(temp != NULL){
		printf(""%d "",temp->data);
		print_preorder(temp->left);
		print_preorder(temp->right);
	}
	return;
}

void print_inorder(node* temp){
	if(temp != NULL){
		print_inorder(temp->left);
		printf(""%d "",temp->data);
		print_inorder(temp->right);
	}
	return;
}

void print_postorder(node* temp){
	if(temp != NULL){
		print_postorder(temp->left);
		print_postorder(temp->right);
		printf(""%d "",temp->data);
	}
	return;
}

void print_preorder_all(node* temp){
	if(temp != NULL){

		printf(""data %d "",temp->data);

		if(temp->left != NULL){
		printf(""left child %d "",temp->left->data);}
		else {
			printf(""left child NULL "");
		}
		if(temp->right != NULL){
		printf(""right child %d \n"",temp->right->data);}
		else {
			printf(""right child NULL \n"");
		}
		
		print_preorder_all(temp->left);
		print_preorder_all(temp->right);
	}
	return;
}


int main(){
	head = NULL;
	node* temp;
	
	int A[7] = {9,4,15,2,6,12,17};
	int i;
	for(i =0 ; i<7 ; i ++){
		temp = insert(head,A[i]);
	}
	
	printf(""tree in print_preorder : \n"");
	print_preorder(head);
	printf(""\n"");

	printf(""tree in print_inorder : \n"");
	print_inorder(head);
	printf(""\n"");

	printf(""tree in print_postorder : \n"");
	print_postorder(head);
	printf(""\n"");
	
	printf(""all info\n"");
	print_preorder_all(head);
	

	return 0;
}"
376-10146,ggupta2005/Programming-and-Algorithm-Questions,reverse_bits_of_an_integer/reverse_bits_of_an_integer.c,98,1,93,1721133.01232445,170603.0,16.676969338171077,1150.0,1138.0,38763.0,12875.0,1572.0,581.0,1322.0,544.0,1500000000,0.0011474220082163,1082014363648.0,0.0134112530260311,0.0778302800263372,"/*
 * This program reverses the bits of an integer. For example if the number
 * is '0x0000ff11', then after reversing the bits in the number we would get
 * '0x88ff0000'.
 */
#include<stdio.h>
#include<assert.h>
#include<limits.h>

/*
 * This function reverses the bits in the input number and returns the
 * number with the reversed bits. This function iterates over all the
 * bits in the number so its time complexity is O(log(n)). The space
 * complexity of this function is O(1).
 */
int reverse_bits_v1 (int num)
{
    int num_reverse;
    int index;
    int len_in_bits = sizeof(num) * CHAR_BIT;

    /*
     * Iterate over all the bits in the input number
     */
    num_reverse = 0;
    for (index = 0; index < len_in_bits; ++index) {

        /*
         * If the bit at 'index' position is set in the input
         * number, then set the bit at position 'len_in_bits -
         * index - 1' in the reversed number
         */
        if (num & (1 << index)) {
            num_reverse |= (1 << (len_in_bits - index - 1));
        }
    }

    /*
     * Return the number with bits reversed
     */
    return(num_reverse);
}

/*
 * This function reverses the bits in the input number and returns the
 * number with the reversed bits. This function reverses the bytes, then
 * neighboring nibbles, then the neighboring group of two bits and finally
 * the neighboring bits using the bitwise operators. The time and space
 * complexities of this function is hence O(1).
 */
int reverse_bits_v2 (int num)
{
    int num_copy = num;

    /*
     * Reverse bytes in the number. We take the bitwise AND with the
     * mask after the right shift operator since right shift operator
     * is known to supplement ones in case signed bit is set.
     */
    num_copy = (((num_copy & 0xff000000) >> 24) & 0x000000ff) |
               (((num_copy & 0x00ff0000) >> 8) & 0x0000ff00) |
               (((num_copy & 0x0000ff00) << 8) & 0x00ff0000) |
               (((num_copy & 0x000000ff) << 24) & 0xff000000);

    /*
     * Swap nibbles in the number
     */
    num_copy = (((num_copy & 0xf0f0f0f0) >> 4) & 0x0f0f0f0f) |
               (((num_copy & 0x0f0f0f0f) << 4) & 0xf0f0f0f0);

    /*
     * Swap half of the nibbles in the number
     */
    num_copy = (((num_copy & 0xcccccccc) >> 2) & 0x33333333) |
               (((num_copy & 0x33333333) << 2) & 0xcccccccc);

    /*
     * Swap the even and odd bits
     */
    num_copy = (((num_copy & 0xaaaaaaaa) >> 1) & 0x55555555) |
               (((num_copy & 0x55555555) << 1) & 0xaaaaaaaa);

    /*
     * Return the number with bits reversed
     */
    return(num_copy);
}

int main ()
{
    /*
     * Test 0: Test with zero. The bit reversed number will be zero.
     */
    assert(0x00000000 == reverse_bits_v1(0x00000000));
    assert(0x00000000 == reverse_bits_v2(0x00000000));

    /*
     * Test 1: Test with a number in which alternating bits starting
     *         from bit zero are set. The bit reversed number should
     *         also have alternating bits set from the first bit.
     */
    assert(0xaaaaaaaa == reverse_bits_v1(0x55555555));
    assert(0xaaaaaaaa == reverse_bits_v2(0x55555555));

    /*
     * Test 2: Test with a few other combination of bits set in
     *         numbers to check if the bit reversing function works.
     */
    assert(0xf33f0000 == reverse_bits_v1(0x0000fccf));
    assert(0xf33f0000 == reverse_bits_v2(0x0000fccf));
    assert(0x88ff0000 == reverse_bits_v1(0x0000ff11));
    assert(0x88ff0000 == reverse_bits_v2(0x0000ff11));

    return(0);
}
"
039-4014,dmolnar/SmartFuzz,drd/tests/fp_race.c,76,2,79,1502232676.371932,184334.0,8149.514880597177,1430.0,1399.0,42282.0,14584.0,1753.0,663.0,1390.0,620.0,1500000000,1.0014884509146214,1082014363648.0,0.0153471416016578,0.0778320965075792,"/* Test data race detection between floating point variables. */


#include <assert.h>
#include <stdio.h>     /* printf() */
#include <pthread.h>
#include <unistd.h>    /* usleep() */


/* Local functions declarations. */

static void* thread_func(void*);


/* Local variables. */

/* s_mutex protects s_d3. */
static pthread_mutex_t s_mutex;

static double s_d1; /* accessed before thread creation and in the created */
                    /* thread (not a race). */
static double s_d2; /* accessed in the created thread and after the join */
                    /* (not a race). */
static double s_d3; /* accessed simultaneously from both threads (race). */
static int    s_debug     = 0;
static int    s_do_printf = 0;
static int    s_use_mutex = 0;


/* Function definitions. */

int main(int argc, char** argv)
{
  int optchar;
  pthread_t threadid;

  while ((optchar = getopt(argc, argv, ""dmp"")) != EOF)
  {
    switch (optchar)
    {
    case 'd':
      s_debug = 1;
      break;
    case 'm':
      s_use_mutex = 1;
      break;
    case 'p':
      s_do_printf = 1;
      break;
    default:
      assert(0);
    }
  }

  pthread_mutex_init(&s_mutex, 0);

  /*
   * Switch to line-buffered mode, such that timing information can be 
   * obtained for each printf() call with strace.
   */
  setlinebuf(stdout);

  if (s_debug)
  {
    printf(""&s_d1 = %p; &s_d2 = %p; &s_d3 = %p\n"", &s_d1, &s_d2, &s_d3);
  }

  s_d1 = 1;
  s_d3 = 3;

  pthread_create(&threadid, 0, thread_func, 0);

  sleep(1); /* Wait until thread_func() finished. */

  {
    if (s_use_mutex) pthread_mutex_lock(&s_mutex);
    s_d3++;
    if (s_use_mutex) pthread_mutex_unlock(&s_mutex);
  }

  /* Wait until the thread finished. */
  pthread_join(threadid, 0);
  if (s_do_printf) printf(""s_d2 = %g (should be 2)\n"", s_d2);
  if (s_do_printf) printf(""s_d3 = %g (should be 5)\n"", s_d3);

  pthread_mutex_destroy(&s_mutex);

  return 0;
}

static void* thread_func(void* thread_arg)
{
  if (s_do_printf)
  {
    printf(""s_d1 = %g (should be 1)\n"", s_d1);
  }
  s_d2 = 2;
  {
    if (s_use_mutex) pthread_mutex_lock(&s_mutex);
    s_d3++;
    if (s_use_mutex) pthread_mutex_unlock(&s_mutex);
  }
  return 0;
}
"
050-27876,timmontague/euler-solutions,019/counting-sundays.c,73,1,69,1484629.5816823498,1205654.0,1.2313889391152022,1356.0,1332.0,136721.0,53268.0,1634.0,697.0,1349.0,653.0,1500000000,0.0009897530544549,1082014363648.0,0.0022294953610239,0.0228065835390469,"/*
 *
 * 1 Jan 1900 was a Monday.
 *
 * Thirty days has September,
 * April, June and November.
 * All the rest have thirty-one,
 * Saving February alone,
 * Which has twenty-eight, rain or shine.
 * And on leap years, twenty-nine.
 *
 * A leap year occurs on any year evenly
 * divisible by 4, but not on a century unless
 * it is divisible by 400.
 * 
 * How many Sundays fell on the first of the month during the twentieth century
 * (1 Jan 1901 to 31 Dec 2000)?
 */
#include <stdio.h>

char *months[] = {
	""jan"", ""feb"", ""mar"", ""apr"", ""may"", ""jun"",
	""jul"", ""aug"", ""sep"", ""oct"", ""nov"", ""dec""
};
int month_days[] = {
	31, 28, 31, 30, 31, 30,
	31, 31, 30, 31, 30, 31
};
char *days[] = {
	""sun"", ""mon"", ""tue"", ""wed"", ""thu"", ""fri"", ""sat""
};
int main(void) {
	int month = 0;		// Jan
	int date = 1;		// 1st
	int year = 1900;	// 1901
	int day = 1;		// Monday
	int n = 0;
	while (year < 2001) {
		// is a Sunday on the 1st of the month?
		if (date == 1 && day == 0 && year > 1900) {
			n++;
			printf(""%s, %s %d, %d\n"", days[day], months[month], date, year);
		}
		// increment date
		day++;
		if (day > 6) {
			day = 0;
		}
		date++;
		if (date > month_days[month]) {
			// is a leap day?
			if (
					// month is feb
					month == 1
					// date is 29th
					&& date == 29
					// year divisible by 4
					&& (year % 4 == 0)
					// year not divisible by 100 but is divisible by 400
					&& ((year % 100 != 0) || (year % 400 == 0))
			   ) {
				printf(""leap year: %s, %s %d, %d\n"", days[day], months[month], date, year);
			} else {
				date = 1;
				month++;
				if (month > 11) {
					month = 0;
					year++;
				}
			}
		}
	}
	printf(""total: %d\n"", n);
	return 0;
}
"
326-32941,Tim-Tom/scratch,magic-puzzle/magic_puzzle.c,108,5,114,167464685.85915855,656830636.0,0.2549586998862215,1383.0,1361.0,139315542.0,45960242.0,1626.0,722.0,1345.0,676.0,1500000000,0.1116431239061057,1082014363648.0,4.177637049195129e-06,2.3581063351484726e-05,"#include <stdio.h>

#define TRUE 1
#define FALSE 0

#define WIDTH 4

#define WM (WIDTH-1)
#define WP (WIDTH+1)
#define SIZE (WIDTH*WIDTH)

typedef int bool;

#if WIDTH == 3

#define GOAL 21
const static int choices[SIZE] = {3,4,5,6,7,8,9,10,11};

#elif WIDTH == 4

#define GOAL 34
const static int choices[SIZE] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};

#endif

static bool picked[SIZE];
static int a[SIZE];

typedef void (*perform)(int);

typedef struct Action {
  int pos;
  perform action;
  int indexes[WIDTH];
} Action;

Action actions[SIZE + 3];

static int choiceSearch(int c) {
  // Since our list is expected to be so small, we actually just do a linear search.
  for(int i = 0; i < SIZE; ++i) {
    if (choices[i] == c) return i;
  }
  return -1;
}

static void choose(int ai) {
  int i;
  const Action* ap = &actions[ai];
  for (i = 0; i < SIZE; ++i) {
    if (!picked[i]) {
      a[ap->pos] = choices[i];
      picked[i] = TRUE;
      actions[ai + 1].action(ai + 1);
      picked[i] = FALSE;
    }
  }
}

static void decide(int ai) {
  int i, n;
  const Action* ap = &actions[ai];
  for(i = 0, n = GOAL; i < WIDTH - 1; ++i) {
    n -= a[ap->indexes[i]];
  }
  i = choiceSearch(n);
  if (i == -1 || picked[i]) {
    return;
  }
  a[ap->pos] = n;
  picked[i] = TRUE;
  actions[ai + 1].action(ai + 1);
  picked[i] = FALSE;
}

static void validate(int ai) {
  int i, n;
  const Action* ap = &actions[ai];
  for(i = 0, n = GOAL; i < WIDTH; ++i) {
    n -= a[ap->indexes[i]];
  }
  if (n == 0) {
    actions[ai + 1].action(ai + 1);
  }
}

// Prints out a solution
static void solution(int ai) {
  static int count = 0;
  int i, c;
  char sep;
  printf(""--- Solution %d ---\n"", ++count);
  for(i = 0, c = 1; i < SIZE; ++i, ++c) {
    if (c == WIDTH) {
      sep = '\n';
      c = 0;
    } else {
      sep = ' ';
    }
    printf(""%2d%c"", a[i], sep);
  }
}

int main(int argc, const char* argv[]) {
  int i = -1;
#if WIDTH == 3
  actions[++i].pos = 0; actions[i].action = &choose;
  actions[++i].pos = 1; actions[i].action = &choose;
  actions[++i].pos = 2; actions[i].action = &decide; actions[i].indexes[0] = 0; actions[i].indexes[1] = 1;
  actions[++i].pos = 4; actions[i].action = &choose;
  actions[++i].pos = 8; actions[i].action = &decide; actions[i].indexes[0] = 0; actions[i].indexes[1] = 4;
  actions[++i].pos = 5; actions[i].action = &decide; actions[i].indexes[0] = 2; actions[i].indexes[1] = 8;
  actions[++i].pos = 3; actions[i].action = &decide; actions[i].indexes[0] = 4; actions[i].indexes[1] = 5;
  actions[++i].pos = 6; actions[i].action = &decide; actions[i].indexes[0] = 0; actions[i].indexes[1] = 3;
  actions[++i].pos = 7; actions[i].action = &decide; actions[i].indexes[0] = 6; actions[i].indexes[1] = 8;
  actions[++i].pos = 0; actions[i].action = &validate; actions[i].indexes[0] = 1; actions[i].indexes[1] = 4; actions[i].indexes[2] = 7;
  actions[++i].pos = 0; actions[i].action = &validate; actions[i].indexes[0] = 2; actions[i].indexes[1] = 4; actions[i].indexes[2] = 6;
  actions[++i].pos = 0; actions[i].action = &solution;
#elif WIDTH == 4
  actions[++i].pos =  0; actions[i].action = &choose;
  actions[++i].pos =  1; actions[i].action = &choose;
  actions[++i].pos =  2; actions[i].action = &choose;
  actions[++i].pos =  3; actions[i].action = &decide; actions[i].indexes[0] =  0; actions[i].indexes[1] =  1; actions[i].indexes[2] =  2;
  actions[++i].pos =  5; actions[i].action = &choose;
  actions[++i].pos =  9; actions[i].action = &choose;
  actions[++i].pos = 13; actions[i].action = &decide; actions[i].indexes[0] =  1; actions[i].indexes[1] =  5; actions[i].indexes[2] =  9;
  actions[++i].pos = 10; actions[i].action = &choose;
  actions[++i].pos = 15; actions[i].action = &decide; actions[i].indexes[0] =  0; actions[i].indexes[1] =  5; actions[i].indexes[2] = 10;
  actions[++i].pos =  6; actions[i].action = &choose;
  actions[++i].pos = 14; actions[i].action = &decide; actions[i].indexes[0] =  2; actions[i].indexes[1] =  6; actions[i].indexes[2] = 10;
  actions[++i].pos = 12; actions[i].action = &decide; actions[i].indexes[0] = 13; actions[i].indexes[1] = 14; actions[i].indexes[2] = 15;
  actions[++i].pos =  4; actions[i].action = &choose;
  actions[++i].pos =  7; actions[i].action = &decide; actions[i].indexes[0] =  4; actions[i].indexes[1] =  5; actions[i].indexes[2] =  6;
  actions[++i].pos =  8; actions[i].action = &decide; actions[i].indexes[0] =  0; actions[i].indexes[1] =  4; actions[i].indexes[2] = 12;
  actions[++i].pos = 11; actions[i].action = &decide; actions[i].indexes[0] =  8; actions[i].indexes[1] =  9; actions[i].indexes[2] = 10;
  actions[++i].pos =  0; actions[i].action = &validate; actions[i].indexes[0] =  3; actions[i].indexes[1] =  7; actions[i].indexes[2] = 11; actions[i].indexes[3] = 15;
  actions[++i].pos =  0; actions[i].action = &validate; actions[i].indexes[0] =  3; actions[i].indexes[1] =  6; actions[i].indexes[2] =  9; actions[i].indexes[3] = 12;
  actions[++i].pos =  0; actions[i].action = &solution;
#endif
  actions[0].action(0);
  return 0;
}
"
309-32389,DavideCanton/Python3,bf/sda.bf.c,99,7,136,1940447.95352955,175076.0,11.083455185176724,1292.0,1276.0,39633.0,13476.0,1636.0,643.0,1347.0,601.0,1500000000,0.0012936319690197,1082014363648.0,0.0146679156480614,0.0795910297689657,"#include <stdio.h>

#define MEM_SIZE 30000

int main(void){
char mem[MEM_SIZE]; register char* mem_ptr = mem;
register char* end = mem + MEM_SIZE;
mem_ptr += 1;
if(mem_ptr >= end) mem_ptr = mem + (end - mem_ptr);
*mem_ptr += 8;
while(*mem_ptr){

mem_ptr -= 1;
if(mem_ptr < mem) mem_ptr = end - (mem - mem_ptr);
*mem_ptr += 9;
mem_ptr += 1;
if(mem_ptr >= end) mem_ptr = mem + (end - mem_ptr);
*mem_ptr -= 1;
}

mem_ptr -= 1;
if(mem_ptr < mem) mem_ptr = end - (mem - mem_ptr);
putchar(*mem_ptr);

mem_ptr += 2;
if(mem_ptr >= end) mem_ptr = mem + (end - mem_ptr);
*mem_ptr += 1;
mem_ptr += 1;
if(mem_ptr >= end) mem_ptr = mem + (end - mem_ptr);
*mem_ptr += 1;
mem_ptr += 1;
if(mem_ptr >= end) mem_ptr = mem + (end - mem_ptr);
*mem_ptr += 2;
mem_ptr += 1;
if(mem_ptr >= end) mem_ptr = mem + (end - mem_ptr);
while(*mem_ptr){

*mem_ptr -= 1;
}

*mem_ptr += 1;
mem_ptr -= 1;
if(mem_ptr < mem) mem_ptr = end - (mem - mem_ptr);
while(*mem_ptr){

mem_ptr += 1;
if(mem_ptr >= end) mem_ptr = mem + (end - mem_ptr);
while(*mem_ptr){

*mem_ptr -= 1;
mem_ptr += 1;
if(mem_ptr >= end) mem_ptr = mem + (end - mem_ptr);
*mem_ptr += 1;
mem_ptr -= 2;
if(mem_ptr < mem) mem_ptr = end - (mem - mem_ptr);
*mem_ptr += 4;
mem_ptr += 1;
if(mem_ptr >= end) mem_ptr = mem + (end - mem_ptr);
}

mem_ptr -= 2;
if(mem_ptr < mem) mem_ptr = end - (mem - mem_ptr);
}

mem_ptr += 1;
if(mem_ptr >= end) mem_ptr = mem + (end - mem_ptr);
putchar(*mem_ptr);

*mem_ptr += 7;
putchar(*mem_ptr);
putchar(*mem_ptr);

*mem_ptr += 3;
putchar(*mem_ptr);

mem_ptr += 2;
if(mem_ptr >= end) mem_ptr = mem + (end - mem_ptr);
*mem_ptr += 7;
putchar(*mem_ptr);

mem_ptr -= 3;
if(mem_ptr < mem) mem_ptr = end - (mem - mem_ptr);
while(*mem_ptr){
while(*mem_ptr){

*mem_ptr -= 1;
}

mem_ptr -= 1;
if(mem_ptr < mem) mem_ptr = end - (mem - mem_ptr);
while(*mem_ptr){

*mem_ptr -= 1;
}

mem_ptr += 1;
if(mem_ptr >= end) mem_ptr = mem + (end - mem_ptr);
}

mem_ptr -= 1;
if(mem_ptr < mem) mem_ptr = end - (mem - mem_ptr);
*mem_ptr += 15;
putchar(*mem_ptr);

mem_ptr += 2;
if(mem_ptr >= end) mem_ptr = mem + (end - mem_ptr);
putchar(*mem_ptr);

*mem_ptr += 3;
putchar(*mem_ptr);

*mem_ptr -= 6;
putchar(*mem_ptr);

*mem_ptr -= 8;
putchar(*mem_ptr);

mem_ptr += 2;
if(mem_ptr >= end) mem_ptr = mem + (end - mem_ptr);
*mem_ptr += 1;
putchar(*mem_ptr);

mem_ptr += 1;
if(mem_ptr >= end) mem_ptr = mem + (end - mem_ptr);
*mem_ptr += 4;
putchar(*mem_ptr);

}
"
079-28615,Mikescher/Project-Euler_Befunge,compiled/C/Euler_Problem-073.c,63,3,86,431783645.87947726,1989104135.0,0.2170744293385122,1377.0,1357.0,494310339.0,240468323.0,4298358.0,6069869.0,1350.0,3005140.0,1500000000,0.2878557639196515,1082014363648.0,1.3744881184915942e-06,0.0182023753433384,"/* transpiled with BefunCompile v1.3.0 (c) 2017 */
#include <stdio.h>
#include <stdlib.h>
#define int64 long long
char* _g = ""v{ }  *// Project Euler - Problem 73{ } 4]XX  ????{ } J!{{#}~~~}  ;{#}~Ow{ } 5%>\"";}`\""*11p051p0v{ } 4uvp12*\""(2\""     <     v+1{ } ""
           "" 4{<{ }  1}  \""{ } 45>1+:1+2/61p:71p:3/1+>:61g\\`!#v_:21g%71g3+g!|>81g11g`91g11g`+#^_081g21gv{ } 4=|-g11:{ }  2>#$ #<{ }  .^p19+g1""
           ""9g17p18+g18:p+3g19%<{ } 4=>$51g.@{ }  1^p19g17p18:p15+1g15<{ } 4X"";
int t=0;int z=0;
int64 g[24020000];
int d(){int s,w,i,j,h;h=z;for(;t<321;t++)if(_g[t]==';')g[z++]=_g[++t];else if(_g[t]=='}')return z-h;else if(_g[t]=='{'){t++;s=z;w=d();for(i=1;i<_g[t+1]*9025+_g[t+2]*95+_g[t+3]-291872;i++)for(j=0;j<w;g[z++]=g[s+j++]);t+=3;}else g[z++]=_g[t];return z-h;}
int64 gr(int64 x,int64 y){if(x>=0&&y>=0&&x<2000&&y<12010){return g[y*2000+x];}else{return 0;}}
void gw(int64 x,int64 y,int64 v){if(x>=0&&y>=0&&x<2000&&y<12010){g[y*2000+x]=v;}}
int64 td(int64 a,int64 b){ return (b==0)?0:(a/b); }
int64 tm(int64 a,int64 b){ return (b==0)?0:(a%b); }
int64*s;int q=16384;int y=0;
int64 sp(){if(!y)return 0;return s[--y];}
void sa(int64 v){if(q-y<8)s=(int64*)realloc(s,(q*=2)*sizeof(int64));s[y++]=v;}
int64 sr(){if(!y)return 0;return s[y-1];}
int main(void)
{
    d();
    s=(int64*)calloc(q,sizeof(int64));
    gw(1,1,12000);
    gw(5,1,0);
    gw(2,1,2000);
    gw(6,1,1);
    gw(7,1,1);
    sa(1);
    sa(1);
    sa(1<gr(6,1)?1:0);
_1:
    if(sp()!=0)goto _5;else goto _2;
_2:
    sp();

    if((sr()-gr(1,1))!=0)goto _4;else goto _3;
_3:
    printf(""%lld "", gr(5,1));
    sp();
    return 0;
_4:
    sa(sp()+1LL);

    gw(6,1,(sr()+1)/2);
    sa(sr());
    gw(7,1,sp());
    sa((sr()/3)+1);
    sa(sr()<gr(6,1)?1:0);
    goto _1;
_5:
    if((gr(tm(sr(),gr(2,1)),gr(7,1)+3))!=0)goto _6;else goto _9;
_6:
    gw(5,1,gr(5,1)+1);
    sa(sr());
    gw(8,1,sp());
    gw(9,1,gr(7,1));
_7:
    if(((gr(8,1)>gr(1,1)?1:0)+(gr(9,1)>gr(1,1)?1LL:0LL))!=0)goto _9;else goto _8;
_8:
    gw(tm(gr(8,1),gr(2,1)),gr(9,1)+3,0);
    gw(8,1,sr()+gr(8,1));
    gw(9,1,gr(7,1)+gr(9,1));
    goto _7;
_9:
    sa(sp()+1LL);

    sa(sr()<gr(6,1)?1:0);
    goto _1;
}
"
159-20191,MichaelPalmer1/Systems-Software,c/semaphore_v4.c,97,13,128,9004009151.947685,214202.0,42035.13109588146,1576.0,1534.0,49498.0,20113.0,1824.0,1073.0,1386.0,951.0,1500000000,6.002672767965123,1082014363648.0,0.0145190054247859,0.0751892660642714,"/**
 * Michael Palmer
 * CSCI 3232-A
 * April 1, 2015
 * Using Semaphores to Maintain Thread Execution Order
 */

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>

#define MIN_THREAD 'A' // Minimum thread identifier
#define MAX_THREAD 'H' // Maximum thread identifier

/**
 * Structure for ordered threads
 */
struct Thread_Order {
	int threadID;
	int waitThread1;
	int waitThread2;
	int numToPost;
};

// Initialize variables
void *state( void *args );
pthread_t threads[ MAX_THREAD ];
sem_t sem[ MAX_THREAD ];
struct Thread_Order *orderedThreads[ MAX_THREAD ];

/**
 * Create an ordered thread
 *
 * @param int threadID		Identifier for the semaphore
 * @param int waitThread1	Semaphore to wait for before executing. Use -1 if thread
 * 							does not need to wait for another semaphore
 * @param int waitThread2	Semaphore to wait for before executing. Use -1 if thread
 * 							does not need to wait for a second semaphore
 * @param int numToPost		Number of times to post the semaphore
 * @return struct Thread_Order *thread
 */
struct Thread_Order *addOrder(int threadID, int waitThread1, int waitThread2, int numToPost) {
	struct Thread_Order *thread = malloc( sizeof( struct Thread_Order ) );
	thread->threadID = threadID;
	thread->waitThread1 = waitThread1;
	thread->waitThread2 = waitThread2;
	thread->numToPost = numToPost;
	return thread;
}

/**
 * State where semaphores will check if it needs to
 * wait for another semaphore before executing. This
 * method is called by pthread_create() in main()
 *
 * @param void *args Arguments passed by pthread_create()
 */
void *state( void *args ) {
	int i;
	
	// Convert passed argument to the Thread_Order structure
	struct Thread_Order *thread = (struct Thread_Order *) args;

	// Check if this thread needs to wait for another
	if(thread->waitThread1 >= MIN_THREAD) {
		printf(""Thread %c: Waiting on Thread %c\n"", thread->threadID, thread->waitThread1);
		sem_wait( &sem[ thread->waitThread1 ] );
	}

	// Check if this thread needs to wait for a second thread
	if(thread->waitThread2 >= MIN_THREAD) {
		printf(""Thread %c: Waiting on Thread %c\n"", thread->threadID, thread->waitThread2);
		sem_wait( &sem[ thread->waitThread2 ] );
	}

	/*** Start Critical Region ***/
	
	printf(""Thread %c: Entered\n"", thread->threadID);
	sleep(1);
	
	/*** End Critical Region ***/

	// Post the thread
	for(i = 0; i < thread->numToPost; i++) {
		sem_post( &sem[ thread->threadID ] );
	}
	printf(""Thread %c: Finished\n"", thread->threadID);
	return 0;
}

int main() {
	int i;
	
	// Set up the order of the threads
	orderedThreads[ 'A' ] = addOrder( 'A', -1, -1, 2 );
	orderedThreads[ 'B' ] = addOrder( 'B', 'A', -1, 2 );
	orderedThreads[ 'C' ] = addOrder( 'C', 'A', -1, 1 );
	orderedThreads[ 'D' ] = addOrder( 'D', 'B', -1, 1 );
	orderedThreads[ 'E' ] = addOrder( 'E', 'C', 'D', 1 );
	orderedThreads[ 'F' ] = addOrder( 'F', 'B', -1, 1 );
	orderedThreads[ 'G' ] = addOrder( 'G', 'E', -1, 1 );
	orderedThreads[ 'H' ] = addOrder( 'H', 'F', 'G', 1 );

	// Initialize semaphores and create threads
	for(i = MIN_THREAD; i <= MAX_THREAD; i++) {
		sem_init( &sem[ i ], 0, 0 );
		pthread_create( &threads[ i ], NULL, state, orderedThreads[ i ] );
	}

	// Join threads
	for(i = MIN_THREAD; i <= MAX_THREAD; i++) {
		pthread_join( threads[ i ], NULL );
	}

	// Close semaphores
	for(i = MIN_THREAD; i <= MAX_THREAD; i++) {
		sem_destroy( &sem[ i ] );
	}

	return 0;
}"
211-27434,selmentdev/selment-toolchain,source/gcc-latest/gcc/testsuite/gcc.dg/pr64536.c,64,1,65,1586235.0119277,169083.0,9.381398484767836,1143.0,1133.0,38460.0,12696.0,1568.0,585.0,1317.0,546.0,1500000000,0.0010574900079518,1082014363648.0,0.0134608446739175,0.0785049652044725,"/* PR rtl-optimization/64536 */
/* { dg-do link } */
/* { dg-options ""-O2"" } */
/* { dg-additional-options ""-fPIC"" { target fpic } } */

struct S { long q; } *h;
long a, b, g, j, k, *c, *d, *e, *f, *i;
long *baz (void)
{
  asm volatile ("""" : : : ""memory"");
  return e;
}

void
bar (int x)
{
  int y;
  for (y = 0; y < x; y++)
    {
      switch (b)
	{
	case 0:
	case 2:
	  a++;
	  break;
	case 3:
	  a++;
	  break;
	case 1:
	  a++;
	}
      if (d)
	{
	  f = baz ();
	  g = k++;
	  if (&h->q)
	    {
	      j = *f;
	      h->q = *f;
	    }
	  else
	    i = (long *) (h->q = *f);
	  *c++ = (long) f;
	  e += 6;
	}
      else
	{
	  f = baz ();
	  g = k++;
	  if (&h->q)
	    {
	      j = *f;
	      h->q = *f;
	    }
	  else
	    i = (long *) (h->q = *f);
	  *c++ = (long) f;
	  e += 6;
	}
    }
}

int
main ()
{
  return 0;
}
"
081-12423,begeekmyfriend/leetcode,0113_path_sum_ii/path_sum.c,83,2,69,1758498.1396794,182354.0,9.643320135560502,1364.0,1341.0,41428.0,14594.0,1646.0,640.0,1359.0,597.0,1500000000,0.0011723320931196,1082014363648.0,0.014833784836088,0.0757202527578451,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>


struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
};

static void dfs(struct TreeNode *node, int sum, int *stack, int len, int **results, int *sizes, int *count)
{
    if (node == NULL) {
        return;
    } else if (node->left == NULL && node->right == NULL && sum == node->val) {
        results[*count] = malloc((len + 1) * sizeof(int));
        memcpy(results[*count], stack, len * sizeof(int));
        results[*count][len] = node->val;
        sizes[*count] = len + 1;
        (*count)++;
    } else {
        stack[len] = node->val;
        dfs(node->left, sum - node->val, stack, len + 1, results, sizes, count);
        dfs(node->right, sum - node->val, stack, len + 1, results, sizes, count);
    }
}

/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *returnColumnSizes array must be malloced, assume caller calls free().
 */
int **pathSum(struct TreeNode *root, int sum, int *returnSize, int **returnColumnSizes)
{
    if (root == NULL) {
        *returnSize = 0;
        return NULL;
    }

    int level = 5000, cap = 1000;
    int *stack = malloc(level * sizeof(int));
    int **results = malloc(cap * sizeof(int *));
    *returnColumnSizes = malloc(cap * sizeof(int));
    dfs(root, sum, stack, 0, results, *returnColumnSizes, returnSize);
    return results;
}

int main(int argc, char **argv)
{
    struct TreeNode root, n1[2], n2[4], n3[8];
    root.val = 5;
    n1[0].val = 4;
    n1[1].val = 8;
    n2[0].val = 11;
    n2[2].val = 13;
    n2[3].val = 4;
    n3[0].val = 7;
    n3[1].val = 2;
    n3[6].val = 5;
    n3[7].val = 1;

    root.left = &n1[0];
    root.right = &n1[1];
    n1[0].left = &n2[0];
    n1[0].right = NULL;
    n1[1].left = &n2[2];
    n1[1].right = &n2[3];
    n2[0].left = &n3[0];
    n2[0].right = &n3[1];
    n2[2].left = NULL;
    n2[2].right = NULL;
    n2[3].left = &n3[6];
    n2[3].right = &n3[7];
    n3[0].left = NULL;
    n3[0].right = NULL;
    n3[1].left = NULL;
    n3[1].right = NULL;
    n3[6].left = NULL;
    n3[6].right = NULL;
    n3[7].left = NULL;
    n3[7].right = NULL;

    int i, j, count = 0;
    int *col_sizes, sum = 22;
    int **list = pathSum(&root, sum, &count, &col_sizes);
    for (i = 0; i < count; i++) {
        for (j = 0; j < col_sizes[i]; j++) {
            printf(""%d "", list[i][j]);
        }
        printf(""\n"");
    }

    return 0;
}
"
100-23843,nullgoat/utn-programacion-1,guia-wagstaff.c,75,6,87,2630521543.440409,7182607762.0,0.3661035309364844,1341.0,1321.0,40500.0,14202.0,1626.0,642.0,1345.0,598.0,1500000000,1.753681028960273,1082014363648.0,3.706174815898293e-07,0.0769807319659244,"/*
  Funcion: Resolver la formula w = (2^p + 1) / 3

           Los primeros numeros de Wagstaff son:
	   3, 11, 43, 683, 2731, 43691, 174763, 2796203, 715827883
	   2932031007403, 768614336404564651, etc...

           Link a wikipedia eng sobre numeros de Wagstaff
	   https://en.wikipedia.org/wiki/Wagstaff_prime#Known_Wagstaff_primes
	   
	   Nota:    A lo largo del codigo aparecen varios printf(); comentados
	   con '//DEBUG'
           Si uno necesitara checkear el valor de alguna variable, descomentar
	   esa linea.

*/
#include <stdio.h>
#define n 31

int main () {
  int p, w, div_p, div_w, prim_v, resultado, i;
  /*
    n   = el numero hasta donde voy a buscar primos (tmb evaluo a n inclusive)
    p   = numero a comprobar si es n° primo
    w   = numero a comprobar si es n° de wagstaff
  div_p = divisor del posible numero primo
  div_w = divisor del posible numero wagstaff
  prim_v es un contador:
                      cada vez que el modulo de p / div_p == 0, se aumenta en 1
                      cada vez que el modulo de w / div_w == 0, se aumenta en 1
                      va a utilizarse en momentos diferentes.
  resultado == 2 en primera instancia, sirve para calcular 2^p
    i   = la variable del for para calcular 2^p
  */
  //Genero un numero
  //Inicializa en 2 porque 2 es el 1er n° primo
  for (p = 2; p <= n ; p++) {
    //reseteo de prim_v
    prim_v = 0;
    //DEBUG printf(""\np = %d"", p);
    for (div_p = 1; div_p <= p ; div_p++) {
      //DEBUG printf(""\ndiv_p = %d"", div_p);
      if (p % div_p == 0) {	
	prim_v = prim_v + 1;
	//DEBUG printf(""\nprim_v = %d"", prim_v);
      }
    }
    //Aca se verifica si el numero 'p' es primo o no
    if (prim_v == 2) {
      //DEBUG printf(""\n%d es primo"", p);
      
      //Si consegui un n° primo, sigo resolviendo la formula de w
      //Ahora calculo cuanto seria 2^p
      
      //resultado = el resultado de 2^p
      //siempre se inicializa en 2

      resultado = 2;
      for(i = 2; i <= p ; i++) {
	resultado = resultado * 2;
	//DEBUG printf(""\n2^%d es %d\n\n"", p, resultado);
      }

      w = (resultado + 1) / 3;
      //DEBUG printf(""\nPosible n° de wagstaff = %d\n"", w);

      //por ahora 'w' es un posible numero de wagstaff, checkeo si w es un numero primo

      //reseteo de prim_v
      prim_v = 0;

      //div_w = divisor del posible numero w
      for (div_w = 1; div_w <= w ; div_w++) {
	//DEBUG printf(""\ndiv_w = %d"", div_w);
	if (w % div_w == 0) {	
	  prim_v = prim_v + 1;
	  //DEBUG printf(""\nprim_v = %d"", prim_v);
	}
      }
      if (prim_v == 2)
	printf(""\nn° de Wagstaff encontrado! %d"", w);
    } else {
      //DEBUG printf(""\n%d no es primo\n"", p);
    }
    //Vuelvo al primer for, donde 'p' ahora es p + 1
  }
  printf(""\n\n"");
  return 0;
}
"
176-6732,AllenDowney/ExercisesInC,exercises/ex08/matrix_soln.c,70,8,74,2181409.5089211,217549.0,10.027207663560851,1435.0,1410.0,48792.0,19877.0,1635.0,647.0,1357.0,602.0,1500000000,0.0014542730059474,1082014363648.0,0.0130775135716551,0.0617600372802865,"/* Example code for Exercises in C.

Copyright 2016 Allen Downey
License: Creative Commons Attribution-ShareAlike 3.0

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    int num_rows, num_cols;
    double **rows;
} Matrix;

/* Make a matrix.
*/
Matrix *make_matrix(int num_rows, int num_cols) {
    Matrix *matrix = malloc(sizeof(Matrix));
    matrix->num_rows = num_rows;
    matrix->num_cols = num_cols;
    matrix->rows = malloc(num_rows * sizeof(double*));
    for (int i=0; i<num_rows; i++) {
        matrix->rows[i] = calloc(num_cols, sizeof(double));
    }
    return matrix;
}

/* Free a matrix.
*/
void free_matrix(Matrix *matrix) {
    for (int i=0; i<matrix->num_rows; i++) {
        free(matrix->rows[i]);
    }
    free(matrix->rows);
    free(matrix);
}

/* Print a row of a matrix.
*/
void print_matrix_row(double *row, int num_cols) {
    for (int j=0; j<num_cols; j++) {
        printf(""%f "", row[j]);
    }
}

/* Print a matrix.
*/
void print_matrix(Matrix *matrix) {
    for (int i=0; i<matrix->num_rows; i++) {
        print_matrix_row(matrix->rows[i], matrix->num_cols);
        printf(""\n"");
    }
}

/* Perform row reduction.

Subtract a multiple of row j from row i so that the first element
of row i is 0.
*/
void reduce_matrix_rows(Matrix *matrix, int i, int j) {
    double *row1 = matrix->rows[i];
    double *row2 = matrix->rows[j];
    double factor = row1[0] / row2[0];

    for (int j=0; j<matrix->num_cols; j++) {
        row1[j] -= row2[j] * factor;
    }
}

int main () {
    Matrix *matrix = make_matrix(3, 4);
    for (int i=0; i<matrix->num_rows; i++) {
        for (int j=0; j<matrix->num_cols; j++) {
            matrix->rows[i][j] = i + j + 1;
        }
    }

    print_matrix(matrix);
    printf(""reducing...\n"");
    reduce_matrix_rows(matrix, 1, 0);
    reduce_matrix_rows(matrix, 2, 0);
    print_matrix(matrix);

    free_matrix(matrix);
}
"
136-16423,frivoal/presto-testo,imported/peter/unicode/tables/hz.c,65,5,51,6571090.430952599,7172268.0,0.916180209663108,1465.0,1438.0,1562555.0,1149527.0,1657.0,771.0,1368.0,727.0,1500000000,0.0043807269539684,1082014363648.0,0.0004047534196993,0.001667722436121,"#include <stdio.h>

int main(void)
{
	int i, j, pl;
	FILE *gbk = fopen(""hz-gb2312.html"", ""w"");
	if (!gbk) return 1;

	fputs(""<html lang=zh-cn>\n <head>\n  <meta http-equiv=\""Content-Type\"" ""
	      ""content=\""text/html;charset=hz-gb-2312\"">\n  <title>HZ</title>\n""
	      ""  <style>.unused { background: #ccc; }""
	      "" .special { background: #eee; } table { float: left; }</style>\n""
	      "" </head>\n <body>\n""
		  ""  <table><caption>ASCII/CNS-Roman</caption>\n""
	      ""   <tr><th>  "", gbk);

	for (i = 0; i < 16; i ++)
	{
		fprintf(gbk, ""<th>%X"", i);
	}

	/* Singlebyte */

	for (i = 32; i < 128; i ++)
	{
		if (0 == (i & 0x0F))
		{
			fprintf(gbk, ""\n   <tr><th>%02X"", i);
		}
		if ((char) '~' == i)
		{
			fputs(""<td class=special>~~"", gbk);
		}
		else
		{
			fprintf(gbk, ""<td%s>%c"",
			        (127 == i) ? "" class=unused"" : """",
			        (char) i);
		}
	}

	fputs(""\n  </table>\n"", gbk);

	/* Row-cell multibyte */

	for (i = 0x21; i < 0x7E; i ++)
	{
		fprintf(gbk, ""  <table><caption>Multibyte: HZ (Lead %X)</caption>\n   <tr><th> "", i);
		for (j = 0; j < 16; j ++)
		{
			fprintf(gbk, ""<th>%X"", j);
		}
		for (j = 0x20; j < 0x80; j ++)
		{
			if (0 == (j & 0x0F))
			{
				fprintf(gbk, ""\n   <tr><th>%02X"", j);
			}
			if (0x20 == j || j > 0x7E)
			{
				fputs(""<td class=unused>&nbsp;"", gbk);
			}
			else
			{
				fprintf(gbk, ""<td>~{%c%c~}"", (char) i, (char) j);
			}
		}
		fputs(""\n  </table>\n"", gbk);
	}

	/* End */

	fputs(""\n </body>\n</html>\n"", gbk);
	fclose(gbk);

	return 0;
}
"
216-21649,ErwanAliasr1/syslinux,diag/geodsp/mk-lba-img.c,72,4,190,41758149.16379745,12310979.0,3.391943808855494,1352.0,1328.0,1007378.0,2699902.0,1679.0,704.0,1381.0,659.0,1500000000,0.0278387661091983,1082014363648.0,0.0002176918667475,0.0011930579832114,"/* ----------------------------------------------------------------------- *
 *
 *   Copyright 2010 Gene Cumm
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
 *   Boston MA 02111-1307, USA; either version 2 of the License, or
 *   (at your option) any later version; incorporated herein by reference.
 *
 * ----------------------------------------------------------------------- */

/*
 * mk-lba-img.c
 *
 * Makes an image that contains the LBA in every *word of every sector
 */

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>

#define NUM_SECT (256*63+1)
#define BPS (512)
#define SECT_INT (BPS / sizeof(unsigned int))

typedef unsigned char uint8_t;
typedef unsigned int uint32_t;

const char DEF_FN[] = ""-"";

int main(int argc, char *argv[])
{
	int i, rv = 0, one = 0;
	unsigned int lba, b[SECT_INT];
	int len;
	FILE *f;
	uint8_t tt = 0;
	const char *fn;

	if (argc >= 2) {
		if (argc >= 3) {
			if (strcasecmp(""-1"", argv[1]) == 0) {
				fn = argv[2];
				one = 1;
			} else {
				fn = argv[1];
			}
		} else {
			fn = argv[1];
		}
	} else {
		fn = DEF_FN;
	}

	if (!strcmp(fn, ""-""))
		f = stdout;
	else
		f = fopen(fn, ""w"");

	if (!f) {
		fprintf(stderr, ""%s: %s: unable to open for writing: %s\n"",
			argv[0], fn, strerror(errno));
		return 1;
	}

	lba = 0;
	while ((len = fread(b, 1, BPS, stdin))) {
		if (len < BPS)
			memset((char *)b + len, 0, BPS - len);
		fwrite(b, 1, BPS, f);
		lba++;
	}

	memset(b, 0, sizeof b);

	while (lba < NUM_SECT) {
		if (one) {
			b[0] = lba;
		} else {
			for (i = 0; i < SECT_INT; i++)
				b[i] = lba;
		}
		fwrite(b, 1, BPS, f);
		lba++;
	}

	if (f != stdout)
		fclose(f);

	return rv;
}
"
102-5437,ElsevierSoftwareX/SOFTX-D-15-00010,files/extrae/tests/overhead/ia32_rdtsc_clock.c,68,3,414,19380166.4281635,3175292.0,6.10342796819946,1342.0,1322.0,39718.0,13485.0,1635.0,636.0,1352.0,593.0,1500000000,0.012920110952109,1082014363648.0,0.0008389779585625,0.0792436516737778,"/*****************************************************************************\
 *                        ANALYSIS PERFORMANCE TOOLS                         *
 *                                   Extrae                                  *
 *              Instrumentation package for parallel applications            *
 *****************************************************************************
 *     ___     This library is free software; you can redistribute it and/or *
 *    /  __         modify it under the terms of the GNU LGPL as published   *
 *   /  /  _____    by the Free Software Foundation; either version 2.1      *
 *  /  /  /     \   of the License, or (at your option) any later version.   *
 * (  (  ( B S C )                                                           *
 *  \  \  \_____/   This library is distributed in hope that it will be      *
 *   \  \__         useful but WITHOUT ANY WARRANTY; without even the        *
 *    \___          implied warranty of MERCHANTABILITY or FITNESS FOR A     *
 *                  PARTICULAR PURPOSE. See the GNU LGPL for more details.   *
 *                                                                           *
 * You should have received a copy of the GNU Lesser General Public License  *
 * along with this library; if not, write to the Free Software Foundation,   *
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA          *
 * The GNU LEsser General Public License is contained in the file COPYING.   *
 *                                 ---------                                 *
 *   Barcelona Supercomputing Center - Centro Nacional de Supercomputacion   *
\*****************************************************************************/

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- *\
 | @file: $HeadURL: https://svn.bsc.es/repos/ptools/extrae/branches/2.3/example/LINUX/SEQ/pi_instrumented.c $
 | @last_commit: $Date: 2013-05-17 12:18:49 +0200 (Fri, 17 May 2013) $
 | @version:     $Revision: 1734 $
\* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- */

#include <stdio.h>
#include <time.h>
#include <stdlib.h>

unsigned long long proc_timebase_MHz = 2000; /* Assume a 2.0GHz machine, in fact, it does not matter */

#if (defined(linux) || defined (__FreeBSD__) || defined (__APPLE__)) && \
    ((__x86_64__) || defined(x86_64) || defined(__amd64__) || defined(amd64) || defined(__i386__))
static __inline unsigned long long ia32_cputime (void)
{
# if defined (__x86_64__) || defined(x86_64) || defined(__amd64__) || defined(amd64)
	unsigned long lo, hi;
# else
	unsigned long long cycles;
# endif

# if defined (__FreeBSD__) || defined (__APPLE__)
	/* 0x0f 0x31 is the bytecode of RDTSC instruction */
#  if defined (__x86_64__) || defined(x86_64) || defined(__amd64__) || defined(amd64)
  /* We cannot use ""=A"", since this would use %rax on x86_64 */
	__asm __volatile ("".byte 0x0f, 0x31"" : ""=a"" (lo), ""=d"" (hi));
#  else
	__asm __volatile ("".byte 0x0f, 0x31"" : ""=A"" (cycles));
# endif
# elif defined(linux)
#  if defined (__x86_64__) || defined(x86_64) || defined(__amd64__) || defined(amd64)
	/* We cannot use ""=A"", since this would use %rax on x86_64 */
	__asm__ __volatile__ (""rdtsc"" : ""=a"" (lo), ""=d"" (hi));
#  else
	__asm__ __volatile__ (""rdtsc"" : ""=A"" (cycles));
#  endif
# else
#  error ""Unknown operating system!""
# endif

# if defined (__x86_64__) || defined(x86_64) || defined(__amd64__) || defined(amd64)
	return ((unsigned long long )hi << 32) | lo;
# else
	return cycles;
# endif
}
#else
static __inline unsigned long long ia32_cputime (void)
{
	return 0;
}
#endif

unsigned long long ia32_getTime (void)
{
  return (ia32_cputime() * 1000) / proc_timebase_MHz; 
}

int main (int argc, char *argv[])
{
	struct timespec start, stop;
	int i;
	unsigned n = 1000000;
	unsigned long long t1, t2, useless;

	clock_gettime (CLOCK_MONOTONIC, &start);
	for (i = 0; i < n; i++)
		useless = ia32_getTime();
	clock_gettime (CLOCK_MONOTONIC, &stop);
	t1 = start.tv_nsec;
	t1 += start.tv_sec * 1000000000;
	t2 = stop.tv_nsec;
	t2 += stop.tv_sec * 1000000000;
	printf (""RESULT : clock_gettime() %Lu ns\n"", (t2 - t1) / n);

	return 0;
}
"
326-35343,chggr/puzzles,easy/sum_swap.c,91,7,83,1844958.1693857,175193.0,10.531002951031148,1359.0,1341.0,39659.0,13499.0,1633.0,636.0,1351.0,593.0,1500000000,0.0012299721129238,1082014363648.0,0.0154115746633712,0.0792542985063396,"#include <stdio.h>

// Task description: Given two arrays of integers, find a pair of values (one
// from each array) that can be swapped to give the two arrays the same sum.
//
// E.g. for arrays {1, 4, 2, 1, 1, 2} and {3, 6, 3, 3}
//      the answer is {1, 3}
//
// Solution: The first step in the implementation below is to compute the sum
// of the two arrays provided. Then we iterate through all elements of the first
// array and for each one we search in the second array for an element that is
// equal to:
//
// sum_a - a[i] + b[j] = sum_b + a[i] - b[j] =>
// 2*b[j] = sum_b - sum_a + 2*a[i] =>
// b[j] = (sum_b - sum_a + 2*a[i]) / 2
//
// The runtime complexity of the solution below is O(M*N) where M is the length
// of the first table and N is the length of the second. This can be improved to
// O(M+N) if we store the elements of the second array into a HashSet to reduce
// the time it takes to search for the required element to O(1).

struct pair {
    int one;
    int two;
};

int sum(int array[], int length) {
    int result = 0;
    for (int i = 0; i < length; i++) {
        result += array[i];
    }
    return result;
}

void sum_swap(int a[], int a_len, int b[], int b_len, struct pair* result) {
    int sum_a = sum(a, a_len);
    int sum_b = sum(b, b_len);
    if (sum_a == sum_b) return;

    int req = 0;
    for (int i = 0; i < a_len; i++) {
        req = sum_b - sum_a + 2 * a[i];
        if (req % 2 != 0) continue;
        req /= 2;

        for (int j = 0; j < b_len; j++) {
            if (b[j] == req) {
                result->one = a[i];
                result->two = b[j];
                return;
            }
        }
    }
}

int test_same_sum() {
    int a[] = {1, 4, 2, 1, 1, 2};
    int b[] = {3, 2, 3, 3};

    struct pair p;
    p.one = -1;
    p.two = -1;
    sum_swap(a, 6, b, 4, &p);
    return -1 == p.one && -1 == p.two;
}

int test_diff_sum() {
    int a[] = {1, 4, 2, 1, 1, 2};
    int b[] = {3, 6, 3, 3};

    struct pair p;
    p.one = -1;
    p.two = -1;
    sum_swap(a, 6, b, 4, &p);
    return 1 == p.one && 3 == p.two;
}

int test_neg_num() {
    int a[] = {-3, 4, 2, 1, 1, 2};
    int b[] = {3, 6, 3, 3};

    struct pair p;
    p.one = -1;
    p.two = -1;
    sum_swap(a, 6, b, 4, &p);
    return 2 == p.one && 6 == p.two;
}

int main() {
    int counter = 0;
    if (!test_same_sum()) {
        printf(""Same sum test failed!\n"");
        counter++;
    }
    if (!test_diff_sum()) {
        printf(""Different sum test failed!\n"");
        counter++;
    }
    if (!test_neg_num()) {
        printf(""Negative numbers test failed!\n"");
        counter++;
    }
    printf(""%d tests failed.\n"", counter);
}

"
171-12549,alainlebret/os,exemplier/8_threads/thread_02_withmutex.c,87,6,76,1502206803.1830714,407442.0,3686.921826910333,2260.0,1754.0,105238.0,45466.0,2249.0,995.0,1658.0,888.0,1500000000,1.0014712021220475,1082014363648.0,0.0098517089548941,0.0384196836182184,"/*
 * ENSICAEN
 * 6 Boulevard Maréchal Juin
 * F-14050 Caen Cedex
 *
 * Unix System Programming Examples / Exemplier de programmation système Unix
 * Chapter ""Threads"" / Chapitre ""Threads""
 *
 * Copyright (C) 1995-2016 Alain Lebret (alain.lebret@ensicaen.fr)
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @author Alain Lebret
 * @version	1.0
 * @date 2012-04-10
 */

/**
 * @file threads_02_withmutex.c
 *
 * A simple program using 3 POSIX threads and a mutex.
 *
 * On Mac OS X, compile with gcc -DMUTEX -Wall -Wextra thread_02_withmutex.c
 * On Linux, compile with gcc -DMUTEX -Wall -Wextra thread_02_withmutex.c -pthread
 */

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

#define ITERATIONS 100000

pthread_mutex_t mutex ;

void display(int n, char letter)
{
	int i, j;

	for (j = 1; j < n; j++) {
		pthread_mutex_lock(&mutex) ;
		for (i = 1; i < ITERATIONS; i++);
		printf(""%c"", letter);
		fflush(stdout);
		pthread_mutex_unlock(&mutex) ;
	}
}

void *threadA(void *unused)
{
	display(100, 65);
	printf(""\n End of the thread A\n"");
	fflush(stdout);

	pthread_exit(NULL);
}

void *threadC(void *unused)
{
	display(150, 67);

	printf(""\n End of the thread C\n"");
	fflush(stdout);

	pthread_exit(NULL);
}

void *threadB(void *unused)
{
	pthread_t thC;

	pthread_create(&thC, NULL, threadC, NULL);
	display(100, 66);

	printf(""\n Thread B is waiting for thread C\n"");
	pthread_join(thC, NULL);

	printf(""\n End of the thread B\n"");
	fflush(stdout);

	pthread_exit(NULL);
}

int main(void)
{
	pthread_t thA, thB;

	pthread_mutex_init(&mutex, NULL);
	printf("" Creation of the thread A\n"");
	pthread_create(&thA, NULL, threadA, NULL);
	printf("" Creation of the thread B\n"");
	pthread_create(&thB, NULL, threadB, NULL);
	sleep(1);

	/* The main thread is waiting for A and B to finish */
	printf(""The main thread is waiting for A and B to finish\n"");
	pthread_join(thA, NULL);
	pthread_join(thB, NULL);

	pthread_exit(NULL);
}
"
081-32975,AllenDowney/ExercisesInC,exercises/ex10/tree.c,85,2,107,2067752.9973908998,188808.0,10.951612219821191,1348.0,1328.0,44223.0,15904.0,1633.0,641.0,1353.0,598.0,1500000000,0.0013785019982606,1082014363648.0,0.0141731282572772,0.0702679328754137,"/* Example from

https://www.geeksforgeeks.org/binary-tree-set-1-introduction/

1) Draw a stack diagram that shows the state of main before calling
   rotate_right()

2) Draw a stack diagram that shows the state of main after calling
   rotate_right()

3) Fill in the body of rotate_left() and test it.

*/

#include <stdio.h>
#include <stdlib.h>


struct node
{
    int data;
    struct node* left;
    struct node* right;
};

/* newNode() allocates a new node with the given data and NULL left and
right pointers. */
struct node* newNode(int data)
{
    // Allocate memory for new node
    struct node* node = (struct node*)malloc(sizeof(struct node));

    // Assign data to this node
    node->data = data;

    // Initialize left and right children as NULL
    node->left = NULL;
    node->right = NULL;
    return(node);
}

/* Print the data in the tree in in-order.
*/
void print_tree(struct node* root) {
    if (root == NULL) return;
    print_tree(root->left);
    printf(""%d "", root->data);
    print_tree(root->right);
}

int COUNT = 10;

// Function to print binary tree in 2D
// It does reverse inorder traversal
// From https://www.geeksforgeeks.org/print-binary-tree-2-dimensions/
void print2D(struct node* root, int space)
{
    // Base case
    if (root == NULL)
        return;

    // Increase distance between levels
    space += COUNT;

    // Process right child first
    print2D(root->right, space);

    // Print current node after space
    // count
    printf(""\n"");
    for (int i = COUNT; i < space; i++)
        printf("" "");
    printf(""%d\n"", root->data);

    // Process left child
    print2D(root->left, space);
}


/* Rotates the tree around the given node.

root: root of the tree to rotate

returns: pointer to the new root
*/
struct node *rotate_right(struct node* root) {
    struct node* pivot = root->left;
    root->left = pivot->right;
    pivot->right = root;
    return pivot;
}


struct node *rotate_left(struct node* root) {
    // TODO: fill this in
    // See
}


int main()
{
    /*create root*/
    struct node *root = newNode(5);

    root->left = newNode(3);
    root->right = newNode(7);

    root->left->left = newNode(2);
    root->left->right = newNode(4);

    print2D(root, 0);
    printf(""-----\n"");

    root = rotate_right(root);
    print2D(root, 0);

    return 0;
}
"
367-34398,Sniper/MIPS-Emulator,MIPS-Float/alg.c,96,4,121,2152535.9479710003,170640.0,12.614480778246602,1152.0,1144.0,38742.0,12806.0,1583.0,587.0,1327.0,546.0,1500000000,0.001435023965314,1082014363648.0,0.013455227379278,0.0784317529293086,"/**
 * Just some high level C code to make sure we actually understand the format
 */

#include <stdio.h>

#define EXPONENT_MASK   0x7F800000
#define EXP_SHIFT       23
#define SIGN_MASK       0x80000000
#define MAGNITUDE_MASK  0x007FFFFF

#define numA			0.3
#define numB			-4.3

int absolute(int x) {
   if (x < 0)
	  return -x;
   return x;
}

float packFloat(int exponent, int magnitude) {
   if (magnitude == 0)
	   return 0;

   int res = ((magnitude < 0) ? 1 : 0) << 31;
   res |= ((exponent + 127) << EXP_SHIFT) & EXPONENT_MASK;
   res |= absolute(magnitude) & MAGNITUDE_MASK;
   /*printf(""packing float: %d * 2^%d -> 0x%X (%d)\n"", magnitude, exponent, res, res);*/
   return *((float *) ((void *) &res)); 
}

void unpackFloat(float aV, int *exponent, int *magnitude) {
   int a = *((int *) ((void *) &aV));
   *exponent = ((((int) a) & EXPONENT_MASK) >> EXP_SHIFT) - 127;
   *magnitude = (a & MAGNITUDE_MASK) + (MAGNITUDE_MASK + 1);
   if (a & SIGN_MASK)
	   *magnitude = -*magnitude;

   /*printf("" unpacking float: 0x%X (%f) exponent: %d, magnitude: %d\n"", (int) a,
         aV, *exponent, *magnitude);*/
}

void normalizeFloat(int *exponent, int *magnitude) {
   if (*magnitude == 0) {
	  *exponent = 0;
	  return;
   }
   int sign = 0;
   if (*magnitude < 0) {
	  sign = 1;
	  *magnitude = -*magnitude;
   }
   /*printf(""exp: %d, mag: 0x%X (%d) \n"", *exponent, *magnitude, *magnitude);*/
   while ((*magnitude & ~MAGNITUDE_MASK) == 0) {
      *magnitude <<= 1;
      (*exponent)--;
	  /*printf(""exp: %d, mag: 0x%X (%d) \n"", *exponent, *magnitude, *magnitude);
	  printf(""mag: %X ~mask: %X &: %X\n"", *magnitude, ~MAGNITUDE_MASK, 
			*magnitude & ~MAGNITUDE_MASK);*/
   }
   while (*magnitude & (~MAGNITUDE_MASK << 1)) {
      *magnitude >>= 1;
      (*exponent)++;
	  /*printf(""exp: %d, mag: 0x%X (%d) \n"", *exponent, *magnitude, *magnitude);*/
   }
   if (sign) {
	  *magnitude = -*magnitude;
   }
}

float fSum(float a, float b) {
   int aExp, aMag;
   int bExp, bMag;

   unpackFloat(a, &aExp, &aMag);
   unpackFloat(b, &bExp, &bMag);

   while (aExp < bExp) {
	  aExp++;
	  aMag >>= 1;
   }
   while (bExp < aExp) {
      bExp++;
      bMag >>= 1;
   }
   /*printf(""bExp: exp: 0x%X (%d) mag: 0x%x (%d)\n"", 
         bExp, bExp, bMag, bMag);
   printf(""aExp: exp: 0x%X (%d) mag: 0x%x (%d)\n"", 
         aExp, aExp, aMag, aMag);*/

   int cExp = bExp, cMag = aMag + bMag;

   normalizeFloat(&cExp, &cMag);
   return packFloat(cExp, cMag);
}

float fDiff(float a, float b) {
   return fSum(a, -b);
}

float fProd(float a, float b) {
   int aExp, aMag;
   int bExp, bMag;

   unpackFloat(a, &aExp, &aMag);
   unpackFloat(b, &bExp, &bMag);

   long lcMag = (long) aMag * (long) bMag;
   lcMag >>= 23;
   int icMag = (int) lcMag;
   int cExp = aExp + bExp;

   normalizeFloat(&cExp, &icMag);
   return packFloat(cExp, icMag);
}

int main(void) {
   float a = numA, b = numB;

   float sum = fSum(a, b);
   float diff = fDiff(a, b);
   float prod = fProd(a, b);

   return 0;
}
"
355-21797,dunso/algorithm,C/BT/LeetCode0051.c,107,15,111,5553264.05446965,4270571.0,1.3003563223746897,1460.0,1434.0,1031281.0,583377.0,2164.0,1245.0,1357.0,1171.0,1500000000,0.0037021760363131,1082014363648.0,0.0006776611371172,0.0036769396367527,"#include <stdio.h>
#include <stdlib.h>

char ** board;
int* row;
int* col;
int** diagonal;

void Marking(int i, int j, int n, int mark) {
	row[i] += mark;
	col[j] += mark;

	for (int x = i, y = j; x >= 0 && y < n; x--, y++)
	{
		diagonal[x][y] += mark;
	}

	for (int x = i + 1, y = j - 1; x < n && y >= 0; x++, y--)
	{
		diagonal[x][y] += mark;
	}

	for (int x = i - 1, y = j - 1; x >= 0 && y >= 0; x--, y--)
	{
		diagonal[x][y] += mark;
	}

	for (int x = i + 1, y = j + 1; x < n && y < n; x++, y++)
	{
		diagonal[x][y] += mark;
	}
}

void findNextOne(char*** ret, int* returnSize, int i, int j, int n)
{
	if (i == n)
	{
		ret[*returnSize] = (char **)malloc(sizeof(void *) * n);

		for (int a = 0; a < n; a++)
		{
			ret[*returnSize][a] = (char *)malloc(sizeof(char) * (n + 1));
		}

		for (int a = 0; a < n; a++)
		{
			for (int b = 0; b < n; b++)
			{
				ret[*returnSize][a][b] = board[a][b];
			}
			ret[*returnSize][a][n] = '\0';
		}

		(*returnSize)++;

		return;
	}

	for (int y = j; y < n; y++)
	{
		if (row[i] == 0 && col[y] == 0 && diagonal[i][y] == 0)
		{
			board[i][y] = 'Q';
			Marking(i, y, n, 1);
			findNextOne(ret, returnSize, i + 1, 0, n);
			Marking(i, y, n, -1);
			board[i][y] = '.';
		}
	}
}

char*** solveNQueens(int n, int* returnSize) {

	*returnSize = 0;
	char*** ret = (char***)malloc(sizeof(char **) * 512);

	board = (char **)malloc(sizeof(char*) * n);
	for (int i = 0; i< n; i++)
	{
		board[i] = (char *)malloc(sizeof(char) * n);
	}

	row = (int *)malloc(sizeof(int) * n);
	col = (int *)malloc(sizeof(int) * n);
	diagonal = (int **)malloc(sizeof(int *) * n);

	for (int i = 0; i< n; i++)
	{
		diagonal[i] = (int *)malloc(sizeof(int) * n);
	}

	for (int i = 0; i < n; i++)
	{
		row[i] = 0; col[i] = 0;
		for (int j = 0; j< n; j++)
		{
			board[i][j] = '.';
			diagonal[i][j] = 0;
		}
	}

	findNextOne(ret, returnSize, 0, 0, n);
	return ret;
}

int main()
{
	int n = 8;
	int returnSize = 0;
	char*** res = solveNQueens(n, &returnSize);
	printf(""size = %d\n"", returnSize);

	for (int i = 0; i < returnSize; i++)
	{
		for (int j = 0; j < n; j++)
		{
			for (int k = 0; k < n; k++)
			{
				printf(""%c "", res[i][j][k]);
			}
			printf(""\n"");
			free(res[i][j]);
		}
		printf(""\n"");
		free(res[i]);
	}

	free(res);
	system(""pause"");
	return 0;
}
"
001-35337,MatthewZheng/Project-Euler-Solutions-.C-and-.py-,questionTwo.c,71,2,61,4311860.888265,175638.0,24.549698812329908,1400.0,1379.0,39756.0,13700.0,1633.0,643.0,1351.0,597.0,1500000000,0.00287457392551,1082014363648.0,0.0158223163552306,0.0790182580065848,"/*
*Author: Matthew Zheng
*Purpose: Euler Q2 solution: Even fibonacci numbers
*/

#include <stdlib.h>
#include <stdio.h>

/*Function Initialization*/
void printFib(int);
void printFibSum(int);

int main(void){

   //printFib(33);
   printFibSum(32);

   system(""PAUSE"");
   return 0;
}

/*Function purpose: Print out the fibonnaci seq up to given number, prints if number is over or under 4 million*/
void printFib(int range){
   int fibNum1 = 1;
   int fibNum2 = 2;
   int sumNum;
   /*Hardcode the first two cases*/
   if(range <= 0){
      puts(""There's nothing to show!"");
   } else if (range >= 1){
      printf(""%d, "", 1);
   }
   for (int i = 1; i< range; i++){
      if(i == 1){
         /*Hardcode the first two cases*/
         printf(""%d, "", 2);
      } else {
         /*Assign to temp*/
         sumNum = fibNum1+fibNum2;
         printf(""%d, "", sumNum);
         /*Print out cases compared to 4 million*/
         if(sumNum > 4000000){
            puts(""This is over 4 mill."");
         } else if (sumNum == 4000000){
            puts(""This gives you 4 mill"");
         } else {
            puts(""Under 4 mill"");
         }
         fibNum1 = fibNum2;
         fibNum2 = sumNum;
      }
   }
}

/*Function purpose: Sums up the fibonnaci seq within certain range*/
void printFibSum(int range){
   long int sum = 0;
   int fibNum1 = 1;
   int fibNum2 = 2;
   int sumNum;
   if(range <= 0){
      /*No increment*/
   } else if (range >= 1){
      /*Do nothing because 1 is not even*/
   }
   for (int i = 1; i< range; i++){
      if(i == 1){
         /*First even number*/
         sum += 2;
      } else {
         sumNum = fibNum1+fibNum2;
         if (sumNum % 2 == 0){
            sum += sumNum;
         }
         fibNum1 = fibNum2;
         fibNum2 = sumNum;
      }
   }
   printf(""Your sum is %ld\n"", sum);
}
"
216-3644,lugon/LuxCC,src/tests/execute/llvm/Puzzle.c,107,52,276,113697118.3586865,572787023.0,0.1984980689759795,1372.0,1351.0,93709417.0,7115865.0,2974.0,8772.0,1352.0,1055.0,1500000000,0.075798078905791,1082014363648.0,4.753948484618514e-06,0.0001403715389558,"#include <stdio.h>
#include <stdlib.h>

#define  nil		0
#define	 false		0
#define  true		1

    /* Puzzle */
#define size	 	 511
#define classmax 	 3
#define typemax 	 12
#define d 		     8

    /* global */
long    seed;  /* converted to long for 16 bit WR*/

    /* Puzzle */
int	piececount[classmax+1],	class[typemax+1], piecemax[typemax+1];
int	puzzl[size+1], p[typemax+1][size+1], n, kount;

void Initrand (void) {
    seed = 74755L;   /* constant to long WR*/
}

int Rand (void) {
    seed = (seed * 1309L + 13849L) & 65535L;  /* constants to long WR*/
    return( (int)seed );     /* typecast back to int WR*/
}

    /* A compute-bound program from Forest Baskett. */

int Fit (int i, int j) {
	int k;
	for ( k = 0; k <= piecemax[i]; k++ )
	    if ( p[i][k] ) if ( puzzl[j+k] ) return (false);
	return (true);
}

int Place (int i, int j) {
	int k;
	for ( k = 0; k <= piecemax[i]; k++ ) if ( p[i][k] ) puzzl[j+k] = true;
	piececount[class[i]] = piececount[class[i]] - 1;
	for ( k = j; k <= size; k++ ) if ( ! puzzl[k] ) return (k);
	return (0);
}

void Remove (int i, int j) {
	int k;
	for ( k = 0; k <= piecemax[i]; k++ ) if ( p[i][k] ) puzzl[j+k] = false;
	piececount[class[i]] = piececount[class[i]] + 1;
}

int Trial (int j) {
	int i, k;
	kount = kount + 1;
	for ( i = 0; i <= typemax; i++ )
	    if ( piececount[class[i]] != 0 )
		if ( Fit (i, j) ) {
		    k = Place (i, j);
		    if ( Trial(k) || (k == 0) )return (true);
			else Remove (i, j);
		}
	return (false);
}

void Puzzle (void)  {
    int i, j, k, m;
    for ( m = 0; m <= size; m++ ) puzzl[m] = true;
    for( i = 1; i <= 5; i++ )for( j = 1; j <= 5; j++ )for( k = 1; k <= 5; k++ )	puzzl[i+d*(j+d*k)] = false;
    for( i = 0; i <= typemax; i++ )for( m = 0; m<= size; m++ ) p[i][m] = false;
    for( i = 0; i <= 3; i++ )for( j = 0; j <= 1; j++ )for( k = 0; k <= 0; k++ ) p[0][i+d*(j+d*k)] = true;
    class[0] = 0;
    piecemax[0] = 3+d*1+d*d*0;
    for( i = 0; i <= 1; i++ )for( j = 0; j <= 0; j++ )for( k = 0; k <= 3; k++ )	p[1][i+d*(j+d*k)] = true;
    class[1] = 0;
    piecemax[1] = 1+d*0+d*d*3;
    for( i = 0; i <= 0; i++ )for( j = 0; j <= 3; j++ )for( k = 0; k <= 1; k++ )	p[2][i+d*(j+d*k)] = true;
    class[2] = 0;
    piecemax[2] = 0+d*3+d*d*1;
    for( i = 0; i <= 1; i++ )for( j = 0; j <= 3; j++ )for( k = 0; k <= 0; k++ )	p[3][i+d*(j+d*k)] = true;
    class[3] = 0;
    piecemax[3] = 1+d*3+d*d*0;
    for( i = 0; i <= 3; i++ )for( j = 0; j <= 0; j++ )for( k = 0; k <= 1; k++ )	p[4][i+d*(j+d*k)] = true;
    class[4] = 0;
    piecemax[4] = 3+d*0+d*d*1;
    for( i = 0; i <= 0; i++ )for( j = 0; j <= 1; j++ )for( k = 0; k <= 3; k++ )	p[5][i+d*(j+d*k)] = true;
    class[5] = 0;
    piecemax[5] = 0+d*1+d*d*3;
    for( i = 0; i <= 2; i++ )for( j = 0; j <= 0; j++ )for( k = 0; k <= 0; k++ )	p[6][i+d*(j+d*k)] = true;
    class[6] = 1;
    piecemax[6] = 2+d*0+d*d*0;
    for( i = 0; i <= 0; i++ )for( j = 0; j <= 2; j++ )for( k = 0; k <= 0; k++ )	p[7][i+d*(j+d*k)] = true;
    class[7] = 1;
    piecemax[7] = 0+d*2+d*d*0;
    for( i = 0; i <= 0; i++ )for( j = 0; j <= 0; j++ )for( k = 0; k <= 2; k++ )	p[8][i+d*(j+d*k)] = true;
    class[8] = 1;
    piecemax[8] = 0+d*0+d*d*2;
    for( i = 0; i <= 1; i++ )for( j = 0; j <= 1; j++ )for( k = 0; k <= 0; k++ )	p[9][i+d*(j+d*k)] = true;
    class[9] = 2;
    piecemax[9] = 1+d*1+d*d*0;
    for( i = 0; i <= 1; i++ )for( j = 0; j <= 0; j++ )for( k = 0; k <= 1; k++ )	p[10][i+d*(j+d*k)] = true;
    class[10] = 2;
    piecemax[10] = 1+d*0+d*d*1;
    for( i = 0; i <= 0; i++ )for( j = 0; j <= 1; j++ )for( k = 0; k <= 1; k++ )	p[11][i+d*(j+d*k)] = true;
    class[11] = 2;
    piecemax[11] = 0+d*1+d*d*1;
    for( i = 0; i <= 1; i++ )for( j = 0; j <= 1; j++ )for( k = 0; k <= 1; k++ )	p[12][i+d*(j+d*k)] = true;
    class[12] = 3;
    piecemax[12] = 1+d*1+d*d*1;
    piececount[0] = 13;
    piececount[1] = 3;
    piececount[2] = 1;
    piececount[3] = 1;
    m = 1+d*(1+d*1);
    kount = 0;
    if ( Fit(0, m) ) n = Place(0, m);
    else printf(""Error1 in Puzzle\n"");
    if ( ! Trial(n) ) printf (""Error2 in Puzzle.\n"");
    else if ( kount != 2005 ) printf ( ""Error3 in Puzzle.\n"");
	 printf(""%d\n"", n);
	 printf(""%d\n"", kount);
}

int main(void)
{
	int i;
	for (i = 0; i < 100; i++) Puzzle();
	return 0;
}
"
356-22780,laluferu/hw_6,burgers/burgers.c,72,6,91,581901052.3846372,4622655575.0,0.1258802527159943,1447.0,1424.0,975096817.0,592708415.0,122284.0,3149.0,1363.0,1010.0,1500000000,0.3879340349230915,1082014363648.0,6.210715796190375e-07,8.151905440254329e-05,"/*
 * burgers.c
 *
 *  Created on: 2/11/2015
 *      Author: Laura Ferrer
 */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>

int main()
{
	int nx = 41;
	int nt = 120;
	int c = 1;
	int pasos = 500;
	double dx = 2./(nx-1.);
	double sigma = .0009;
	double nu = 0.01;
	double dt = sigma*dx*dx/nu;
	double x[nx];
	double y[nx];
	int i;
	int j;
	for (i = 0; i < nx; i += 1)
	{
		x[i]= i*dx;
		y[i]= i*dx;
	}
	double u[nx][nx];
	double v[nx][nx];
	for (i = 0; i < nx; i += 1)
	{
		for (j = 0; j < nx; j += 1)
		{
			if (((i>=0.5) && (i<=dx)) && ((j>=0.5) && (j<=dx)))
			{
				u[i][j] = 2;
				v[i][j] = 2;
			}
			else
			{
				u[i][j] = 1;
				v[i][j] = 1;
			}
		}
	}
	int paso;
	for (paso = 0; paso < pasos; paso += 1)
	{
		for (i = 0; i < nx; i += 1)
		{
			for (j = 0; j < nx; j += 1)
			{
				if (i == 0 || i == nx-1 || j == 0 || j == nx-1)//Fronteras
				{
					u[i][j] = 1;
					v[i][j] = 1;
				}
				else
				{
					u[i][j]=u[i][j]- dt/dx*u[i][j]*(u[i][j]-u[i][j-1])
							-dt/dx*u[i][j]*(u[i][j]-u[i-1][j])+
							nu*dt/pow(dx,2.)*(u[i][j+1]-2*u[i][j]+u[i][j-1])+
							nu*dt/pow(dx,2.)*(u[i+1][j]-2*u[i][j]+u[i-1][j]);
					v[i][j]=v[i][j]- dt/dx*v[i][j]*(v[i][j]-v[i][j-1])
							-dt/dx*v[i][j]*(v[i][j]-v[i-1][j])+
							nu*dt/pow(dx,2.)*(v[i][j+1]-2*v[i][j]+v[i][j-1])+
							nu*dt/pow(dx,2.)*(v[i+1][j]-2*v[i][j]+v[i-1][j]);
				}
				printf(""%g,%g,%g,%g"", x[i],y[j],u[i][j],v[i][j]);
			}
		}
	}


	return 0;
}
"
217-17421,imyouxia/DataStructure,BinaryTree/PreorderTraversal.c,78,2,107,1904402.97592425,184542.0,10.31644286937391,1368.0,1348.0,41775.0,14925.0,1641.0,644.0,1355.0,599.0,1500000000,0.0012696019839495,1082014363648.0,0.0147175168796263,0.0747619047619047,"/* 二叉树前序遍历方式 */

#include <stdio.h>
#include <stdlib.h>

struct tree   //树的结构声明
{
	int data;   //结点数据
	struct tree *left;     //指向左子树的指针
	struct tree *right;    //指向右子树的指针
};

typedef struct tree treenode;   //树的结构新类型
typedef treenode *btree;   //声明树结点指针类型

/* 插入二叉树的结点 */
btree insertnode(btree root,int value)
{
	btree newnode;  	 //树根指针
	btree current; 		 //目前树结点指针
	btree back;  		 //父结点指针

	/* 创建新结点内存 */
	newnode = (btree)malloc(sizeof(treenode));
	newnode->data = value;    //创建结点内容
	newnode->left = NULL;     //设置指针初值
	newnode->right = NULL;    //设置指针初值

	if(root == NULL)  //是否是根结点
	{
		return newnode;   //返回新结点位置
	}

	else
	{
		current = root;   //保留目前树指针
		while(current != NULL)
		{
			back = current;    //保留父结点指针
			if(current->data > value)  //比较结点值
				current = current->left;  //左子树
			else
				current = current->right;   //右子树
		
		}

		if(back->data > value)  //接起父子的连接
		{
			back->left = newnode;   //左子树
		}
		else
		{
			back->right = newnode;   //右子树
		}
	}
	return root;   //返回树根指针
}

/* 创建二叉树 */
btree createbtree(int *data,int len)
{
	btree root = NULL;   //树根指针
	int i;

	for(i = 0; i < len; i++)
	{
		root = insertnode(root,data[i]);
	}
	return root;
}


/* 二叉树前序遍历 */
void preorder(btree ptr)
{
	if(ptr != NULL)  //终止条件
	{
		printf(""[%2d]\n"",ptr->data);   //输出结点内容
		preorder(ptr->left);  //左子树
		preorder(ptr->right);   //右子树
	}
}

/* 主程序：创建二叉树且用前序遍历输出 */
int main()
{
	btree root = NULL;   //树根指针

	/* 二叉树结点数据 */
	int data[9] = {5,6,4,8,2,3,7,1,9};
	root = createbtree(data,9);
	printf(""树的结点内容\n"");
	preorder(root);   //前序遍历二叉树
	return 0;

}


"
249-12141,abnerfcastro/c-fundamentals,miscellaneous/time/time_c.c,68,1,53,2457949.79855415,202437.0,12.14179720110454,1779.0,1722.0,45349.0,16627.0,1783.0,686.0,1424.0,638.0,1500000000,0.0016386331990361,1082014363648.0,0.0172942693282354,0.0731089453982186,"/*
 * Author: Abner Castro
 * Date: August 11th, 2016
 * Description:
 *      Play around with time functions in C.
 */

#include <stdio.h>      // printf
#include <time.h>       // time_t, ctime
#include <limits.h>     // MAX_INT

static inline void days_since_beginning();
static inline void time_your_program();
static inline void when_time_t_wrap_around();
static inline void struct_tm_mktime();
static inline void format_time();


int main()
{
    // days_since_beginning();
    // time_your_program();
    // when_time_t_wrap_around();
    struct_tm_mktime();
    format_time();    
    return 0;
}

static inline void days_since_beginning()
{
    time_t seconds;
    seconds = time(NULL);
    printf(""Days since January 1, 1970 = %d\n"", seconds/3600/24);
}

static inline void time_your_program()
{
    clock_t start, end, elapsed;

    start = clock();
    // Loop just to stall a bit...
    for (int i = 0; i < INT_MAX; i++) {}
    end = clock();
    elapsed = end - start;
    printf(""It took me %d clicks (%f seconds).\n"", elapsed, ((float)elapsed)/CLOCKS_PER_SEC);

}

static inline void when_time_t_wrap_around()
{
    printf("":: When will time_t wrap around? \n\n"");
    
    time_t biggest = 0x7FFFFFFF;
    printf(""biggest = %s"", ctime(&biggest));
    printf(""biggest = %s"", asctime(gmtime(&biggest)));
}

static inline void struct_tm_mktime()
{
    time_t now;
    struct tm *today;

    time(&now);
    today = localtime(&now);

    printf(""The current time with asctime function: %s\n"", asctime(today));
    printf(""Year: %d, Month: %d\n"", 1900 + today->tm_year, 1 + today->tm_mon);

    struct tm *utc_time;
    utc_time = gmtime(&now);
    printf(""UTC Time: %s\n"", asctime(utc_time));
}

static inline void format_time()
{
    printf(""Formatting Time with strftime\n"");
    time_t raw_time;
    struct tm *timeinfo;
    char buffer[200];

    time(&raw_time);
    timeinfo = localtime(&raw_time);

    strftime(buffer, 200, ""Now it's %I:%M%p."", timeinfo);
    puts(buffer);

    strftime(buffer, 200, ""Today it is %A, %d of %B, %Y. Day of number %j. Offset from UTC %z."", timeinfo);
    puts(buffer);
}"
360-8288,atmark-techno/atmark-dist,uClibc/test/string/tester.c,1390,41,2030,59740798.431448504,389123327.0,0.1535266427242487,1881.0,1839.0,69191834.0,19497436.0,1804.0,647.0,1483.0,598.0,1500000000,0.039827198954299,1082014363648.0,9.55995115656482e-06,5.109975535935745e-05,"/* Tester for string functions.
   Copyright (C) 1995-2001, 2003, 2005 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif

/* Make sure we don't test the optimized inline functions if we want to
   test the real implementation.  */
#if !defined DO_STRING_INLINES
#undef __USE_STRING_INLINES
#endif

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <fcntl.h>

#ifdef __UCLIBC__
# define __TEST_BSD_FUNCS__
#else
# undef __TEST_BSD_FUNCS__
#endif

#if defined(__UCLIBC_SUSV3_LEGACY__) || defined(__UCLIBC_SUSV3_LEGACY_MACROS__)
# define __TEST_SUSV3_LEGACY__
#else
# undef __TEST_SUSV3_LEGACY__
#endif

#define	STREQ(a, b)	(strcmp((a), (b)) == 0)

const char *it = ""<UNSET>"";	/* Routine name for message routines. */
size_t errors = 0;

/* Complain if condition is not true.  */
static void
check (int thing, int number)
{
  if (!thing)
    {
      printf(""%s flunked test %d\n"", it, number);
      ++errors;
    }
}

/* Complain if first two args don't strcmp as equal.  */
static void
equal (const char *a, const char *b, int number)
{
  check(a != NULL && b != NULL && STREQ (a, b), number);
}

char one[50];
char two[50];
char *cp;

static void
test_strcmp (void)
{
  it = ""strcmp"";
  check (strcmp ("""", """") == 0, 1);		/* Trivial case. */
  check (strcmp (""a"", ""a"") == 0, 2);		/* Identity. */
  check (strcmp (""abc"", ""abc"") == 0, 3);	/* Multicharacter. */
  check (strcmp (""abc"", ""abcd"") < 0, 4);	/* Length mismatches. */
  check (strcmp (""abcd"", ""abc"") > 0, 5);
  check (strcmp (""abcd"", ""abce"") < 0, 6);	/* Honest miscompares. */
  check (strcmp (""abce"", ""abcd"") > 0, 7);
  check (strcmp (""a\203"", ""a"") > 0, 8);		/* Tricky if char signed. */
  check (strcmp (""a\203"", ""a\003"") > 0, 9);

  {
    char buf1[0x40], buf2[0x40];
    int i, j;
    for (i=0; i < 0x10; i++)
      for (j = 0; j < 0x10; j++)
	{
	  int k;
	  for (k = 0; k < 0x3f; k++)
	    {
	      buf1[k] = '0' ^ (k & 4);
	      buf2[k] = '4' ^ (k & 4);
	    }
	  buf1[i] = buf1[0x3f] = 0;
	  buf2[j] = buf2[0x3f] = 0;
	  for (k = 0; k < 0xf; k++)
	    {
	      int cnum = 0x10+0x10*k+0x100*j+0x1000*i;
	      check (strcmp (buf1+i,buf2+j) == 0, cnum);
	      buf1[i+k] = 'A' + i + k;
	      buf1[i+k+1] = 0;
	      check (strcmp (buf1+i,buf2+j) > 0, cnum+1);
	      check (strcmp (buf2+j,buf1+i) < 0, cnum+2);
	      buf2[j+k] = 'B' + i + k;
	      buf2[j+k+1] = 0;
	      check (strcmp (buf1+i,buf2+j) < 0, cnum+3);
	      check (strcmp (buf2+j,buf1+i) > 0, cnum+4);
	      buf2[j+k] = 'A' + i + k;
	      buf1[i] = 'A' + i + 0x80;
	      check (strcmp (buf1+i,buf2+j) > 0, cnum+5);
	      check (strcmp (buf2+j,buf1+i) < 0, cnum+6);
	      buf1[i] = 'A' + i;
	    }
	}
  }
}

#define SIMPLE_COPY(fn, n, str, ntest) \
  do {									      \
    int __n;								      \
    for (__n = 0; __n < (int) sizeof (one); ++__n)			      \
      one[__n] = 'Z';							      \
    fn (one, str);							      \
    for (cp = one, __n = 0; __n < n; ++__n, ++cp)			      \
      check (*cp == '0' + (n % 10), ntest);				      \
    check (*cp == '\0', ntest);						      \
  } while (0)

static void
test_strcpy (void)
{
  int i;
  it = ""strcpy"";
  check (strcpy (one, ""abcd"") == one, 1); /* Returned value. */
  equal (one, ""abcd"", 2);		/* Basic test. */

  (void) strcpy (one, ""x"");
  equal (one, ""x"", 3);			/* Writeover. */
  equal (one+2, ""cd"", 4);		/* Wrote too much? */

  (void) strcpy (two, ""hi there"");
  (void) strcpy (one, two);
  equal (one, ""hi there"", 5);		/* Basic test encore. */
  equal (two, ""hi there"", 6);		/* Stomped on source? */

  (void) strcpy (one, """");
  equal (one, """", 7);			/* Boundary condition. */

  for (i = 0; i < 16; i++)
    {
      (void) strcpy (one + i, ""hi there"");	/* Unaligned destination. */
      equal (one + i, ""hi there"", 8 + (i * 2));
      (void) strcpy (two, one + i);		/* Unaligned source. */
      equal (two, ""hi there"", 9 + (i * 2));
    }

  SIMPLE_COPY(strcpy, 0, """", 41);
  SIMPLE_COPY(strcpy, 1, ""1"", 42);
  SIMPLE_COPY(strcpy, 2, ""22"", 43);
  SIMPLE_COPY(strcpy, 3, ""333"", 44);
  SIMPLE_COPY(strcpy, 4, ""4444"", 45);
  SIMPLE_COPY(strcpy, 5, ""55555"", 46);
  SIMPLE_COPY(strcpy, 6, ""666666"", 47);
  SIMPLE_COPY(strcpy, 7, ""7777777"", 48);
  SIMPLE_COPY(strcpy, 8, ""88888888"", 49);
  SIMPLE_COPY(strcpy, 9, ""999999999"", 50);
  SIMPLE_COPY(strcpy, 10, ""0000000000"", 51);
  SIMPLE_COPY(strcpy, 11, ""11111111111"", 52);
  SIMPLE_COPY(strcpy, 12, ""222222222222"", 53);
  SIMPLE_COPY(strcpy, 13, ""3333333333333"", 54);
  SIMPLE_COPY(strcpy, 14, ""44444444444444"", 55);
  SIMPLE_COPY(strcpy, 15, ""555555555555555"", 56);
  SIMPLE_COPY(strcpy, 16, ""6666666666666666"", 57);

  /* Simple test using implicitly coerced `void *' arguments.  */
  const void *src = ""frobozz"";
  void *dst = one;
  check (strcpy (dst, src) == dst, 1);
  equal (dst, ""frobozz"", 2);
}

static void
test_stpcpy (void)
{
  it = ""stpcpy"";
  check ((stpcpy (one, ""a"") - one) == 1, 1);
  equal (one, ""a"", 2);

  check ((stpcpy (one, ""ab"") - one) == 2, 3);
  equal (one, ""ab"", 4);

  check ((stpcpy (one, ""abc"") - one) == 3, 5);
  equal (one, ""abc"", 6);

  check ((stpcpy (one, ""abcd"") - one) == 4, 7);
  equal (one, ""abcd"", 8);

  check ((stpcpy (one, ""abcde"") - one) == 5, 9);
  equal (one, ""abcde"", 10);

  check ((stpcpy (one, ""abcdef"") - one) == 6, 11);
  equal (one, ""abcdef"", 12);

  check ((stpcpy (one, ""abcdefg"") - one) == 7, 13);
  equal (one, ""abcdefg"", 14);

  check ((stpcpy (one, ""abcdefgh"") - one) == 8, 15);
  equal (one, ""abcdefgh"", 16);

  check ((stpcpy (one, ""abcdefghi"") - one) == 9, 17);
  equal (one, ""abcdefghi"", 18);

  check ((stpcpy (one, ""x"") - one) == 1, 19);
  equal (one, ""x"", 20);			/* Writeover. */
  equal (one+2, ""cdefghi"", 21);		/* Wrote too much? */

  check ((stpcpy (one, ""xx"") - one) == 2, 22);
  equal (one, ""xx"", 23);		/* Writeover. */
  equal (one+3, ""defghi"", 24);		/* Wrote too much? */

  check ((stpcpy (one, ""xxx"") - one) == 3, 25);
  equal (one, ""xxx"", 26);		/* Writeover. */
  equal (one+4, ""efghi"", 27);		/* Wrote too much? */

  check ((stpcpy (one, ""xxxx"") - one) == 4, 28);
  equal (one, ""xxxx"", 29);		/* Writeover. */
  equal (one+5, ""fghi"", 30);		/* Wrote too much? */

  check ((stpcpy (one, ""xxxxx"") - one) == 5, 31);
  equal (one, ""xxxxx"", 32);		/* Writeover. */
  equal (one+6, ""ghi"", 33);		/* Wrote too much? */

  check ((stpcpy (one, ""xxxxxx"") - one) == 6, 34);
  equal (one, ""xxxxxx"", 35);		/* Writeover. */
  equal (one+7, ""hi"", 36);		/* Wrote too much? */

  check ((stpcpy (one, ""xxxxxxx"") - one) == 7, 37);
  equal (one, ""xxxxxxx"", 38);		/* Writeover. */
  equal (one+8, ""i"", 39);		/* Wrote too much? */

  check ((stpcpy (stpcpy (stpcpy (one, ""a""), ""b""), ""c"") - one) == 3, 40);
  equal (one, ""abc"", 41);
  equal (one + 4, ""xxx"", 42);

  SIMPLE_COPY(stpcpy, 0, """", 43);
  SIMPLE_COPY(stpcpy, 1, ""1"", 44);
  SIMPLE_COPY(stpcpy, 2, ""22"", 45);
  SIMPLE_COPY(stpcpy, 3, ""333"", 46);
  SIMPLE_COPY(stpcpy, 4, ""4444"", 47);
  SIMPLE_COPY(stpcpy, 5, ""55555"", 48);
  SIMPLE_COPY(stpcpy, 6, ""666666"", 49);
  SIMPLE_COPY(stpcpy, 7, ""7777777"", 50);
  SIMPLE_COPY(stpcpy, 8, ""88888888"", 51);
  SIMPLE_COPY(stpcpy, 9, ""999999999"", 52);
  SIMPLE_COPY(stpcpy, 10, ""0000000000"", 53);
  SIMPLE_COPY(stpcpy, 11, ""11111111111"", 54);
  SIMPLE_COPY(stpcpy, 12, ""222222222222"", 55);
  SIMPLE_COPY(stpcpy, 13, ""3333333333333"", 56);
  SIMPLE_COPY(stpcpy, 14, ""44444444444444"", 57);
  SIMPLE_COPY(stpcpy, 15, ""555555555555555"", 58);
  SIMPLE_COPY(stpcpy, 16, ""6666666666666666"", 59);
}

static void
test_stpncpy (void)
{
  it = ""stpncpy"";
  memset (one, 'x', sizeof (one));
  check (stpncpy (one, ""abc"", 2) == one + 2, 1);
  check (stpncpy (one, ""abc"", 3) == one + 3, 2);
  check (stpncpy (one, ""abc"", 4) == one + 3, 3);
  check (one[3] == '\0' && one[4] == 'x', 4);
  check (stpncpy (one, ""abcd"", 5) == one + 4, 5);
  check (one[4] == '\0' && one[5] == 'x', 6);
  check (stpncpy (one, ""abcd"", 6) == one + 4, 7);
  check (one[4] == '\0' && one[5] == '\0' && one[6] == 'x', 8);
}

static void
test_strcat (void)
{
  it = ""strcat"";
  (void) strcpy (one, ""ijk"");
  check (strcat (one, ""lmn"") == one, 1); /* Returned value. */
  equal (one, ""ijklmn"", 2);		/* Basic test. */

  (void) strcpy (one, ""x"");
  (void) strcat (one, ""yz"");
  equal (one, ""xyz"", 3);			/* Writeover. */
  equal (one+4, ""mn"", 4);			/* Wrote too much? */

  (void) strcpy (one, ""gh"");
  (void) strcpy (two, ""ef"");
  (void) strcat (one, two);
  equal (one, ""ghef"", 5);			/* Basic test encore. */
  equal (two, ""ef"", 6);			/* Stomped on source? */

  (void) strcpy (one, """");
  (void) strcat (one, """");
  equal (one, """", 7);			/* Boundary conditions. */
  (void) strcpy (one, ""ab"");
  (void) strcat (one, """");
  equal (one, ""ab"", 8);
  (void) strcpy (one, """");
  (void) strcat (one, ""cd"");
  equal (one, ""cd"", 9);
}

static void
test_strncat (void)
{
  /* First test it as strcat, with big counts, then test the count
     mechanism.  */
  it = ""strncat"";
  (void) strcpy (one, ""ijk"");
  check (strncat (one, ""lmn"", 99) == one, 1);	/* Returned value. */
  equal (one, ""ijklmn"", 2);		/* Basic test. */

  (void) strcpy (one, ""x"");
  (void) strncat (one, ""yz"", 99);
  equal (one, ""xyz"", 3);		/* Writeover. */
  equal (one+4, ""mn"", 4);		/* Wrote too much? */

  (void) strcpy (one, ""gh"");
  (void) strcpy (two, ""ef"");
  (void) strncat (one, two, 99);
  equal (one, ""ghef"", 5);			/* Basic test encore. */
  equal (two, ""ef"", 6);			/* Stomped on source? */

  (void) strcpy (one, """");
  (void) strncat (one, """", 99);
  equal (one, """", 7);			/* Boundary conditions. */
  (void) strcpy (one, ""ab"");
  (void) strncat (one, """", 99);
  equal (one, ""ab"", 8);
  (void) strcpy (one, """");
  (void) strncat (one, ""cd"", 99);
  equal (one, ""cd"", 9);

  (void) strcpy (one, ""ab"");
  (void) strncat (one, ""cdef"", 2);
  equal (one, ""abcd"", 10);			/* Count-limited. */

  (void) strncat (one, ""gh"", 0);
  equal (one, ""abcd"", 11);			/* Zero count. */

  (void) strncat (one, ""gh"", 2);
  equal (one, ""abcdgh"", 12);		/* Count and length equal. */

  (void) strncat (one, ""ij"", (size_t)-1);	/* set sign bit in count */
  equal (one, ""abcdghij"", 13);
}

static void
test_strlcat (void)
{
#ifdef __TEST_BSD_FUNCS__
  /* First test it as strcat, with big counts, then test the count
     mechanism.  */
  it = ""strlcat"";
  (void) strcpy (one, ""ijk"");
  check (strlcat (one, ""lmn"", 99) == 6, 1);	/* Returned value. */
  equal (one, ""ijklmn"", 2);		/* Basic test. */

  (void) strcpy (one, ""x"");
  (void) strlcat (one, ""yz"", 99);
  equal (one, ""xyz"", 3);		/* Writeover. */
  equal (one+4, ""mn"", 4);		/* Wrote too much? */

  (void) strcpy (one, ""gh"");
  (void) strcpy (two, ""ef"");
  (void) strlcat (one, two, 99);
  equal (one, ""ghef"", 5);			/* Basic test encore. */
  equal (two, ""ef"", 6);			/* Stomped on source? */

  (void) strcpy (one, """");
  (void) strlcat (one, """", 99);
  equal (one, """", 7);			/* Boundary conditions. */
  (void) strcpy (one, ""ab"");
  (void) strlcat (one, """", 99);
  equal (one, ""ab"", 8);
  (void) strcpy (one, """");
  (void) strlcat (one, ""cd"", 99);
  equal (one, ""cd"", 9);

  (void) strcpy (one, ""ab"");
  (void) strlcat (one, ""cdef"", 2);
  equal (one, ""ab"", 10);			/* Count-limited. */

  (void) strlcat (one, ""gh"", 0);
  equal (one, ""ab"", 11);			/* Zero count. */

  (void) strlcat (one, ""gh"", 4);
  equal (one, ""abg"", 12);		/* Count and length equal. */

  (void) strlcat (one, ""ij"", (size_t)-1);	/* set sign bit in count */
  equal (one, ""abgij"", 13);
#endif
}

static void
test_strncmp (void)
{
  /* First test as strcmp with big counts, then test count code.  */
  it = ""strncmp"";
  check (strncmp ("""", """", 99) == 0, 1);	/* Trivial case. */
  check (strncmp (""a"", ""a"", 99) == 0, 2);	/* Identity. */
  check (strncmp (""abc"", ""abc"", 99) == 0, 3);	/* Multicharacter. */
  check (strncmp (""abc"", ""abcd"", 99) < 0, 4);	/* Length unequal. */
  check (strncmp (""abcd"", ""abc"", 99) > 0, 5);
  check (strncmp (""abcd"", ""abce"", 99) < 0, 6);	/* Honestly unequal. */
  check (strncmp (""abce"", ""abcd"", 99) > 0, 7);
  check (strncmp (""a\203"", ""a"", 2) > 0, 8);	/* Tricky if '\203' < 0 */
  check (strncmp (""a\203"", ""a\003"", 2) > 0, 9);
  check (strncmp (""abce"", ""abcd"", 3) == 0, 10);	/* Count limited. */
  check (strncmp (""abce"", ""abc"", 3) == 0, 11);	/* Count == length. */
  check (strncmp (""abcd"", ""abce"", 4) < 0, 12);	/* Nudging limit. */
  check (strncmp (""abc"", ""def"", 0) == 0, 13);	/* Zero count. */
  check (strncmp (""abc"", """", (size_t)-1) > 0, 14);	/* set sign bit in count */
  check (strncmp (""abc"", ""abc"", (size_t)-2) == 0, 15);
}

static void
test_strncpy (void)
{
  /* Testing is a bit different because of odd semantics.  */
  it = ""strncpy"";
  check (strncpy (one, ""abc"", 4) == one, 1);	/* Returned value. */
  equal (one, ""abc"", 2);			/* Did the copy go right? */

  (void) strcpy (one, ""abcdefgh"");
  (void) strncpy (one, ""xyz"", 2);
  equal (one, ""xycdefgh"", 3);			/* Copy cut by count. */

  (void) strcpy (one, ""abcdefgh"");
  (void) strncpy (one, ""xyz"", 3);		/* Copy cut just before NUL. */
  equal (one, ""xyzdefgh"", 4);

  (void) strcpy (one, ""abcdefgh"");
  (void) strncpy (one, ""xyz"", 4);		/* Copy just includes NUL. */
  equal (one, ""xyz"", 5);
  equal (one+4, ""efgh"", 6);			/* Wrote too much? */

  (void) strcpy (one, ""abcdefgh"");
  (void) strncpy (one, ""xyz"", 5);		/* Copy includes padding. */
  equal (one, ""xyz"", 7);
  equal (one+4, """", 8);
  equal (one+5, ""fgh"", 9);

  (void) strcpy (one, ""abc"");
  (void) strncpy (one, ""xyz"", 0);		/* Zero-length copy. */
  equal (one, ""abc"", 10);

  (void) strncpy (one, """", 2);		/* Zero-length source. */
  equal (one, """", 11);
  equal (one+1, """", 12);
  equal (one+2, ""c"", 13);

  (void) strcpy (one, ""hi there"");
  (void) strncpy (two, one, 9);
  equal (two, ""hi there"", 14);		/* Just paranoia. */
  equal (one, ""hi there"", 15);		/* Stomped on source? */
}

static void
test_strlcpy (void)
{
#ifdef __TEST_BSD_FUNCS__
  /* Testing is a bit different because of odd semantics.  */
  it = ""strlcpy"";
  check (strlcpy (one, ""abc"", sizeof(one)) == 3, 1);	/* Returned value. */
  equal (one, ""abc"", 2);			/* Did the copy go right? */

  (void) strcpy (one, ""abcdefgh"");
  (void) strlcpy (one, ""xyz"", 2);
  equal (one, ""x\0cdefgh"", 3);			/* Copy cut by count. */

  (void) strcpy (one, ""abcdefgh"");
  (void) strlcpy (one, ""xyz"", 3);		/* Copy cut just before NUL. */
  equal (one, ""xy\0defgh"", 4);

  (void) strcpy (one, ""abcdefgh"");
  (void) strlcpy (one, ""xyz"", 4);		/* Copy just includes NUL. */
  equal (one, ""xyz"", 5);
  equal (one+4, ""efgh"", 6);			/* Wrote too much? */

  (void) strcpy (one, ""abcdefgh"");
  (void) strlcpy (one, ""xyz"", 5);		/* Copy includes padding. */
  equal (one, ""xyz"", 7);
  equal (one+3, """", 8);
  equal (one+4, ""efgh"", 9);

  (void) strcpy (one, ""abc"");
  (void) strlcpy (one, ""xyz"", 0);		/* Zero-length copy. */
  equal (one, ""abc"", 10);

  (void) strlcpy (one, """", 2);		/* Zero-length source. */
  equal (one, """", 11);
  equal (one+1, ""bc"", 12);
  equal (one+2, ""c"", 13);

  (void) strcpy (one, ""hi there"");
  (void) strlcpy (two, one, 9);
  equal (two, ""hi there"", 14);		/* Just paranoia. */
  equal (one, ""hi there"", 15);		/* Stomped on source? */
#endif
}

static void
test_strlen (void)
{
  it = ""strlen"";
  check (strlen ("""") == 0, 1);		/* Empty. */
  check (strlen (""a"") == 1, 2);		/* Single char. */
  check (strlen (""abcd"") == 4, 3);	/* Multiple chars. */
  {
    char buf[4096];
    int i;
    char *p;
    for (i=0; i < 0x100; i++)
      {
	p = (char *) ((unsigned long int)(buf + 0xff) & ~0xff) + i;
	strcpy (p, ""OK"");
	strcpy (p+3, ""BAD/WRONG"");
	check (strlen (p) == 2, 4+i);
      }
   }
}

static void
test_strnlen (void)
{
  it = ""strnlen"";
  check (strnlen ("""", 10) == 0, 1);		/* Empty. */
  check (strnlen (""a"", 10) == 1, 2);		/* Single char. */
  check (strnlen (""abcd"", 10) == 4, 3);		/* Multiple chars. */
  check (strnlen (""foo"", (size_t)-1) == 3, 4);	/* limits of n. */

  {
    char buf[4096];
    int i;
    char *p;
    for (i=0; i < 0x100; i++)
      {
	p = (char *) ((unsigned long int)(buf + 0xff) & ~0xff) + i;
	strcpy (p, ""OK"");
	strcpy (p+3, ""BAD/WRONG"");
	check (strnlen (p, 100) == 2, 5+i);
      }
   }
}

static void
test_strchr (void)
{
  it = ""strchr"";
  check (strchr (""abcd"", 'z') == NULL, 1);	/* Not found. */
  (void) strcpy (one, ""abcd"");
  check (strchr (one, 'c') == one+2, 2);	/* Basic test. */
  check (strchr (one, 'd') == one+3, 3);	/* End of string. */
  check (strchr (one, 'a') == one, 4);		/* Beginning. */
  check (strchr (one, '\0') == one+4, 5);	/* Finding NUL. */
  (void) strcpy (one, ""ababa"");
  check (strchr (one, 'b') == one+1, 6);	/* Finding first. */
  (void) strcpy (one, """");
  check (strchr (one, 'b') == NULL, 7);		/* Empty string. */
  check (strchr (one, '\0') == one, 8);		/* NUL in empty string. */
  {
    char buf[4096];
    int i;
    char *p;
    for (i=0; i < 0x100; i++)
      {
	p = (char *) ((unsigned long int) (buf + 0xff) & ~0xff) + i;
	strcpy (p, ""OK"");
	strcpy (p+3, ""BAD/WRONG"");
	check (strchr (p, '/') == NULL, 9+i);
      }
   }
}

static void
test_strchrnul (void)
{
  const char *os;
  it = ""strchrnul"";
  cp = strchrnul ((os = ""abcd""), 'z');
  check (*cp == '\0', 1);			/* Not found. */
  check (cp == os + 4, 2);
  (void) strcpy (one, ""abcd"");
  check (strchrnul (one, 'c') == one+2, 3);	/* Basic test. */
  check (strchrnul (one, 'd') == one+3, 4);	/* End of string. */
  check (strchrnul (one, 'a') == one, 5);	/* Beginning. */
  check (strchrnul (one, '\0') == one+4, 6);	/* Finding NUL. */
  (void) strcpy (one, ""ababa"");
  check (strchrnul (one, 'b') == one+1, 7);	/* Finding first. */
  (void) strcpy (one, """");
  check (strchrnul (one, 'b') == one, 8);	/* Empty string. */
  check (strchrnul (one, '\0') == one, 9);	/* NUL in empty string. */
  {
    char buf[4096];
    int i;
    char *p;
    for (i=0; i < 0x100; i++)
      {
	p = (char *) ((unsigned long int) (buf + 0xff) & ~0xff) + i;
	strcpy (p, ""OK"");
	strcpy (p+3, ""BAD/WRONG"");
	cp = strchrnul (p, '/');
	check (*cp == '\0', 9+2*i);
	check (cp == p+2, 10+2*i);
      }
   }
}

static void
test_rawmemchr (void)
{
  it = ""rawmemchr"";
  (void) strcpy (one, ""abcd"");
  check (rawmemchr (one, 'c') == one+2, 1);	/* Basic test. */
  check (rawmemchr (one, 'd') == one+3, 2);	/* End of string. */
  check (rawmemchr (one, 'a') == one, 3);		/* Beginning. */
  check (rawmemchr (one, '\0') == one+4, 4);	/* Finding NUL. */
  (void) strcpy (one, ""ababa"");
  check (rawmemchr (one, 'b') == one+1, 5);	/* Finding first. */
  (void) strcpy (one, """");
  check (rawmemchr (one, '\0') == one, 6);	/* NUL in empty string. */
  {
    char buf[4096];
    int i;
    char *p;
    for (i=0; i < 0x100; i++)
      {
	p = (char *) ((unsigned long int) (buf + 0xff) & ~0xff) + i;
	strcpy (p, ""OK"");
	strcpy (p+3, ""BAD/WRONG"");
	check (rawmemchr (p, 'R') == p+8, 6+i);
      }
   }
}

static void
test_index (void)
{
#ifdef __TEST_SUSV3_LEGACY__
  it = ""index"";
  check (index (""abcd"", 'z') == NULL, 1);	/* Not found. */
  (void) strcpy (one, ""abcd"");
  check (index (one, 'c') == one+2, 2);	/* Basic test. */
  check (index (one, 'd') == one+3, 3);	/* End of string. */
  check (index (one, 'a') == one, 4);	/* Beginning. */
  check (index (one, '\0') == one+4, 5);	/* Finding NUL. */
  (void) strcpy (one, ""ababa"");
  check (index (one, 'b') == one+1, 6);	/* Finding first. */
  (void) strcpy (one, """");
  check (index (one, 'b') == NULL, 7);	/* Empty string. */
  check (index (one, '\0') == one, 8);	/* NUL in empty string. */
#endif
}

static void
test_strrchr (void)
{
  it = ""strrchr"";
  check (strrchr (""abcd"", 'z') == NULL, 1);	/* Not found. */
  (void) strcpy (one, ""abcd"");
  check (strrchr (one, 'c') == one+2, 2);	/* Basic test. */
  check (strrchr (one, 'd') == one+3, 3);	/* End of string. */
  check (strrchr (one, 'a') == one, 4);		/* Beginning. */
  check (strrchr (one, '\0') == one+4, 5);	/* Finding NUL. */
  (void) strcpy (one, ""ababa"");
  check (strrchr (one, 'b') == one+3, 6);	/* Finding last. */
  (void) strcpy (one, """");
  check (strrchr (one, 'b') == NULL, 7);	/* Empty string. */
  check (strrchr (one, '\0') == one, 8);	/* NUL in empty string. */
  {
    char buf[4096];
    int i;
    char *p;
    for (i=0; i < 0x100; i++)
      {
	p = (char *) ((unsigned long int) (buf + 0xff) & ~0xff) + i;
	strcpy (p, ""OK"");
	strcpy (p+3, ""BAD/WRONG"");
	check (strrchr (p, '/') == NULL, 9+i);
      }
   }
}

static void
test_memrchr (void)
{
  size_t l;
  it = ""memrchr"";
  check (memrchr (""abcd"", 'z', 5) == NULL, 1);	/* Not found. */
  (void) strcpy (one, ""abcd"");
  l = strlen (one) + 1;
  check (memrchr (one, 'c', l) == one+2, 2);	/* Basic test. */
  check (memrchr (one, 'd', l) == one+3, 3);	/* End of string. */
  check (memrchr (one, 'a', l) == one, 4);		/* Beginning. */
  check (memrchr (one, '\0', l) == one+4, 5);	/* Finding NUL. */
  (void) strcpy (one, ""ababa"");
  l = strlen (one) + 1;
  check (memrchr (one, 'b', l) == one+3, 6);	/* Finding last. */
  (void) strcpy (one, """");
  l = strlen (one) + 1;
  check (memrchr (one, 'b', l) == NULL, 7);	/* Empty string. */
  check (memrchr (one, '\0', l) == one, 8);	/* NUL in empty string. */

  /* now test all possible alignment and length combinations to catch
     bugs due to unrolled loops (assuming unrolling is limited to no
     more than 128 byte chunks: */
  {
    char buf[128 + sizeof(long)];
    long align, len, i, pos;

    for (align = 0; align < (long) sizeof(long); ++align) {
      for (len = 0; len < (long) (sizeof(buf) - align); ++len) {
	for (i = 0; i < len; ++i)
	  buf[align + i] = 'x';		/* don't depend on memset... */

	for (pos = len - 1; pos >= 0; --pos) {
#if 0
	  printf(""align %d, len %d, pos %d\n"", align, len, pos);
#endif
	  check(memrchr(buf + align, 'x', len) == buf + align + pos, 9);
	  check(memrchr(buf + align + pos + 1, 'x', len - (pos + 1)) == NULL,
		10);
	  buf[align + pos] = '-';
	}
      }
    }
  }
}

static void
test_rindex (void)
{
#ifdef __TEST_SUSV3_LEGACY__
  it = ""rindex"";
  check (rindex (""abcd"", 'z') == NULL, 1);	/* Not found. */
  (void) strcpy (one, ""abcd"");
  check (rindex (one, 'c') == one+2, 2);	/* Basic test. */
  check (rindex (one, 'd') == one+3, 3);	/* End of string. */
  check (rindex (one, 'a') == one, 4);	/* Beginning. */
  check (rindex (one, '\0') == one+4, 5);	/* Finding NUL. */
  (void) strcpy (one, ""ababa"");
  check (rindex (one, 'b') == one+3, 6);	/* Finding last. */
  (void) strcpy (one, """");
  check (rindex (one, 'b') == NULL, 7);	/* Empty string. */
  check (rindex (one, '\0') == one, 8);	/* NUL in empty string. */
#endif
}

static void
test_strpbrk (void)
{
  it = ""strpbrk"";
  check(strpbrk(""abcd"", ""z"") == NULL, 1);	/* Not found. */
  (void) strcpy(one, ""abcd"");
  check(strpbrk(one, ""c"") == one+2, 2);	/* Basic test. */
  check(strpbrk(one, ""d"") == one+3, 3);	/* End of string. */
  check(strpbrk(one, ""a"") == one, 4);	/* Beginning. */
  check(strpbrk(one, """") == NULL, 5);	/* Empty search list. */
  check(strpbrk(one, ""cb"") == one+1, 6);	/* Multiple search. */
  (void) strcpy(one, ""abcabdea"");
  check(strpbrk(one, ""b"") == one+1, 7);	/* Finding first. */
  check(strpbrk(one, ""cb"") == one+1, 8);	/* With multiple search. */
  check(strpbrk(one, ""db"") == one+1, 9);	/* Another variant. */
  (void) strcpy(one, """");
  check(strpbrk(one, ""bc"") == NULL, 10);	/* Empty string. */
  (void) strcpy(one, """");
  check(strpbrk(one, ""bcd"") == NULL, 11);	/* Empty string. */
  (void) strcpy(one, """");
  check(strpbrk(one, ""bcde"") == NULL, 12);	/* Empty string. */
  check(strpbrk(one, """") == NULL, 13);	/* Both strings empty. */
  (void) strcpy(one, ""abcabdea"");
  check(strpbrk(one, ""befg"") == one+1, 14);	/* Finding first. */
  check(strpbrk(one, ""cbr"") == one+1, 15);	/* With multiple search. */
  check(strpbrk(one, ""db"") == one+1, 16);	/* Another variant. */
  check(strpbrk(one, ""efgh"") == one+6, 17);	/* And yet another. */
}

static void
test_strstr (void)
{
  it = ""strstr"";
  check(strstr(""abcd"", ""z"") == NULL, 1);	/* Not found. */
  check(strstr(""abcd"", ""abx"") == NULL, 2);	/* Dead end. */
  (void) strcpy(one, ""abcd"");
  check(strstr(one, ""c"") == one+2, 3);	/* Basic test. */
  check(strstr(one, ""bc"") == one+1, 4);	/* Multichar. */
  check(strstr(one, ""d"") == one+3, 5);	/* End of string. */
  check(strstr(one, ""cd"") == one+2, 6);	/* Tail of string. */
  check(strstr(one, ""abc"") == one, 7);	/* Beginning. */
  check(strstr(one, ""abcd"") == one, 8);	/* Exact match. */
  check(strstr(one, ""abcde"") == NULL, 9);	/* Too long. */
  check(strstr(one, ""de"") == NULL, 10);	/* Past end. */
  check(strstr(one, """") == one, 11);	/* Finding empty. */
  (void) strcpy(one, ""ababa"");
  check(strstr(one, ""ba"") == one+1, 12);	/* Finding first. */
  (void) strcpy(one, """");
  check(strstr(one, ""b"") == NULL, 13);	/* Empty string. */
  check(strstr(one, """") == one, 14);	/* Empty in empty string. */
  (void) strcpy(one, ""bcbca"");
  check(strstr(one, ""bca"") == one+2, 15);	/* False start. */
  (void) strcpy(one, ""bbbcabbca"");
  check(strstr(one, ""bbca"") == one+1, 16);	/* With overlap. */
}

static void
test_strspn (void)
{
  it = ""strspn"";
  check(strspn(""abcba"", ""abc"") == 5, 1);	/* Whole string. */
  check(strspn(""abcba"", ""ab"") == 2, 2);	/* Partial. */
  check(strspn(""abc"", ""qx"") == 0, 3);	/* None. */
  check(strspn("""", ""ab"") == 0, 4);	/* Null string. */
  check(strspn(""abc"", """") == 0, 5);	/* Null search list. */
}

static void
test_strcspn (void)
{
  it = ""strcspn"";
  check(strcspn(""abcba"", ""qx"") == 5, 1);	/* Whole string. */
  check(strcspn(""abcba"", ""cx"") == 2, 2);	/* Partial. */
  check(strcspn(""abc"", ""abc"") == 0, 3);	/* None. */
  check(strcspn("""", ""ab"") == 0, 4);	/* Null string. */
  check(strcspn(""abc"", """") == 3, 5);	/* Null search list. */
}

static void
test_strtok (void)
{
  it = ""strtok"";
  (void) strcpy(one, ""first, second, third"");
  equal(strtok(one, "", ""), ""first"", 1);	/* Basic test. */
  equal(one, ""first"", 2);
  equal(strtok((char *)NULL, "", ""), ""second"", 3);
  equal(strtok((char *)NULL, "", ""), ""third"", 4);
  check(strtok((char *)NULL, "", "") == NULL, 5);
  (void) strcpy(one, "", first, "");
  equal(strtok(one, "", ""), ""first"", 6);	/* Extra delims, 1 tok. */
  check(strtok((char *)NULL, "", "") == NULL, 7);
  (void) strcpy(one, ""1a, 1b; 2a, 2b"");
  equal(strtok(one, "", ""), ""1a"", 8);	/* Changing delim lists. */
  equal(strtok((char *)NULL, ""; ""), ""1b"", 9);
  equal(strtok((char *)NULL, "", ""), ""2a"", 10);
  (void) strcpy(two, ""x-y"");
  equal(strtok(two, ""-""), ""x"", 11);	/* New string before done. */
  equal(strtok((char *)NULL, ""-""), ""y"", 12);
  check(strtok((char *)NULL, ""-"") == NULL, 13);
  (void) strcpy(one, ""a,b, c,, ,d"");
  equal(strtok(one, "", ""), ""a"", 14);	/* Different separators. */
  equal(strtok((char *)NULL, "", ""), ""b"", 15);
  equal(strtok((char *)NULL, "" ,""), ""c"", 16);	/* Permute list too. */
  equal(strtok((char *)NULL, "" ,""), ""d"", 17);
  check(strtok((char *)NULL, "", "") == NULL, 18);
  check(strtok((char *)NULL, "", "") == NULL, 19);	/* Persistence. */
  (void) strcpy(one, "", "");
  check(strtok(one, "", "") == NULL, 20);	/* No tokens. */
  (void) strcpy(one, """");
  check(strtok(one, "", "") == NULL, 21);	/* Empty string. */
  (void) strcpy(one, ""abc"");
  equal(strtok(one, "", ""), ""abc"", 22);	/* No delimiters. */
  check(strtok((char *)NULL, "", "") == NULL, 23);
  (void) strcpy(one, ""abc"");
  equal(strtok(one, """"), ""abc"", 24);	/* Empty delimiter list. */
  check(strtok((char *)NULL, """") == NULL, 25);
  (void) strcpy(one, ""abcdefgh"");
  (void) strcpy(one, ""a,b,c"");
  equal(strtok(one, "",""), ""a"", 26);	/* Basics again... */
  equal(strtok((char *)NULL, "",""), ""b"", 27);
  equal(strtok((char *)NULL, "",""), ""c"", 28);
  check(strtok((char *)NULL, "","") == NULL, 29);
  equal(one+6, ""gh"", 30);			/* Stomped past end? */
  equal(one, ""a"", 31);			/* Stomped old tokens? */
  equal(one+2, ""b"", 32);
  equal(one+4, ""c"", 33);
}

static void
test_strtok_r (void)
{
  it = ""strtok_r"";
  (void) strcpy(one, ""first, second, third"");
  cp = NULL;	/* Always initialize cp to make sure it doesn't point to some old data.  */
  equal(strtok_r(one, "", "", &cp), ""first"", 1);	/* Basic test. */
  equal(one, ""first"", 2);
  equal(strtok_r((char *)NULL, "", "", &cp), ""second"", 3);
  equal(strtok_r((char *)NULL, "", "", &cp), ""third"", 4);
  check(strtok_r((char *)NULL, "", "", &cp) == NULL, 5);
  (void) strcpy(one, "", first, "");
  cp = NULL;
  equal(strtok_r(one, "", "", &cp), ""first"", 6);	/* Extra delims, 1 tok. */
  check(strtok_r((char *)NULL, "", "", &cp) == NULL, 7);
  (void) strcpy(one, ""1a, 1b; 2a, 2b"");
  cp = NULL;
  equal(strtok_r(one, "", "", &cp), ""1a"", 8);	/* Changing delim lists. */
  equal(strtok_r((char *)NULL, ""; "", &cp), ""1b"", 9);
  equal(strtok_r((char *)NULL, "", "", &cp), ""2a"", 10);
  (void) strcpy(two, ""x-y"");
  cp = NULL;
  equal(strtok_r(two, ""-"", &cp), ""x"", 11);	/* New string before done. */
  equal(strtok_r((char *)NULL, ""-"", &cp), ""y"", 12);
  check(strtok_r((char *)NULL, ""-"", &cp) == NULL, 13);
  (void) strcpy(one, ""a,b, c,, ,d"");
  cp = NULL;
  equal(strtok_r(one, "", "", &cp), ""a"", 14);	/* Different separators. */
  equal(strtok_r((char *)NULL, "", "", &cp), ""b"", 15);
  equal(strtok_r((char *)NULL, "" ,"", &cp), ""c"", 16);	/* Permute list too. */
  equal(strtok_r((char *)NULL, "" ,"", &cp), ""d"", 17);
  check(strtok_r((char *)NULL, "", "", &cp) == NULL, 18);
  check(strtok_r((char *)NULL, "", "", &cp) == NULL, 19);	/* Persistence. */
  (void) strcpy(one, "", "");
  cp = NULL;
  check(strtok_r(one, "", "", &cp) == NULL, 20);	/* No tokens. */
  (void) strcpy(one, """");
  cp = NULL;
  check(strtok_r(one, "", "", &cp) == NULL, 21);	/* Empty string. */
  check(strtok_r((char *)NULL, "", "", &cp) == NULL, 22);	/* Persistence. */
  (void) strcpy(one, ""abc"");
  cp = NULL;
  equal(strtok_r(one, "", "", &cp), ""abc"", 23);	/* No delimiters. */
  check(strtok_r((char *)NULL, "", "", &cp) == NULL, 24);
  (void) strcpy(one, ""abc"");
  cp = NULL;
  equal(strtok_r(one, """", &cp), ""abc"", 25);	/* Empty delimiter list. */
  check(strtok_r((char *)NULL, """", &cp) == NULL, 26);
  (void) strcpy(one, ""abcdefgh"");
  (void) strcpy(one, ""a,b,c"");
  cp = NULL;
  equal(strtok_r(one, "","", &cp), ""a"", 27);	/* Basics again... */
  equal(strtok_r((char *)NULL, "","", &cp), ""b"", 28);
  equal(strtok_r((char *)NULL, "","", &cp), ""c"", 29);
  check(strtok_r((char *)NULL, "","", &cp) == NULL, 30);
  equal(one+6, ""gh"", 31);			/* Stomped past end? */
  equal(one, ""a"", 32);			/* Stomped old tokens? */
  equal(one+2, ""b"", 33);
  equal(one+4, ""c"", 34);
}

static void
test_strsep (void)
{
  char *ptr;
  it = ""strsep"";
  cp = strcpy(one, ""first, second, third"");
  equal(strsep(&cp, "", ""), ""first"", 1);	/* Basic test. */
  equal(one, ""first"", 2);
  equal(strsep(&cp, "", ""), """", 3);
  equal(strsep(&cp, "", ""), ""second"", 4);
  equal(strsep(&cp, "", ""), """", 5);
  equal(strsep(&cp, "", ""), ""third"", 6);
  check(strsep(&cp, "", "") == NULL, 7);
  cp = strcpy(one, "", first, "");
  equal(strsep(&cp, "", ""), """", 8);
  equal(strsep(&cp, "", ""), """", 9);
  equal(strsep(&cp, "", ""), ""first"", 10);	/* Extra delims, 1 tok. */
  equal(strsep(&cp, "", ""), """", 11);
  equal(strsep(&cp, "", ""), """", 12);
  check(strsep(&cp, "", "") == NULL, 13);
  cp = strcpy(one, ""1a, 1b; 2a, 2b"");
  equal(strsep(&cp, "", ""), ""1a"", 14);	/* Changing delim lists. */
  equal(strsep(&cp, "", ""), """", 15);
  equal(strsep(&cp, ""; ""), ""1b"", 16);
  equal(strsep(&cp, "", ""), """", 17);
  equal(strsep(&cp, "", ""), ""2a"", 18);
  cp = strcpy(two, ""x-y"");
  equal(strsep(&cp, ""-""), ""x"", 19);	/* New string before done. */
  equal(strsep(&cp, ""-""), ""y"", 20);
  check(strsep(&cp, ""-"") == NULL, 21);
  cp = strcpy(one, ""a,b, c,, ,d "");
  equal(strsep(&cp, "", ""), ""a"", 22);	/* Different separators. */
  equal(strsep(&cp, "", ""), ""b"", 23);
  equal(strsep(&cp, "" ,""), """", 24);
  equal(strsep(&cp, "" ,""), ""c"", 25);	/* Permute list too. */
  equal(strsep(&cp, "" ,""), """", 26);
  equal(strsep(&cp, "" ,""), """", 27);
  equal(strsep(&cp, "" ,""), """", 28);
  equal(strsep(&cp, "" ,""), ""d"", 29);
  equal(strsep(&cp, "" ,""), """", 30);
  check(strsep(&cp, "", "") == NULL, 31);
  check(strsep(&cp, "", "") == NULL, 32);	/* Persistence. */
  cp = strcpy(one, "", "");
  equal(strsep(&cp, "", ""), """", 33);
  equal(strsep(&cp, "", ""), """", 34);
  equal(strsep(&cp, "", ""), """", 35);
  check(strsep(&cp, "", "") == NULL, 36);	/* No tokens. */
  cp = strcpy(one, """");
  equal(strsep(&cp, "", ""), """", 37);
  check(strsep(&cp, "", "") == NULL, 38);	/* Empty string. */
  cp = strcpy(one, ""abc"");
  equal(strsep(&cp, "", ""), ""abc"", 39);	/* No delimiters. */
  check(strsep(&cp, "", "") == NULL, 40);
  cp = strcpy(one, ""abc"");
  equal(strsep(&cp, """"), ""abc"", 41);	/* Empty delimiter list. */
  check(strsep(&cp, """") == NULL, 42);
  (void) strcpy(one, ""abcdefgh"");
  cp = strcpy(one, ""a,b,c"");
  equal(strsep(&cp, "",""), ""a"", 43);	/* Basics again... */
  equal(strsep(&cp, "",""), ""b"", 44);
  equal(strsep(&cp, "",""), ""c"", 45);
  check(strsep(&cp, "","") == NULL, 46);
  equal(one+6, ""gh"", 47);		/* Stomped past end? */
  equal(one, ""a"", 48);			/* Stomped old tokens? */
  equal(one+2, ""b"", 49);
  equal(one+4, ""c"", 50);

  {
    char text[] = ""This,is,a,test"";
    char *list = strdupa (text);
    equal (strsep (&list, "",""), ""This"", 51);
    equal (strsep (&list, "",""), ""is"", 52);
    equal (strsep (&list, "",""), ""a"", 53);
    equal (strsep (&list, "",""), ""test"", 54);
    check (strsep (&list, "","") == NULL, 55);
  }

  cp = strcpy(one, ""a,b, c,, ,d,"");
  equal(strsep(&cp, "",""), ""a"", 56);	/* Different separators. */
  equal(strsep(&cp, "",""), ""b"", 57);
  equal(strsep(&cp, "",""), "" c"", 58);	/* Permute list too. */
  equal(strsep(&cp, "",""), """", 59);
  equal(strsep(&cp, "",""), "" "", 60);
  equal(strsep(&cp, "",""), ""d"", 61);
  equal(strsep(&cp, "",""), """", 62);
  check(strsep(&cp, "","") == NULL, 63);
  check(strsep(&cp, "","") == NULL, 64);	/* Persistence. */

  cp = strcpy(one, ""a,b, c,, ,d,"");
  equal(strsep(&cp, ""xy,""), ""a"", 65);	/* Different separators. */
  equal(strsep(&cp, ""x,y""), ""b"", 66);
  equal(strsep(&cp, "",xy""), "" c"", 67);	/* Permute list too. */
  equal(strsep(&cp, ""xy,""), """", 68);
  equal(strsep(&cp, ""x,y""), "" "", 69);
  equal(strsep(&cp, "",xy""), ""d"", 70);
  equal(strsep(&cp, ""xy,""), """", 71);
  check(strsep(&cp, ""x,y"") == NULL, 72);
  check(strsep(&cp, "",xy"") == NULL, 73);	/* Persistence. */

  cp = strcpy(one, ""ABC"");
  one[4] = ':';
  equal(strsep(&cp, ""C""), ""AB"", 74);	/* Access beyond NUL.  */
  ptr = strsep(&cp, "":"");
  equal(ptr, """", 75);
  check(ptr == one + 3, 76);
  check(cp == NULL, 77);

  cp = strcpy(one, ""ABC"");
  one[4] = ':';
  equal(strsep(&cp, ""CD""), ""AB"", 78);	/* Access beyond NUL.  */
  ptr = strsep(&cp, "":."");
  equal(ptr, """", 79);
  check(ptr == one + 3, 80);

  cp = strcpy(one, ""ABC"");		/* No token in string.  */
  equal(strsep(&cp, "",""), ""ABC"", 81);
  check(cp == NULL, 82);

  *one = '\0';				/* Empty string. */
  cp = one;
  ptr = strsep(&cp, "","");
  equal(ptr, """", 83);
  check(ptr == one, 84);
  check(cp == NULL, 85);

  *one = '\0';				/* Empty string and no token. */
  cp = one;
  ptr = strsep(&cp, """");
  equal(ptr, """", 86);
  check(ptr == one , 87);
  check(cp == NULL, 88);
}

static void
test_memcmp (void)
{
  it = ""memcmp"";
  check(memcmp(""a"", ""a"", 1) == 0, 1);		/* Identity. */
  check(memcmp(""abc"", ""abc"", 3) == 0, 2);	/* Multicharacter. */
  check(memcmp(""abcd"", ""abce"", 4) < 0, 3);	/* Honestly unequal. */
  check(memcmp(""abce"", ""abcd"", 4) > 0, 4);
  check(memcmp(""alph"", ""beta"", 4) < 0, 5);
  check(memcmp(""a\203"", ""a\003"", 2) > 0, 6);
  check(memcmp(""abce"", ""abcd"", 3) == 0, 7);	/* Count limited. */
  check(memcmp(""abc"", ""def"", 0) == 0, 8);	/* Zero count. */
}

static void
test_memchr (void)
{
  it = ""memchr"";
  check(memchr(""abcd"", 'z', 4) == NULL, 1);	/* Not found. */
  (void) strcpy(one, ""abcd"");
  check(memchr(one, 'c', 4) == one+2, 2);	/* Basic test. */
  check(memchr(one, ~0xff|'c', 4) == one+2, 2);	/* ignore highorder bits. */
  check(memchr(one, 'd', 4) == one+3, 3);	/* End of string. */
  check(memchr(one, 'a', 4) == one, 4);	/* Beginning. */
  check(memchr(one, '\0', 5) == one+4, 5);	/* Finding NUL. */
  (void) strcpy(one, ""ababa"");
  check(memchr(one, 'b', 5) == one+1, 6);	/* Finding first. */
  check(memchr(one, 'b', 0) == NULL, 7);	/* Zero count. */
  check(memchr(one, 'a', 1) == one, 8);	/* Singleton case. */
  (void) strcpy(one, ""a\203b"");
  check(memchr(one, 0203, 3) == one+1, 9);	/* Unsignedness. */

  /* now test all possible alignment and length combinations to catch
     bugs due to unrolled loops (assuming unrolling is limited to no
     more than 128 byte chunks: */
  {
    char buf[128 + sizeof(long)];
    long align, len, i, pos;

    for (align = 0; align < (long) sizeof(long); ++align) {
      for (len = 0; len < (long) (sizeof(buf) - align); ++len) {
	for (i = 0; i < len; ++i) {
	  buf[align + i] = 'x';		/* don't depend on memset... */
	}
	for (pos = 0; pos < len; ++pos) {
#if 0
	  printf(""align %d, len %d, pos %d\n"", align, len, pos);
#endif
	  check(memchr(buf + align, 'x', len) == buf + align + pos, 10);
	  check(memchr(buf + align, 'x', pos) == NULL, 11);
	  buf[align + pos] = '-';
	}
      }
    }
  }
}

static void
test_memcpy (void)
{
  int i;
  it = ""memcpy"";
  check(memcpy(one, ""abc"", 4) == one, 1);	/* Returned value. */
  equal(one, ""abc"", 2);			/* Did the copy go right? */

  (void) strcpy(one, ""abcdefgh"");
  (void) memcpy(one+1, ""xyz"", 2);
  equal(one, ""axydefgh"", 3);		/* Basic test. */

  (void) strcpy(one, ""abc"");
  (void) memcpy(one, ""xyz"", 0);
  equal(one, ""abc"", 4);			/* Zero-length copy. */

  (void) strcpy(one, ""hi there"");
  (void) strcpy(two, ""foo"");
  (void) memcpy(two, one, 9);
  equal(two, ""hi there"", 5);		/* Just paranoia. */
  equal(one, ""hi there"", 6);		/* Stomped on source? */

  for (i = 0; i < 16; i++)
    {
      const char *x = ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"";
      strcpy (one, x);
      check (memcpy (one + i, ""hi there"", 9) == one + i,
	     7 + (i * 6));		/* Unaligned destination. */
      check (memcmp (one, x, i) == 0, 8 + (i * 6));  /* Wrote under? */
      equal (one + i, ""hi there"", 9 + (i * 6));
      check (one[i + 9] == 'x', 10 + (i * 6));       /* Wrote over? */
      check (memcpy (two, one + i, 9) == two,
	     11 + (i * 6));		/* Unaligned source. */
      equal (two, ""hi there"", 12 + (i * 6));
    }
}

static void
test_mempcpy (void)
{
  int i;
  it = ""mempcpy"";
  check(mempcpy(one, ""abc"", 4) == one + 4, 1);	/* Returned value. */
  equal(one, ""abc"", 2);			/* Did the copy go right? */

  (void) strcpy(one, ""abcdefgh"");
  (void) mempcpy(one+1, ""xyz"", 2);
  equal(one, ""axydefgh"", 3);		/* Basic test. */

  (void) strcpy(one, ""abc"");
  (void) mempcpy(one, ""xyz"", 0);
  equal(one, ""abc"", 4);			/* Zero-length copy. */

  (void) strcpy(one, ""hi there"");
  (void) strcpy(two, ""foo"");
  (void) mempcpy(two, one, 9);
  equal(two, ""hi there"", 5);		/* Just paranoia. */
  equal(one, ""hi there"", 6);		/* Stomped on source? */

  for (i = 0; i < 16; i++)
    {
      const char *x = ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"";
      strcpy (one, x);
      check (mempcpy (one + i, ""hi there"", 9) == one + i + 9,
	     7 + (i * 6));		/* Unaligned destination. */
      check (memcmp (one, x, i) == 0, 8 + (i * 6));  /* Wrote under? */
      equal (one + i, ""hi there"", 9 + (i * 6));
      check (one[i + 9] == 'x', 10 + (i * 6));       /* Wrote over? */
      check (mempcpy (two, one + i, 9) == two + 9,
	     11 + (i * 6));		/* Unaligned source. */
      equal (two, ""hi there"", 12 + (i * 6));
    }
}

static void
test_memmove (void)
{
  it = ""memmove"";
  check(memmove(one, ""abc"", 4) == one, 1);	/* Returned value. */
  equal(one, ""abc"", 2);			/* Did the copy go right? */

  (void) strcpy(one, ""abcdefgh"");
  (void) memmove(one+1, ""xyz"", 2);
  equal(one, ""axydefgh"", 3);		/* Basic test. */

  (void) strcpy(one, ""abc"");
  (void) memmove(one, ""xyz"", 0);
  equal(one, ""abc"", 4);			/* Zero-length copy. */

  (void) strcpy(one, ""hi there"");
  (void) strcpy(two, ""foo"");
  (void) memmove(two, one, 9);
  equal(two, ""hi there"", 5);		/* Just paranoia. */
  equal(one, ""hi there"", 6);		/* Stomped on source? */

  (void) strcpy(one, ""abcdefgh"");
  (void) memmove(one+1, one, 9);
  equal(one, ""aabcdefgh"", 7);		/* Overlap, right-to-left. */

  (void) strcpy(one, ""abcdefgh"");
  (void) memmove(one+1, one+2, 7);
  equal(one, ""acdefgh"", 8);		/* Overlap, left-to-right. */

  (void) strcpy(one, ""abcdefgh"");
  (void) memmove(one, one, 9);
  equal(one, ""abcdefgh"", 9);		/* 100% overlap. */
}

static void
test_memccpy (void)
{
  /* First test like memcpy, then the search part The SVID, the only
     place where memccpy is mentioned, says overlap might fail, so we
     don't try it.  Besides, it's hard to see the rationale for a
     non-left-to-right memccpy.  */
  it = ""memccpy"";
  check(memccpy(one, ""abc"", 'q', 4) == NULL, 1);	/* Returned value. */
  equal(one, ""abc"", 2);			/* Did the copy go right? */

  (void) strcpy(one, ""abcdefgh"");
  (void) memccpy(one+1, ""xyz"", 'q', 2);
  equal(one, ""axydefgh"", 3);		/* Basic test. */

  (void) strcpy(one, ""abc"");
  (void) memccpy(one, ""xyz"", 'q', 0);
  equal(one, ""abc"", 4);			/* Zero-length copy. */

  (void) strcpy(one, ""hi there"");
  (void) strcpy(two, ""foo"");
  (void) memccpy(two, one, 'q', 9);
  equal(two, ""hi there"", 5);		/* Just paranoia. */
  equal(one, ""hi there"", 6);		/* Stomped on source? */

  (void) strcpy(one, ""abcdefgh"");
  (void) strcpy(two, ""horsefeathers"");
  check(memccpy(two, one, 'f', 9) == two+6, 7);	/* Returned value. */
  equal(one, ""abcdefgh"", 8);		/* Source intact? */
  equal(two, ""abcdefeathers"", 9);		/* Copy correct? */

  (void) strcpy(one, ""abcd"");
  (void) strcpy(two, ""bumblebee"");
  check(memccpy(two, one, 'a', 4) == two+1, 10);	/* First char. */
  equal(two, ""aumblebee"", 11);
  check(memccpy(two, one, 'd', 4) == two+4, 12);	/* Last char. */
  equal(two, ""abcdlebee"", 13);
  (void) strcpy(one, ""xyz"");
  check(memccpy(two, one, 'x', 1) == two+1, 14);	/* Singleton. */
  equal(two, ""xbcdlebee"", 15);
}

static void
test_memset (void)
{
  int i;

  it = ""memset"";
  (void) strcpy(one, ""abcdefgh"");
  check(memset(one+1, 'x', 3) == one+1, 1);	/* Return value. */
  equal(one, ""axxxefgh"", 2);		/* Basic test. */

  (void) memset(one+2, 'y', 0);
  equal(one, ""axxxefgh"", 3);		/* Zero-length set. */

  (void) memset(one+5, 0, 1);
  equal(one, ""axxxe"", 4);			/* Zero fill. */
  equal(one+6, ""gh"", 5);			/* And the leftover. */

  (void) memset(one+2, 010045, 1);
  equal(one, ""ax\045xe"", 6);		/* Unsigned char convert. */

  /* Non-8bit fill character.  */
  memset (one, 0x101, sizeof (one));
  for (i = 0; i < (int) sizeof (one); ++i)
    check (one[i] == '\01', 7);

  /* Test for more complex versions of memset, for all alignments and
     lengths up to 256. This test takes a little while, perhaps it should
     be made weaker?  */
  {
    char data[512];
    int j;
    int k;
    int c;

    for (i = 0; i < 512; i++)
      data[i] = 'x';
    for (c = 0; c <= 'y'; c += 'y')  /* check for memset(,0,) and
					memset(,'y',) */
      for (j = 0; j < 256; j++)
	for (i = 0; i < 256; i++)
	  {
	    memset (data + i, c, j);
	    for (k = 0; k < i; k++)
	      if (data[k] != 'x')
		goto fail;
	    for (k = i; k < i+j; k++)
	      {
		if (data[k] != c)
		  goto fail;
		data[k] = 'x';
	      }
	    for (k = i+j; k < 512; k++)
	      if (data[k] != 'x')
		goto fail;
	    continue;

	  fail:
	    check (0, 8 + i + j * 256 + (c != 0) * 256 * 256);
	  }
  }
}

static void
test_bcopy (void)
{
#ifdef __TEST_SUSV3_LEGACY__
  /* Much like memcpy.  Berklix manual is silent about overlap, so
     don't test it.  */
  it = ""bcopy"";
  (void) bcopy(""abc"", one, 4);
  equal(one, ""abc"", 1);			/* Simple copy. */

  (void) strcpy(one, ""abcdefgh"");
  (void) bcopy(""xyz"", one+1, 2);
  equal(one, ""axydefgh"", 2);		/* Basic test. */

  (void) strcpy(one, ""abc"");
  (void) bcopy(""xyz"", one, 0);
  equal(one, ""abc"", 3);			/* Zero-length copy. */

  (void) strcpy(one, ""hi there"");
  (void) strcpy(two, ""foo"");
  (void) bcopy(one, two, 9);
  equal(two, ""hi there"", 4);		/* Just paranoia. */
  equal(one, ""hi there"", 5);		/* Stomped on source? */
#endif
}

static void
test_bzero (void)
{
#ifdef __TEST_SUSV3_LEGACY__
  it = ""bzero"";
  (void) strcpy(one, ""abcdef"");
  bzero(one+2, 2);
  equal(one, ""ab"", 1);			/* Basic test. */
  equal(one+3, """", 2);
  equal(one+4, ""ef"", 3);

  (void) strcpy(one, ""abcdef"");
  bzero(one+2, 0);
  equal(one, ""abcdef"", 4);		/* Zero-length copy. */
#endif
}

static void
test_strndup (void)
{
  char *p, *q;
  it = ""strndup"";
  p = strndup(""abcdef"", 12);
  check(p != NULL, 1);
  if (p != NULL)
    {
      equal(p, ""abcdef"", 2);
      q = strndup(p + 1, 2);
      check(q != NULL, 3);
      if (q != NULL)
	equal(q, ""bc"", 4);
      free (q);
    }
  free (p);
  p = strndup(""abc def"", 3);
  check(p != NULL, 5);
  if (p != NULL)
    equal(p, ""abc"", 6);
  free (p);
}

static void
test_bcmp (void)
{
#ifdef __TEST_SUSV3_LEGACY__
  it = ""bcmp"";
  check(bcmp(""a"", ""a"", 1) == 0, 1);	/* Identity. */
  check(bcmp(""abc"", ""abc"", 3) == 0, 2);	/* Multicharacter. */
  check(bcmp(""abcd"", ""abce"", 4) != 0, 3);	/* Honestly unequal. */
  check(bcmp(""abce"", ""abcd"", 4) != 0, 4);
  check(bcmp(""alph"", ""beta"", 4) != 0, 5);
  check(bcmp(""abce"", ""abcd"", 3) == 0, 6);	/* Count limited. */
  check(bcmp(""abc"", ""def"", 0) == 0, 8);	/* Zero count. */
#endif
}

static void
test_strerror (void)
{
  it = ""strerror"";
  check(strerror(EDOM) != 0, 1);
  check(strerror(ERANGE) != 0, 2);
  check(strerror(ENOENT) != 0, 3);
}

static void
test_strcasecmp (void)
{
  it = ""strcasecmp"";
  /* Note that the locale is ""C"".  */
  check(strcasecmp(""a"", ""a"") == 0, 1);
  check(strcasecmp(""a"", ""A"") == 0, 2);
  check(strcasecmp(""A"", ""a"") == 0, 3);
  check(strcasecmp(""a"", ""b"") < 0, 4);
  check(strcasecmp(""c"", ""b"") > 0, 5);
  check(strcasecmp(""abc"", ""AbC"") == 0, 6);
  check(strcasecmp(""0123456789"", ""0123456789"") == 0, 7);
  check(strcasecmp("""", ""0123456789"") < 0, 8);
  check(strcasecmp(""AbC"", """") > 0, 9);
  check(strcasecmp(""AbC"", ""A"") > 0, 10);
  check(strcasecmp(""AbC"", ""Ab"") > 0, 11);
  check(strcasecmp(""AbC"", ""ab"") > 0, 12);
}

static void
test_strncasecmp (void)
{
  it = ""strncasecmp"";
  /* Note that the locale is ""C"".  */
  check(strncasecmp(""a"", ""a"", 5) == 0, 1);
  check(strncasecmp(""a"", ""A"", 5) == 0, 2);
  check(strncasecmp(""A"", ""a"", 5) == 0, 3);
  check(strncasecmp(""a"", ""b"", 5) < 0, 4);
  check(strncasecmp(""c"", ""b"", 5) > 0, 5);
  check(strncasecmp(""abc"", ""AbC"", 5) == 0, 6);
  check(strncasecmp(""0123456789"", ""0123456789"", 10) == 0, 7);
  check(strncasecmp("""", ""0123456789"", 10) < 0, 8);
  check(strncasecmp(""AbC"", """", 5) > 0, 9);
  check(strncasecmp(""AbC"", ""A"", 5) > 0, 10);
  check(strncasecmp(""AbC"", ""Ab"", 5) > 0, 11);
  check(strncasecmp(""AbC"", ""ab"", 5) > 0, 12);
  check(strncasecmp(""0123456789"", ""AbC"", 0) == 0, 13);
  check(strncasecmp(""AbC"", ""abc"", 1) == 0, 14);
  check(strncasecmp(""AbC"", ""abc"", 2) == 0, 15);
  check(strncasecmp(""AbC"", ""abc"", 3) == 0, 16);
  check(strncasecmp(""AbC"", ""abcd"", 3) == 0, 17);
  check(strncasecmp(""AbC"", ""abcd"", 4) < 0, 18);
  check(strncasecmp(""ADC"", ""abcd"", 1) == 0, 19);
  check(strncasecmp(""ADC"", ""abcd"", 2) > 0, 20);
}

int
main (void)
{
  int status;

  /* Test strcmp first because we use it to test other things.  */
  test_strcmp ();

  /* Test strcpy next because we need it to set up other tests.  */
  test_strcpy ();

  /* A closely related function is stpcpy.  */
  test_stpcpy ();

  /* stpncpy.  */
  test_stpncpy ();

  /* strcat.  */
  test_strcat ();

  /* strncat.  */
  test_strncat ();

  /* strlcat.  */
  test_strlcat ();

  /* strncmp.  */
  test_strncmp ();

  /* strncpy.  */
  test_strncpy ();

  /* strlcpy.  */
  test_strlcpy ();

  /* strlen.  */
  test_strlen ();

  /* strnlen.  */
  test_strnlen ();

  /* strchr.  */
  test_strchr ();

  /* strchrnul.  */
  test_strchrnul ();

  /* rawmemchr.  */
  test_rawmemchr ();

  /* index - just like strchr.  */
  test_index ();

  /* strrchr.  */
  test_strrchr ();

  /* memrchr.  */
  test_memrchr ();

  /* rindex - just like strrchr.  */
  test_rindex ();

  /* strpbrk - somewhat like strchr.  */
  test_strpbrk ();

  /* strstr - somewhat like strchr.  */
  test_strstr ();

  /* strspn.  */
  test_strspn ();

  /* strcspn.  */
  test_strcspn ();

  /* strtok - the hard one.  */
  test_strtok ();

  /* strtok_r.  */
  test_strtok_r ();

  /* strsep.  */
  test_strsep ();

  /* memcmp.  */
  test_memcmp ();

  /* memchr.  */
  test_memchr ();

  /* memcpy - need not work for overlap.  */
  test_memcpy ();

  /* memmove - must work on overlap.  */
  test_memmove ();

  /* mempcpy */
  test_mempcpy ();

  /* memccpy.  */
  test_memccpy ();

  /* memset.  */
  test_memset ();

  /* bcopy.  */
  test_bcopy ();

  /* bzero.  */
  test_bzero ();

  /* bcmp - somewhat like memcmp.  */
  test_bcmp ();

  /* strndup.  */
  test_strndup ();

  /* strerror - VERY system-dependent.  */
  test_strerror ();

  /* strcasecmp.  Without locale dependencies.  */
  test_strcasecmp ();

  /* strncasecmp.  Without locale dependencies.  */
  test_strncasecmp ();

  if (errors == 0)
    {
      status = EXIT_SUCCESS;
      puts(""No errors."");
    }
  else
    {
      status = EXIT_FAILURE;
      printf(""%Zd errors.\n"", errors);
    }

  return status;
}
"
174-3779,sebastianscatularo/glibc,string/tester.c,1413,53,2063,81620710.31983934,584031036.0,0.1397540626590947,1942.0,1900.0,150402275.0,22309609.0,1839.0,646.0,1502.0,599.0,1500000000,0.0544138068798929,1082014363648.0,6.578417520948322e-06,2.655289198281225e-05,"/* Tester for string functions.
   Copyright (C) 1995-2014 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif

/* Make sure we don't test the optimized inline functions if we want to
   test the real implementation.  */
#if !defined DO_STRING_INLINES
#undef __USE_STRING_INLINES
#endif

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <fcntl.h>


#define	STREQ(a, b)	(strcmp((a), (b)) == 0)

const char *it = ""<UNSET>"";	/* Routine name for message routines. */
size_t errors = 0;

/* Complain if condition is not true.  */
static void
check (int thing, int number)
{
  if (!thing)
    {
      printf (""%s flunked test %d\n"", it, number);
      ++errors;
    }
}

/* Complain if first two args don't strcmp as equal.  */
static void
equal (const char *a, const char *b, int number)
{
  check (a != NULL && b != NULL && STREQ (a, b), number);
}

char one[50];
char two[50];
char *cp;

static void
test_strcmp (void)
{
  it = ""strcmp"";
  check (strcmp ("""", """") == 0, 1);		/* Trivial case. */
  check (strcmp (""a"", ""a"") == 0, 2);		/* Identity. */
  check (strcmp (""abc"", ""abc"") == 0, 3);	/* Multicharacter. */
  check (strcmp (""abc"", ""abcd"") < 0, 4);	/* Length mismatches. */
  check (strcmp (""abcd"", ""abc"") > 0, 5);
  check (strcmp (""abcd"", ""abce"") < 0, 6);	/* Honest miscompares. */
  check (strcmp (""abce"", ""abcd"") > 0, 7);
  check (strcmp (""a\203"", ""a"") > 0, 8);		/* Tricky if char signed. */
  check (strcmp (""a\203"", ""a\003"") > 0, 9);

  {
    char buf1[0x40], buf2[0x40];
    int i, j;
    for (i=0; i < 0x10; i++)
      for (j = 0; j < 0x10; j++)
	{
	  int k;
	  for (k = 0; k < 0x3f; k++)
	    {
	      buf1[k] = '0' ^ (k & 4);
	      buf2[k] = '4' ^ (k & 4);
	    }
	  buf1[i] = buf1[0x3f] = 0;
	  buf2[j] = buf2[0x3f] = 0;
	  for (k = 0; k < 0xf; k++)
	    {
	      int cnum = 0x10+0x10*k+0x100*j+0x1000*i;
	      check (strcmp (buf1+i,buf2+j) == 0, cnum);
	      buf1[i+k] = 'A' + i + k;
	      buf1[i+k+1] = 0;
	      check (strcmp (buf1+i,buf2+j) > 0, cnum+1);
	      check (strcmp (buf2+j,buf1+i) < 0, cnum+2);
	      buf2[j+k] = 'B' + i + k;
	      buf2[j+k+1] = 0;
	      check (strcmp (buf1+i,buf2+j) < 0, cnum+3);
	      check (strcmp (buf2+j,buf1+i) > 0, cnum+4);
	      buf2[j+k] = 'A' + i + k;
	      buf1[i] = 'A' + i + 0x80;
	      check (strcmp (buf1+i,buf2+j) > 0, cnum+5);
	      check (strcmp (buf2+j,buf1+i) < 0, cnum+6);
	      buf1[i] = 'A' + i;
	    }
	}
  }
}

#define SIMPLE_COPY(fn, n, str, ntest) \
  do {									      \
    int __n;								      \
    char *cp;								      \
    for (__n = 0; __n < (int) sizeof (one); ++__n)			      \
      one[__n] = 'Z';							      \
    fn (one, str);							      \
    for (cp = one, __n = 0; __n < n; ++__n, ++cp)			      \
      check (*cp == '0' + (n % 10), ntest);				      \
    check (*cp == '\0', ntest);						      \
  } while (0)

static void
test_strcpy (void)
{
  int i;
  it = ""strcpy"";
  check (strcpy (one, ""abcd"") == one, 1); /* Returned value. */
  equal (one, ""abcd"", 2);		/* Basic test. */

  (void) strcpy (one, ""x"");
  equal (one, ""x"", 3);			/* Writeover. */
  equal (one+2, ""cd"", 4);		/* Wrote too much? */

  (void) strcpy (two, ""hi there"");
  (void) strcpy (one, two);
  equal (one, ""hi there"", 5);		/* Basic test encore. */
  equal (two, ""hi there"", 6);		/* Stomped on source? */

  (void) strcpy (one, """");
  equal (one, """", 7);			/* Boundary condition. */

  for (i = 0; i < 16; i++)
    {
      (void) strcpy (one + i, ""hi there"");	/* Unaligned destination. */
      equal (one + i, ""hi there"", 8 + (i * 2));
      (void) strcpy (two, one + i);		/* Unaligned source. */
      equal (two, ""hi there"", 9 + (i * 2));
    }

  SIMPLE_COPY(strcpy, 0, """", 41);
  SIMPLE_COPY(strcpy, 1, ""1"", 42);
  SIMPLE_COPY(strcpy, 2, ""22"", 43);
  SIMPLE_COPY(strcpy, 3, ""333"", 44);
  SIMPLE_COPY(strcpy, 4, ""4444"", 45);
  SIMPLE_COPY(strcpy, 5, ""55555"", 46);
  SIMPLE_COPY(strcpy, 6, ""666666"", 47);
  SIMPLE_COPY(strcpy, 7, ""7777777"", 48);
  SIMPLE_COPY(strcpy, 8, ""88888888"", 49);
  SIMPLE_COPY(strcpy, 9, ""999999999"", 50);
  SIMPLE_COPY(strcpy, 10, ""0000000000"", 51);
  SIMPLE_COPY(strcpy, 11, ""11111111111"", 52);
  SIMPLE_COPY(strcpy, 12, ""222222222222"", 53);
  SIMPLE_COPY(strcpy, 13, ""3333333333333"", 54);
  SIMPLE_COPY(strcpy, 14, ""44444444444444"", 55);
  SIMPLE_COPY(strcpy, 15, ""555555555555555"", 56);
  SIMPLE_COPY(strcpy, 16, ""6666666666666666"", 57);

  /* Simple test using implicitly coerced `void *' arguments.  */
  const void *src = ""frobozz"";
  void *dst = one;
  check (strcpy (dst, src) == dst, 1);
  equal (dst, ""frobozz"", 2);
}

static void
test_stpcpy (void)
{
  it = ""stpcpy"";
  check ((stpcpy (one, ""a"") - one) == 1, 1);
  equal (one, ""a"", 2);

  check ((stpcpy (one, ""ab"") - one) == 2, 3);
  equal (one, ""ab"", 4);

  check ((stpcpy (one, ""abc"") - one) == 3, 5);
  equal (one, ""abc"", 6);

  check ((stpcpy (one, ""abcd"") - one) == 4, 7);
  equal (one, ""abcd"", 8);

  check ((stpcpy (one, ""abcde"") - one) == 5, 9);
  equal (one, ""abcde"", 10);

  check ((stpcpy (one, ""abcdef"") - one) == 6, 11);
  equal (one, ""abcdef"", 12);

  check ((stpcpy (one, ""abcdefg"") - one) == 7, 13);
  equal (one, ""abcdefg"", 14);

  check ((stpcpy (one, ""abcdefgh"") - one) == 8, 15);
  equal (one, ""abcdefgh"", 16);

  check ((stpcpy (one, ""abcdefghi"") - one) == 9, 17);
  equal (one, ""abcdefghi"", 18);

  check ((stpcpy (one, ""x"") - one) == 1, 19);
  equal (one, ""x"", 20);			/* Writeover. */
  equal (one+2, ""cdefghi"", 21);		/* Wrote too much? */

  check ((stpcpy (one, ""xx"") - one) == 2, 22);
  equal (one, ""xx"", 23);		/* Writeover. */
  equal (one+3, ""defghi"", 24);		/* Wrote too much? */

  check ((stpcpy (one, ""xxx"") - one) == 3, 25);
  equal (one, ""xxx"", 26);		/* Writeover. */
  equal (one+4, ""efghi"", 27);		/* Wrote too much? */

  check ((stpcpy (one, ""xxxx"") - one) == 4, 28);
  equal (one, ""xxxx"", 29);		/* Writeover. */
  equal (one+5, ""fghi"", 30);		/* Wrote too much? */

  check ((stpcpy (one, ""xxxxx"") - one) == 5, 31);
  equal (one, ""xxxxx"", 32);		/* Writeover. */
  equal (one+6, ""ghi"", 33);		/* Wrote too much? */

  check ((stpcpy (one, ""xxxxxx"") - one) == 6, 34);
  equal (one, ""xxxxxx"", 35);		/* Writeover. */
  equal (one+7, ""hi"", 36);		/* Wrote too much? */

  check ((stpcpy (one, ""xxxxxxx"") - one) == 7, 37);
  equal (one, ""xxxxxxx"", 38);		/* Writeover. */
  equal (one+8, ""i"", 39);		/* Wrote too much? */

  check ((stpcpy (stpcpy (stpcpy (one, ""a""), ""b""), ""c"") - one) == 3, 40);
  equal (one, ""abc"", 41);
  equal (one + 4, ""xxx"", 42);

  SIMPLE_COPY(stpcpy, 0, """", 43);
  SIMPLE_COPY(stpcpy, 1, ""1"", 44);
  SIMPLE_COPY(stpcpy, 2, ""22"", 45);
  SIMPLE_COPY(stpcpy, 3, ""333"", 46);
  SIMPLE_COPY(stpcpy, 4, ""4444"", 47);
  SIMPLE_COPY(stpcpy, 5, ""55555"", 48);
  SIMPLE_COPY(stpcpy, 6, ""666666"", 49);
  SIMPLE_COPY(stpcpy, 7, ""7777777"", 50);
  SIMPLE_COPY(stpcpy, 8, ""88888888"", 51);
  SIMPLE_COPY(stpcpy, 9, ""999999999"", 52);
  SIMPLE_COPY(stpcpy, 10, ""0000000000"", 53);
  SIMPLE_COPY(stpcpy, 11, ""11111111111"", 54);
  SIMPLE_COPY(stpcpy, 12, ""222222222222"", 55);
  SIMPLE_COPY(stpcpy, 13, ""3333333333333"", 56);
  SIMPLE_COPY(stpcpy, 14, ""44444444444444"", 57);
  SIMPLE_COPY(stpcpy, 15, ""555555555555555"", 58);
  SIMPLE_COPY(stpcpy, 16, ""6666666666666666"", 59);
}

static void
test_stpncpy (void)
{
  it = ""stpncpy"";
  memset (one, 'x', sizeof (one));
  check (stpncpy (one, ""abc"", 2) == one + 2, 1);
  check (stpncpy (one, ""abc"", 3) == one + 3, 2);
  check (stpncpy (one, ""abc"", 4) == one + 3, 3);
  check (one[3] == '\0' && one[4] == 'x', 4);
  check (stpncpy (one, ""abcd"", 5) == one + 4, 5);
  check (one[4] == '\0' && one[5] == 'x', 6);
  check (stpncpy (one, ""abcd"", 6) == one + 4, 7);
  check (one[4] == '\0' && one[5] == '\0' && one[6] == 'x', 8);
}

static void
test_strcat (void)
{
  it = ""strcat"";
  (void) strcpy (one, ""ijk"");
  check (strcat (one, ""lmn"") == one, 1); /* Returned value. */
  equal (one, ""ijklmn"", 2);		/* Basic test. */

  (void) strcpy (one, ""x"");
  (void) strcat (one, ""yz"");
  equal (one, ""xyz"", 3);			/* Writeover. */
  equal (one+4, ""mn"", 4);			/* Wrote too much? */

  (void) strcpy (one, ""gh"");
  (void) strcpy (two, ""ef"");
  (void) strcat (one, two);
  equal (one, ""ghef"", 5);			/* Basic test encore. */
  equal (two, ""ef"", 6);			/* Stomped on source? */

  (void) strcpy (one, """");
  (void) strcat (one, """");
  equal (one, """", 7);			/* Boundary conditions. */
  (void) strcpy (one, ""ab"");
  (void) strcat (one, """");
  equal (one, ""ab"", 8);
  (void) strcpy (one, """");
  (void) strcat (one, ""cd"");
  equal (one, ""cd"", 9);

  int ntest = 10;
  char buf1[80] __attribute__ ((aligned (16)));
  char buf2[32] __attribute__ ((aligned (16)));
  for (size_t n1 = 0; n1 < 16; ++n1)
    for (size_t n2 = 0; n2 < 16; ++n2)
      for (size_t n3 = 0; n3 < 32; ++n3)
	{
	  size_t olderrors = errors;

	  memset (buf1, 'b', sizeof (buf1));

	  memset (buf1 + n2, 'a', n3);
	  buf1[n2 + n3] = '\0';
	  strcpy (buf2 + n1, ""123"");

	  check (strcat (buf1 + n2, buf2 + n1) == buf1 + n2, ntest);
	  if (errors == olderrors)
	    for (size_t i = 0; i < sizeof (buf1); ++i)
	      {
		if (i < n2)
		  check (buf1[i] == 'b', ntest);
		else if (i < n2 + n3)
		  check (buf1[i] == 'a', ntest);
		else if (i < n2 + n3 + 3)
		  check (buf1[i] == ""123""[i - (n2 + n3)], ntest);
		else if (i == n2 + n3 + 3)
		  check (buf1[i] == '\0', ntest);
		else
		  check (buf1[i] == 'b', ntest);

		if (errors != olderrors)
		  {
		    printf (""n1=%zu, n2=%zu, n3=%zu, buf1=%02hhx"",
			    n1, n2, n3, buf1[0]);
		    for (size_t j = 1; j < sizeof (buf1); ++j)
		      printf ("",%02hhx"", buf1[j]);
		    putchar_unlocked ('\n');
		    break;
		  }
	      }
	}
}

static void
test_strncat (void)
{
  /* First test it as strcat, with big counts, then test the count
     mechanism.  */
  it = ""strncat"";
  (void) strcpy (one, ""ijk"");
  check (strncat (one, ""lmn"", 99) == one, 1);	/* Returned value. */
  equal (one, ""ijklmn"", 2);		/* Basic test. */

  (void) strcpy (one, ""x"");
  (void) strncat (one, ""yz"", 99);
  equal (one, ""xyz"", 3);		/* Writeover. */
  equal (one+4, ""mn"", 4);		/* Wrote too much? */

  (void) strcpy (one, ""gh"");
  (void) strcpy (two, ""ef"");
  (void) strncat (one, two, 99);
  equal (one, ""ghef"", 5);			/* Basic test encore. */
  equal (two, ""ef"", 6);			/* Stomped on source? */

  (void) strcpy (one, """");
  (void) strncat (one, """", 99);
  equal (one, """", 7);			/* Boundary conditions. */
  (void) strcpy (one, ""ab"");
  (void) strncat (one, """", 99);
  equal (one, ""ab"", 8);
  (void) strcpy (one, """");
  (void) strncat (one, ""cd"", 99);
  equal (one, ""cd"", 9);

  (void) strcpy (one, ""ab"");
  (void) strncat (one, ""cdef"", 2);
  equal (one, ""abcd"", 10);			/* Count-limited. */

  (void) strncat (one, ""gh"", 0);
  equal (one, ""abcd"", 11);			/* Zero count. */

  (void) strncat (one, ""gh"", 2);
  equal (one, ""abcdgh"", 12);		/* Count and length equal. */

  (void) strncat (one, ""ij"", (size_t)-1);	/* set sign bit in count */
  equal (one, ""abcdghij"", 13);

  int ntest = 14;
  char buf1[80] __attribute__ ((aligned (16)));
  char buf2[32] __attribute__ ((aligned (16)));
  for (size_t n1 = 0; n1 < 16; ++n1)
    for (size_t n2 = 0; n2 < 16; ++n2)
      for (size_t n3 = 0; n3 < 32; ++n3)
	for (size_t n4 = 0; n4 < 16; ++n4)
	  {
	    size_t olderrors = errors;

	    memset (buf1, 'b', sizeof (buf1));

	    memset (buf1 + n2, 'a', n3);
	    buf1[n2 + n3] = '\0';
	    strcpy (buf2 + n1, ""123"");

	    check (strncat (buf1 + n2, buf2 + n1, ~((size_t) 0) - n4)
		   == buf1 + n2, ntest);
	    if (errors == olderrors)
	      for (size_t i = 0; i < sizeof (buf1); ++i)
		{
		  if (i < n2)
		    check (buf1[i] == 'b', ntest);
		  else if (i < n2 + n3)
		    check (buf1[i] == 'a', ntest);
		  else if (i < n2 + n3 + 3)
		    check (buf1[i] == ""123""[i - (n2 + n3)], ntest);
		  else if (i == n2 + n3 + 3)
		    check (buf1[i] == '\0', ntest);
		  else
		    check (buf1[i] == 'b', ntest);

		  if (errors != olderrors)
		    {
		      printf (""n1=%zu, n2=%zu, n3=%zu, n4=%zu, buf1=%02hhx"",
			      n1, n2, n3, n4, buf1[0]);
		      for (size_t j = 1; j < sizeof (buf1); ++j)
			printf ("",%02hhx"", buf1[j]);
		      putchar_unlocked ('\n');
		      break;
		    }
		}
	  }
}

static void
test_strncmp (void)
{
  /* First test as strcmp with big counts, then test count code.  */
  it = ""strncmp"";
  check (strncmp ("""", """", 99) == 0, 1);	/* Trivial case. */
  check (strncmp (""a"", ""a"", 99) == 0, 2);	/* Identity. */
  check (strncmp (""abc"", ""abc"", 99) == 0, 3);	/* Multicharacter. */
  check (strncmp (""abc"", ""abcd"", 99) < 0, 4);	/* Length unequal. */
  check (strncmp (""abcd"", ""abc"", 99) > 0, 5);
  check (strncmp (""abcd"", ""abce"", 99) < 0, 6);	/* Honestly unequal. */
  check (strncmp (""abce"", ""abcd"", 99) > 0, 7);
  check (strncmp (""a\203"", ""a"", 2) > 0, 8);	/* Tricky if '\203' < 0 */
  check (strncmp (""a\203"", ""a\003"", 2) > 0, 9);
  check (strncmp (""abce"", ""abcd"", 3) == 0, 10);	/* Count limited. */
  check (strncmp (""abce"", ""abc"", 3) == 0, 11);	/* Count == length. */
  check (strncmp (""abcd"", ""abce"", 4) < 0, 12);	/* Nudging limit. */
  check (strncmp (""abc"", ""def"", 0) == 0, 13);	/* Zero count. */
  check (strncmp (""abc"", """", (size_t)-1) > 0, 14);	/* set sign bit in count */
  check (strncmp (""abc"", ""abc"", (size_t)-2) == 0, 15);
}

static void
test_strncpy (void)
{
  /* Testing is a bit different because of odd semantics.  */
  it = ""strncpy"";
  check (strncpy (one, ""abc"", 4) == one, 1);	/* Returned value. */
  equal (one, ""abc"", 2);			/* Did the copy go right? */

  (void) strcpy (one, ""abcdefgh"");
  (void) strncpy (one, ""xyz"", 2);
  equal (one, ""xycdefgh"", 3);			/* Copy cut by count. */

  (void) strcpy (one, ""abcdefgh"");
  (void) strncpy (one, ""xyz"", 3);		/* Copy cut just before NUL. */
  equal (one, ""xyzdefgh"", 4);

  (void) strcpy (one, ""abcdefgh"");
  (void) strncpy (one, ""xyz"", 4);		/* Copy just includes NUL. */
  equal (one, ""xyz"", 5);
  equal (one+4, ""efgh"", 6);			/* Wrote too much? */

  (void) strcpy (one, ""abcdefgh"");
  (void) strncpy (one, ""xyz"", 5);		/* Copy includes padding. */
  equal (one, ""xyz"", 7);
  equal (one+4, """", 8);
  equal (one+5, ""fgh"", 9);

  (void) strcpy (one, ""abc"");
  (void) strncpy (one, ""xyz"", 0);		/* Zero-length copy. */
  equal (one, ""abc"", 10);

  (void) strncpy (one, """", 2);		/* Zero-length source. */
  equal (one, """", 11);
  equal (one+1, """", 12);
  equal (one+2, ""c"", 13);

  (void) strcpy (one, ""hi there"");
  (void) strncpy (two, one, 9);
  equal (two, ""hi there"", 14);		/* Just paranoia. */
  equal (one, ""hi there"", 15);		/* Stomped on source? */
}

static void
test_strlen (void)
{
  it = ""strlen"";
  check (strlen ("""") == 0, 1);		/* Empty. */
  check (strlen (""a"") == 1, 2);		/* Single char. */
  check (strlen (""abcd"") == 4, 3);	/* Multiple chars. */
  {
    char buf[4096];
    int i;
    char *p;
    for (i=0; i < 0x100; i++)
      {
	p = (char *) ((unsigned long int)(buf + 0xff) & ~0xff) + i;
	strcpy (p, ""OK"");
	strcpy (p+3, ""BAD/WRONG"");
	check (strlen (p) == 2, 4+i);
      }
   }
}

static void
test_strnlen (void)
{
  it = ""strnlen"";
  check (strnlen ("""", 10) == 0, 1);		/* Empty. */
  check (strnlen (""a"", 10) == 1, 2);		/* Single char. */
  check (strnlen (""abcd"", 10) == 4, 3);		/* Multiple chars. */
  check (strnlen (""foo"", (size_t) -1) == 3, 4);	/* limits of n. */
  check (strnlen (""abcd"", 0) == 0, 5);		/* Restricted. */
  check (strnlen (""abcd"", 1) == 1, 6);		/* Restricted. */
  check (strnlen (""abcd"", 2) == 2, 7);		/* Restricted. */
  check (strnlen (""abcd"", 3) == 3, 8);		/* Restricted. */
  check (strnlen (""abcd"", 4) == 4, 9);		/* Restricted. */

  char buf[4096];
  for (int i = 0; i < 0x100; ++i)
    {
      char *p = (char *) ((unsigned long int)(buf + 0xff) & ~0xff) + i;
      strcpy (p, ""OK"");
      strcpy (p + 3, ""BAD/WRONG"");
      check (strnlen (p, 100) == 2, 10 + i);
    }
}

static void
test_strchr (void)
{
  it = ""strchr"";
  check (strchr (""abcd"", 'z') == NULL, 1);	/* Not found. */
  (void) strcpy (one, ""abcd"");
  check (strchr (one, 'c') == one+2, 2);	/* Basic test. */
  check (strchr (one, 'd') == one+3, 3);	/* End of string. */
  check (strchr (one, 'a') == one, 4);		/* Beginning. */
  check (strchr (one, '\0') == one+4, 5);	/* Finding NUL. */
  (void) strcpy (one, ""ababa"");
  check (strchr (one, 'b') == one+1, 6);	/* Finding first. */
  (void) strcpy (one, """");
  check (strchr (one, 'b') == NULL, 7);		/* Empty string. */
  check (strchr (one, '\0') == one, 8);		/* NUL in empty string. */
  {
    char buf[4096];
    int i;
    char *p;
    for (i=0; i < 0x100; i++)
      {
	p = (char *) ((unsigned long int) (buf + 0xff) & ~0xff) + i;
	strcpy (p, ""OK"");
	strcpy (p+3, ""BAD/WRONG"");
	check (strchr (p, '/') == NULL, 9+i);
      }
   }
}

static void
test_strchrnul (void)
{
  const char *os;
  it = ""strchrnul"";
  cp = strchrnul ((os = ""abcd""), 'z');
  check (*cp == '\0', 1);			/* Not found. */
  check (cp == os + 4, 2);
  (void) strcpy (one, ""abcd"");
  check (strchrnul (one, 'c') == one+2, 3);	/* Basic test. */
  check (strchrnul (one, 'd') == one+3, 4);	/* End of string. */
  check (strchrnul (one, 'a') == one, 5);	/* Beginning. */
  check (strchrnul (one, '\0') == one+4, 6);	/* Finding NUL. */
  (void) strcpy (one, ""ababa"");
  check (strchrnul (one, 'b') == one+1, 7);	/* Finding first. */
  (void) strcpy (one, """");
  check (strchrnul (one, 'b') == one, 8);	/* Empty string. */
  check (strchrnul (one, '\0') == one, 9);	/* NUL in empty string. */
  {
    char buf[4096];
    int i;
    char *p;
    for (i=0; i < 0x100; i++)
      {
	p = (char *) ((unsigned long int) (buf + 0xff) & ~0xff) + i;
	strcpy (p, ""OK"");
	strcpy (p+3, ""BAD/WRONG"");
	cp = strchrnul (p, '/');
	check (*cp == '\0', 9+2*i);
	check (cp == p+2, 10+2*i);
      }
   }
}

static void
test_rawmemchr (void)
{
  it = ""rawmemchr"";
  (void) strcpy (one, ""abcd"");
  check (rawmemchr (one, 'c') == one+2, 1);	/* Basic test. */
  check (rawmemchr (one, 'd') == one+3, 2);	/* End of string. */
  check (rawmemchr (one, 'a') == one, 3);		/* Beginning. */
  check (rawmemchr (one, '\0') == one+4, 4);	/* Finding NUL. */
  (void) strcpy (one, ""ababa"");
  check (rawmemchr (one, 'b') == one+1, 5);	/* Finding first. */
  (void) strcpy (one, """");
  check (rawmemchr (one, '\0') == one, 6);	/* NUL in empty string. */
  {
    char buf[4096];
    int i;
    char *p;
    for (i=0; i < 0x100; i++)
      {
	p = (char *) ((unsigned long int) (buf + 0xff) & ~0xff) + i;
	strcpy (p, ""OK"");
	strcpy (p+3, ""BAD/WRONG"");
	check (rawmemchr (p, 'R') == p+8, 6+i);
      }
   }
}

static void
test_index (void)
{
  it = ""index"";
  check (index (""abcd"", 'z') == NULL, 1);	/* Not found. */
  (void) strcpy (one, ""abcd"");
  check (index (one, 'c') == one+2, 2);	/* Basic test. */
  check (index (one, 'd') == one+3, 3);	/* End of string. */
  check (index (one, 'a') == one, 4);	/* Beginning. */
  check (index (one, '\0') == one+4, 5);	/* Finding NUL. */
  (void) strcpy (one, ""ababa"");
  check (index (one, 'b') == one+1, 6);	/* Finding first. */
  (void) strcpy (one, """");
  check (index (one, 'b') == NULL, 7);	/* Empty string. */
  check (index (one, '\0') == one, 8);	/* NUL in empty string. */
}

static void
test_strrchr (void)
{
  it = ""strrchr"";
  check (strrchr (""abcd"", 'z') == NULL, 1);	/* Not found. */
  (void) strcpy (one, ""abcd"");
  check (strrchr (one, 'c') == one+2, 2);	/* Basic test. */
  check (strrchr (one, 'd') == one+3, 3);	/* End of string. */
  check (strrchr (one, 'a') == one, 4);		/* Beginning. */
  check (strrchr (one, '\0') == one+4, 5);	/* Finding NUL. */
  (void) strcpy (one, ""ababa"");
  check (strrchr (one, 'b') == one+3, 6);	/* Finding last. */
  (void) strcpy (one, """");
  check (strrchr (one, 'b') == NULL, 7);	/* Empty string. */
  check (strrchr (one, '\0') == one, 8);	/* NUL in empty string. */
  {
    char buf[4096];
    int i;
    char *p;
    for (i=0; i < 0x100; i++)
      {
	p = (char *) ((unsigned long int) (buf + 0xff) & ~0xff) + i;
	strcpy (p, ""OK"");
	strcpy (p+3, ""BAD/WRONG"");
	check (strrchr (p, '/') == NULL, 9+i);
      }
   }
}

static void
test_memrchr (void)
{
  size_t l;
  it = ""memrchr"";
  check (memrchr (""abcd"", 'z', 5) == NULL, 1);	/* Not found. */
  (void) strcpy (one, ""abcd"");
  l = strlen (one) + 1;
  check (memrchr (one, 'c', l) == one+2, 2);	/* Basic test. */
  check (memrchr (one, 'd', l) == one+3, 3);	/* End of string. */
  check (memrchr (one, 'a', l) == one, 4);		/* Beginning. */
  check (memrchr (one, '\0', l) == one+4, 5);	/* Finding NUL. */
  (void) strcpy (one, ""ababa"");
  l = strlen (one) + 1;
  check (memrchr (one, 'b', l) == one+3, 6);	/* Finding last. */
  (void) strcpy (one, """");
  l = strlen (one) + 1;
  check (memrchr (one, 'b', l) == NULL, 7);	/* Empty string. */
  check (memrchr (one, '\0', l) == one, 8);	/* NUL in empty string. */

  /* now test all possible alignment and length combinations to catch
     bugs due to unrolled loops (assuming unrolling is limited to no
     more than 128 byte chunks: */
  {
    char buf[128 + sizeof(long)];
    long align, len, i, pos, n = 9;

    for (align = 0; align < (long) sizeof(long); ++align) {
      for (len = 0; len < (long) (sizeof(buf) - align); ++len) {
	for (i = 0; i < len; ++i)
	  buf[align + i] = 'x';		/* don't depend on memset... */

	for (pos = len - 1; pos >= 0; --pos) {
#if 0
	  printf(""align %d, len %d, pos %d\n"", align, len, pos);
#endif
	  check(memrchr(buf + align, 'x', len) == buf + align + pos, n++);
	  check(memrchr(buf + align + pos + 1, 'x', len - (pos + 1)) == NULL,
		n++);
	  buf[align + pos] = '-';
	}
      }
    }
  }
}

static void
test_rindex (void)
{
  it = ""rindex"";
  check (rindex (""abcd"", 'z') == NULL, 1);	/* Not found. */
  (void) strcpy (one, ""abcd"");
  check (rindex (one, 'c') == one+2, 2);	/* Basic test. */
  check (rindex (one, 'd') == one+3, 3);	/* End of string. */
  check (rindex (one, 'a') == one, 4);	/* Beginning. */
  check (rindex (one, '\0') == one+4, 5);	/* Finding NUL. */
  (void) strcpy (one, ""ababa"");
  check (rindex (one, 'b') == one+3, 6);	/* Finding last. */
  (void) strcpy (one, """");
  check (rindex (one, 'b') == NULL, 7);	/* Empty string. */
  check (rindex (one, '\0') == one, 8);	/* NUL in empty string. */
}

static void
test_strpbrk (void)
{
  it = ""strpbrk"";
  check(strpbrk(""abcd"", ""z"") == NULL, 1);	/* Not found. */
  (void) strcpy(one, ""abcd"");
  check(strpbrk(one, ""c"") == one+2, 2);	/* Basic test. */
  check(strpbrk(one, ""d"") == one+3, 3);	/* End of string. */
  check(strpbrk(one, ""a"") == one, 4);	/* Beginning. */
  check(strpbrk(one, """") == NULL, 5);	/* Empty search list. */
  check(strpbrk(one, ""cb"") == one+1, 6);	/* Multiple search. */
  (void) strcpy(one, ""abcabdea"");
  check(strpbrk(one, ""b"") == one+1, 7);	/* Finding first. */
  check(strpbrk(one, ""cb"") == one+1, 8);	/* With multiple search. */
  check(strpbrk(one, ""db"") == one+1, 9);	/* Another variant. */
  (void) strcpy(one, """");
  check(strpbrk(one, ""bc"") == NULL, 10);	/* Empty string. */
  (void) strcpy(one, """");
  check(strpbrk(one, ""bcd"") == NULL, 11);	/* Empty string. */
  (void) strcpy(one, """");
  check(strpbrk(one, ""bcde"") == NULL, 12);	/* Empty string. */
  check(strpbrk(one, """") == NULL, 13);	/* Both strings empty. */
  (void) strcpy(one, ""abcabdea"");
  check(strpbrk(one, ""befg"") == one+1, 14);	/* Finding first. */
  check(strpbrk(one, ""cbr"") == one+1, 15);	/* With multiple search. */
  check(strpbrk(one, ""db"") == one+1, 16);	/* Another variant. */
  check(strpbrk(one, ""efgh"") == one+6, 17);	/* And yet another. */
}

static void
test_strstr (void)
{
  it = ""strstr"";
  check(strstr(""abcd"", ""z"") == NULL, 1);	/* Not found. */
  check(strstr(""abcd"", ""abx"") == NULL, 2);	/* Dead end. */
  (void) strcpy(one, ""abcd"");
  check(strstr(one, ""c"") == one+2, 3);	/* Basic test. */
  check(strstr(one, ""bc"") == one+1, 4);	/* Multichar. */
  check(strstr(one, ""d"") == one+3, 5);	/* End of string. */
  check(strstr(one, ""cd"") == one+2, 6);	/* Tail of string. */
  check(strstr(one, ""abc"") == one, 7);	/* Beginning. */
  check(strstr(one, ""abcd"") == one, 8);	/* Exact match. */
  check(strstr(one, ""abcde"") == NULL, 9);	/* Too long. */
  check(strstr(one, ""de"") == NULL, 10);	/* Past end. */
  check(strstr(one, """") == one, 11);	/* Finding empty. */
  (void) strcpy(one, ""ababa"");
  check(strstr(one, ""ba"") == one+1, 12);	/* Finding first. */
  (void) strcpy(one, """");
  check(strstr(one, ""b"") == NULL, 13);	/* Empty string. */
  check(strstr(one, """") == one, 14);	/* Empty in empty string. */
  (void) strcpy(one, ""bcbca"");
  check(strstr(one, ""bca"") == one+2, 15);	/* False start. */
  (void) strcpy(one, ""bbbcabbca"");
  check(strstr(one, ""bbca"") == one+1, 16);	/* With overlap. */
}

static void
test_strspn (void)
{
  it = ""strspn"";
  check(strspn(""abcba"", ""abc"") == 5, 1);	/* Whole string. */
  check(strspn(""abcba"", ""ab"") == 2, 2);	/* Partial. */
  check(strspn(""abc"", ""qx"") == 0, 3);	/* None. */
  check(strspn("""", ""ab"") == 0, 4);	/* Null string. */
  check(strspn(""abc"", """") == 0, 5);	/* Null search list. */
}

static void
test_strcspn (void)
{
  it = ""strcspn"";
  check(strcspn(""abcba"", ""qx"") == 5, 1);	/* Whole string. */
  check(strcspn(""abcba"", ""cx"") == 2, 2);	/* Partial. */
  check(strcspn(""abc"", ""abc"") == 0, 3);	/* None. */
  check(strcspn("""", ""ab"") == 0, 4);	/* Null string. */
  check(strcspn(""abc"", """") == 3, 5);	/* Null search list. */
}

static void
test_strtok (void)
{
  it = ""strtok"";
  (void) strcpy(one, ""first, second, third"");
  equal(strtok(one, "", ""), ""first"", 1);	/* Basic test. */
  equal(one, ""first"", 2);
  equal(strtok((char *)NULL, "", ""), ""second"", 3);
  equal(strtok((char *)NULL, "", ""), ""third"", 4);
  check(strtok((char *)NULL, "", "") == NULL, 5);
  (void) strcpy(one, "", first, "");
  equal(strtok(one, "", ""), ""first"", 6);	/* Extra delims, 1 tok. */
  check(strtok((char *)NULL, "", "") == NULL, 7);
  (void) strcpy(one, ""1a, 1b; 2a, 2b"");
  equal(strtok(one, "", ""), ""1a"", 8);	/* Changing delim lists. */
  equal(strtok((char *)NULL, ""; ""), ""1b"", 9);
  equal(strtok((char *)NULL, "", ""), ""2a"", 10);
  (void) strcpy(two, ""x-y"");
  equal(strtok(two, ""-""), ""x"", 11);	/* New string before done. */
  equal(strtok((char *)NULL, ""-""), ""y"", 12);
  check(strtok((char *)NULL, ""-"") == NULL, 13);
  (void) strcpy(one, ""a,b, c,, ,d"");
  equal(strtok(one, "", ""), ""a"", 14);	/* Different separators. */
  equal(strtok((char *)NULL, "", ""), ""b"", 15);
  equal(strtok((char *)NULL, "" ,""), ""c"", 16);	/* Permute list too. */
  equal(strtok((char *)NULL, "" ,""), ""d"", 17);
  check(strtok((char *)NULL, "", "") == NULL, 18);
  check(strtok((char *)NULL, "", "") == NULL, 19);	/* Persistence. */
  (void) strcpy(one, "", "");
  check(strtok(one, "", "") == NULL, 20);	/* No tokens. */
  (void) strcpy(one, """");
  check(strtok(one, "", "") == NULL, 21);	/* Empty string. */
  (void) strcpy(one, ""abc"");
  equal(strtok(one, "", ""), ""abc"", 22);	/* No delimiters. */
  check(strtok((char *)NULL, "", "") == NULL, 23);
  (void) strcpy(one, ""abc"");
  equal(strtok(one, """"), ""abc"", 24);	/* Empty delimiter list. */
  check(strtok((char *)NULL, """") == NULL, 25);
  (void) strcpy(one, ""abcdefgh"");
  (void) strcpy(one, ""a,b,c"");
  equal(strtok(one, "",""), ""a"", 26);	/* Basics again... */
  equal(strtok((char *)NULL, "",""), ""b"", 27);
  equal(strtok((char *)NULL, "",""), ""c"", 28);
  check(strtok((char *)NULL, "","") == NULL, 29);
  equal(one+6, ""gh"", 30);			/* Stomped past end? */
  equal(one, ""a"", 31);			/* Stomped old tokens? */
  equal(one+2, ""b"", 32);
  equal(one+4, ""c"", 33);
}

static void
test_strtok_r (void)
{
  it = ""strtok_r"";
  (void) strcpy(one, ""first, second, third"");
  cp = NULL;	/* Always initialize cp to make sure it doesn't point to some old data.  */
  equal(strtok_r(one, "", "", &cp), ""first"", 1);	/* Basic test. */
  equal(one, ""first"", 2);
  equal(strtok_r((char *)NULL, "", "", &cp), ""second"", 3);
  equal(strtok_r((char *)NULL, "", "", &cp), ""third"", 4);
  check(strtok_r((char *)NULL, "", "", &cp) == NULL, 5);
  (void) strcpy(one, "", first, "");
  cp = NULL;
  equal(strtok_r(one, "", "", &cp), ""first"", 6);	/* Extra delims, 1 tok. */
  check(strtok_r((char *)NULL, "", "", &cp) == NULL, 7);
  (void) strcpy(one, ""1a, 1b; 2a, 2b"");
  cp = NULL;
  equal(strtok_r(one, "", "", &cp), ""1a"", 8);	/* Changing delim lists. */
  equal(strtok_r((char *)NULL, ""; "", &cp), ""1b"", 9);
  equal(strtok_r((char *)NULL, "", "", &cp), ""2a"", 10);
  (void) strcpy(two, ""x-y"");
  cp = NULL;
  equal(strtok_r(two, ""-"", &cp), ""x"", 11);	/* New string before done. */
  equal(strtok_r((char *)NULL, ""-"", &cp), ""y"", 12);
  check(strtok_r((char *)NULL, ""-"", &cp) == NULL, 13);
  (void) strcpy(one, ""a,b, c,, ,d"");
  cp = NULL;
  equal(strtok_r(one, "", "", &cp), ""a"", 14);	/* Different separators. */
  equal(strtok_r((char *)NULL, "", "", &cp), ""b"", 15);
  equal(strtok_r((char *)NULL, "" ,"", &cp), ""c"", 16);	/* Permute list too. */
  equal(strtok_r((char *)NULL, "" ,"", &cp), ""d"", 17);
  check(strtok_r((char *)NULL, "", "", &cp) == NULL, 18);
  check(strtok_r((char *)NULL, "", "", &cp) == NULL, 19);	/* Persistence. */
  (void) strcpy(one, "", "");
  cp = NULL;
  check(strtok_r(one, "", "", &cp) == NULL, 20);	/* No tokens. */
  (void) strcpy(one, """");
  cp = NULL;
  check(strtok_r(one, "", "", &cp) == NULL, 21);	/* Empty string. */
  check(strtok_r((char *)NULL, "", "", &cp) == NULL, 22);	/* Persistence. */
  (void) strcpy(one, ""abc"");
  cp = NULL;
  equal(strtok_r(one, "", "", &cp), ""abc"", 23);	/* No delimiters. */
  check(strtok_r((char *)NULL, "", "", &cp) == NULL, 24);
  (void) strcpy(one, ""abc"");
  cp = NULL;
  equal(strtok_r(one, """", &cp), ""abc"", 25);	/* Empty delimiter list. */
  check(strtok_r((char *)NULL, """", &cp) == NULL, 26);
  (void) strcpy(one, ""abcdefgh"");
  (void) strcpy(one, ""a,b,c"");
  cp = NULL;
  equal(strtok_r(one, "","", &cp), ""a"", 27);	/* Basics again... */
  equal(strtok_r((char *)NULL, "","", &cp), ""b"", 28);
  equal(strtok_r((char *)NULL, "","", &cp), ""c"", 29);
  check(strtok_r((char *)NULL, "","", &cp) == NULL, 30);
  equal(one+6, ""gh"", 31);			/* Stomped past end? */
  equal(one, ""a"", 32);				/* Stomped old tokens? */
  equal(one+2, ""b"", 33);
  equal(one+4, ""c"", 34);
  strcpy (one, "":::"");
  cp = NULL;
  check (strtok_r (one, "":"", &cp) == NULL, 35);	/* Must store pointer in cp. */
  check (strtok_r (NULL, "":"", &cp) == NULL, 36);
}

static void
test_strsep (void)
{
  char *ptr;
  it = ""strsep"";
  cp = strcpy(one, ""first, second, third"");
  equal(strsep(&cp, "", ""), ""first"", 1);	/* Basic test. */
  equal(one, ""first"", 2);
  equal(strsep(&cp, "", ""), """", 3);
  equal(strsep(&cp, "", ""), ""second"", 4);
  equal(strsep(&cp, "", ""), """", 5);
  equal(strsep(&cp, "", ""), ""third"", 6);
  check(strsep(&cp, "", "") == NULL, 7);
  cp = strcpy(one, "", first, "");
  equal(strsep(&cp, "", ""), """", 8);
  equal(strsep(&cp, "", ""), """", 9);
  equal(strsep(&cp, "", ""), ""first"", 10);	/* Extra delims, 1 tok. */
  equal(strsep(&cp, "", ""), """", 11);
  equal(strsep(&cp, "", ""), """", 12);
  check(strsep(&cp, "", "") == NULL, 13);
  cp = strcpy(one, ""1a, 1b; 2a, 2b"");
  equal(strsep(&cp, "", ""), ""1a"", 14);	/* Changing delim lists. */
  equal(strsep(&cp, "", ""), """", 15);
  equal(strsep(&cp, ""; ""), ""1b"", 16);
  equal(strsep(&cp, "", ""), """", 17);
  equal(strsep(&cp, "", ""), ""2a"", 18);
  cp = strcpy(two, ""x-y"");
  equal(strsep(&cp, ""-""), ""x"", 19);	/* New string before done. */
  equal(strsep(&cp, ""-""), ""y"", 20);
  check(strsep(&cp, ""-"") == NULL, 21);
  cp = strcpy(one, ""a,b, c,, ,d "");
  equal(strsep(&cp, "", ""), ""a"", 22);	/* Different separators. */
  equal(strsep(&cp, "", ""), ""b"", 23);
  equal(strsep(&cp, "" ,""), """", 24);
  equal(strsep(&cp, "" ,""), ""c"", 25);	/* Permute list too. */
  equal(strsep(&cp, "" ,""), """", 26);
  equal(strsep(&cp, "" ,""), """", 27);
  equal(strsep(&cp, "" ,""), """", 28);
  equal(strsep(&cp, "" ,""), ""d"", 29);
  equal(strsep(&cp, "" ,""), """", 30);
  check(strsep(&cp, "", "") == NULL, 31);
  check(strsep(&cp, "", "") == NULL, 32);	/* Persistence. */
  cp = strcpy(one, "", "");
  equal(strsep(&cp, "", ""), """", 33);
  equal(strsep(&cp, "", ""), """", 34);
  equal(strsep(&cp, "", ""), """", 35);
  check(strsep(&cp, "", "") == NULL, 36);	/* No tokens. */
  cp = strcpy(one, """");
  equal(strsep(&cp, "", ""), """", 37);
  check(strsep(&cp, "", "") == NULL, 38);	/* Empty string. */
  cp = strcpy(one, ""abc"");
  equal(strsep(&cp, "", ""), ""abc"", 39);	/* No delimiters. */
  check(strsep(&cp, "", "") == NULL, 40);
  cp = strcpy(one, ""abc"");
  equal(strsep(&cp, """"), ""abc"", 41);	/* Empty delimiter list. */
  check(strsep(&cp, """") == NULL, 42);
  (void) strcpy(one, ""abcdefgh"");
  cp = strcpy(one, ""a,b,c"");
  equal(strsep(&cp, "",""), ""a"", 43);	/* Basics again... */
  equal(strsep(&cp, "",""), ""b"", 44);
  equal(strsep(&cp, "",""), ""c"", 45);
  check(strsep(&cp, "","") == NULL, 46);
  equal(one+6, ""gh"", 47);		/* Stomped past end? */
  equal(one, ""a"", 48);			/* Stomped old tokens? */
  equal(one+2, ""b"", 49);
  equal(one+4, ""c"", 50);

  {
    char text[] = ""This,is,a,test"";
    char *list = strdupa (text);
    equal (strsep (&list, "",""), ""This"", 51);
    equal (strsep (&list, "",""), ""is"", 52);
    equal (strsep (&list, "",""), ""a"", 53);
    equal (strsep (&list, "",""), ""test"", 54);
    check (strsep (&list, "","") == NULL, 55);
  }

  cp = strcpy(one, ""a,b, c,, ,d,"");
  equal(strsep(&cp, "",""), ""a"", 56);	/* Different separators. */
  equal(strsep(&cp, "",""), ""b"", 57);
  equal(strsep(&cp, "",""), "" c"", 58);	/* Permute list too. */
  equal(strsep(&cp, "",""), """", 59);
  equal(strsep(&cp, "",""), "" "", 60);
  equal(strsep(&cp, "",""), ""d"", 61);
  equal(strsep(&cp, "",""), """", 62);
  check(strsep(&cp, "","") == NULL, 63);
  check(strsep(&cp, "","") == NULL, 64);	/* Persistence. */

  cp = strcpy(one, ""a,b, c,, ,d,"");
  equal(strsep(&cp, ""xy,""), ""a"", 65);	/* Different separators. */
  equal(strsep(&cp, ""x,y""), ""b"", 66);
  equal(strsep(&cp, "",xy""), "" c"", 67);	/* Permute list too. */
  equal(strsep(&cp, ""xy,""), """", 68);
  equal(strsep(&cp, ""x,y""), "" "", 69);
  equal(strsep(&cp, "",xy""), ""d"", 70);
  equal(strsep(&cp, ""xy,""), """", 71);
  check(strsep(&cp, ""x,y"") == NULL, 72);
  check(strsep(&cp, "",xy"") == NULL, 73);	/* Persistence. */

  cp = strcpy(one, ""ABC"");
  one[4] = ':';
  equal(strsep(&cp, ""C""), ""AB"", 74);	/* Access beyond NUL.  */
  ptr = strsep(&cp, "":"");
  equal(ptr, """", 75);
  check(ptr == one + 3, 76);
  check(cp == NULL, 77);

  cp = strcpy(one, ""ABC"");
  one[4] = ':';
  equal(strsep(&cp, ""CD""), ""AB"", 78);	/* Access beyond NUL.  */
  ptr = strsep(&cp, "":."");
  equal(ptr, """", 79);
  check(ptr == one + 3, 80);

  cp = strcpy(one, ""ABC"");		/* No token in string.  */
  equal(strsep(&cp, "",""), ""ABC"", 81);
  check(cp == NULL, 82);

  *one = '\0';				/* Empty string. */
  cp = one;
  ptr = strsep(&cp, "","");
  equal(ptr, """", 83);
  check(ptr == one, 84);
  check(cp == NULL, 85);

  *one = '\0';				/* Empty string and no token. */
  cp = one;
  ptr = strsep(&cp, """");
  equal(ptr, """", 86);
  check(ptr == one , 87);
  check(cp == NULL, 88);
}

static void
test_memcmp (void)
{
  int cnt = 1;
  char one[21];
  char two[21];

  it = ""memcmp"";
  check(memcmp(""a"", ""a"", 1) == 0, cnt++);	/* Identity. */
  check(memcmp(""abc"", ""abc"", 3) == 0, cnt++);	/* Multicharacter. */
  check(memcmp(""abcd"", ""abcf"", 4) < 0, cnt++);	/* Honestly unequal. */
  check(memcmp(""abcf"", ""abcd"", 4) > 0, cnt++);
  check(memcmp(""alph"", ""cold"", 4) < 0, cnt++);
  check(memcmp(""a\203"", ""a\003"", 2) > 0, cnt++);
  check(memcmp(""a\003"", ""a\203"", 2) < 0, cnt++);
  check(memcmp(""a\003bc"", ""a\203bc"", 2) < 0, cnt++);
  check(memcmp(""abc\203"", ""abc\003"", 4) > 0, cnt++);
  check(memcmp(""abc\003"", ""abc\203"", 4) < 0, cnt++);
  check(memcmp(""abcf"", ""abcd"", 3) == 0, cnt++);	/* Count limited. */
  check(memcmp(""abc"", ""def"", 0) == 0, cnt++);	/* Zero count. */
  /* Comparisons with shifting 4-byte boundaries. */
  for (int i = 0; i < 4; ++i)
    {
      char *a = one + i;
      char *b = two + i;
      strncpy(a, ""--------11112222"", 16);
      strncpy(b, ""--------33334444"", 16);
      check(memcmp(b, a, 16) > 0, cnt++);
      check(memcmp(a, b, 16) < 0, cnt++);
    }
}

static void
test_memchr (void)
{
  it = ""memchr"";
  check(memchr(""abcd"", 'z', 4) == NULL, 1);	/* Not found. */
  (void) strcpy(one, ""abcd"");
  check(memchr(one, 'c', 4) == one+2, 2);	/* Basic test. */
  check(memchr(one, ~0xff|'c', 4) == one+2, 2);	/* ignore highorder bits. */
  check(memchr(one, 'd', 4) == one+3, 3);	/* End of string. */
  check(memchr(one, 'a', 4) == one, 4);	/* Beginning. */
  check(memchr(one, '\0', 5) == one+4, 5);	/* Finding NUL. */
  (void) strcpy(one, ""ababa"");
  check(memchr(one, 'b', 5) == one+1, 6);	/* Finding first. */
  check(memchr(one, 'b', 0) == NULL, 7);	/* Zero count. */
  check(memchr(one, 'a', 1) == one, 8);	/* Singleton case. */
  (void) strcpy(one, ""a\203b"");
  check(memchr(one, 0203, 3) == one+1, 9);	/* Unsignedness. */

  /* now test all possible alignment and length combinations to catch
     bugs due to unrolled loops (assuming unrolling is limited to no
     more than 128 byte chunks: */
  {
    char buf[128 + sizeof(long)];
    long align, len, i, pos;

    for (align = 0; align < (long) sizeof(long); ++align) {
      for (len = 0; len < (long) (sizeof(buf) - align); ++len) {
	for (i = 0; i < len; ++i) {
	  buf[align + i] = 'x';		/* don't depend on memset... */
	}
	for (pos = 0; pos < len; ++pos) {
#if 0
	  printf(""align %d, len %d, pos %d\n"", align, len, pos);
#endif
	  check(memchr(buf + align, 'x', len) == buf + align + pos, 10);
	  check(memchr(buf + align, 'x', pos) == NULL, 11);
	  buf[align + pos] = '-';
	}
      }
    }
  }
}

static void
test_memcpy (void)
{
  int i;
  it = ""memcpy"";
  check(memcpy(one, ""abc"", 4) == one, 1);	/* Returned value. */
  equal(one, ""abc"", 2);			/* Did the copy go right? */

  (void) strcpy(one, ""abcdefgh"");
  (void) memcpy(one+1, ""xyz"", 2);
  equal(one, ""axydefgh"", 3);		/* Basic test. */

  (void) strcpy(one, ""abc"");
  (void) memcpy(one, ""xyz"", 0);
  equal(one, ""abc"", 4);			/* Zero-length copy. */

  (void) strcpy(one, ""hi there"");
  (void) strcpy(two, ""foo"");
  (void) memcpy(two, one, 9);
  equal(two, ""hi there"", 5);		/* Just paranoia. */
  equal(one, ""hi there"", 6);		/* Stomped on source? */

  for (i = 0; i < 16; i++)
    {
      const char *x = ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"";
      strcpy (one, x);
      check (memcpy (one + i, ""hi there"", 9) == one + i,
	     7 + (i * 6));		/* Unaligned destination. */
      check (memcmp (one, x, i) == 0, 8 + (i * 6));  /* Wrote under? */
      equal (one + i, ""hi there"", 9 + (i * 6));
      check (one[i + 9] == 'x', 10 + (i * 6));       /* Wrote over? */
      check (memcpy (two, one + i, 9) == two,
	     11 + (i * 6));		/* Unaligned source. */
      equal (two, ""hi there"", 12 + (i * 6));
    }
}

static void
test_mempcpy (void)
{
  int i;
  it = ""mempcpy"";
  check(mempcpy(one, ""abc"", 4) == one + 4, 1);	/* Returned value. */
  equal(one, ""abc"", 2);			/* Did the copy go right? */

  (void) strcpy(one, ""abcdefgh"");
  (void) mempcpy(one+1, ""xyz"", 2);
  equal(one, ""axydefgh"", 3);		/* Basic test. */

  (void) strcpy(one, ""abc"");
  (void) mempcpy(one, ""xyz"", 0);
  equal(one, ""abc"", 4);			/* Zero-length copy. */

  (void) strcpy(one, ""hi there"");
  (void) strcpy(two, ""foo"");
  (void) mempcpy(two, one, 9);
  equal(two, ""hi there"", 5);		/* Just paranoia. */
  equal(one, ""hi there"", 6);		/* Stomped on source? */

  for (i = 0; i < 16; i++)
    {
      const char *x = ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"";
      strcpy (one, x);
      check (mempcpy (one + i, ""hi there"", 9) == one + i + 9,
	     7 + (i * 6));		/* Unaligned destination. */
      check (memcmp (one, x, i) == 0, 8 + (i * 6));  /* Wrote under? */
      equal (one + i, ""hi there"", 9 + (i * 6));
      check (one[i + 9] == 'x', 10 + (i * 6));       /* Wrote over? */
      check (mempcpy (two, one + i, 9) == two + 9,
	     11 + (i * 6));		/* Unaligned source. */
      equal (two, ""hi there"", 12 + (i * 6));
    }
}

static void
test_memmove (void)
{
  it = ""memmove"";
  check(memmove(one, ""abc"", 4) == one, 1);	/* Returned value. */
  equal(one, ""abc"", 2);			/* Did the copy go right? */

  (void) strcpy(one, ""abcdefgh"");
  (void) memmove(one+1, ""xyz"", 2);
  equal(one, ""axydefgh"", 3);		/* Basic test. */

  (void) strcpy(one, ""abc"");
  (void) memmove(one, ""xyz"", 0);
  equal(one, ""abc"", 4);			/* Zero-length copy. */

  (void) strcpy(one, ""hi there"");
  (void) strcpy(two, ""foo"");
  (void) memmove(two, one, 9);
  equal(two, ""hi there"", 5);		/* Just paranoia. */
  equal(one, ""hi there"", 6);		/* Stomped on source? */

  (void) strcpy(one, ""abcdefgh"");
  (void) memmove(one+1, one, 9);
  equal(one, ""aabcdefgh"", 7);		/* Overlap, right-to-left. */

  (void) strcpy(one, ""abcdefgh"");
  (void) memmove(one+1, one+2, 7);
  equal(one, ""acdefgh"", 8);		/* Overlap, left-to-right. */

  (void) strcpy(one, ""abcdefgh"");
  (void) memmove(one, one, 9);
  equal(one, ""abcdefgh"", 9);		/* 100% overlap. */
}

static void
test_memccpy (void)
{
  /* First test like memcpy, then the search part The SVID, the only
     place where memccpy is mentioned, says overlap might fail, so we
     don't try it.  Besides, it's hard to see the rationale for a
     non-left-to-right memccpy.  */
  it = ""memccpy"";
  check(memccpy(one, ""abc"", 'q', 4) == NULL, 1);	/* Returned value. */
  equal(one, ""abc"", 2);			/* Did the copy go right? */

  (void) strcpy(one, ""abcdefgh"");
  (void) memccpy(one+1, ""xyz"", 'q', 2);
  equal(one, ""axydefgh"", 3);		/* Basic test. */

  (void) strcpy(one, ""abc"");
  (void) memccpy(one, ""xyz"", 'q', 0);
  equal(one, ""abc"", 4);			/* Zero-length copy. */

  (void) strcpy(one, ""hi there"");
  (void) strcpy(two, ""foo"");
  (void) memccpy(two, one, 'q', 9);
  equal(two, ""hi there"", 5);		/* Just paranoia. */
  equal(one, ""hi there"", 6);		/* Stomped on source? */

  (void) strcpy(one, ""abcdefgh"");
  (void) strcpy(two, ""horsefeathers"");
  check(memccpy(two, one, 'f', 9) == two+6, 7);	/* Returned value. */
  equal(one, ""abcdefgh"", 8);		/* Source intact? */
  equal(two, ""abcdefeathers"", 9);		/* Copy correct? */

  (void) strcpy(one, ""abcd"");
  (void) strcpy(two, ""bumblebee"");
  check(memccpy(two, one, 'a', 4) == two+1, 10);	/* First char. */
  equal(two, ""aumblebee"", 11);
  check(memccpy(two, one, 'd', 4) == two+4, 12);	/* Last char. */
  equal(two, ""abcdlebee"", 13);
  (void) strcpy(one, ""xyz"");
  check(memccpy(two, one, 'x', 1) == two+1, 14);	/* Singleton. */
  equal(two, ""xbcdlebee"", 15);
}

static void
test_memset (void)
{
  int i;

  it = ""memset"";
  (void) strcpy(one, ""abcdefgh"");
  check(memset(one+1, 'x', 3) == one+1, 1);	/* Return value. */
  equal(one, ""axxxefgh"", 2);		/* Basic test. */

  (void) memset(one+2, 'y', 0);
  equal(one, ""axxxefgh"", 3);		/* Zero-length set. */

  (void) memset(one+5, 0, 1);
  equal(one, ""axxxe"", 4);			/* Zero fill. */
  equal(one+6, ""gh"", 5);			/* And the leftover. */

  (void) memset(one+2, 010045, 1);
  equal(one, ""ax\045xe"", 6);		/* Unsigned char convert. */

  /* Non-8bit fill character.  */
  memset (one, 0x101, sizeof (one));
  for (i = 0; i < (int) sizeof (one); ++i)
    check (one[i] == '\01', 7);

  /* Test for more complex versions of memset, for all alignments and
     lengths up to 256. This test takes a little while, perhaps it should
     be made weaker?  */
  {
    char data[512];
    int j;
    int k;
    int c;

    for (i = 0; i < 512; i++)
      data[i] = 'x';
    for (c = 0; c <= 'y'; c += 'y')  /* check for memset(,0,) and
					memset(,'y',) */
      for (j = 0; j < 256; j++)
	for (i = 0; i < 256; i++)
	  {
	    memset (data + i, c, j);
	    for (k = 0; k < i; k++)
	      if (data[k] != 'x')
		goto fail;
	    for (k = i; k < i+j; k++)
	      {
		if (data[k] != c)
		  goto fail;
		data[k] = 'x';
	      }
	    for (k = i+j; k < 512; k++)
	      if (data[k] != 'x')
		goto fail;
	    continue;

	  fail:
	    check (0, 8 + i + j * 256 + (c != 0) * 256 * 256);
	  }
  }
}

static void
test_bcopy (void)
{
  /* Much like memcpy.  Berklix manual is silent about overlap, so
     don't test it.  */
  it = ""bcopy"";
  (void) bcopy(""abc"", one, 4);
  equal(one, ""abc"", 1);			/* Simple copy. */

  (void) strcpy(one, ""abcdefgh"");
  (void) bcopy(""xyz"", one+1, 2);
  equal(one, ""axydefgh"", 2);		/* Basic test. */

  (void) strcpy(one, ""abc"");
  (void) bcopy(""xyz"", one, 0);
  equal(one, ""abc"", 3);			/* Zero-length copy. */

  (void) strcpy(one, ""hi there"");
  (void) strcpy(two, ""foo"");
  (void) bcopy(one, two, 9);
  equal(two, ""hi there"", 4);		/* Just paranoia. */
  equal(one, ""hi there"", 5);		/* Stomped on source? */
}

static void
test_bzero (void)
{
  it = ""bzero"";
  (void) strcpy(one, ""abcdef"");
  bzero(one+2, 2);
  equal(one, ""ab"", 1);			/* Basic test. */
  equal(one+3, """", 2);
  equal(one+4, ""ef"", 3);

  (void) strcpy(one, ""abcdef"");
  bzero(one+2, 0);
  equal(one, ""abcdef"", 4);		/* Zero-length copy. */
}

static void
test_strndup (void)
{
  char *p, *q;
  it = ""strndup"";
  p = strndup(""abcdef"", 12);
  check(p != NULL, 1);
  if (p != NULL)
    {
      equal(p, ""abcdef"", 2);
      q = strndup(p + 1, 2);
      check(q != NULL, 3);
      if (q != NULL)
	equal(q, ""bc"", 4);
      free (q);
    }
  free (p);
  p = strndup(""abc def"", 3);
  check(p != NULL, 5);
  if (p != NULL)
    equal(p, ""abc"", 6);
  free (p);
}

static void
test_bcmp (void)
{
  it = ""bcmp"";
  check(bcmp(""a"", ""a"", 1) == 0, 1);	/* Identity. */
  check(bcmp(""abc"", ""abc"", 3) == 0, 2);	/* Multicharacter. */
  check(bcmp(""abcd"", ""abce"", 4) != 0, 3);	/* Honestly unequal. */
  check(bcmp(""abce"", ""abcd"", 4) != 0, 4);
  check(bcmp(""alph"", ""beta"", 4) != 0, 5);
  check(bcmp(""abce"", ""abcd"", 3) == 0, 6);	/* Count limited. */
  check(bcmp(""abc"", ""def"", 0) == 0, 8);	/* Zero count. */
}

static void
test_strerror (void)
{
  it = ""strerror"";
  check(strerror(EDOM) != 0, 1);
  check(strerror(ERANGE) != 0, 2);
  check(strerror(ENOENT) != 0, 3);
}

static void
test_strcasecmp (void)
{
  it = ""strcasecmp"";
  /* Note that the locale is ""C"".  */
  check(strcasecmp(""a"", ""a"") == 0, 1);
  check(strcasecmp(""a"", ""A"") == 0, 2);
  check(strcasecmp(""A"", ""a"") == 0, 3);
  check(strcasecmp(""a"", ""b"") < 0, 4);
  check(strcasecmp(""c"", ""b"") > 0, 5);
  check(strcasecmp(""abc"", ""AbC"") == 0, 6);
  check(strcasecmp(""0123456789"", ""0123456789"") == 0, 7);
  check(strcasecmp("""", ""0123456789"") < 0, 8);
  check(strcasecmp(""AbC"", """") > 0, 9);
  check(strcasecmp(""AbC"", ""A"") > 0, 10);
  check(strcasecmp(""AbC"", ""Ab"") > 0, 11);
  check(strcasecmp(""AbC"", ""ab"") > 0, 12);
}

static void
test_strncasecmp (void)
{
  it = ""strncasecmp"";
  /* Note that the locale is ""C"".  */
  check(strncasecmp(""a"", ""a"", 5) == 0, 1);
  check(strncasecmp(""a"", ""A"", 5) == 0, 2);
  check(strncasecmp(""A"", ""a"", 5) == 0, 3);
  check(strncasecmp(""a"", ""b"", 5) < 0, 4);
  check(strncasecmp(""c"", ""b"", 5) > 0, 5);
  check(strncasecmp(""abc"", ""AbC"", 5) == 0, 6);
  check(strncasecmp(""0123456789"", ""0123456789"", 10) == 0, 7);
  check(strncasecmp("""", ""0123456789"", 10) < 0, 8);
  check(strncasecmp(""AbC"", """", 5) > 0, 9);
  check(strncasecmp(""AbC"", ""A"", 5) > 0, 10);
  check(strncasecmp(""AbC"", ""Ab"", 5) > 0, 11);
  check(strncasecmp(""AbC"", ""ab"", 5) > 0, 12);
  check(strncasecmp(""0123456789"", ""AbC"", 0) == 0, 13);
  check(strncasecmp(""AbC"", ""abc"", 1) == 0, 14);
  check(strncasecmp(""AbC"", ""abc"", 2) == 0, 15);
  check(strncasecmp(""AbC"", ""abc"", 3) == 0, 16);
  check(strncasecmp(""AbC"", ""abcd"", 3) == 0, 17);
  check(strncasecmp(""AbC"", ""abcd"", 4) < 0, 18);
  check(strncasecmp(""ADC"", ""abcd"", 1) == 0, 19);
  check(strncasecmp(""ADC"", ""abcd"", 2) > 0, 20);
}

int
main (void)
{
  int status;

  /* Test strcmp first because we use it to test other things.  */
  test_strcmp ();

  /* Test strcpy next because we need it to set up other tests.  */
  test_strcpy ();

  /* A closely related function is stpcpy.  */
  test_stpcpy ();

  /* stpncpy.  */
  test_stpncpy ();

  /* strcat.  */
  test_strcat ();

  /* strncat.  */
  test_strncat ();

  /* strncmp.  */
  test_strncmp ();

  /* strncpy.  */
  test_strncpy ();

  /* strlen.  */
  test_strlen ();

  /* strnlen.  */
  test_strnlen ();

  /* strchr.  */
  test_strchr ();

  /* strchrnul.  */
  test_strchrnul ();

  /* rawmemchr.  */
  test_rawmemchr ();

  /* index - just like strchr.  */
  test_index ();

  /* strrchr.  */
  test_strrchr ();

  /* memrchr.  */
  test_memrchr ();

  /* rindex - just like strrchr.  */
  test_rindex ();

  /* strpbrk - somewhat like strchr.  */
  test_strpbrk ();

  /* strstr - somewhat like strchr.  */
  test_strstr ();

  /* strspn.  */
  test_strspn ();

  /* strcspn.  */
  test_strcspn ();

  /* strtok - the hard one.  */
  test_strtok ();

  /* strtok_r.  */
  test_strtok_r ();

  /* strsep.  */
  test_strsep ();

  /* memcmp.  */
  test_memcmp ();

  /* memchr.  */
  test_memchr ();

  /* memcpy - need not work for overlap.  */
  test_memcpy ();

  /* memmove - must work on overlap.  */
  test_memmove ();

  /* mempcpy */
  test_mempcpy ();

  /* memccpy.  */
  test_memccpy ();

  /* memset.  */
  test_memset ();

  /* bcopy.  */
  test_bcopy ();

  /* bzero.  */
  test_bzero ();

  /* bcmp - somewhat like memcmp.  */
  test_bcmp ();

  /* strndup.  */
  test_strndup ();

  /* strerror - VERY system-dependent.  */
  test_strerror ();

  /* strcasecmp.  Without locale dependencies.  */
  test_strcasecmp ();

  /* strncasecmp.  Without locale dependencies.  */
  test_strncasecmp ();

  if (errors == 0)
    {
      status = EXIT_SUCCESS;
      puts(""No errors."");
    }
  else
    {
      status = EXIT_FAILURE;
      printf(""%Zd errors.\n"", errors);
    }

  return status;
}
"
067-1732,DYNA-instruments-open-source/eco-g45-linux-bsp,BSP-3.14/local_src/common/imx-test-11.09.01/test/mxc_sound_test/check_2w1r.c,134,9,135,2094767.8713127498,177760.0,11.784242799279928,1368.0,1350.0,40466.0,13939.0,1645.0,646.0,1364.0,601.0,1500000000,0.0013965119142085,1082014363648.0,0.0152902790279027,0.0782281040345556,"/*
 * Copyright 2004-2006 Freescale Semiconductor, Inc. All rights reserved.
 */

/*
 * The code contained herein is licensed under the GNU General Public
 * License. You may obtain a copy of the GNU General Public License
 * Version 2 or later at the following locations:
 *
 * http://www.opensource.org/licenses/gpl-license.html
 * http://www.gnu.org/copyleft/gpl.html
 */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>

#define MAX_INSTANCES                   2

#define AUDIODEV_CODEC                  ""/dev/sound/dsp""
#define AUDIODEV_STDAC                  ""/dev/sound/dsp1""

int main(int ac, char *av[])
{
	int fd_audio[MAX_INSTANCES], i, err;
	err = 0;

	printf(""Hi... \n"");

	printf
	    (""This program checks that it is possible to open the driver for 2W and 1R \n"");
	printf(""-> main <no arg>\n\n"");

	for (i = 0; i < MAX_INSTANCES; i++) {
		fd_audio[i] = -1;
	}

	/** 2 open in RDWR should fail */
	if ((fd_audio[0] = open(AUDIODEV_CODEC, O_RDWR)) < 0) {
		printf(""[2 open in RDWR] Error at first opening\n"");
		err++;
	}

	if ((fd_audio[1] = open(AUDIODEV_STDAC, O_RDWR)) >= 0) {
		printf(""[2 open in RDWR] Error : 2RW allowed\n"");
		err++;
	}

	for (i = 0; i < MAX_INSTANCES; i++) {
		if (fd_audio[i] >= 0) {
			close(fd_audio[i]);
			fd_audio[i] = -1;
		}
	}

	/** 2 open in WR should not fail */
	if ((fd_audio[0] = open(AUDIODEV_CODEC, O_WRONLY)) < 0) {
		printf(""[2 open in WR] Error at first opening\n"");
		err++;
	}

	if ((fd_audio[1] = open(AUDIODEV_STDAC, O_WRONLY)) < 0) {
		printf(""[2 open in WR] Error at second opening\n"");
		err++;
	}

	for (i = 0; i < MAX_INSTANCES; i++) {
		if (fd_audio[i] >= 0) {
			close(fd_audio[i]);
			fd_audio[i] = -1;
		}
	}

	/** second open in RD should fail */
	if ((fd_audio[0] = open(AUDIODEV_CODEC, O_RDONLY)) < 0) {
		printf(""[2 open in RD] Error at first opening\n"");
		err++;
	}

	if ((fd_audio[1] = open(AUDIODEV_STDAC, O_RDONLY)) >= 0) {
		printf(""[2 open in RD] Error : 2RW allowed\n"");
		err++;
	}

	for (i = 0; i < MAX_INSTANCES; i++) {
		if (fd_audio[i] >= 0) {
			close(fd_audio[i]);
			fd_audio[i] = -1;
		}
	}

	/** 1 RD + 1 WR should not fail */
	if ((fd_audio[0] = open(AUDIODEV_CODEC, O_RDONLY)) < 0) {
		printf(""[1 RD + 1 WR] Error at first opening\n"");
		err++;
	}

	if ((fd_audio[1] = open(AUDIODEV_STDAC, O_WRONLY)) < 0) {
		printf(""[1 RD + 1 WR] Error at second opening\n"");
		err++;
	}

	for (i = 0; i < MAX_INSTANCES; i++) {
		if (fd_audio[i] >= 0) {
			close(fd_audio[i]);
			fd_audio[i] = -1;
		}
	}

	/** 1 RDWR + 1 WR should not fail */
	if ((fd_audio[0] = open(AUDIODEV_CODEC, O_RDWR)) < 0) {
		printf(""[1 RDWR + 1 WR] Error at first opening\n"");
		err++;
	}

	if ((fd_audio[1] = open(AUDIODEV_STDAC, O_WRONLY)) < 0) {
		printf(""[1 RDWR + 1 WR] Error at second opening\n"");
		err++;
	}

	for (i = 0; i < MAX_INSTANCES; i++) {
		if (fd_audio[i] >= 0) {
			close(fd_audio[i]);
			fd_audio[i] = -1;
		}
	}

	/** 1 RD + 1 RDWR should fail */
	if ((fd_audio[0] = open(AUDIODEV_CODEC, O_RDONLY)) < 0) {
		printf(""[1 RD + 1 RDWR] Error at first opening\n"");
		err++;
	}

	if ((fd_audio[1] = open(AUDIODEV_STDAC, O_RDWR)) >= 0) {
		printf(""[1 RD + 1 RDWR] Error : second opening should fail\n"");
		err++;
	}

	for (i = 0; i < MAX_INSTANCES; i++) {
		if (fd_audio[i]) {
			close(fd_audio[i]);
			fd_audio[i] = -1;
		}
	}

	/** 1 RDWR + 1 RD should fail */
	if ((fd_audio[0] = open(AUDIODEV_CODEC, O_RDWR)) < 0) {
		printf(""[1 RDWR + 1 RD] Error at first opening\n"");
		err++;
	}

	if ((fd_audio[1] = open(AUDIODEV_STDAC, O_RDONLY)) >= 0) {
		printf(""[1 RDWR + 1 RD] Error : second opening should fail\n"");
		err++;
	}

	for (i = 0; i < MAX_INSTANCES; i++) {
		if (fd_audio[i] >= 0) {
			close(fd_audio[i]);
			fd_audio[i] = -1;
		}
	}

	if (err == 0) {
		printf(""\n --> All the tests were passed successfully\n"");
	} else {
		printf(""\nEncountered %i errors\n"", err);
	}

	return 0;

}
"
319-29343,crazyleen/msp430-gdb-7.2a,gdb/testsuite/gdb.base/whatis.c,241,5,174,1572692.99961615,169168.0,9.296628203915636,1153.0,1143.0,38464.0,12754.0,1570.0,595.0,1319.0,556.0,1500000000,0.0010484619997441,1082014363648.0,0.0135723068192565,0.0788785192705689,"/* This test program is part of GDB, the GNU debugger.

   Copyright 1992, 1993, 1994, 1997, 1999, 2004, 2007, 2008, 2009, 2010
   Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */

/*
 *	Test file with lots of different types, for testing the
 *	""whatis"" command.
 */

/*
 *	First the basic C types.
 */

char		v_char;
signed char	v_signed_char;
unsigned char	v_unsigned_char;

short		v_short;
signed short	v_signed_short;
unsigned short	v_unsigned_short;

int		v_int;
signed int	v_signed_int;
unsigned int	v_unsigned_int;

long		v_long;
signed long	v_signed_long;
unsigned long	v_unsigned_long;

#ifndef NO_LONG_LONG
long long		v_long_long;
signed long long	v_signed_long_long;
unsigned long long	v_unsigned_long_long;
#endif

float		v_float;
double		v_double;

/*
 *	Now some derived types, which are arrays, functions-returning,
 *	pointers, structures, unions, and enumerations.
 */

/**** arrays *******/

char		v_char_array[2];
signed char	v_signed_char_array[2];
unsigned char	v_unsigned_char_array[2];

short		v_short_array[2];
signed short	v_signed_short_array[2];
unsigned short	v_unsigned_short_array[2];

int		v_int_array[2];
signed int	v_signed_int_array[2];
unsigned int	v_unsigned_int_array[2];

long		v_long_array[2];
signed long	v_signed_long_array[2];
unsigned long	v_unsigned_long_array[2];

#ifndef NO_LONG_LONG
long long		v_long_long_array[2];
signed long long	v_signed_long_long_array[2];
unsigned long long	v_unsigned_long_long_array[2];
#endif

float		v_float_array[2];
double		v_double_array[2];

/**** pointers *******/

/* Make sure they still print as pointer to foo even there is a typedef
   for that type.  Test this not just for char *, which might be
   a special case kludge in GDB (Unix system include files like to define
   caddr_t), but for a variety of types.  */
typedef char *char_addr;
static char_addr a_char_addr;
typedef unsigned short *ushort_addr;
static ushort_addr a_ushort_addr;
typedef signed long *slong_addr;
static slong_addr a_slong_addr;
#ifndef NO_LONG_LONG
typedef signed long long *slong_long_addr;
static slong_long_addr a_slong_long_addr;
#endif

char		*v_char_pointer;
signed char	*v_signed_char_pointer;
unsigned char	*v_unsigned_char_pointer;

short		*v_short_pointer;
signed short	*v_signed_short_pointer;
unsigned short	*v_unsigned_short_pointer;

int		*v_int_pointer;
signed int	*v_signed_int_pointer;
unsigned int	*v_unsigned_int_pointer;

long		*v_long_pointer;
signed long	*v_signed_long_pointer;
unsigned long	*v_unsigned_long_pointer;

#ifndef NO_LONG_LONG
long long		*v_long_long_pointer;
signed long long	*v_signed_long_long_pointer;
unsigned long long	*v_unsigned_long_long_pointer;
#endif

float		*v_float_pointer;
double		*v_double_pointer;

/**** structs *******/

struct t_struct {
    char	v_char_member;
    short	v_short_member;
    int		v_int_member;
    long	v_long_member;
#ifndef NO_LONG_LONG
    long long	v_long_long_member;
#endif
    float	v_float_member;
    double	v_double_member;
} v_struct1;

struct {
    char	v_char_member;
    short	v_short_member;
    int		v_int_member;
    long	v_long_member;
#ifndef NO_LONG_LONG
    long long	v_long_long_member;
#endif
    float	v_float_member;
    double	v_double_member;
} v_struct2;

/**** unions *******/

union t_union {
    char	v_char_member;
    short	v_short_member;
    int		v_int_member;
    long	v_long_member;
#ifndef NO_LONG_LONG
    long long	v_long_long_member;
#endif
    float	v_float_member;
    double	v_double_member;
} v_union;

union {
    char	v_char_member;
    short	v_short_member;
    int		v_int_member;
    long	v_long_member;
#ifndef NO_LONG_LONG
    long long	v_long_long_member;
#endif
    float	v_float_member;
    double	v_double_member;
} v_union2;

/*** Functions returning type ********/

char		v_char_func () { return(0); }
signed char	v_signed_char_func () { return (0); }
unsigned char	v_unsigned_char_func () { return (0); }

short		v_short_func () { return (0); }
signed short	v_signed_short_func () { return (0); }
unsigned short	v_unsigned_short_func () { return (0); }

int		v_int_func () { return (0); }
signed int	v_signed_int_func () { return (0); }
unsigned int	v_unsigned_int_func () { return (0); }

long		v_long_func () { return (0); }
signed long	v_signed_long_func () { return (0); }
unsigned long	v_unsigned_long_func () { return (0); }

#ifndef NO_LONG_LONG
long long		v_long_long_func () { return (0); }
signed long long	v_signed_long_long_func () { return (0); }
unsigned long long	v_unsigned_long_long_func () { return (0); }
#endif

float		v_float_func () { return (0.0); }
double		v_double_func () { return (0.0); }

/**** Some misc more complicated things *******/

struct link {
	struct link *next;
#ifdef __STDC__
	struct link *(*linkfunc) (struct link *this, int flags);
#else
	struct link *(*linkfunc) ();
#endif
	struct t_struct stuff[1][2][3];
} *s_link;

union tu_link {
	struct link *next;
#ifdef __STDC__
	struct link *(*linkfunc) (struct link *this, int flags);
#else
	struct link *(*linkfunc) ();
#endif
	struct t_struct stuff[1][2][3];
} u_link;

struct outer_struct {
	int outer_int;
	struct inner_struct {
		int inner_int;
		long inner_long;
	}inner_struct_instance;
	union inner_union {
		int inner_union_int;
		long inner_union_long;
	}inner_union_instance;
	long outer_long;
} nested_su;

/**** Enumerations *******/

enum colors {red, green, blue} color;
enum cars {chevy, ford, porsche} clunker;

/***********/

int main ()
{
#ifdef usestubs
  set_debug_traps();
  breakpoint();
#endif
  /* Some linkers (e.g. on AIX) remove unreferenced variables,
     so make sure to reference them. */
  v_char = 0;
  v_signed_char = 1;
  v_unsigned_char = 2;

  v_short = 3;
  v_signed_short = 4;
  v_unsigned_short = 5;    

  v_int = 6;
  v_signed_int = 7;
  v_unsigned_int = 8;    

  v_long = 9;
  v_signed_long = 10;
  v_unsigned_long = 11;    

#ifndef NO_LONG_LONG
  v_long_long = 12;
  v_signed_long_long = 13;
  v_unsigned_long_long = 14;
#endif

  v_float = 100.0;
  v_double = 200.0;


  v_char_array[0] = v_char;
  v_signed_char_array[0] = v_signed_char;
  v_unsigned_char_array[0] = v_unsigned_char;

  v_short_array[0] = v_short;
  v_signed_short_array[0] = v_signed_short;
  v_unsigned_short_array[0] = v_unsigned_short;

  v_int_array[0] = v_int;
  v_signed_int_array[0] = v_signed_int;
  v_unsigned_int_array[0] = v_unsigned_int;

  v_long_array[0] = v_long;
  v_signed_long_array[0] = v_signed_long;
  v_unsigned_long_array[0] = v_unsigned_long;

#ifndef NO_LONG_LONG
  v_long_long_array[0] = v_long_long;
  v_signed_long_long_array[0] = v_signed_long_long;
  v_unsigned_long_long_array[0] = v_unsigned_long_long;
#endif

  v_float_array[0] = v_float;
  v_double_array[0] = v_double;

  v_char_pointer = &v_char;
  v_signed_char_pointer = &v_signed_char;
  v_unsigned_char_pointer = &v_unsigned_char;

  v_short_pointer = &v_short;
  v_signed_short_pointer = &v_signed_short;
  v_unsigned_short_pointer = &v_unsigned_short;

  v_int_pointer = &v_int;
  v_signed_int_pointer = &v_signed_int;
  v_unsigned_int_pointer = &v_unsigned_int;

  v_long_pointer = &v_long;
  v_signed_long_pointer = &v_signed_long;
  v_unsigned_long_pointer = &v_unsigned_long;

#ifndef NO_LONG_LONG
  v_long_long_pointer = &v_long_long;
  v_signed_long_long_pointer = &v_signed_long_long;
  v_unsigned_long_long_pointer = &v_unsigned_long_long;
#endif

  v_float_pointer = &v_float;
  v_double_pointer = &v_double;

  color = red;
  clunker = porsche;

  u_link.next = s_link;

  v_union2.v_short_member = v_union.v_short_member;

  v_struct1.v_char_member = 0;
  v_struct2.v_char_member = 0;

  nested_su.outer_int = 0;
  return 0;
}
"
224-6279,griffint/SoftwareSystems,lecture15/list.c,121,7,138,1524256.7751556502,184467.0,13.49628388817512,1372.0,1351.0,41831.0,14894.0,1639.0,643.0,1357.0,600.0,1500000000,0.0010161711834371,1082014363648.0,0.0147614478470403,0.0747289554869986,"/* Example code for Software Systems at Olin College.

Based on an example from http://www.learn-c.org/en/Linked_lists

Copyright 2014 Allen Downey
License: Creative Commons Attribution-ShareAlike 3.0

*/

#include <stdio.h>
#include <stdlib.h>

typedef struct node {
    int val;
    struct node * next;
} Node;

// Makes a new node
Node *make_node(int val, Node *next) {
    Node *node = malloc(sizeof(Node)); //make memory space for new node
    node->val = val;
    node->next = next;
    return node;
}

// prints a list, input *head points to the first node
void print_list(Node *head) {
    printf(""\nprinting the list\n"");
    Node *current = head;

    while (current != NULL) { // prints node values until 
        printf(""%d\n"", current->val);
        current = current->next;
    }
}

//removes the first element from the list, and returns its value
int pop(Node **head) {
    int retval; //this will return the value of the node to be popped
    Node *next_node;
    Node **first = head;
    if (first == NULL) { // if we have no linked elements from head, stop
        return -1;
    }

    next_node = (*first)->next;
    retval = (*first)->val;
    free(*first);
    *first = next_node;

    printf(""The val of node we just popped is : %d\n"", retval);
    return retval;
}

// Add a new element to the beginning of the list.
void push(Node **head, int val) { //takes a double pointer to a node as well as a int val as input
    // FILL THIS IN!
    //first we get the address of the first node
    //then make a new node pointing to that one
    //*head is the pointer to the first node
    Node *new_first = make_node(val, NULL);
    new_first->next = *head;
    *head = new_first;

}

// Remove the first element with the given value; return the number
// of nodes removed.
//TODO: this might not work if the node to remove is the first node
int remove_by_value(Node **head, int val) {
    // FILL THIS IN!
    // maybe a while loop until val matches the node value
    printf(""\nstarting remove_by_value\n"");
    Node *current = *head;

    //check if the first node is bad 
    if (current->val == val){
        int val_popped = pop(head);
        printf(""the first node matched by val, so we popped it with val=%d/n"", val_popped);
        return 0;
    }

    while (val != current->val) {
        printf(""current val is :%d\n"", current->val);
        if (current->next == NULL){
            printf(""val not found\n"");
            return -1;
        }
        current = current->next;
        //if we're at the end without finding it
    }
    if (val == current->val){
        printf(""we found the value which in our list is : %d\n"",current->val);   
        //now to remove this value
        //we need to make the node before this one point to the one after
        //and maybe free the memorey of this node but not essential
        Node *pointer_to_remove = current;
        Node *point_to_next = current->next;
        Node *current = *head;
        while (pointer_to_remove != current->next) { //run this loop until we're one before the one to remove
            current = current->next;
        }
        if (current->next == pointer_to_remove) {
            current->next = point_to_next;
        }
        return 0;
    }

    return 0;

}

// Reverse the elements of the list without allocating new nodes.
void reverse(Node **head) {
    // FILL THIS IN!
    Node *node = *head;
    Node *next, *temp;

    if (node == NULL || node->next == NULL) {
    return;
    }

    next = node->next;
    node->next = NULL;

    while (next != NULL) {
    temp = next->next;
    next->next = node;
    node = next;
    next = temp;
    }
}


int main() {
    Node *test_list = make_node(1, NULL);
    test_list->next = make_node(2, NULL);
    test_list->next->next = make_node(3, NULL);
    test_list->next->next->next = make_node(4, NULL);

    int retval = pop(&test_list);

    
    push(&test_list, retval+10);

    remove_by_value(&test_list, 3);
    remove_by_value(&test_list,7);

    print_list(test_list);

    reverse(&test_list);
    
    print_list(test_list);
}
"
296-30639,metbosch/PCA-Lab,lab4_session/pi/pi.c,159,7,80,3919918837.607838,4816907250.0,0.8137833330712357,1327.0,1310.0,1354150568.0,602330561.0,7178207.0,1111960.0,1367.0,1464.0,1500000000,2.613279225071892,1082014363648.0,5.474467045218693e-07,0.0042387314025557,"#include <memory.h>
#include <stdio.h>
#include <stdlib.h>

int N, N4;
char a[10240], b[10240], c[10240];
char string[100];

#define DIVIDE(x,n) ({ \
   int j, k; \
   unsigned q, r, u; \
   long v; \
   r = 0; \
   for(k = 0; k <= N4; k++ ) {\
        u = r * 10 + (x)[k];\
        q = u / (n);\
        r = u - q * (n);\
        (x)[k] = q;\
    }\
})


void LONGDIV( char *x, int n )                          
{                                                
    int j, k;
    unsigned q, r, u;
    long v;

    if( n < 6553 )                               
    {                                            
        r = 0;                                   
        for( k = 0; k <= N4; k++ )               
        {                                        
            u = r * 10 + x[k];                   
            q = u / n;                           
            r = u - q * n;                       
            x[k] = q;                            
        }                                       
    }                                            
    else                                         
    {                                            
        r = 0;                                   
        for( k = 0; k <= N4; k++ )              
        {                                       
            if( r < 6553 )                      
            {                                   
                u = r * 10 + x[k];              
                q = u / n;                      
                r = u - q * n;                  
            }                                   
            else                                
            {                                   
                v = (long) r * 10 + x[k];       
                q = v / n;                      
                r = v - q * n;                  
            }                                   
            x[k] = q;                           
        }                                       
    }                                           
}

void MULTIPLY( char *x, int n )                        
{                                            
    int j, k;
    unsigned q, r, u;
    long v;
    r = 0;                                   
    for( k = N4; k >= 0; k-- )               
    {                                        
        q = n * x[k] + r;                    
        r = q / 10;                          
        x[k] = q - r * 10;                   
    }                                        
}

void SET( char *x, int n )                              
{                                                
    memset( x, 0, N4 + 1 );                      
    x[0] = n;                                    
}


void SUBTRACT( char *x, char *y, char *z )                      
{                                                
    int j, k;
    unsigned q, r, u;
    long v;
    for( k = N4; k >= 0; k-- )                   
    {                                            
        if( (x[k] = y[k] - z[k]) < 0 )           
        {                                        
            x[k] += 10;                          
            z[k-1]++;                            
        }                                        
    }                                            
}


void calculate( void );
void progress( void );
void epilog( void );


int main( int argc, char *argv[] )
{
    N = 10000;

    if (argc>1)
      N = atoi(argv[1]);

    setbuf(stdout, NULL);

    calculate();

    epilog();

    return 0;
}

void calculate( void )
{
    int j;

    N4 = N + 4;

    SET( a, 0 );
    SET( b, 0 );

    for( j = 2 * N4 + 1; j >= 3; j -= 2 )
    {
        SET( c, 1 );
        LONGDIV( c, j );

        SUBTRACT( a, c, a );
        DIVIDE( a, 25 );

        SUBTRACT( b, c, b );
        DIVIDE( b, 239 );
        DIVIDE( b, 239 );

        progress();
    }

    SET( c, 1 );

    SUBTRACT( a, c, a );
    DIVIDE( a, 5 );

    SUBTRACT( b, c, b );
    DIVIDE( b, 239 );

    MULTIPLY( a, 4 );
    SUBTRACT( a, a, b );
    MULTIPLY( a, 4 );

    progress();
}

/*

 N = 10000                      
 A = 0                          
 B = 0                          
 J = 2 * (N + 4) + 1            
 FOR J = J TO 3 STEP -2         
     A = (1 / J - A) / 5 ^ 2    
     B = (1 / J - B) / 239 ^ 2  
 NEXT J                         
 A = (1 - A) / 5                
 B = (1 - B) / 239              
 PI = (A * 4 - B) * 4           

*/

void progress( void )
{
    printf(""."");
}

void epilog( void )
{
    int j;

    {
        fprintf( stdout, "" \n3."");
        for( j = 1; j <= N; j++ )
        {
            fprintf( stdout, ""%d"", a[j]);
            if( j % 5  == 0 )
                if( j % 50 == 0 )
                    if( j % 250  == 0 )
                        fprintf( stdout, ""    <%d>\n\n   "", j );
                    else
                        fprintf( stdout, ""\n   "" );
                else
                    fprintf( stdout, "" "" );
        }
    }
}

"
139-5525,alantsv/ufpa-paradigms,linked-list.c,198,8,109,1963339.280337,211687.0,9.274726364868886,1382.0,1361.0,48110.0,19112.0,1643.0,651.0,1363.0,606.0,1500000000,0.001308892853558,1082014363648.0,0.0129578103520764,0.0634167385677308,"/*
Trabalho I: em dupla. 

Dada as funções da classe abaixo implemente-as no paradigmas
imperativo, como do programa acima; não use recursividade, 
caminhe na lista com comandos iterativos; 

programe o imprimir lista, com esta saida: [1,3,4,5,7,9]; 
depois responda as perguntas abaixo.
antes de cada uma destas perguntas exiba a lista; 
depois rode a ação; 
se ação é sobre a lista exiba novamente a lista;

1) cria a lista com insere inicio [1,3,4,5,7,9];
2) mostre o tamanho da lista;
3) remova o fim;
4) insira o 11 no final;
5) mostre qual é a posição do valor 5; 
6) insira o 6 na sua posição mantendo a ordem da lista;
7) remova o item valor 4;
8) remova duas vezes inicio;
9) cria a lista com insere fim[1,3,4,5,7,9];
10)inverta a lista;
*/

#include <stdio.h>
#include <stdlib.h>


typedef struct node
{
    int value;
    struct node *next;
} node;

// typedef node *list;

void make_list (node *head)
{
    head = NULL;
}

int is_empty (node *head)
{
    if (head == NULL)
        return 1;
    return 0;
}

void print_list (node *head)
{
    while(head != NULL)
   {
        printf(""%d "", head->value);
        head = head->next;
   }
    printf (""\n"");
}

void insert_begin(node **head, int value)
{
    if (is_empty(*head))
    {
        *head = (node *)malloc(sizeof(node));
        (*head)->value = value;
        (*head)->next = NULL;
    }
    else
    {
        node *new_head = (node *)malloc(sizeof(node));
        new_head->value = value;
        new_head->next = *head;
        *head = new_head;
    }
}

void insert_end(node **list, int value)
{
    node *head = *list;
    if (is_empty(head))
    {
        head = (node *)malloc(sizeof(node));
        head->value = value;
        head->next = NULL;
        *list = head;
    }
    else
    {
        while(!is_empty(head->next))
           head = head->next;
        head->next = (node *)malloc(sizeof(node));
        head = head->next;
        head->value = value;
        head->next = NULL;
    }
}

void length_list(node *head)
{
    int length = 0;
    while (!is_empty(head))
    {
        length++;
        head = head->next;
    }
    printf(""%d\n"", length);
}

void remove_end_list(node *head)
{
    while(!is_empty(head->next->next))
        head = head->next;
    free(head->next);
    head->next = NULL;
}

void find_position(node *head, int position)
{
    while(position != 0)
    {
        head = head->next;
        position--;
    }
    printf(""%d\n"", head->value);
}

void insert_orderned(node **list, int value)
{
    node *head = *list;
        while(head->next->value <= value && head->next != NULL)
            head = head->next;
        node *new_node = (node *)malloc(sizeof(node));
        new_node->value = value;
        new_node->next = head->next;
        head->next = new_node;
}

void remove_value(node **list, int value)
{
    node *ref, *head = *list;
    while(head->next->value != value && head->next != NULL)
        head = head->next;
    if(is_empty(head->next))
        printf(""Not found this value"");
    else
    {
        ref = head->next;
        head->next = ref->next;
        free(ref);
        ref = NULL;
    }
}

void remove_begin(node **list)
{
    node *head = *list;
    *list = (*list)->next;
    free(head);
    head = NULL;
}

void reverse_list(node **list)
{
    node *ref = *list;
    node *new_list = NULL;
    while(!is_empty(ref))
    {
        insert_begin(&new_list, ref->value);
        *list = (*list)->next;
        free(ref);
        ref = *list;
    }
    *list = new_list;
}


int main()
{
    node *list = NULL;

    insert_begin(&list, 9);
    insert_begin(&list, 7);
    insert_begin(&list, 5);
    insert_begin(&list, 4);
    insert_begin(&list, 3);
    insert_begin(&list, 1);

    printf(""The first list is:\n"");
    print_list(list);

    printf(""The length list is:\n"");
    length_list(list);

    remove_end_list(list);
    printf(""The list without last element is\n"");
    print_list(list);

    insert_end(&list, 11);
    printf(""The list with last element being 11 is:\n"");
    print_list(list);

    printf(""The index 5 in the list is:\n"");
    find_position(list, 5);


    insert_orderned(&list, 6);
    printf(""The list with value 6 addicioned is:\n"");
    print_list(list);
    
    remove_value(&list, 4);
    printf(""The list without value 4 is:\n"");
    print_list(list);

    remove_begin(&list);
    remove_begin(&list);
    printf(""The list with twice begin removed:\n"");
    print_list(list);

    node *list2 = NULL;
    insert_end(&list2, 1);
    insert_end(&list2, 3);
    insert_end(&list2, 4);
    insert_end(&list2, 5);
    insert_end(&list2, 7);
    insert_end(&list2, 9);

    printf(""The second list is:\n"");
    print_list(list2);

    reverse_list(&list2);
    printf(""The list 2 reversed is:\n"");
    print_list(list2);


    return 0;
}
"
169-30018,ganboing/binutils-gdb,gdb/testsuite/gdb.python/py-prettyprint.c,284,3,100,1638723.1880797502,169091.0,9.68692597477098,1140.0,1130.0,38458.0,12700.0,1568.0,590.0,1317.0,549.0,1500000000,0.0010924821253865,1082014363648.0,0.0134247239652021,0.0786582743656906,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2008-2017 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <string.h>

struct s
{
  int a;
  int *b;
};

struct ss
{
  struct s a;
  struct s b;
};

struct arraystruct
{
  int y;
  struct s x[2];
};

struct ns {
  const char *null_str;
  int length;
};

struct lazystring {
  const char *lazy_str;
  /* If -1, don't pass length to gdb.lazy_string().  */
  int len;
};

struct hint_error {
  int x;
};

struct children_as_list {
  int x;
};

#ifdef __cplusplus
struct S : public s {
  int zs;
};

struct SS {
  int zss;
  S s;
};

struct SSS
{
  SSS (int x, const S& r);
  int a;
  const S &b;
};
SSS::SSS (int x, const S& r) : a(x), b(r) { }

class VirtualTest 
{ 
 private: 
  int value; 

 public: 
  VirtualTest () 
    { 
      value = 1;
    } 
};

class Vbase1 : public virtual VirtualTest { };
class Vbase2 : public virtual VirtualTest { };
class Vbase3 : public virtual VirtualTest { };

class Derived : public Vbase1, public Vbase2, public Vbase3
{ 
 private: 
  int value; 
  
 public:
  Derived () 
    { 
      value = 2; 
    }
};

class Fake
{
  int sname;
  
 public:
  Fake (const int name = 0):
  sname (name)
  {
  }
};
#endif

struct substruct {
  int a;
  int b;
};

struct outerstruct {
  struct substruct s;
  int x;
};

struct outerstruct
substruct_test (void)
{
  struct outerstruct outer;
  outer.s.a = 0;
  outer.s.b = 0;
  outer.x = 0;

  outer.s.a = 3;		/* MI outer breakpoint here */

  return outer;  
}

typedef struct string_repr
{
  struct whybother
  {
    const char *contents;
  } whybother;
} string;

/* This lets us avoid malloc.  */
int array[100];
int narray[10];

struct justchildren
{
  int len;
  int *elements;
};

typedef struct justchildren nostring_type;

struct memory_error
{
  const char *s;
};

struct container
{
  string name;
  int len;
  int *elements;
};

typedef struct container zzz_type;

string
make_string (const char *s)
{
  string result;
  result.whybother.contents = s;
  return result;
}

zzz_type
make_container (const char *s)
{
  zzz_type result;

  result.name = make_string (s);
  result.len = 0;
  result.elements = 0;

  return result;
}

void
add_item (zzz_type *c, int val)
{
  if (c->len == 0)
    c->elements = array;
  c->elements[c->len] = val;
  ++c->len;
}

void
set_item(zzz_type *c, int i, int val)
{
  if (i < c->len)
    c->elements[i] = val;
}

void init_s(struct s *s, int a)
{
  s->a = a;
  s->b = &s->a;
}

void init_ss(struct ss *s, int a, int b)
{
  init_s(&s->a, a);
  init_s(&s->b, b);
}

void do_nothing(void)
{
  int c;

  c = 23;			/* Another MI breakpoint */
}

struct nullstr
{
  char *s;
};

struct string_repr string_1 = { { ""one"" } };
struct string_repr string_2 = { { ""two"" } };

int
eval_func (int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8)
{
  return p1;
}

static void
eval_sub (void)
{
  struct eval_type_s { int x; } eval1 = { 1 }, eval2 = { 2 }, eval3 = { 3 },
				eval4 = { 4 }, eval5 = { 5 }, eval6 = { 6 },
				eval7 = { 7 }, eval8 = { 8 }, eval9 = { 9 };

  eval1.x++; /* eval-break */
}

static void
bug_14741()
{
  zzz_type c = make_container (""bug_14741"");
  add_item (&c, 71);
  set_item(&c, 0, 42); /* breakpoint bug 14741 */
  set_item(&c, 0, 5);
}

/* Some typedefs/variables for checking that GDB doesn't lose typedefs
   when looking for a printer.  */
typedef int int_type;
typedef int_type int_type2;

int an_int = -1;
int_type an_int_type = 1;
int_type2 an_int_type2 = 2;

int
main ()
{
  struct ss  ss;
  struct ss  ssa[2];
  struct arraystruct arraystruct;
  string x = make_string (""this is x"");
  zzz_type c = make_container (""container"");
  zzz_type c2 = make_container (""container2"");
  const struct string_repr cstring = { { ""const string"" } };
  /* Clearing by being `static' could invoke an other GDB C++ bug.  */
  struct nullstr nullstr;
  nostring_type nstype, nstype2;
  struct memory_error me;
  struct ns ns, ns2;
  struct lazystring estring, estring2, estring3;
  struct hint_error hint_error;
  struct children_as_list children_as_list;

  nstype.elements = narray;
  nstype.len = 0;

  me.s = ""blah"";

  init_ss(&ss, 1, 2);
  init_ss(ssa+0, 3, 4);
  init_ss(ssa+1, 5, 6);
  memset (&nullstr, 0, sizeof nullstr);

  arraystruct.y = 7;
  init_s (&arraystruct.x[0], 23);
  init_s (&arraystruct.x[1], 24);

  ns.null_str = ""embedded\0null\0string"";
  ns.length = 20;

  /* Make a ""corrupted"" string.  */
  ns2.null_str = NULL;
  ns2.length = 20;

  estring.lazy_str = ""embedded x\201\202\203\204"";
  estring.len = -1;

  /* Incomplete UTF-8, but ok Latin-1.  */
  estring2.lazy_str = ""embedded x\302"";
  estring2.len = -1;

  estring3.lazy_str = NULL;
  estring3.len = 42;

#ifdef __cplusplus
  S cps;

  cps.zs = 7;
  init_s(&cps, 8);

  SS cpss;
  cpss.zss = 9;
  init_s(&cpss.s, 10);

  SS cpssa[2];
  cpssa[0].zss = 11;
  init_s(&cpssa[0].s, 12);
  cpssa[1].zss = 13;
  init_s(&cpssa[1].s, 14);

  SSS sss(15, cps);

  SSS& ref (sss);

  Derived derived;
  
  Fake fake (42);
#endif

  add_item (&c, 23);		/* MI breakpoint here */
  add_item (&c, 72);

#ifdef MI
  add_item (&c, 1011);
  c.elements[0] = 1023;
  c.elements[0] = 2323;

  add_item (&c2, 2222);
  add_item (&c2, 3333);

  substruct_test ();
  do_nothing ();
#endif

  nstype.elements[0] = 7;
  nstype.elements[1] = 42;
  nstype.len = 2;
  
  nstype2 = nstype;

  eval_sub ();

  bug_14741();      /* break to inspect struct and union */
  return 0;
}
"
159-20570,griffint/SoftwareSystems,hw04/hash/hash_soln.c,266,6,295,1790281.61801385,196663.0,14.868714501456807,1398.0,1375.0,44710.0,17005.0,1645.0,649.0,1366.0,606.0,1500000000,0.0011935210786759,1082014363648.0,0.0141002628862572,0.0691241999513894,"/* Example code for Software Systems at Olin College.
Copyright 2012 Allen Downey
License: Creative Commons Attribution-ShareAlike 3.0
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


// VALUE: represents a value in a key-value pair

/* Here's one way of making a polymorphic object in C */

typedef struct {
    enum Type {INT, STRING} type;
    union {
	int i;
	char *s;
    };
} Value;


/* Makes a Value object that contains an int. */
Value *make_int_value(int i) 
{
    Value *value = (Value *) malloc (sizeof (Value));
    value->type = INT;
    value->i = i;
    return value;
}


/* Makes a Value object that contains a string. */
Value *make_string_value(char *s) 
{
    Value *value = (Value *) malloc (sizeof (Value));
    value->type = STRING;
    value->s = s;
    return value;
}


/* Prints a value object. */
void print_value (Value *value) 
{
    if (value == NULL) {
	printf (""%p"", value);
	return;
    }
    switch (value->type) {
    case INT:
	printf (""%d"", value->i);
	break;
    case STRING:
	printf (""%s"", value->s);
	break;
    }
}

// HASHABLE: Represents a key in a key-value pair.

/* Here's another way to make a polymorphic object.
The key can be any pointer type.  It's stored as a (void *), so
when you extract it, you have to cast it back to whatever it is.
hash is a pointer to a function that knows how to hash the key.
equal is a pointer to a function that knows how to compare keys.
 */

typedef struct {
    void *key;
    int (*hash) (void *);
    int (*equal) (void *, void *);
} Hashable;


/* Makes a Hashable object. */
Hashable *make_hashable(void *key, 
			int (*hash) (void *),
			int (*equal) (void *, void *)
			)
{
    Hashable *hashable = (Hashable *) malloc (sizeof (Hashable));
    hashable->key = key;
    hashable->hash = hash;
    hashable->equal = equal;
    return hashable;
}


/* Prints a Hashable object. */
void print_hashable(Hashable *hashable)
{
    printf (""key %p\n"", hashable->key);
    printf (""hash %p\n"", hashable->hash);
}


/* Hashes an integer. */
int hash_int(void *p)
{
    return *(int *)p;
}


/* Hashes a string. */
int hash_string(void *p)
{
    char *s = (char *) p;
    int total = 0;
    int i = 0;

    while (s[i] != 0) {
	total += s[i];
	i++;
    }
    return total;
}


/* Hashes any Hashable. */
int hash_hashable(Hashable *hashable)
{
    return hashable->hash (hashable->key);
}


/* Compares integers. */
int equal_int (void *ip, void *jp)
{
    return *(int *)ip == *(int *)jp;
}


/* Compares strings. */
int equal_string (void *s1, void *s2)
{
    int x = strcmp ((char *) s1, (char *) s2);
    return (x == 0);
}


/* Compares Hashables. */
int equal_hashable(Hashable *h1, Hashable *h2)
{
    /* if they don't have the same equal method,
       they are not the same type */
    if (h1->equal != h2->equal) return 0;

    /* use the equal method to compare keys */
    return h1->equal(h1->key, h2->key);
}


/* Makes a Hashable int. 
Allocates space and copies the int.
*/
Hashable *make_hashable_int (int x)
{
    int *p = (int *) malloc (sizeof (int));
    *p = x;
    return make_hashable((void *) p, hash_int, equal_int);
}


/* Makes a Hashable string. 
Stores a reference to the string (not a copy).
*/
Hashable *make_hashable_string (char *s)
{
    return make_hashable((void *) s, hash_string, equal_string);
}



// NODE: a node in a list of key-value pairs

typedef struct node {
    Hashable *key;
    Value *value;
    struct node *next;
} Node;


/* Makes a Node. */
Node *make_node(Hashable *key, Value *value, Node *next)
{
    Node *node = (Node *) malloc (sizeof (Node));
    node->key = key;
    node->value = value;
    node->next = next;
    return node;
}


/* Prints a Node. */
void print_node(Node *node)
{
    print_hashable(node->key);
    printf (""value %p\n"", node->value);
    printf (""next %p\n"", node->next);
}


/* Prints all the Nodes in a list. */
void print_list(Node *node)
{
    if (node == NULL) {
	return;
    }
    print_hashable(node->key);
    printf (""value %p\n"", node->value);
    print_list(node->next);
}


/* Prepends a new key-value pair onto a list.
This is actually a synonym for make_node.
 */
Node *prepend(Hashable *key, Value *value, Node *rest)
{
    return make_node(key, value, rest);
}


/* Looks up a key and returns the corresponding value, or NULL */
Value *list_lookup(Node *list, Hashable *key)
{
    Node *node;

    for (node = list; node != NULL; node = node->next) {
	if (equal_hashable(key, node->key)) {
	    return node->value;
	}
    }
    return NULL;
}


// MAP: a map in a list of key-value pairs

typedef struct map {
    int n;
    Node **lists;
} Map;


/* Makes a Map with n lists. */
Map *make_map(int n)
{
    int i;

    Map *map = (Map *) malloc (sizeof (Map));
    map->n = n;
    map->lists = (Node **) malloc (sizeof (Node *) * n);
    for (i=0; i<n; i++) {
	map->lists[i] = NULL;
    }
    return map;
}


/* Prints a Map. */
void print_map(Map *map)
{
    int i;

    for (i=0; i<map->n; i++) {
	if (map->lists[i] != NULL) {
	    printf (""%d\n"", i);
	    print_list (map->lists[i]);
	}
    }
}


/* Adds a key-value pair to a map. */
void map_add(Map *map, Hashable *key, Value *value)
{
    int hashval = hash_hashable(key) % map->n;
    Node *list = map->lists[hashval];
    
    map->lists[hashval] = prepend(key, value, list);
}


/* Looks up a key and returns the corresponding value, or NULL. */
Value *map_lookup(Map *map, Hashable *key)
{
    int hashval = hash_hashable(key) % map->n;
    Node *list = map->lists[hashval];
    
    return list_lookup(list, key);
}


/* Prints the results of a test lookup. */
void print_lookup(Value *value)
{
    printf (""Lookup returned "");
    print_value (value);
    printf (""\n"");
}


int main ()
{
    Hashable *hashable1 = make_hashable_int (1);
    Hashable *hashable2 = make_hashable_string (""Allen"");
    Hashable *hashable3 = make_hashable_int (2);

    // make a list by hand
    Value *value1 = make_int_value (17);
    Node *node1 = make_node(hashable1, value1, NULL);
    print_node (node1);

    Value *value2 = make_string_value (""Downey"");
    Node *list = prepend(hashable2, value2, node1);
    print_list (list);

    // run some test lookups
    Value *value = list_lookup (list, hashable1);
    print_lookup(value);

    value = list_lookup (list, hashable2);
    print_lookup(value);

    value = list_lookup (list, hashable3);
    print_lookup(value);

    // make a map
    Map *map = make_map(10);
    map_add(map, hashable1, value1);
    map_add(map, hashable2, value2);

    printf (""Map\n"");
    print_map(map);

    // run some test lookups
    value = map_lookup(map, hashable1);
    print_lookup(value);

    value = map_lookup(map, hashable2);
    print_lookup(value);

    value = map_lookup(map, hashable3);
    print_lookup(value);

    return 0;
}"
033-16155,dezelin/vbox-haiku,src/VBox/Devices/Graphics/BIOS/vbetables-gen.c,218,6,343,2282794.5649623,1286574.0,1.7743200157938837,1408.0,1387.0,277171.0,181323.0,1686.0,700.0,1400.0,656.0,1500000000,0.0015218630433082,1082014363648.0,0.0021724362531809,0.0096882401950734,"/* Generate the VGABIOS VBE Tables */
#include <stdlib.h>
#include <stdio.h>

#define VBE_DISPI_TOTAL_VIDEO_MEMORY_MB 8

typedef struct {
    int width;
    int height;
    int depth;
    int mode;
} ModeInfo;

ModeInfo modes[] = {
    /* standard VESA modes */
{ 640, 400, 8                          , 0x100},
{ 640, 480, 8                          , 0x101},
{ 800, 600, 4                          , 0x102},
{ 800, 600, 8                          , 0x103},
{ 1024, 768, 4                         , 0x104},
{ 1024, 768, 8                         , 0x105},
{ 1280, 1024, 4                        , 0x106},
{ 1280, 1024, 8                        , 0x107},
{ 320, 200, 15                       , 0x10D},
{ 320, 200, 16                        , 0x10E},
{ 320, 200, 24                        , 0x10F},
{ 640, 480, 15                       , 0x110},
{ 640, 480, 16                        , 0x111},
{ 640, 480, 24                        , 0x112},
{ 800, 600, 15                       , 0x113},
{ 800, 600, 16                        , 0x114},
{ 800, 600, 24                        , 0x115},
{ 1024, 768, 15                      , 0x116},
{ 1024, 768, 16                       , 0x117},
{ 1024, 768, 24                       , 0x118},
{ 1280, 1024, 15                     , 0x119},
{ 1280, 1024, 16                      , 0x11A},
{ 1280, 1024, 24                      , 0x11B},
#if 0 /* Ubuntu fails with this */
{ 1600, 1200, 8                        , 0x11C},
{ 1600, 1200, 15                     , 0x11D},
{ 1600, 1200, 16                      , 0x11E},
{ 1600, 1200, 24                      , 0x11F},
#endif

      /* BOCHS/PLE, 86 'own' mode numbers */
{ 320, 200, 32                        , 0x140},
{ 640, 400, 32                        , 0x141},
{ 640, 480, 32                        , 0x142},
{ 800, 600, 32                        , 0x143},
{ 1024, 768, 32                       , 0x144},
{ 1280, 1024, 32                      , 0x145},
{ 320, 200, 8                           , 0x146},
{ 1600, 1200, 32                      , 0x147},
{ 1152, 864, 8                      , 0x148},
{ 1152, 864, 15                      , 0x149},
{ 1152, 864, 16                      , 0x14a},
{ 1152, 864, 24                      , 0x14b},
{ 1152, 864, 32                      , 0x14c},
{ 0, },
};

int main(int argc, char **argv)
{
  const ModeInfo *pm;
  int pages, pitch;
  int r_size, r_pos, g_size, g_pos, b_size, b_pos, a_size, a_pos;
  const char *str;
  long vram_size = VBE_DISPI_TOTAL_VIDEO_MEMORY_MB * 1024 * 1024;

  printf(""/* THIS FILE IS AUTOMATICALLY GENERATED - DO NOT EDIT */\n\n"");
  printf(""#define VBE_DISPI_TOTAL_VIDEO_MEMORY_MB %d\n\n"", VBE_DISPI_TOTAL_VIDEO_MEMORY_MB);
  printf(""static ModeInfoListItem mode_info_list[]=\n"");
  printf(""{\n"");
  for (pm = modes; pm->mode != 0; pm++) {
    if (pm->depth == 4)
      pitch = (pm->width + 7) / 8;
    else
      pitch = pm->width * ((pm->depth + 7) / 8);
    pages = vram_size / (pm->height * pitch);
    if (pages > 0) {
      printf(""{ 0x%04x, /* %dx%dx%d */\n"",
             pm->mode, pm->width, pm->height, pm->depth);
      if (pm->depth == 4)
        printf(""{ /*Bit16u ModeAttributes*/ %s,\n"",
               ""VBE_MODE_ATTRIBUTE_SUPPORTED | ""
               ""VBE_MODE_ATTRIBUTE_EXTENDED_INFORMATION_AVAILABLE | ""
               ""VBE_MODE_ATTRIBUTE_COLOR_MODE | ""
               ""VBE_MODE_ATTRIBUTE_TTY_BIOS_SUPPORT | ""
               ""VBE_MODE_ATTRIBUTE_GRAPHICS_MODE"");
      else
        printf(""{ /*Bit16u ModeAttributes*/ %s,\n"",
               ""VBE_MODE_ATTRIBUTE_SUPPORTED | ""
               ""VBE_MODE_ATTRIBUTE_EXTENDED_INFORMATION_AVAILABLE | ""
               ""VBE_MODE_ATTRIBUTE_COLOR_MODE | ""
               ""VBE_MODE_ATTRIBUTE_LINEAR_FRAME_BUFFER_MODE | ""
               ""VBE_MODE_ATTRIBUTE_GRAPHICS_MODE"");
      printf(""/*Bit8u  WinAAttributes*/ %s,\n"",
             ""VBE_WINDOW_ATTRIBUTE_RELOCATABLE | ""
             ""VBE_WINDOW_ATTRIBUTE_READABLE | ""
             ""VBE_WINDOW_ATTRIBUTE_WRITEABLE"");

      printf(""/*Bit8u  WinBAttributes*/ %d,\n"", 0);

      printf(""/*Bit16u WinGranularity*/ %s,\n"", ""VBE_DISPI_BANK_SIZE_KB"");

      printf(""/*Bit16u WinSize*/ %s,\n"", ""VBE_DISPI_BANK_SIZE_KB"");

      printf(""/*Bit16u WinASegment*/ %s,\n"", ""VGAMEM_GRAPH"");

      printf(""/*Bit16u WinBSegment*/ 0x%04x,\n"", 0);

      printf(""/*Bit32u WinFuncPtr*/ %d,\n"", 0);

      printf(""/*Bit16u BytesPerScanLine*/ %d,\n"", pitch);

      /* Mandatory information for VBE 1.2 and above */
      printf(""/*Bit16u XResolution*/ %d,\n"", pm->width);
      printf(""/*Bit16u YResolution*/ %d,\n"", pm->height);
      printf(""/*Bit8u  XCharSize*/ %d,\n"", 8);
      printf(""/*Bit8u  YCharSize*/ %d,\n"", 16);
      if (pm->depth == 4) {
        printf(""/*Bit8u  NumberOfPlanes*/ %d,\n"", 4);
      } else {
        printf(""/*Bit8u  NumberOfPlanes*/ %d,\n"", 1);
      }
      printf(""/*Bit8u  BitsPerPixel*/ %d,\n"", pm->depth);
      printf(""/*Bit8u  NumberOfBanks*/ %d,\n"", 1);  /* This would only be non-zero for CGA/HGC modes! */

      if (pm->depth == 4)
        str = ""VBE_MEMORYMODEL_PLANAR"";
      else if (pm->depth == 8)
        str = ""VBE_MEMORYMODEL_PACKED_PIXEL"";
      else
        str = ""VBE_MEMORYMODEL_DIRECT_COLOR"";
      printf(""/*Bit8u  MemoryModel*/ %s,\n"", str);
      printf(""/*Bit8u  BankSize*/ %d,\n"", 0);
      if (pm->depth == 4)
        printf(""/*Bit8u  NumberOfImagePages*/ %d,\n"", (pages / 4) - 1);
      else
        printf(""/*Bit8u  NumberOfImagePages*/ %d,\n"", pages - 1);
      printf(""/*Bit8u  Reserved_page*/ %d,\n"", 0);

      /* Direct Color fields (required for direct/6 and YUV/7 memory models) */
      switch(pm->depth) {
        case 15:
          r_size = 5;
          r_pos = 10;
          g_size = 5;
          g_pos = 5;
          b_size = 5;
          b_pos = 0;
          a_size = 1;
          a_pos = 15;
          break;
        case 16:
          r_size = 5;
          r_pos = 11;
          g_size = 6;
          g_pos = 5;
          b_size = 5;
          b_pos = 0;
          a_size = 0;
          a_pos = 0;
          break;
        case 24:
          r_size = 8;
          r_pos = 16;
          g_size = 8;
          g_pos = 8;
          b_size = 8;
          b_pos = 0;
          a_size = 0;
          a_pos = 0;
          break;
        case 32:
          r_size = 8;
          r_pos = 16;
          g_size = 8;
          g_pos = 8;
          b_size = 8;
          b_pos = 0;
          a_size = 8;
          a_pos = 24;
          break;
        default:
          r_size = 0;
          r_pos = 0;
          g_size = 0;
          g_pos = 0;
          b_size = 0;
          b_pos = 0;
          a_size = 0;
          a_pos = 0;
          break;
      }

      printf(""/*Bit8u  RedMaskSize*/ %d,\n"", r_size);
      printf(""/*Bit8u  RedFieldPosition*/ %d,\n"", r_pos);
      printf(""/*Bit8u  GreenMaskSize*/ %d,\n"", g_size);
      printf(""/*Bit8u  GreenFieldPosition*/ %d,\n"", g_pos);
      printf(""/*Bit8u  BlueMaskSize*/ %d,\n"", b_size);
      printf(""/*Bit8u  BlueFieldPosition*/ %d,\n"", b_pos);
      printf(""/*Bit8u  RsvdMaskSize*/ %d,\n"", a_size);
      printf(""/*Bit8u  RsvdFieldPosition*/ %d,\n"", a_pos);
      if (pm->depth == 32)
        printf(""/*Bit8u  DirectColorModeInfo*/ %s,\n"",
               ""VBE_DIRECTCOLOR_RESERVED_BITS_AVAILABLE"");
      else
        printf(""/*Bit8u  DirectColorModeInfo*/ %s,\n"", ""0"");

      /* Mandatory information for VBE 2.0 and above */
      if (pm->depth > 4)
        printf(""/*Bit32u PhysBasePtr*/ %s,\n"",
               ""VBE_DISPI_LFB_PHYSICAL_ADDRESS"");
      else
        printf(""/*Bit32u PhysBasePtr*/ %s,\n"", ""0"");
      printf(""/*Bit32u OffScreenMemOffset*/ %d,\n"", 0);
      printf(""/*Bit16u OffScreenMemSize*/ %d,\n"", 0);
      /* Mandatory information for VBE 3.0 and above */
      printf(""/*Bit16u LinBytesPerScanLine*/ %d,\n"", pitch);
      printf(""/*Bit8u  BnkNumberOfPages*/ %d,\n"", 0);
      printf(""/*Bit8u  LinNumberOfPages*/ %d,\n"", 0);
      printf(""/*Bit8u  LinRedMaskSize*/ %d,\n"", r_size);
      printf(""/*Bit8u  LinRedFieldPosition*/ %d,\n"", r_pos);
      printf(""/*Bit8u  LinGreenMaskSize*/ %d,\n"", g_size);
      printf(""/*Bit8u  LinGreenFieldPosition*/ %d,\n"", g_pos);
      printf(""/*Bit8u  LinBlueMaskSize*/ %d,\n"", b_size);
      printf(""/*Bit8u  LinBlueFieldPosition*/ %d,\n"", b_pos);
      printf(""/*Bit8u  LinRsvdMaskSize*/ %d,\n"", a_size);
      printf(""/*Bit8u  LinRsvdFieldPosition*/ %d,\n"", a_pos);
      printf(""/*Bit32u MaxPixelClock*/ %d,\n"", 0);
      printf(""} },\n"");
    }
  }
#ifndef VBOX    /* We'll add the terminator ourselves, thank you. */
  printf(""{ VBE_VESA_MODE_END_OF_LIST,\n"");
  printf(""{ 0,\n"");
  printf(""} },\n"");
#endif
  printf(""};\n"");
  return 0;
}
"
032-10353,Bladefidz/algorithm,data_structure/pointer.c,144,10,228,1917617.7447661501,170413.0,11.249799017680576,1145.0,1137.0,38721.0,12787.0,1582.0,587.0,1326.0,546.0,1500000000,0.0012784118298441,1082014363648.0,0.0133909971657091,0.0784538324143822,"#include <stdlib.h>
#include <stdio.h>
#include <string.h>

/**
 * The main power of C programming language is ""Address Arithmetic"".
 * It's means you are outperforming turing complete computation model in every
 * programming aspect. We will see that array and pointer almost similar in C.
 * The rest of implementation depend on programmer intelligent, for example:
 * Some maybe create more space efficient storage using binary tree, while
 * others keeps using bizarre size of arrays because their goal more important
 * than efficiency issues.
 */


// Dummy function used to test pointer as argument
void f1(int arr[]){}
void f2(int *arr){}

/**
 * Pointer or array arithmetic can be used to count allocated chars in memory
 * @param  s string
 * @return   ('\0' address) - (first address)
 */
int myStrlen(char *s)
{
    char *p = s;
    while (*p != '\0')
        p++;
    return p - s;
}

/**
 * Implementing pointer to copy string ""t"" to string ""s""
 * @param s Copy destination
 * @param t String to be copied
 */
void myStrcpy(char *s, char *t)
{
    while ((*s++ = *t++) != '\0');
}
void myStrcpy1(char *s, char *t)
{
    while (*s++ = *t++);
}

/**
 * Compare string s to string t
 * @return   0 if s<t, 0 if s==t, >0 if s>t
 */
int myStrcmp(char *s, char *t)
{
    for ( ; *s == *t; s++, t++)
        if (*s == '\0')
            return 0;
    return *s - *t;
}

/**
 * Get specific index in array of pointer
 * @param  i [description]
 * @return   [description]
 */
char *getTerm(unsigned int i)
{
    char *arrStr[] = {""pointer"", ""is"", ""beautiful!""};
    return arrStr[i];
}

/**
 * Main testing program
 * @param  argc Argument count
 * @param  argv Argument variable
 * @return      integer
 */
int main(int argc, char const *argv[])
{
    int x = 4, y, z[10];
    int *p;  // p point to int

    for (int i = 0; i < 10; ++i)
    {
        z[i] = i;
    }

    p = &x;     // p is now 4
    y = *p;     // y is now 4
    *p = 0;     // x is now 0
    p = &z[0];  // p is now point to z[0]
    p = z;      // equivalent to p = &z[0]
    (*p)++;     // Increment x by 1
    p++;        // Access next address

    y = *(z+2);  // Evaluating each address in array
    y = z[2];  // equivalent to y = *(z+2)

    // All arguments below are equivalent
    f1(&z[2]);
    f2(&z[2]);
    f1(z+2);
    f2(z+2);

    // Array
    char amsg[] = ""Array of character"";  // Allocate as array
    amsg[1] = 'B';  // This is allowed

    // Pointer of Array
    char *pmsg = ""Pointer to an array of character"";  // Pointer to fixed size array
    // *(pmsg + 1) = ""B"";  // This is not allowed

    // Pointer of Pointer of array
    char *ss[] = {""aku"", ""kamu"", ""dia"", ""dan"", ""mereka""};
    char **ps;
    ps = malloc(sizeof(char) * 2);  // Allocate Pointer
    ps[0] = ""aku"";  // First pointer pointed to array ""aku""
    ps[1] = malloc(sizeof(char) * 5);
    for (int i = 0; i < 5; ++i)
    {
        ps[1][i] = 'a'+i;
    }

    // Self reference structure
    struct A {
        char *value;
        struct A *next;  // Pointer of self
    } A;

    // Pointer to structure
    struct A *a = malloc(sizeof(A));
    (*a).value = ""aku"";

    // Pointer of pointer to structure
    struct B {
        unsigned int count;
        struct A **child;  // or array of structure
    } B;
    struct B *b = malloc(sizeof(B));
    (*b).child = malloc(sizeof(A) * 2);

    // Allocate each index of array of structure
    *((*b).child) = malloc(sizeof(A));
    (*(*((*b).child))).value = malloc(sizeof(char) * 4);
    for (int i = 0; i < 4; ++i)
    {
        *((*(*((*b).child))).value + i) = 'a'+i;
    }
    (*(*((*b).child))).next = NULL;
    b->child[1] = malloc(sizeof(A));
    b->child[1]->value = malloc(sizeof(char) * 5);
    for (int i = 0; i < 4; ++i)
    {
        b->child[1]->value[i] = 'f'+i;
    }
    b->child[1]->next = NULL;

    free(a); free(b);

    // Working on string using pointer is more portable than using array
    char *s1 = ""aku"";
    char *s2 = NULL;  // Set destination pointer to NULL to allocate latter
    s2 = malloc(sizeof(s1) * strlen(s1));  // Allocate string length
    strcpy(s2, s1);
    s2[1] = 'l';  // Update the copied string

    // We can not update 'not allocated' string
    s1 = ""kamu"";
    //s1[0] = ""j"";  // Because the address is not owned by pointer nor anything

    return 0;
}"
018-28578,alpha93/HelloWorld,all_sorting_algorithms.c,167,17,240,1865104.4229045,180459.0,10.335333787730177,1349.0,1331.0,40881.0,14289.0,1634.0,632.0,1352.0,590.0,1500000000,0.001243402948603,1082014363648.0,0.0148510187909719,0.0762733369584919,"#include <stdio.h>

void merge(int [], int, int [], int, int []);
void merge_sort(int [], int);

int partition(int [], int, int);
void quicksort(int [], int, int);

int main() {
	/* all sorting algorithms */

	/* selection sort */
	/* 1. traverse the array form 0th position, find the minimum, swap with 0th element
	 * 2. traverse the array form 1st position, find the minimum, swap with 1th element
	 * 3. repeat
	 *
	 * ** took 652,671ms to sort a 1,000,000 sized reverse sorted array in java.
	 * ** in-place Algorithm.
	 */


	/*int arr[9] = {5, 2, 4, 1, 8, 3, 6, 9, 7}, i, j, index_min;
	int len = sizeof(arr)/sizeof(int);

	for(i=0; i<len-1; i++) {
		index_min = i;
		
		for(j=i+1; j<len; j++) {
			if(arr[j] < arr[index_min])
				index_min = j;
		}

		arr[i] = arr[i] + arr[index_min] - (arr[index_min] = arr[i]);
 	}

 	for(i=0; i<len; i++)		//print the array
 		printf(""%i "", arr[i]);*/


 	/* Bubble sort */
 	/* 1.compare each element to its right element. If the right element is smaller, swap the two.
 	 * 2.improvement : if in any traversal no swapping takes place, it means the array has been sorted and no more 
 	 *   traversals are needed.
	 * 3. repeat
	 *
	 * ** took 877,739ms to sort a 1,000,000 sized reverse sorted array in java.
 	 * ** in-place Algorithm.
 	 */ 


	/*int arr[9] = {5, 2, 4, 1, 8, 3, 6, 9, 7}, i, j;
	int len = sizeof(arr)/sizeof(int);

	for(i=0; i<len-1 ;i++) {
		int flag = 0;

		for(j=0; j<len-1-i; j++) {
			if(arr[j] > arr[j+1]) {
				arr[j] = arr[j] + arr[j+1] - (arr[j+1] = arr[j]);
				flag = 1;
			}
		}

		if(flag == 0)
			break;
	}

	for(i=0; i<len; i++)		//print the array
 		printf(""%i "", arr[i]);*/


 	/* Insertion sort */
 	/* 1.mentally devide the array in two pars. initially assume the 1st element to be part of the sorted array
 	 *   and the rest of the array to be unsorted.
 	 * 2.Sunsequently take one element, starting withn the 1th and insert it in the correct position in the 
 	 *   sorted part.
 	 * ** better than selection and bubble sort in practical scenarios.
 	 * ** took 1,059,155ms to sort a 1,000,000 sized reverse sorted array in java.
 	 * ** in-place Algorithm.
 	 */


 	/*int arr[9] = {5, 2, 4, 1, 8, 3, 6, 9, 7}, i, j;
	int len = sizeof(arr)/sizeof(int);

	for(i=1; i<len; i++) {
		j = i;
		
		while(j > 0  &&  arr[j] < arr[j-1]) {
			arr[j] = arr[j] + arr[j-1] - (arr[j-1] = arr[j]);
			j--;
		}
	}

	for(i=0; i<len; i++)		//print the array
 		printf(""%i "", arr[i]);*/



 	/* Merge sort */
 	/* A. merging two sorted arrays into one sorted array :
	 * 1. find the smallest unpicked item form either of the sorted arrays and put in the final array.
	 * 2. repeat.
	 * 3. if one of the arrays in exhausted, put all the leftover items from the other array into final one.
	 *
	 * B. merge sort
	 * 1. split the array into two halves.
	 * 2. call merge_sort on the left array. call merge_sort on the right array.
	 * 3. if there is only one element in the array, just return.
	 * 4. call merge on the arrays.
	 *
	 * ** took 108ms to sort a 1,000,000(1M) and about 10,100ms to sort a 100,000,000(100M) sized reverse sorted array in java.
	 *    WAYYYYYYY FASTER THAN selection, bubble or insertion.
	 * ** not in-place, stable Algorithm.
 	 */



 	/*int arr[9] = {5, 2, 4, 1, 8, 3, 6, 9, 7};
	int len = sizeof(arr)/sizeof(int); 

	merge_sort(arr, len);

	for(int i=0; i<len; i++)		//print the array
 		printf(""%i "", arr[i]);*/



 	/* Quicksort */
 	/* A. partition :
 	 * 1. select the rightmost element to be the pivot.
 	 * 2. swap all the elements smaller than or equal to pivot with indices 0, 1 and so on.
 	 * 3. swap pivot with the frirst element greater than the pivot.
 	 *
 	 * B. quicksort: call partition recursively to sort the array
 	 * 1. call partition on the array.
 	 * 2. call quicksort on left and right array.
 	 *
 	 * ** in the worst case i.e. in the case of a reversed sorted array 1,000,000(1M) size STACK OVERFLOW results, because
 	 *    the depth of the recursion equals the array size in worst case.
 	 * ** took anywhere between 60ms to 100ms to sort a 1,000,000(1M) and 5,800ms on average to sort a 100,000,000(100M) sized
 	 *    reverse sorted array in java that implements a RANDOMIZED version of quicksort by selecting the pivot element randomly
 	 *    like as follows:
 	 *	 
 	 *    int pivot = x[start + rand.nextInt(end-start+1)];		//in java of course
 	 * ** the RANDOMIZED quicksort is almost twice as fast as merge sort.
 	 * ** in-place, non-stable Algorithm.
 	 */



 	int arr[9] = {5, 2, 4, 1, 7, 7, 6, 9, 3};
	int len = sizeof(arr)/sizeof(int); 
	
 	quicksort(arr, 0, 8);

 	for(int i=0; i<len; i++)		//print the array
 		printf(""%i "", arr[i]);



 	return 0;
}

void merge (int left[], int l, int right[], int r, int final[]) {
	int i = 0, j = 0, k = 0;

	while(i < l && j < r) {
		if(left[i] < right[j]) {
			final[k++] = left[i++];
		} else {
			final[k++] = right[j++];
		}
	}

	while(i < l) {
		final[k++] = left[i++];
	}
	while(j < r) {
		final[k++] = right[j++];
	}
}

void merge_sort(int x[], int size) {
	if(size == 1) 
		return;

	int left[size/2], right[size-size/2], i;
	register int l_size = size/2, r_size = size-size/2;

	for(i=0; i<l_size; i++)
		left[i] = x[i];
	for(i=0; i<r_size; i++)
		right[i] = x[i+l_size];

	merge_sort(left, l_size);
	merge_sort(right, r_size);

	merge(left, l_size, right, r_size, x);
}


int partition(int x[], int start, int end) {
	int pivot = x[end], swap_index = start;

	for(int i=start; i<end; i++) {
		if(x[i] <= pivot) {
			x[i] = x[i] + x[swap_index] - (x[swap_index] = x[i]);
			swap_index++;
		}
	}

	x[end] = x[end] + x[swap_index] - (x[swap_index] = x[end]);

	return swap_index;
}

void quicksort(int x[], int start, int end) {
	if(start == end)
		return;

	int p_index = partition(x, start, end);

	if(p_index != start)
		quicksort(x, start, p_index-1);
	if(p_index != end)
		quicksort(x, p_index+1, end);
}
"
114-20038,aczid/ru_crypto_engineering,PRESENT.c,148,6,75,2631169.5110052,1333304.0,1.9734201652436356,1393.0,1372.0,199117.0,82220.0,1636.0,644.0,1357.0,601.0,1500000000,0.0017541130073368,1082014363648.0,0.0020737956235037,0.0150637847137063,"/*

Copyright (c) 2013 Aram Verstegen

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the ""Software""), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

#include <string.h>
#include <stdio.h>

#ifndef CHAR_BIT
#define CHAR_BIT 8
#endif

typedef union {
	unsigned char 		bytes[8];
	long long unsigned int 	value;
} block_t;

typedef struct {
	unsigned char 	 	bytes[10];
} key_t;

#define test_bit(x,n)	x[(sizeof(x)-1)-(n/CHAR_BIT)] &  (1<<(n%CHAR_BIT))
#define set_bit(x,n)	x[(sizeof(x)-1)-(n/CHAR_BIT)] |= (1<<(n%CHAR_BIT))

const unsigned char sbox[16] = {
	0xC, 0x5, 0x6, 0xB, 0x9, 0x0, 0xA, 0xD, 0x3, 0xE, 0xF, 0x8, 0x4, 0x7, 0x1, 0x2
};
const unsigned char inverse_sbox[16] = {
	0x5, 0xE, 0xF, 0x8, 0xC, 0x1, 0x2, 0xD, 0xB, 0x4, 0x6, 0x3, 0x0, 0x7, 0x9, 0xA
};
const unsigned char *active_sbox = NULL;

unsigned int round_counter;
key_t 	key;
block_t state;

void rotate_left_i(int i){
	key_t newkey;
	unsigned int bit;
	memset(newkey.bytes, 0x0, 10);
	for(bit = 0; bit < 80; bit++){
		if(test_bit(key.bytes,bit)){
			set_bit(newkey.bytes,(bit+i)%80);
		}
	}
	memcpy(key.bytes, newkey.bytes, 10);
}

void schedule_key(void){
	/* 3. [k38k37k36k35k34] ^= round_counter - also stolen from Zhu/Gong */
	key.bytes[5] ^= round_counter << 2;

	/* 1. [k79k78..k1k0] = [k18k17..k20k19] */
	rotate_left_i(61);
	
	/* 2. [k79k78k77k76] = S[k79k78k77k76] */
	key.bytes[0] = (sbox[key.bytes[0] >> 4] << 4) | (key.bytes[0] & 0xf);
}

void addRoundKey(void){
	block_t roundkey;
	memcpy(roundkey.bytes, key.bytes, 8);
	state.value ^= roundkey.value;
}

void sBoxLayer(void){
	unsigned int i;
	for(i = 0; i < 8; i++){
		state.bytes[i] = (active_sbox[state.bytes[i] >> 4] << 4) | active_sbox[(state.bytes[i] & 0xf)];
	}
}

void pLayer(void){
	block_t newstate;
	unsigned int bit;
	newstate.value = 0;
	for(bit = 0; bit < 64; bit++){
		if(test_bit(state.bytes,bit)){
			set_bit(newstate.bytes,((16 * (bit % 4)) + (bit / 4)));
		}
	}
	state.value = newstate.value;
}

void setup(unsigned char *statebytes, unsigned char *keybytes){
	active_sbox = sbox;
	memcpy(state.bytes, statebytes, 8);
	memcpy(key.bytes, keybytes, 10);
}

void encrypt(unsigned char *statebytes, unsigned char *keybytes){
	setup(statebytes, keybytes);
	for(round_counter = 1; round_counter < 32; round_counter++){
		addRoundKey();
		sBoxLayer();
		pLayer();
		schedule_key();
	}
	addRoundKey();
	memcpy(statebytes, state.bytes, 8);
}

void decrypt(unsigned char *statebytes, unsigned char *keybytes){
	setup(statebytes, keybytes);
	for(round_counter = 1; round_counter < 32; round_counter++){
		schedule_key();
	}
	active_sbox = inverse_sbox;
	for(round_counter = 31; round_counter > 0; round_counter--){
		addRoundKey();
		pLayer();
		pLayer();
		sBoxLayer();

	inverse_schedule_key:
		key.bytes[0] = (inverse_sbox[key.bytes[0] >> 4] << 4) | (key.bytes[0] & 0xf);
		rotate_left_i(19);
		key.bytes[5] ^= round_counter << 2;
	}
	addRoundKey();
	memcpy(statebytes, state.bytes, 8);
}

void print_block(block_t block){
	printf(""%02x%02x%02x%02x %02x%02x%02x%02x\n"",
		block.bytes[0], block.bytes[1], block.bytes[2], block.bytes[3],
		block.bytes[4], block.bytes[5], block.bytes[6], block.bytes[7]
	);
}

void print_key(key_t key){
	printf(""%02x%02x%02x%02x %02x%02x%02x%02x %02x%02x\n"",
		key.bytes[0], key.bytes[1], key.bytes[2], key.bytes[3],
		key.bytes[4], key.bytes[5], key.bytes[6], key.bytes[7],
		key.bytes[8], key.bytes[9]
	);
}

void test(int keyval, int input){
	block_t test_state;
	key_t   test_key;
	memset(test_key.bytes, keyval, 10);
	test_state.value = input;

	printf(""Key:        "");
	print_key(test_key);
	printf(""Plaintext:  "");
	print_block(test_state);

	encrypt(test_state.bytes, test_key.bytes);

	printf(""Ciphertext: "");
	print_block(test_state);

	decrypt(test_state.bytes, test_key.bytes);

	printf(""Plaintext:  "");
	print_block(test_state);
	printf(""\n"");
}

int main(int argc, char* argv[]){
	test(0,0);
	test(-1,0);
	test(0,-1);
	test(-1,-1);

	return 0;
}


"
004-15112,ruchikd/Algorithms,C/FindLeastCommonAncestorInBST/FindLeastCommonAncestorInBST/main.c,140,2,412,2071607.9743577999,186963.0,11.080304659210643,1377.0,1356.0,42392.0,15389.0,1634.0,650.0,1354.0,607.0,1500000000,0.0013810719829052,1082014363648.0,0.0146178655669838,0.0734670566449178,"//
//  main.c
//  FindLeastCommonAncestorInBST
//
//  Created by Ruchik Dave on 3/7/16.
//  Copyright © 2016 Ruchik Dave. All rights reserved.
//

/**************************************************************
                          9
                        /   \
                      5       11
                   /    \      / \
                  2      7    10  15
                /       / \
               1       4    6
                      /
                     3
 **************************************************************/

/**************************************************************
 Complexity of below algorithm is O(h^2) where h = height of tree
 It can be further optimised to O(h) by using dictionary or hash
 table. Implementation is available in python section of same project
 **************************************************************/


#include <stdio.h>

struct listNode {
    int val;
    struct listNode * next;
};

struct Node {
    int val;
    struct Node * left;
    struct Node * right;
    struct Node * parent;
};

struct Node * createNode(int val){
    struct Node * node = (struct Node *)malloc (sizeof(struct Node));
    
    node->val = val;
    node->left = NULL;
    node->right = NULL;
    node->parent = NULL;
    
    return node;
}

struct listNode * createListNode(int val){
    struct listNode * node = (struct listNode*)malloc(sizeof(struct listNode));
    
    node->val = val;
    node->next = NULL;
    
    return node;
}

struct Node * createAboveBST(struct Node * root){
    if (root == NULL){
        printf(""Error: No root node\n"");
        return root;
    }
    
    root->left = createNode(5);
    root->left->parent = root;
    root->left->left = createNode(2);
    root->left->left->parent = root->left;
    root->left->left->left = createNode(1);
    root->left->left->left->parent = root->left->left;
    
    root->left->right = createNode(7);
    root->left->right->parent = root->left;
    root->left->right->left = createNode(4);
    root->left->right->left->parent = root->left->right;
    root->left->right->left->left = createNode(3);
    root->left->right->left->left->parent = root->left->right->left;
    
    root->left->right->right = createNode(6);
    root->left->right->right->parent = root->left->right;
    
    root->right = createNode(11);
    root->right->parent = root;
    root->right->left = createNode(10);
    root->right->left->parent = root->right;
    root->right->right = createNode(15);
    root->right->right->parent = root->right;
    
    return root;
}

void inorderTraversal(struct Node * root){
    if (root == NULL){
        return;
    }
    
    inorderTraversal(root->left);
    printf(""%d "", root->val);
    inorderTraversal(root->right);
    
}

int findLeastCommonAncester(struct Node* node1, struct Node* node2){
    struct Node * node1Temp = node1;
    struct Node * node2Temp = node2;
    
    while (node1Temp != NULL){
        while (node2Temp != NULL){
            if(node2Temp->val == node1Temp->val){
                return node2Temp->val;
            }
            node2Temp = node2Temp->parent;
        }
        node2Temp = node2;
        node1Temp = node1Temp->parent;
    }
    
    return -1;
}

int main(int argc, const char * argv[]) {
    struct Node * root = createNode(9);
    
    root = createAboveBST(root);
    
    inorderTraversal(root);
    printf(""\n"");
    
    int lca = findLeastCommonAncester(root->left->left->left, root->left->right);
    if (lca != -1)
        printf (""Least Common ancestor = %d\n"", lca);
    else
        printf (""Either one of the nodes is NULL or nodes are from different trees\n"");

    lca = findLeastCommonAncester(root->left->left->left, root->right->right);
    if (lca != -1)
        printf (""Least Common ancestor = %d\n"", lca);
    else
        printf (""Either one of the nodes is NULL or nodes are from different trees\n"");

    lca = findLeastCommonAncester(root->left->left->left, NULL);
    if (lca != -1)
        printf (""Least Common ancestor = %d\n"", lca);
    else
        printf (""Either one of the nodes is NULL or nodes are from different trees\n"");

    lca = findLeastCommonAncester(root->left->left->left, root);
    if (lca != -1)
        printf (""Least Common ancestor = %d\n"", lca);
    else
        printf (""Either one of the nodes is NULL or nodes are from different trees\n"");

    struct Node * newNode = createNode(50);
    lca = findLeastCommonAncester(root->left->left->left, newNode);
    if (lca != -1)
        printf (""Least Common ancestor = %d\n"", lca);
    else
        printf (""Either one of the nodes is NULL or nodes are from different trees\n"");

    lca = findLeastCommonAncester(NULL, NULL);
    if (lca != -1)
        printf (""Least Common ancestor = %d\n"", lca);
    else
        printf (""Either one of the nodes is NULL or nodes are from different trees\n"");

    lca = findLeastCommonAncester(root, root);
    if (lca != -1)
        printf (""Least Common ancestor = %d\n"", lca);
    else
        printf (""Either one of the nodes is NULL or nodes are from different trees\n"");

    return 0;
}
"
228-31542,Eiamnacken/Semester2HLC,testCEx.c,117,3,155,2202558.09836085,187059.0,11.774670023896205,1462.0,1437.0,42336.0,15295.0,1640.0,640.0,1358.0,598.0,1500000000,0.0014683720655739,1082014363648.0,0.0154977841215873,0.0735021082403567,"#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <limits.h>

typedef struct listnode_ {
	int data;
	struct listnode_* next;
} Listnode;

int counta(char s[]);
int sumArray(int values[], size_t count);
void applyFkt(int values[], size_t count, int (*fkt) (int));
int countAFile(char* filename);
double avgList(Listnode* head);
Listnode* addFront(Listnode* head, int item);
void freeList(Listnode* head);


/* Es folgen die Aufgaben */
// **************************


// Aufgabe 1 (10 Punkte)

/**
 * Bestimmt die Anzahl der Vorkommen des Buchstabens 'a' in der
 * Zeichenkette s
 * @param s Zeichenkette
 * @return Anzahl der Vorkommen von 'a'
 */
int counta(char s[])
{

}


// Aufgabe 2 (15 Punkte)

/**
 * Bestimmt die Summe der Elemente im uebergebenen Array
 * @param values Array der zu summierenden Elemente
 * @param count Anzahl der Elemente in dem Array values
 * @return Summe der Elemente
 */
int sumArray(int values[], size_t count)
{

}


// Aufgabe 3 (15 Punkte)

/**
 * Wendet auf jedes Element eines int-Arrays eine Funktion an und
 * ersetzt das Element durch den Rueckgabewert der Funktion.
 * @param values Array von int-Werten
 * @param count Anzahl der Elemente in values
 * @param fkt Funktionspointer auf die anzuwendende Funktion
 */
void applyFkt(int values[], size_t count, int (*fkt) (int))
{

}


// Aufgabe 4 (20 Punkte)

/**
 * Die Funktion ermittelt die Anzahl der 'a' oder 'A' in der
 * uebergebenen Datei.
 * Dazu oeffnet die Funktion die Datei mit fopen
 * liest die Datei zeichenweise mit fgetc ein bis das Ergebnis
 * EOF ist und schliesst die Datei mit fclose
 * @param filename Dateiname
 * @return Anzahl der 'A'/'a' in der Datei
 */
int countAFile(char* filename)
{

}

// Aufgabe 5 (20 Punkte)

/**
 * Bestimmt den Durchschnittswert der in der verketteten Liste
 * gespeicherten Werte.
 * @param head Zeiger auf das erste Element der Liste
 * @return Durchschnitt der gespeicherten Werte.
 */
double avgList(Listnode* head)
{

}

// Aufgabe 6 (20 Punkte)

// Ein Reiseplan soll in C verwaltet werden
// Erstellen Sie einen typedef Station fuer eine Struktur,
// die eine Station auf der Reise abbildet.
// In der Stuktur sollen Reisetag und Reiseziel
// enthalten sein.
// Erstellen Sie eine Funktion mkSt(tag, ziel), die eine solche Struktur
// auf dem Heap erzeugt und die Eintraege der Struktur den Parametern
// entsprechend fuellt. Die Funktion soll dann einen Zeiger auf die
// Struktur zurueckgeben.


// Ende der Aufgaben

Listnode* addFront(Listnode* head, int item)
{
	Listnode* newHead = (Listnode*) malloc(sizeof(Listnode));
	newHead->next = head;
	newHead->data = item;
	return newHead;
}

void freeList(Listnode* head)
{
	if (head == NULL)
		return;
	freeList(head->next);
	free(head);
}

int quad(int x)
{
	return x*x;
}


int main(void)
{
	char s[] = ""analysis"";
	int v[] = {1, 6, -3, 6, 0 };
	int i = 0;
	Listnode* head = NULL;
	printf(""%s %d\n"", s, counta(s));
	printf(""%d = %d\n"", 10, sumArray(v, sizeof(v) / sizeof(int)));
	for (i = 0; i < sizeof(v) / sizeof(int); i++)
			printf(""%d "", v[i]);
	printf("" == quad ==> "");
	applyFkt(v, sizeof(v) / sizeof(int), quad);
	for (i = 0; i < sizeof(v) / sizeof(int); i++)
		printf(""%d "", v[i]);
	printf(""\n"");
	for (i = 0; i < sizeof(v) / sizeof(int) ; i++)
		head = addFront(head, v[i]);
	printf(""Durchschnitt %f\n"", avgList(head));
	freeList(head);
	return EXIT_SUCCESS;
}
"
069-21667,djtuBIG-MaliceX/my-random-tools,vgm-rip-aids/ys2special_msdos/unpack_binary.c,131,6,148,1958299.66105515,180093.0,11.85468618991299,1340.0,1313.0,41091.0,14101.0,1664.0,640.0,1379.0,595.0,1500000000,0.0013055331073701,1082014363648.0,0.014731277728729,0.0775112335121032,"﻿/*
 *  Generic binary file unpacker
 *  Made for Ys II Special
 *  
 *  2013 James Alan Nguyen (dj.tuBIG/MaliceX)
 *  Do whatever the hell you want with it. :)
 *
 *  Compile with gcc -Wall -ansi -pedantic
 *
 *  http://www.codingchords.com
 */

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>

#define FILENAME_LEN 256
#define OFFSET_SIZE 4
#define OFFSET_ENTRY_SIZE 8
/*#define BUFFER_SIZE 65536*/

#if _WIN32
#define DIR_SEP '\\'
#else
#define DIR_SEP '/'
#endif

/* 
 * Function name: printUsage
 * Args: fname - Filename of the executable
 * Description: Self-explanatory.
 */
void printUsage(char *fname)
{
   printf(""\nUsage:\n""
      ""   %s <input file> <output directory>\n"",
      fname
   );
}

/* 
 * Function name: unpackBinaryFile
 * Args: in_file - input file pointer
 *       out_dirname - output directory (must exist or program will fail)
 *       cur_entry - counter ID for the data being extracted
 *
 * Description: Routine for extracting the next data segment.
 *
 * Note: Assumes an offset header structure as follows:
 *       <4 bytes start offset> <4 bytes data size> (repeat until end location)
 */
void unpackBinaryFile(FILE *in_file, char *out_dirname, int cur_entry)
{
   FILE *out_file;
   char out_fname[FILENAME_LEN], *file_buffer;
   int entry_offset, entry_size/*, written = 0*/;
   
   /*Append counter as filename suffix (probably on extension)*/
   sprintf(out_fname, ""%s[%04d]"", out_dirname, cur_entry);
   
   assert((out_file = fopen(out_fname, ""wb"")) != NULL);
   
   /*Read header*/
   fseek(in_file, (OFFSET_ENTRY_SIZE*cur_entry), SEEK_SET);
   fread(&entry_offset, OFFSET_SIZE, 1, in_file);
   fread(&entry_size, OFFSET_SIZE, 1, in_file);
   
   /*printf(""Extracting: %s (%d bytes)\n"", out_fname, entry_size);*/
   printf(""[%d] - O:0x%04x, S:0x%04x\n"", cur_entry, entry_offset, entry_size);
   assert((file_buffer = malloc(entry_size)) != NULL);
   
   /*Extract contents*/
   fseek(in_file, entry_offset, SEEK_SET);
   fread(file_buffer, entry_size, 1, in_file);
   fwrite(file_buffer, entry_size, 1, out_file);
   
   /* TODO buffered method
   assert((file_buffer = calloc(1, BUFFER_SIZE)) != NULL);
   while(written < entry_size)
   {
      fread(file_buffer, (entry_size > BUFFER_SIZE)
      ? BUFFER_SIZE : entry_size, 1, in_file);
   }
   
   free(file_buffer);
   */
   
   fclose(out_file);
}

/* 
 * Function name: getNumEntries
 * Args: in_file - input file pointer
 *
 * Description: Count the number of known entries based on the offset header
 *              information.
 *
 * Note: Routine assumes first offset information defines the location that
 *       separates the offsets from the binary data.
 */
int getNumEntries(FILE *in_file)
{
   char bin_cache[OFFSET_SIZE];
   int *offset_cache, num_entries;
   
   /*Get end of offset boundary, defined by first offset*/
   fseek(in_file, 0, SEEK_SET);
   fread(bin_cache, 1, OFFSET_SIZE, in_file);
   offset_cache = (int*)&bin_cache;
   num_entries = (*offset_cache) / OFFSET_ENTRY_SIZE;
   
   printf(""Offset list ends at: 0x%x\n"", (*offset_cache));
   printf(""Number of entries: %d\n"", num_entries-1);
   
   return num_entries;
}

/* 
 * Function name: runProgram
 * Args: in_fname - Input filename from command line argument 1
 *       out_dir - Output directory path from command line argument 2
 *
 * Description: Main application function
 *
 * Note: Default output directory is ./outs (must exist)
 */
void runProgram(char *in_fname, char *out_dir)
{
   FILE *in_file;
   char out_dirname[FILENAME_LEN];
   int cur_entry, end_entry;
   
   /*Create output filename prefix template*/
   (out_dir[strlen(out_dir)-1] == DIR_SEP)
         ? sprintf(out_dirname, ""%s%s"", out_dir, in_fname)
         : sprintf(out_dirname, ""%s%c%s"", out_dir, DIR_SEP, in_fname);
   
   assert((in_file = fopen(in_fname, ""rb"")) != NULL);
   
   end_entry = getNumEntries(in_file);
   
   /*Ignore data size for first offset*/
   fseek(in_file, OFFSET_SIZE, SEEK_CUR);
   
   for(cur_entry = 1; cur_entry < end_entry; ++cur_entry)
      unpackBinaryFile(in_file, out_dirname, cur_entry);
   
   fclose(in_file);
}

int main(int argc, char *argv[])
{
   switch(argc)
   {
      case 3:
         runProgram(argv[1], argv[2]);
         break;
      
      case 2:
         runProgram(argv[1], ""outs"");
         break;
      
      case 1:
      default:
         printUsage(argv[0]);
         break;
   }
   
   return EXIT_SUCCESS;
}"
299-12964,ddki/my_study_project,other/tmp/Introduction-to-Algorithms/algo_indroduce/part1/sort.c,291,14,314,1975444.49474655,196717.0,10.042060421824244,1393.0,1365.0,44467.0,16690.0,1650.0,638.0,1364.0,596.0,1500000000,0.0013169629964977,1082014363648.0,0.0140201406080816,0.0694605687002305,"#include <stdio.h>
#include <math.h>

void printArray(int *A, int len) {
   for(int i = 0; i < len; i++) {
       printf(""%d "", A[i]);
   }
}

void swap(int *A, int i, int j) {
    int tmp = A[i];
    A[i] = A[j];
    A[j] = tmp;
}


/**
 * sorting problme
 * input: <a1, a2, ..., an>
 * output: <a1`,a2`,...,an`> is a reording list, a1` ≤ a2` ≤ ... ≤ an`
 */
 
/**
 * insertion sort
 * A[1..n] -> B[1..n]
 *
 * B[1..1] = A[1..1]
 * B[1..i] = insert(B[1..i-1], A[i])
 *
 * the insert way: 
 * (1) B[j + 1] = B[j]. move all elements bigger than A[i] to the next indice.
 * (2) place A[i] at the right palce. B[j + 1] = A[i]
 */
int * insertionSort(int *A, int len) {
    for (int i = 1; i < len; i++) {
        int v = A[i];
        // insert A[i] into the sorted sequence A[1..i-1]
        int j = i - 1;
        // translate elements bigger than v to next indice
        while(j >= 0 && A[j] > v) {
            A[j + 1] = A [j];
            j--;
        }
        A[j + 1] = v;
    }
    return A;
}

/**
 * p..m   sorted
 * m+1..q sorted
 *
 * compare top of the two stack
 */
void merge(int *A, int p, int m, int q) {
    int len1 = m - p + 1;
    int len2 = q - m;
    int L[len1];
    int R[len2];
    // copy
    for(int i = p; i <= m; i++) {
        L[i - p] = A[i];
    }
    for(int i = m + 1; i <= q; i++) {
        R[i - m - 1] = A[i];
    }
    int k1 = 0;
    int k2 = 0;
    for(int i = p; i <= q; i++) {
        if(k1 >= len1) { // left is all used
            A[i] = R[k2++];
        }
        else if(k2 >= len2) { // right is all used
            A[i] = L[k1++];
        }
        else if(L[k1] <= R[k2]) {
            A[i] = L[k1++];
        } else {
            A[i] = R[k2++];
        }
    }
}

/**
 * merge sort
 *
 * divide and conqure
 *
 * mergeSort(A[p..p]) = A[p..p] 
 * 
 * m = p + (q - p) / 2;
 * mergeSort(A[p..q]) = merge(mergeSort(A[p..m]), mergeSort(A[m+1..q))
 */
int * mergeSort(int *A, int p, int q) {
    if(p == q) {
        return A;
    }
    int m = p + floor((q - p) / 2);
    mergeSort(A, p, m);
    mergeSort(A, m + 1, q);
    // combine
    merge(A, p, m, q);
    return A;
}

/**
 * heapsort
 *
 * (binary) heap
 * 1. is an array object
 *    heap = A[0..A.heap-size - 1]
 *    1 ≤ A.heap-szie ≤ A.length
 * 2. root A[1]
 *    parent(i) = ceil(i / 2) - 1
 *    left(i) = 2 * i + 1
 *    right(i) = 2 * i + 2
 *
 * there are two kind of binary heaps: max-heaps and min-heaps
 *
 * in max-heap, the max-heap property
 * A[parent(i)] ≥ A[i]
 *
 * in min-heap, the min-heap property
 * A[parent(i)] ≤ A[i]
 */
int parent(int i) {
    return ceil(i / 2) - 1;
}

int left(int i) {
    return i * 2 + 1;
}

int right(int i) {
    return 2 * i + 2;
}

// maintain the max-heap property
// assume left(i) and right(i) are max-heap
// T(n) ≤ T(2n/3) + Ø(1)
void maxHeapify(int *A, int heapSize, int i) {
    int l = left(i);
    int r = right(i);
    int largest = i;
    if(l < heapSize && A[l] > A[largest]) {
        largest = l;
    }
    if(r < heapSize && A[r] > A[largest]) {
        largest = r;
    }
    if(largest != i) {
        swap(A, i, largest);
        maxHeapify(A, heapSize, largest);
    }
}

/**
 * in a binary tree, A[(floor(n/2) )..n] are all leaves of the tree
 *
 * T(n) = O(n)
 */
void buildMaxHeap(int *A, int len){
    int m = floor(len / 2) - 1;
    for(int i = m; i >= 0; i--) {
        maxHeapify(A, len, i);
    }
}

/**
 * T(n) = ø(n) + (n - 1)Ø(lgn)
 * T(n) = Ø(nlgn)
 */
int * heapSort(int *A, int len) {
    buildMaxHeap(A, len);
    for(int i = len - 1; i >= 1; i--) {
        swap(A, 0, i);
        maxHeapify(A, i, 0);
    }
    return A;
}

/**
 * proiority queue
 * 1. Set S
 * 2. elem has a value called key.
 *
 * max-priority queue
 * 1. insert(S, x)  S = S U {x}
 * 2. maximum(S)
 * 3. extract-max(S)
 * 4. increase-key(S, x, k) k ≥ x
 */
int heap_maximum(int *A) {
    return A[0];
}

int heap_extract_max(int *A, int len) {
    if(len < 1) {
        printf(""heap under flow"");
        return -1;
    }
    int max = A[0];
    A[0] = A[len - 1];
    len--;
    maxHeapify(A, len, 0);
    return max;
}

void heap_increase_key(int *A, int i, int key) {
    if(key < A[i]) {
        printf(""new key is smaller"");
        return;
    }
    A[i] = key;
    while(i > 1 && A[parent(i) < A[i]]) {
        swap(A, parent(i), i);
        i = parent(i);
    }
}

void max_heap_insert(int *A, int len, int key) {
    len++;
    A[len - 1] = -65535;
    heap_increase_key(A, len - 1, key);
}

/**
 * quicksort
 *
 * divide and conqure
 *
 * 1. divide
 *    A[p..r] to A[p..q-1] A[q] A[q+1..r], make a in A[p..q-1], a < A[q] and b in A[q+1..r], b > A[q]
 * 2. conqure
 *    recursive A[p..q-1] A[q+1..r]
 * 3. combine
 */
int * quickSort(int *A, int p, int r) {
    if(p >= r) {
        return A;
    }
    // divide
    int key = A[r];
    int j = p - 1;
    // at beginning of iteration
    // if p ≤ k ≤ j, A[k] ≤ key
    // if j + 1 ≤ k ≤ i - 1, A[k] > key
    // if k = r, A[k] = x
    for(int i = p; i <= r - 1; i++) {
        if(A[i] <= key) {
            j ++;
            swap(A, i, j);
        }
    }
    swap(A, j + 1, r);
    int q = j + 1;
    // conqure
    quickSort(A, p, q - 1);
    quickSort(A, q + 1, r);
    return A;
}

/**
 * counting sort
 * assumes, each of the n input elements is an integer in the range of 0 to k.
 *
 * a in A[0..n-1], belong to {0..k}
 */

int * countingSort(int *A, int *B,int len, int k) {
    int C[k];
    for(int i = 0; i < k; i++) {
        C[i] = 0;
    }
    for(int i = 0; i < len; i++) {
        C[A[i]] = C[A[i]] + 1;
    } // C[i] contains the number of elements equal to i
    for (int i = 1; i < k; i++) {
        C[i] = C[i] + C[i - 1];
    } // C[i] now contains the number of elements less than or equal to i
    for (int i = len - 1; i >= 0; i--) {
        B[C[A[i]] - 1] = A[i];
        C[A[i]] = C[A[i]] - 1;
    }
    return B;
}

/**
 * radix sort
 *
 * sorting on the least significant digit first.(smart idea)
 *
 * TODO
 */

/**
 * bucket sort
 */

int main (void) {
   int A1[] = { 5, 4, 3, 8, 10, 2 };
    printArray(insertionSort(A1, 6), 6);
    printf(""\n"");
   int A2[] = { 5, 4, 3, 8, 10, 2 };
    printArray(mergeSort(A2, 0, 5), 6);

    printf(""\n"");
    int A3[] = { 5, 4, 3, 8, 10, 2 };
    printArray(heapSort(A3, 6), 6);
    printf(""\n"");
    int A4[] = { 5, 4, 3, 8, 10, 2 };
    printArray(quickSort(A4, 0, 5), 6);
    printf(""\n"");
    int A5[] = { 5, 4, 3, 8, 10, 2 };
    int B[6];
    printArray(countingSort(A5, B, 6, 11), 6);
}
"
338-6760,apan64/ExercisesInC,exercises/ex13/list_errors.c,141,6,116,1872409.60076445,184030.0,10.1744769874477,1371.0,1350.0,41884.0,14865.0,1634.0,643.0,1355.0,598.0,1500000000,0.0012482730671763,1082014363648.0,0.0147856327772645,0.0745387583922183,"/* Example code for Exercises in C.

Copyright 2014 Allen Downey
License: Creative Commons Attribution-ShareAlike 3.0

*/

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>


typedef struct node {
    int val;
    struct node * next;
} Node;

Node *make_node(int val, Node *next) {
    Node *node = malloc(sizeof(Node));
    node->val = val;
    node->next = next;
    return node;
}

void print_list(Node *head) {
    Node *current = head;

    while (current != NULL) {
        printf(""%d\n"", current->val);
        current = current->next;
    }
}

int pop(Node **head) {
    int retval;
    Node *next_node;

    if (*head == NULL) {
        return -1;
    }

    next_node = (*head)->next;
    retval = (*head)->val;
    *head = next_node;

    return retval;
}

// Add a new element to the beginning of the list.
void push(Node **head, int val) {
    Node *new_node = make_node(val, *head);
    *head = new_node;
}

// Remove the first element with the given value; return the number
// of nodes removed.
int remove_by_value(Node **head, int val) {
    Node *node = *head;
    Node *victim;

    if (node == NULL) {
	return 0;
    }

    if (node->val == val) {
	pop(head);
	return 1;
    }

    for(; node->next != NULL; node = node->next) {
	if (node->next->val == val) {
	    victim = node->next;
	    node->next = victim->next;
	    return 1;
	}
    }
    return 0;
}

// Reverse the elements of the list without allocating new nodes.
void reverse(Node **head) {
    Node *node = *head;
    Node *next, *temp;

    if (node == NULL || node->next == NULL) {
	return;
    }

    next = node->next;
    node->next = NULL;

    while (next != NULL) {
	temp = next->next;
	next->next = node;
	node = next;
	next = temp;
    }
    *head = node;
}

// Adds a new element to the list before the indexed element.
// Index 0 adds an element to the beginning.  Index 1 adds an
// element between the first and second elements.
// Returns 0 if successful, -1 if the index is out of range.
int insert_by_index(Node **head, int val, int index) {
    int i;
    Node *node = *head;

    if (index == 0) {
	push(head, val);
	return 0;
    }

    for (i=0; i<index-1; i++) {
	if (node == NULL) return -1;
	node = node->next;
    }
    if (node == NULL) return -1;
    node->next = make_node(val, node->next);
    return 0;
}

// Makes a mysterious data structure.
Node *make_something() {
    Node *node1 = make_node(1, NULL);
    Node *node2 = make_node(2, NULL);
    Node *node3 = make_node(3, NULL);

    int val = pop(&node1);
    push(&node2, val);
    node3->next = node2;

    return node3;
}

// frees a linked list of nodes
void freeNodes(Node *list){
    Node *cur = list;
    Node *prev;
    while(cur != NULL){
        prev = cur;
        cur = cur->next;
        free(prev);
    }
}

int main() {
    // make a list of even numbers
    Node *test_list = make_node(2, NULL);
    test_list->next = make_node(4, NULL);
    test_list->next->next = make_node(6, NULL);

    // insert the odd numbers
    insert_by_index(&test_list, 1, 0);
    insert_by_index(&test_list, 3, 2);
    insert_by_index(&test_list, 5, 4);
    insert_by_index(&test_list, 7, 6);

    // this index is out of bounds; should return -1
    int res = insert_by_index(&test_list, 9, 8);
    assert(res == -1);

    printf(""test_list\n"");
    print_list(test_list);

    freeNodes(test_list);

    // make an empty list
    printf(""empty\n"");
    Node *empty = NULL;

    // add an element to the empty list
    insert_by_index(&empty, 1, 0);
    print_list(empty);

    free(empty);


    Node *something = make_something();
    freeNodes(something);

    return 0;
}
 
"
354-29497,chggr/puzzles,medium/heapsort.c,122,5,97,2067783.03254385,179252.0,11.535620244125589,1375.0,1355.0,40399.0,13815.0,1633.0,636.0,1351.0,593.0,1500000000,0.0013785220216959,1082014363648.0,0.015229955593243,0.0777105544693252,"#include <stdio.h>

// Task description: Given an array of integers, implement heapsort to sort the
// elements in place.
//
// E.g. for input array {8, 2, 9, 4, 0, 5, 1, 7, 6, 3}
//      the output should be {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
//
// Solution: Heapsort is an in-place unstable sorting algorithm with best, worst
// and average runtime complexity of O(n * logn). The algorithm is divided into
// two parts:
//
// (1) A max heap is built out of the input data in place, mapping the structure
// of a complete binary tree into the array indices so that for each node its
// left child is at 2*n + 1 and its right child at 2*n + 2. The root node is
// stored at index 0.
//
// (2) The largest element of the heap (i.e. the root) is continuously removed
// and placed at the end of the array, thus dividing the array into a sorted and
// an unsorted region and iteratively shrinking the unsorted region until the
// whole array is sorted.
//
// The improvement heapsort offers versus insertion or selection sort is that it
// uses a heap data structure to identify the maximum element of the array in
// O(logn) rather than using a linear search in O(n). Although it is slower in
// practice than a well implemented quicksort, it has the advantage of a better
// worst-case complexity of O(n * logn) versus O(n^2).
//
// In the implementation below, method heapify() is used to turn the original
// array into a max heap. The parent node of each element is identified and
// method downheap() is used to bubble it down until it has reached the correct
// position in the heap. Once the max heap has been constructed, sorting the
// array is as simple as swapping the heap's root element with its last element
// and then calling downheap() to restore the heap's constraints.

void swap(int array[], int a, int b) {
    if (a == b) return;
    int temp = array[a];
    array[a] = array[b];
    array[b] = temp;
}

void downheap(int array[], int size, int parent) {
    int left = 2 * parent + 1;
    int right = 2 * parent + 2;
    int max = parent;

    if (left < size && array[left] > array[max]) max = left;
    if (right < size && array[right] > array[max]) max = right;

    if (max != parent) {
        swap(array, parent, max);
        downheap(array, size, max);
    }
}

void heapify(int array[], int size) {
    for (int i = size - 1; i >= 0; i--) {
        int parent = (i - 1) / 2;
        downheap(array, size, parent);
    }
}

void heapsort(int array[], int size) {
    heapify(array, size);

    for (int i = size - 1; i > 0; i--) {
        swap(array, 0, i);
        downheap(array, i, 0);
    }
}

int are_equal(int a[], int b[], int size) {
    for (int i = 0; i < size; i++) {
        if (a[i] != b[i]) return 0;
    }
    return 1;
}

int test_heapify() {
    int input[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    int expected[] = {9, 8, 6, 7, 4, 5, 2, 0, 3, 1};

    heapify(input, 10);
    return are_equal(input, expected, 10);
}

int test_heapsort_sorted() {
    int input[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    int expected[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

    heapsort(input, 10);
    return are_equal(input, expected, 10);
}

int test_heapsort_reverse_sorted() {
    int input[] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0};
    int expected[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

    heapsort(input, 10);
    return are_equal(input, expected, 10);
}

int test_heapsort_all_equal() {
    int input[] = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3};
    int expected[] = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3};

    heapsort(input, 10);
    return are_equal(input, expected, 10);
}

int test_heapsort() {
    int input[] = {8, 2, 9, 4, 0, 5, 1, 7, 6, 3};
    int expected[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

    heapsort(input, 10);
    return are_equal(input, expected, 10);
}

int main() {
    int counter = 0;
    if (!test_heapify()) {
        printf(""Heapify test failed!\n"");
        counter++;
    }
    if (!test_heapsort_sorted()) {
        printf(""Heapsort already sorted test failed!\n"");
        counter++;
    }
    if (!test_heapsort_reverse_sorted()) {
        printf(""Heapsort already reverse sorted test failed!\n"");
        counter++;
    }
    if (!test_heapsort_all_equal()) {
        printf(""Heapsort all elements equal test failed!\n"");
        counter++;
    }
    if (!test_heapsort()) {
        printf(""Heapsort test failed!\n"");
        counter++;
    }
    printf(""%d tests failed.\n"", counter);
}

"
274-14823,qeedquan/misc_utilities,math/matrix-row-column-order.c,199,24,129,117637603.31086814,1172559939.0,0.100325449546166,1477.0,1448.0,305190799.0,195317583.0,5098586.0,1945980.0,1451.0,5471.0,1500000000,0.0784250688739121,1082014363648.0,2.494541986906479e-06,0.0140886511666851,"// https://en.wikipedia.org/wiki/Row-_and_column-major_order
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

void
cons(size_t r, size_t c, int M[r][c], int v)
{
	size_t i, j;

	for (i = 0; i < r; i++) {
		for (j = 0; j < c; j++)
			M[i][j] = v;
	}
}

void
mulsq(size_t n, int A[n][n], int B[n][n], int C[n][n])
{
	size_t i, j, k;

	cons(n, n, C, 0);
	for (i = 0; i < n; i++) {
		for (j = 0; j < n; j++) {
			for (k = 0; k < n; k++)
				C[i][j] += A[i][k] * B[k][j];
		}
	}
}

void
fill(size_t r, size_t c, int M[r][c])
{
	size_t i, j;

	for (i = 0; i < r; i++) {
		for (j = 0; j < c; j++)
			M[i][j] = i * r + j;
	}
}

void
rands(size_t r, size_t c, int M[r][c])
{
	size_t i, j;

	for (i = 0; i < r; i++) {
		for (j = 0; j < c; j++)
			M[i][j] = rand() % 100;
	}
}

void
transpose(size_t r, size_t c, int M[r][c], int N[c][r])
{
	size_t i, j;

	for (i = 0; i < r; i++) {
		for (j = 0; j < c; j++)
			N[j][i] = M[i][j];
	}
}

void
row2col(size_t r, size_t c, int M[r][c], int N[r][c])
{
	size_t i, j;
	int *p;

	p = &N[0][0];
	for (i = 0; i < c; i++) {
		for (j = 0; j < r; j++)
			*p++ = M[j][i];
	}
}

void
dump(size_t r, size_t c, int M[r][c])
{
	size_t i, j;

	for (i = 0; i < r; i++) {
		for (j = 0; j < c; j++)
			printf(""%d "", M[i][j]);
		printf(""\n"");
	}
	printf(""\n"");
}

void
dump_raw(void *b, size_t n)
{
	size_t i;
	int *p;

	p = b;
	for (i = 0; i < n; i++) {
		printf(""%d "", p[i]);
		if ((i & 15) == 15)
			printf(""\n"");
	}
	printf(""\n"");
}

void
test_cycle(size_t r, size_t c)
{
	int M[r][c], N[r][c], T[r][c];
	size_t i;

	fill(r, c, M);

	// if we keep converting row to columns, we will eventually
	// get back the original matrix we start, figure out how many
	// cycles that take
	memcpy(N, M, sizeof(M));
	for (i = 1;; i++) {
		row2col(r, c, N, T);
		memcpy(N, T, sizeof(T));
		if (!memcmp(M, N, sizeof(N)))
			break;
	}
	printf(""%zux%zu took %zu cycles\n"", r, c, i);
}

void
test_transpose(size_t r, size_t c, int n)
{
	int M[r][c];
	int A[r][c], B[r][c];
	int X[r][c], Y[c][r];
	int i, m;

	if (r == 0 || c == 0)
		return;

	fill(r, c, M);
	memcpy(A, M, sizeof(M));
	memcpy(X, M, sizeof(M));
	for (i = 0; i < n; i++) {
		row2col(r, c, A, B);
		if (!(i & 1)) {
			transpose(r, c, X, Y);
			m = memcmp(B, Y, sizeof(Y));
		} else {
			transpose(c, r, Y, X);
			m = memcmp(B, X, sizeof(X));
		}
		memcpy(A, B, sizeof(B));

		if (m) {
			printf(""#%d %zux%zu mismatch\n"", i, r, c);
			dump(r, c, B);
			if (!(i & 1))
				dump(c, r, Y);
			else
				dump(r, c, X);
		}
	}
}

void
test_square_transpose(size_t n)
{
	int A[n][n], B[n][n], C[n][n], D[n][n], E[n][n], F[n][n], G[n][n], H[n][n];

	rands(n, n, A);
	rands(n, n, B);

	// A * B
	mulsq(n, A, B, C);

	// D = transpose(A*B)
	transpose(n, n, C, D);

	// E = transpose(B)
	transpose(n, n, B, E);

	// F = transpose(A)
	transpose(n, n, A, F);

	// G = transpose(B)*transpose(A)
	mulsq(n, E, F, G);

	// same ops as above but replace transpose with row2col
	mulsq(n, A, B, C);
	row2col(n, n, C, D);
	row2col(n, n, B, E);
	row2col(n, n, A, F);
	mulsq(n, E, F, H);
	if (memcmp(H, G, sizeof(G))) {
		printf(""%zux%zu transpose mismatch\n"", n, n);
		dump(n, n, G);
		dump(n, n, H);
	}
}

int
main(void)
{
	int i, j;

	srand(time(NULL));

	// 1x1 matrix takes 1 cycle since its only one element
	// every other square matrix takes 2 cycles
	// this implies that row2col is its own inverse for square matrix
	printf(""# Test Cycle\n"");
	for (i = 1; i <= 100; i++)
		test_cycle(i, i);

	// non-square matrices have a weird number of cycles
	test_cycle(2, 3);
	test_cycle(4, 39);
	test_cycle(54, 100);
	test_cycle(320, 30);
	printf(""\n"");

	// transposing a matrix and converting row to column are the same operation
	// at the first time, afterwards they are not the same operation anymore
	// unless they are square matrices since row2col is its own inverse at that point

	// one common mistake is doing the following
	// transpose(r, c, X, Y);
	// transpose(r, c, Y, X);
	// if we do it this way, the transpose operation will be exactly the same as row2col
	// always, but the issue is that the second transpose should be passed as (c, r) instead of (r, c)

	printf(""# Test Transpose\n"");
	for (i = 0; i <= 4; i++)
		for (j = 0; j <= 4; j++)
			test_transpose(i, j, 5);

	// for square matrices, some identities should work, ie
	// transpose(A*B) = transpose(B)*transpose(A)
	// row2col(A*B) == row2col(A)*row2col(B)
	printf(""# Test Square Transpose\n"");
	for (i = 1; i <= 100; i++)
		test_square_transpose(i);

	return 0;
}
"
199-10659,zajnemzaj/path-finder,1_3.c,181,17,125,353000076.021999,1319031572.0,0.2676206419113673,1598.0,1561.0,299458287.0,89077052.0,1692.0,737.0,1399.0,692.0,1500000000,0.235333384014666,1082014363648.0,2.394938883236981e-06,1.1633433426244916e-05,"/*Feltöltjük a mátrixunkat p valószínűség alapján 0 vagy 1 számokkal, és kiíratjuk*/
#include <stdio.h>
#include <math.h> // rand-hoz kell
#include <time.h> // time-hoz kell
#include <stdlib.h> // srand-hoz kell

#define MMERET 10// tábla méret
//#define p 0.3 // p valószínűség
#define ismetles 1000
#define szorasfinomsag 100

#define max(a,b) (a>b?a:b)

void matrixfeltoltes(int fmatrix[MMERET][MMERET], float fp);

void matrixkiiratas(int fmatrix[MMERET][MMERET]);

void vektorfeltoltes(int fvektor[2][MMERET*2]);

void bejaras(int fmatrix[MMERET][MMERET], int fsegedvektor[2][MMERET*2]);

void clusterjoin(int fmatrix[MMERET][MMERET], int fsegedvektor[2][MMERET*2]);

int eldont(int fmatrix[MMERET][MMERET]);

void matrixkiiratas2(int fsegedvektor[2][MMERET*2]);

int main(void) 
{
	int matrix[MMERET][MMERET], atmente;
	int segedvektor[2][MMERET*2];
	srand ( time(NULL) );
	float valosz;
	FILE *fp;
	fp = fopen(""1_3.txt"", ""w+"");
	 
	//matrixfeltoltes(matrix,p);
	//matrixkiiratas(matrix);
	for (int j = 0; j < szorasfinomsag; j++)
	{
		atmente = 0;
		float p = (float)j/szorasfinomsag;
		for (int i = 0; i < ismetles; i++)
		{
			vektorfeltoltes(segedvektor);
			matrixfeltoltes(matrix,p);
			//printf(""Kezdő mátrix %.1f szórásvalószínűség mellett:\n"",p);matrixkiiratas(matrix);
			bejaras(matrix,segedvektor);
			//printf(""Cluster mátrix:\n"");matrixkiiratas(matrix);
			clusterjoin(matrix,segedvektor);
			//printf(""Clusterjoined mátrix:\n"");matrixkiiratas(matrix);
			//printf(""Segédvektorunk:\n"");matrixkiiratas2(segedvektor);
			atmente += eldont(matrix);
			//printf(""Eddig ennyi probálkozás sikerült: %d\n"",atmente);
		}
		valosz = (float)atmente / (float)ismetles * 100;
		printf(""Sikeres átjárások %.2f szórásvalószínűség mellett: %.2f szazalek \n"",p,valosz);
		fprintf( fp, ""%.2f %.2f\n"", p, valosz);
	}
	
	fclose(fp);
	return 0;
}

void matrixkiiratas2(int fsegedvektor[2][MMERET*2])
{
	for (int i = 0; i < MMERET*2; i++)
	{
		for (int j = 0; j < 2; j++)
			printf(""%d "",fsegedvektor[j][i]);
		printf(""\n"");
	}
}

int eldont(int fmatrix[MMERET][MMERET])
{
	for (int i = 0; i < MMERET; i++)
	{
		if (fmatrix[0][i] != 0)
		{
			for (int j = 0; j < MMERET; j++)
			{
				if (fmatrix[MMERET-1][j] == fmatrix[0][i])
				{
					return 1;
				}
			}
		}
	}
	return 0;
}

void clusterjoin(int fmatrix[MMERET][MMERET], int fsegedvektor[2][MMERET*2])
{
	for (int k = 0; k < MMERET*2; k++)
		if (fsegedvektor[1][k] != 0)
			for (int i = 0; i < MMERET; i++)
				for (int j = 0; j < MMERET; j++)
					if ((fmatrix[i][j] != 0) && (fmatrix[i][j] == fsegedvektor[1][k]))
						fmatrix[i][j] = fsegedvektor[0][k];
}

void bejaras(int fmatrix[MMERET][MMERET], int fsegedvektor[2][MMERET*2])
{
	int clusterszam = 1;
	int unioszam = 0;
	for (int i=0; i < MMERET; i++)
		for (int j=0; j < MMERET; j++)
			if (fmatrix[i][j]) 
			{                        // if occupied ...
				int up = (i==0 ? 0 : fmatrix[i-1][j]);    //  look up  
				int left = (j==0 ? 0 : fmatrix[i][j-1]);  //  look left
	 
				switch (!!up + !!left)
				{
					case 0:
						fmatrix[i][j] = clusterszam++;		// a new cluster
						break;
	  
					case 1:                              	// part of an existing cluster
						fmatrix[i][j] = max(up,left);       // whichever is nonzero is labelled
						break;
	  
					case 2:     
						if (up != left)						// this site binds two clusters
							if (up < left)
							{
								fmatrix[i][j] = up;
								fsegedvektor[0][unioszam] = up;
								fsegedvektor[1][unioszam] = left;
								unioszam++;
							} 
							else
							{
								fmatrix[i][j] = left;
								fsegedvektor[0][unioszam] = left;
								fsegedvektor[1][unioszam] = up;
								unioszam++;
							}
						else
							fmatrix[i][j] = up;
						break;
				}
	
			}
}

void vektorfeltoltes(int fvektor[2][MMERET*2])
{
	for (int j = 0; j < 2; j++)
		for (int i = 0; i < MMERET*2; i++)
		{
			fvektor[j][i] = 0;
		}
	
}

void matrixfeltoltes(int fmatrix[MMERET][MMERET], float fp)
{
	for (int i = 0; i < MMERET; i++)
	{
		for (int j = 0; j < MMERET; j++)
		{
			float irany = rand();
			float kicsirand = irany / RAND_MAX;
			if (kicsirand < fp)
			{
				fmatrix[i][j] = 1;
			} else
			{
				fmatrix[i][j] = 0;
			}
			
		}
	}
}
#define ANSI_COLOR_RED     ""\x1b[31m""
#define ANSI_COLOR_GREEN   ""\x1b[32m""
#define ANSI_COLOR_YELLOW  ""\x1b[33m""
#define ANSI_COLOR_BLUE    ""\x1b[34m""
#define ANSI_COLOR_MAGENTA ""\x1b[35m""
#define ANSI_COLOR_CYAN    ""\x1b[36m""
#define ANSI_COLOR_GRAY    ""\x1b[1;32m""
#define ANSI_COLOR_RESET   ""\x1b[0m""

void matrixkiiratas(int fmatrix[MMERET][MMERET])
{
	for (int i = 0; i < MMERET; i++)
	{
		for (int j = 0; j < MMERET; j++)
		{
			switch (fmatrix[i][j])
			{
				case 1:
					printf(ANSI_COLOR_RED   ""%2d ""  ANSI_COLOR_RESET,fmatrix[i][j]);
					break;
				case 2:
					printf(ANSI_COLOR_GREEN   ""%2d ""  ANSI_COLOR_RESET,fmatrix[i][j]);
					break;
				case 3:
					printf(ANSI_COLOR_YELLOW   ""%2d ""  ANSI_COLOR_RESET,fmatrix[i][j]);
					break;
				case 4:
					printf(ANSI_COLOR_BLUE   ""%2d ""  ANSI_COLOR_RESET,fmatrix[i][j]);
					break;
				case 5:
					printf(ANSI_COLOR_MAGENTA   ""%2d ""  ANSI_COLOR_RESET,fmatrix[i][j]);
					break;
				case 6:
					printf(ANSI_COLOR_CYAN   ""%2d ""  ANSI_COLOR_RESET,fmatrix[i][j]);
					break;
				case 7:
					printf(ANSI_COLOR_GRAY   ""%2d ""  ANSI_COLOR_RESET,fmatrix[i][j]);
					break;
				default:
					printf(""%2d "",fmatrix[i][j]);
					
			}
		}
		printf(""\n"");
	}
	printf(""\n\n"");
}
"
351-31195,f0rk/project-euler,c/problem84.c,173,5,109,385829966.8645486,1715267047.0,0.2248694345726563,1381.0,1361.0,392255388.0,160013954.0,1653.0,642.0,1368.0,598.0,1500000000,0.2572199779096991,1082014363648.0,1.5985848995325565e-06,7.715438239915914e-06,"#include <stdio.h>
#include <stdlib.h>
//solution: 101524

int roll(int sides);
void shuffle(int arr[], int n);

int euler_problem_84() {
    long hits[40] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    int chance[16] = {
        0, //advance to GO
        10, //go to JAIL
        11, //go to C1
        24, //go to E3
        39, //go to H2
        5, //go to R1
        -1, //go to next RR
        -1, //go to next RR
        -2, //go to next Util
        -3, //go back 3 spaces
        -10, //do nothing
        -10,
        -10,
        -10,
        -10,
        -10
    };
    int comchest[16] = {
        0, //advance to GO
        10, //go to jail
        -10, //do nothing
        -10,
        -10,
        -10,
        -10,
        -10,
        -10,
        -10,
        -10,
        -10,
        -10,
        -10,
        -10,
        -10
    };
    int curpos = 0, //GO
        die0 = 0,
        die1 = 0,
        SIDES = 4, //sides on the dice
        doubles = 0, //doubles in a row
        ccpos = 0, //position community chest deck
        chpos = 0, //position in the chance deck
        i = 0;
    long MAXROLLS = 10000000,
         currolls = 0,
         top0 = 0,
         top1 = 0,
         top2 = 0;

         
    //chance and community chest
    shuffle(chance, 16);
    shuffle(comchest, 16);
    
    for(currolls = 0; currolls < MAXROLLS; ++currolls) {
        die0 = roll(SIDES);
        die1 = roll(SIDES);
        
        if(curpos + die0 + die1 > 39) {
            curpos = curpos + die0 + die1 - 39;
        } else {
            curpos = curpos + die0 + die1;
        }
        
        if(die0 == die1) {
            ++doubles;
        } else {
            doubles = 0;
        }
        
        if(doubles == 3) {
            curpos = 10;
            doubles = 0;
        }
        
        if(curpos == 2 || curpos == 17 || curpos == 33) { //community chest
            switch(comchest[ccpos]) {
                case -10:
                    break;
                case 0:
                    curpos = 0;
                    break;
                case 10:
                    curpos = 10;
                    break;
                default:
                    return 1;
            }
            ++ccpos;
            if(ccpos == 16) {
                ccpos = 0;
            }
        }
        
        if(curpos == 7 || curpos == 22 || curpos == 36) { //chance
            switch(chance[chpos]) {
                case -10:
                    break;
                case 0:
                    curpos = 0;
                    break;
                case 10:
                    curpos = 10;
                    break;
                case 11:
                    curpos = 11;
                    break;
                case 24:
                    curpos = 24;
                    break;
                case 39:
                    curpos = 39;
                    break;
                case 5:
                    curpos = 5;
                    break;
                case -1:
                    curpos = (curpos == 7 ? 15 : (curpos == 22 ? 25 : 5));
                    break;
                case -2:
                    curpos = (curpos == 7 ? 12 : (curpos == 22 ? 28 : 12));
                    break;
                case -3:
                    curpos -= 3;
                    break;
                default:
                    return 2;
            }
            ++chpos;
            if(chpos == 16) {
                chpos = 0;
            }
        }
        
        if(curpos == 30) {
            curpos = 10;
        }
        
        ++hits[curpos];
    }
    
    //find the max
    for(i = 0; i < 40; ++i) {
        if(hits[i] > hits[top0]) {
            top0 = i;
        }
    }
    
    for(i = 0; i < 40; ++i) {
        if(hits[i] > hits[top1] && i != top0) {
            top1 = i;
        }
    }
    
    for(i = 0; i < 40; ++i) {
        if(hits[i] > hits[top2] && i != top0 && i != top1) {
            top2 = i;
        }
    }
    
    printf(""%02d%02d%02d\n"", top0, top1, top2);
    return 0;
}

int roll(int sides) {
    return rand() % sides + 1;
}

void shuffle(int arr[], int n) {
    int k, tmp;
    while(n > 1) {
        k = rand()%(n--);
        tmp = arr[n];
        arr[n] = arr[k];
        arr[k] = tmp;
    }
}

int main() {
    if(euler_problem_84() != 0) {
        printf(""ERROR\n"");
    }
    return 0;
}

"
132-7619,tuzz/magic_squares,magic_square.c,182,11,242,373406978.78971696,3006499126.0,0.1241999290040705,1379.0,1358.0,943798676.0,61451971.0,44000194.0,64473.0,17341.0,63096.0,1500000000,0.2489379858598113,1082014363648.0,9.103611493948592e-07,0.0439145243345463,"#include <stdlib.h>
#include <stdio.h>

int main() {
  unsigned int N, i, j, k, l, m, n, v, o, x, y, z, w, sum, centre_square,
    centre, count_i, count_j, count_k, count_l, count_m, count_n, count_x,
    count_y, count_z, count_w, max_root, tmp, remainder;
  int l_square, m_square, n_square, x_square, y_square, z_square, w_square;
  unsigned int* roots;
  short* memory;

  N = 1000;

  // Allocate lots of memory to allow for constant time access.
  memory = malloc(sizeof(short) * N * N * N);
  for (i = 0; i < N * N * N; i += 1) {
    memory[i] = 0;
  }

  // Pre-compute the square roots up to n.
  max_root = N * N;
  roots = malloc(sizeof(unsigned int) * max_root + 1);
  for (i = 0; i < max_root + 1; i += 1) {
    roots[i] = 0;
  }
  for (i = 0; i <= N; i += 1) {
    roots[i * i] = i;
  }
  int iterations = 0;

  printf(""Searching up to %d...\n"", N);

  // For each 3-combination up to N.
  for (i = 3; i <= N; i += 1) {
    for (j = 2; j < i; j += 1) {
      for (k = 1; k < j; k += 1) {
        sum = i * i + j * j + k * k;

        // If sum isn't divisible by three it can't be a magic square.
        if (sum % 3) {
          continue;
        }

        // The centre square must always be a third of the sum.
        centre_square = sum / 3;

        // Look up the square root of the number in the centre.
        centre = roots[centre_square];

        // There must be an integer root for the centre.
        if (!centre) {
          continue;
        }

        // Remember that {i, j, k} produce this sum.
        count_i = memory[centre_square + i] += 1;
        count_j = memory[centre_square + j] += 1;
        count_k = memory[centre_square + k] += 1;

        // The centre must produce this sum in at least four ways.
        if (memory[centre_square + centre] < 4) {
          continue;
        }

        // At least one of the new numbers must produce this sum in at least two ways.
        if (count_i < 2 && count_j < 2 && count_k < 2) {
          continue;
        }

        // Calculate the values that must appear opposite {i, j, k}.
        l_square = sum - centre_square - i * i;
        m_square = sum - centre_square - j * j;
        n_square = sum - centre_square - k * k;

        // Defensively look up their square roots.
        l = l_square > 0 && l_square <= max_root ? roots[l_square] : 0;
        m = m_square > 0 && m_square <= max_root ? roots[m_square] : 0;
        n = n_square > 0 && n_square <= max_root ? roots[n_square] : 0;

        // Opposites must not be the same number. Nullify them if they are.
        l = i == l ? 0 : l;
        m = j == m ? 0 : m;
        n = k == n ? 0 : n;

        // Look up the number of ways the opposite numbers produce this sum.
        count_l = memory[centre_square + l];
        count_m = memory[centre_square + m];
        count_n = memory[centre_square + n];

        // Opposites must produce this sum in at least two ways. Nullify them if they don't.
        l = count_l < 2 ? 0 : l;
        m = count_m < 2 ? 0 : m;
        n = count_n < 2 ? 0 : n;

        // There must be at least one valid opposite number.
        if (!(l || m || n)) {
          continue;
        }

        // Get the valid number and its opposite.
        // If there's more than one, we pick the last and discover the other(s) in a moment.
        if (l) { v = i; o = l; }
        if (m) { v = j; o = m; }
        if (n) { v = k; o = n; }

        // Ensure v is the smaller of the two numbers.
        if (v > o) { tmp = v; v = o; o = tmp; }

        // Find other ways to produce this sum (3rd and 4th number).
        for (x = 1; x <= N; x += 1) {

          // Skip past the number we've already found and its opposite.
          if (x == v || x == o) {
            continue;
          }

          // Look up the number of ways x produces this sum.
          count_x = memory[centre_square + x];

          // TODO, check for other possible layouts.

          // It must produce this sum in at least two ways to be considered.
          if (count_x < 2) {
            continue;
          }

          // Calculate the value's opposite.
          x_square = x * x;
          y_square = sum - centre_square - x_square;

          // If the value has passed (or is equal to) its opposite, we're done.
          // This ensures the opposite value is always bigger, too.
          if (x_square >= y_square) {
            break;
          }

          // Look up how many ways the opposite produces this sum.
          y = y_square > 0 && y_square <= max_root ? roots[y_square] : 0;
          count_y = memory[centre_square + y];

          // Its opposite must produce this sum in at least two ways.
          if (count_y < 2) {
            continue;
          }

          // Find other ways to produce this sum (5th and 6th number).
          for (z = x + 1; z <= N; z += 1) {

            // Skip past the numbers we've already found and their opposites.
            if (z == v || z == o || z == y) {
              continue;
            }

            // Look up the number of ways z produces this sum.
            count_z = memory[centre_square + z];

            // It must produce this sum in at least two ways to be considered.
            if (count_z < 2) {
              continue;
            }

            // Calculate the value's opposite.
            z_square = z * z;
            w_square = sum - centre_square - z_square;

            // If the value has passed (or is equal to) its opposite, we're done.
            // This ensures the opposite value is always bigger, too.
            if (z_square >= w_square) {
              break;
            }

            // Look up how many ways the opposite produces this sum.
            w = w_square > 0 && w_square <= max_root ? roots[w_square] : 0;
            count_w = memory[centre_square + w];

            // Its opposite must produce this sum in at least two ways.
            if (count_w < 2) {
              continue;
            }

            // When we have six numbers, one of two things can happen:
            //
            // 1) There are three numbers on the same row.
            // 2) The numbers are arranged like this:
            //    x | x | _
            //    x | x | x
            //    _ | x | x
            //
            // This section checks case 1:
            if (v + x + w == sum
             || v + y + z == sum
             || v + y + w == sum
             || o + x + z == sum
             || o + x + w == sum
             || o + y + z == sum) {
              printf(""sum=%d, centre=%d\n"", sum, centre_square);
              printf(""%d, %d\n"", v, o);
              printf(""%d, %d\n"", x, y);
              printf(""%d, %d\n"", z, w);
              printf(""---------------------\n"");
            }

            // We can test case 2 by subtracting all the numbers we know from
            // three times the sum and checking we're left with 2/3 of the sum.
            remainder = 3 * sum - v + o + x + y + z + w;
            if (remainder * 3 / 2 == sum) {
              printf(""sum=%d, centre=%d\n"", sum, centre_square);
              printf(""%d, %d\n"", v, o);
              printf(""%d, %d\n"", x, y);
              printf(""%d, %d\n"", z, w);
              printf(""---------------------\n"");
            }

            iterations += 1;
          }
        }
      }
    }

    if (i % 1000 == 0) {
      printf(""%d\n"", i);
    }
  }

  printf(""Finished. Reached the final stage %d times.\n"", iterations);
  return 0;
}
"
183-17908,ensemblr/llvm-project-boilerplate,include/llvm/projects/test-suite/SingleSource/Benchmarks/Misc/flops-4.c,222,9,1139,591027753.3112094,3437679453.0,0.1719263709954751,1469.0,1445.0,40639.0,14133.0,1659.0,642.0,1373.0,599.0,1500000000,0.3940185022074729,1082014363648.0,8.476648389822982e-07,0.0780143138830059,"/*--------------------- Start flops.c source code ----------------------*/

/*****************************/
/*          flops.c          */
/* Version 2.0,  18 Dec 1992 */
/*         Al Aburto         */
/*      aburto@nosc.mil      */
/*****************************/

/*
   Flops.c is a 'c' program which attempts to estimate your systems
   floating-point 'MFLOPS' rating for the FADD, FSUB, FMUL, and FDIV
   operations based on specific 'instruction mixes' (discussed below).
   The program provides an estimate of PEAK MFLOPS performance by making
   maximal use of register variables with minimal interaction with main
   memory. The execution loops are all small so that they will fit in
   any cache. Flops.c can be used along with Linpack and the Livermore
   kernels (which exersize memory much more extensively) to gain further
   insight into the limits of system performance. The flops.c execution
   modules also include various percent weightings of FDIV's (from 0% to
   25% FDIV's) so that the range of performance can be obtained when
   using FDIV's. FDIV's, being computationally more intensive than
   FADD's or FMUL's, can impact performance considerably on some systems.
   
   Flops.c consists of 8 independent modules (routines) which, except for
   module 2, conduct numerical integration of various functions. Module
   2, estimates the value of pi based upon the Maclaurin series expansion
   of atan(1). MFLOPS ratings are provided for each module, but the
   programs overall results are summerized by the MFLOPS(1), MFLOPS(2),
   MFLOPS(3), and MFLOPS(4) outputs.

   The MFLOPS(1) result is identical to the result provided by all
   previous versions of flops.c. It is based only upon the results from
   modules 2 and 3. Two problems surfaced in using MFLOPS(1). First, it
   was difficult to completely 'vectorize' the result due to the 
   recurrence of the 's' variable in module 2. This problem is addressed
   in the MFLOPS(2) result which does not use module 2, but maintains
   nearly the same weighting of FDIV's (9.2%) as in MFLOPS(1) (9.6%).
   The second problem with MFLOPS(1) centers around the percentage of
   FDIV's (9.6%) which was viewed as too high for an important class of
   problems. This concern is addressed in the MFLOPS(3) result where NO
   FDIV's are conducted at all. 
   
   The number of floating-point instructions per iteration (loop) is
   given below for each module executed:

   MODULE   FADD   FSUB   FMUL   FDIV   TOTAL  Comment
     1        7      0      6      1      14   7.1%  FDIV's
     2        3      2      1      1       7   difficult to vectorize.
     3        6      2      9      0      17   0.0%  FDIV's
     4        7      0      8      0      15   0.0%  FDIV's
     5       13      0     15      1      29   3.4%  FDIV's
     6       13      0     16      0      29   0.0%  FDIV's
     7        3      3      3      3      12   25.0% FDIV's
     8       13      0     17      0      30   0.0%  FDIV's
   
   A*2+3     21     12     14      5      52   A=5, MFLOPS(1), Same as
	   40.4%  23.1%  26.9%  9.6%          previous versions of the
						flops.c program. Includes
						only Modules 2 and 3, does
						9.6% FDIV's, and is not
						easily vectorizable.
   
   1+3+4     58     14     66     14     152   A=4, MFLOPS(2), New output
   +5+6+    38.2%  9.2%   43.4%  9.2%          does not include Module 2,
   A*7                                         but does 9.2% FDIV's.
   
   1+3+4     62      5     74      5     146   A=0, MFLOPS(3), New output
   +5+6+    42.9%  3.4%   50.7%  3.4%          does not include Module 2,
   7+8                                         but does 3.4% FDIV's.

   3+4+6     39      2     50      0      91   A=0, MFLOPS(4), New output
   +8       42.9%  2.2%   54.9%  0.0%          does not include Module 2,
						and does NO FDIV's.

   NOTE: Various timer routines are included as indicated below. The
	timer routines, with some comments, are attached at the end 
	of the main program.

   NOTE: Please do not remove any of the printouts.

   EXAMPLE COMPILATION:
   UNIX based systems
       cc -DUNIX -O flops.c -o flops
       cc -DUNIX -DROPT flops.c -o flops 
       cc -DUNIX -fast -O4 flops.c -o flops 
       .
       .
       .
     etc.

   Al Aburto
   aburto@nosc.mil
*/

/***************************************************************/
/* Timer options. You MUST uncomment one of the options below  */
/* or compile, for example, with the '-DUNIX' option.          */
/***************************************************************/
/* #define Amiga       */
/* #define UNIX        */
/* #define UNIX_Old    */
/* #define VMS         */
/* #define BORLAND_C   */
/* #define MSC         */
/* #define MAC         */
/* #define IPSC        */
/* #define FORTRAN_SEC */
#define GTODay
/* #define CTimer      */
/* #define UXPM        */
/* #define MAC_TMgr    */
/* #define PARIX       */
/* #define POSIX       */
/* #define WIN32       */
/* #define POSIX1      */
/***********************/

#include <stdio.h>
#include <math.h>
			    /* 'Uncomment' the line below to run   */
			    /* with 'register double' variables    */
			    /* defined, or compile with the        */
			    /* '-DROPT' option. Don't need this if */
			    /* registers used automatically, but   */
			    /* you might want to try it anyway.    */
/* #define ROPT */

double nulltime, TimeArray[3];   /* Variables needed for 'dtime()'.     */
double TLimit;                   /* Threshold to determine Number of    */
				 /* Loops to run. Fixed at 15.0 seconds.*/

double T[36];                    /* Global Array used to hold timing    */
				 /* results and other information.      */

double sa,sb,sc,sd,one,two,three;
double four,five,piref,piprg;
double scale,pierr;

double A0 = 1.0;
double A1 = -0.1666666666671334;
double A2 = 0.833333333809067E-2;
double A3 = 0.198412715551283E-3;
double A4 = 0.27557589750762E-5;
double A5 = 0.2507059876207E-7;
double A6 = 0.164105986683E-9;

double B0 = 1.0;
double B1 = -0.4999999999982;
double B2 = 0.4166666664651E-1;
double B3 = -0.1388888805755E-2;
double B4 = 0.24801428034E-4;
double B5 = -0.2754213324E-6;
double B6 = 0.20189405E-8;

double C0 = 1.0;
double C1 = 0.99999999668;
double C2 = 0.49999995173;
double C3 = 0.16666704243;
double C4 = 0.4166685027E-1;
double C5 = 0.832672635E-2;
double C6 = 0.140836136E-2;
double C7 = 0.17358267E-3;
double C8 = 0.3931683E-4;

double D1 = 0.3999999946405E-1;
double D2 = 0.96E-3;
double D3 = 0.1233153E-5;

double E2 = 0.48E-3;
double E3 = 0.411051E-6;

int main()
{

#ifdef ROPT
   register double s,u,v,w,x;
#else
   double s,u,v,w,x;
#endif

   long loops, NLimit;
   register long i, m, n;

   printf(""\n"");
   printf(""   FLOPS C Program (Double Precision), V2.0 18 Dec 1992\n\n"");

			/****************************/
   loops = 15625;        /* Initial number of loops. */
			/*     DO NOT CHANGE!       */
			/****************************/

/****************************************************/
/* Set Variable Values.                             */
/* T[1] references all timing results relative to   */
/* one million loops.                               */
/*                                                  */
/* The program will execute from 31250 to 512000000 */
/* loops based on a runtime of Module 1 of at least */
/* TLimit = 15.0 seconds. That is, a runtime of 15  */
/* seconds for Module 1 is used to determine the    */
/* number of loops to execute.                      */
/*                                                  */
/* No more than NLimit = 512000000 loops are allowed*/
/****************************************************/

   TLimit = 1.0;
   NLimit = 512000000;

   piref = 3.14159265358979324;
   one   = 1.0;
   two   = 2.0;
   three = 3.0;
   four  = 4.0;
   five  = 5.0;
   scale = one;

   printf(""   Module     Error        RunTime      MFLOPS\n"");
   printf(""                            (usec)\n"");
/*************************/
/* Initialize the timer. */
/*************************/
#ifdef SMALL_PROBLEM_SIZE
   m = loops*400;
#else
   m = loops*10000;
#endif


/************************************************************/
/* Module 4.  Calculate Integral of cos(x) from 0.0 to PI/3 */
/*            using the Trapazoidal Method. Result is       */
/*            sin(PI/3). There are 15 double precision      */
/*            operations per loop (7 +, 0 -, 8 *, and 0 / ) */
/*            included in the timing.                       */
/*            50.0% +, 00.0% -, 50.0% *, 00.0% /            */
/************************************************************/
   A3 = -A3;
   A5 = -A5;
   x = piref / ( three * (double)m );              /*********************/
   s = 0.0;                                        /*  Loop 5.          */
   v = 0.0;                                        /*********************/

   for( i = 1 ; i <= m-1 ; i++ )
   {
   u = (double)i * x;
   w = u * u;
   s = s + w*(w*(w*(w*(w*(B6*w+B5)+B4)+B3)+B2)+B1)+one;
   }

   u  = piref / three;
   w  = u * u;
   sa = w*(w*(w*(w*(w*(B6*w+B5)+B4)+B3)+B2)+B1)+one;

   sa = x * ( sa + one + two * s ) / two;            /* Module 4 Result */
   u  = piref / three;                               /*******************/
   w  = u * u;
   sb = u * ((((((A6*w+A5)*w+A4)*w+A3)*w+A2)*w+A1)*w+A0);
   sc = sa - sb;
						  /*********************/
						  /*   DO NOT REMOVE   */
						  /*   THIS PRINTOUT!  */
						  /*********************/
   printf(""     4   %13.4lf  %10.4lf  %10.4lf\n"",
          sc* /* stabilize output */  1e-30,
          0* /* stabilize output */ 1e-30 ,
          0* /* stabilize output */ 1e-30 );

   return 0;
}

"
033-34318,tybor/Liberty,misc/benchmarks/shootout/official/c/fasta/fasta.c,124,5,116,2863160.68377345,431914.0,6.62900484818737,1314.0,1291.0,70850.0,25185.0,1655.0,801.0,1365.0,759.0,1500000000,0.0019087737891823,1082014363648.0,0.0060312932667151,0.0476909460092674,"/* The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 * Contributed by Joern Inge Vestgaarden
 * Modified by Jorge Peixoto de Morais Neto
 * Modified by Ryan Flynn
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <err.h>

#define WIDTH 60
#define MIN(a,b) ((a) <= (b) ? (a) : (b))
#define NELEMENTS(x) (sizeof (x) / sizeof ((x)[0]))

typedef struct {
  float p;
  char c;
} aminoacid_t;

static inline float myrandom (float max) {
  unsigned long const IM = 139968;
  unsigned long const IA = 3877;
  unsigned long const IC = 29573;
  static unsigned long last = 42;
  last = (last * IA + IC) % IM;
  /*Integer to float conversions are faster if the integer is signed*/
  return max * (long) last / IM;
}

static inline void accumulate_probabilities (aminoacid_t *genelist, size_t len) {
  float cp = 0.0;
  size_t i;
  for (i = 0; i < len; i++) {
    cp += genelist[i].p;
    genelist[i].p = cp;
  }
}

/* This function prints the characters of the string s. When it */
/* reaches the end of the string, it goes back to the beginning */
/* It stops when the total number of characters printed is count. */
/* Between each WIDTH consecutive characters it prints a newline */
/* This function assumes that WIDTH <= strlen (s) + 1 */
static void repeat_fasta (char const *s, size_t count) {
  size_t pos = 0;
  size_t len = strlen (s);
  char *s2 = malloc (len + WIDTH);
  memcpy (s2, s, len);
  memcpy (s2 + len, s, WIDTH);
  do {
    size_t line = MIN(WIDTH, count);
    fwrite_unlocked (s2 + pos,1,line,stdout);
    putchar_unlocked ('\n');
    pos += line;
    if (pos >= len) pos -= len;
    count -= line;
  } while (count);
  free (s2);
}

/* This function takes a pointer to the first element of an array */
/* Each element of the array is a struct with a character and */
/* a float number p between 0 and 1. */
/* The function generates a random float number r and */
/* finds the first array element such that p >= r. */
/* This is a weighted random selection. */
/* The function then prints the character of the array element. */
/* This is done count times. */
/* Between each WIDTH consecutive characters, the function prints a newline */
static void random_fasta (aminoacid_t const *genelist, size_t count) {
  do {
    size_t line = MIN(WIDTH, count);
    size_t pos = 0;
    char buf[WIDTH + 1];
    do {
      float r = myrandom (1.0);
      size_t i = 0;
      while (genelist[i].p < r)
	++i; /* Linear search */
      buf[pos++] = genelist[i].c;
    } while (pos < line);
    buf[line] = '\n';
    fwrite_unlocked (buf, 1, line + 1, stdout);
    count -= line;
  } while (count);
}

int main (int argc, char **argv) {
  static char OutBuf[128 * 1024];
  size_t n;
  if (argc > 1) {
    char const *arg = argv[1];
    char *tail;
    n = strtoul (arg, &tail, 0);
    if (tail == arg)
      errx (1, ""Could not convert \""%s\"" to an unsigned long integer"", arg);
  } else n = 1000;

  static aminoacid_t iub[] = {
    { 0.27, 'a' },
    { 0.12, 'c' },
    { 0.12, 'g' },
    { 0.27, 't' },
    { 0.02, 'B' },
    { 0.02, 'D' },
    { 0.02, 'H' },
    { 0.02, 'K' },
    { 0.02, 'M' },
    { 0.02, 'N' },
    { 0.02, 'R' },
    { 0.02, 'S' },
    { 0.02, 'V' },
    { 0.02, 'W' },
    { 0.02, 'Y' }};

  static aminoacid_t homosapiens[] = {
    { 0.3029549426680, 'a' },
    { 0.1979883004921, 'c' },
    { 0.1975473066391, 'g' },
    { 0.3015094502008, 't' }};

  accumulate_probabilities (iub, NELEMENTS(iub));
  accumulate_probabilities (homosapiens, NELEMENTS(homosapiens));

    static char const *const alu =""\
GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG\
GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA\
CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT\
ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA\
GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG\
AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC\
AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA"";

    setvbuf(stdout, OutBuf, _IOFBF, sizeof OutBuf); /* buffer output */
    fputs_unlocked ("">ONE Homo sapiens alu\n"", stdout);
    repeat_fasta (alu, 2 * n);
    fputs_unlocked ("">TWO IUB ambiguity codes\n"", stdout);
    random_fasta (iub, 3 * n);
    fputs_unlocked ("">THREE Homo sapiens frequency\n"", stdout);
    random_fasta (homosapiens, 5 * n);
    return 0;
}

"
132-29879,cdepillabout/glibc,string/tester.c,1338,42,1996,63930766.5405795,388991001.0,0.1643502441846977,1888.0,1844.0,68863493.0,19490166.0,1812.0,648.0,1486.0,598.0,1500000000,0.042620511027053,1082014363648.0,9.594052279888087e-06,5.142967536862282e-05,"/* Tester for string functions.
   Copyright (C) 1995-2001, 2003, 2005, 2008, 2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif

/* Make sure we don't test the optimized inline functions if we want to
   test the real implementation.  */
#if !defined DO_STRING_INLINES
#undef __USE_STRING_INLINES
#endif

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <fcntl.h>


#define	STREQ(a, b)	(strcmp((a), (b)) == 0)

const char *it = ""<UNSET>"";	/* Routine name for message routines. */
size_t errors = 0;

/* Complain if condition is not true.  */
static void
check (int thing, int number)
{
  if (!thing)
    {
      printf(""%s flunked test %d\n"", it, number);
      ++errors;
    }
}

/* Complain if first two args don't strcmp as equal.  */
static void
equal (const char *a, const char *b, int number)
{
  check(a != NULL && b != NULL && STREQ (a, b), number);
}

char one[50];
char two[50];
char *cp;

static void
test_strcmp (void)
{
  it = ""strcmp"";
  check (strcmp ("""", """") == 0, 1);		/* Trivial case. */
  check (strcmp (""a"", ""a"") == 0, 2);		/* Identity. */
  check (strcmp (""abc"", ""abc"") == 0, 3);	/* Multicharacter. */
  check (strcmp (""abc"", ""abcd"") < 0, 4);	/* Length mismatches. */
  check (strcmp (""abcd"", ""abc"") > 0, 5);
  check (strcmp (""abcd"", ""abce"") < 0, 6);	/* Honest miscompares. */
  check (strcmp (""abce"", ""abcd"") > 0, 7);
  check (strcmp (""a\203"", ""a"") > 0, 8);		/* Tricky if char signed. */
  check (strcmp (""a\203"", ""a\003"") > 0, 9);

  {
    char buf1[0x40], buf2[0x40];
    int i, j;
    for (i=0; i < 0x10; i++)
      for (j = 0; j < 0x10; j++)
	{
	  int k;
	  for (k = 0; k < 0x3f; k++)
	    {
	      buf1[k] = '0' ^ (k & 4);
	      buf2[k] = '4' ^ (k & 4);
	    }
	  buf1[i] = buf1[0x3f] = 0;
	  buf2[j] = buf2[0x3f] = 0;
	  for (k = 0; k < 0xf; k++)
	    {
	      int cnum = 0x10+0x10*k+0x100*j+0x1000*i;
	      check (strcmp (buf1+i,buf2+j) == 0, cnum);
	      buf1[i+k] = 'A' + i + k;
	      buf1[i+k+1] = 0;
	      check (strcmp (buf1+i,buf2+j) > 0, cnum+1);
	      check (strcmp (buf2+j,buf1+i) < 0, cnum+2);
	      buf2[j+k] = 'B' + i + k;
	      buf2[j+k+1] = 0;
	      check (strcmp (buf1+i,buf2+j) < 0, cnum+3);
	      check (strcmp (buf2+j,buf1+i) > 0, cnum+4);
	      buf2[j+k] = 'A' + i + k;
	      buf1[i] = 'A' + i + 0x80;
	      check (strcmp (buf1+i,buf2+j) > 0, cnum+5);
	      check (strcmp (buf2+j,buf1+i) < 0, cnum+6);
	      buf1[i] = 'A' + i;
	    }
	}
  }
}

#define SIMPLE_COPY(fn, n, str, ntest) \
  do {									      \
    int __n;								      \
    char *cp;								      \
    for (__n = 0; __n < (int) sizeof (one); ++__n)			      \
      one[__n] = 'Z';							      \
    fn (one, str);							      \
    for (cp = one, __n = 0; __n < n; ++__n, ++cp)			      \
      check (*cp == '0' + (n % 10), ntest);				      \
    check (*cp == '\0', ntest);						      \
  } while (0)

static void
test_strcpy (void)
{
  int i;
  it = ""strcpy"";
  check (strcpy (one, ""abcd"") == one, 1); /* Returned value. */
  equal (one, ""abcd"", 2);		/* Basic test. */

  (void) strcpy (one, ""x"");
  equal (one, ""x"", 3);			/* Writeover. */
  equal (one+2, ""cd"", 4);		/* Wrote too much? */

  (void) strcpy (two, ""hi there"");
  (void) strcpy (one, two);
  equal (one, ""hi there"", 5);		/* Basic test encore. */
  equal (two, ""hi there"", 6);		/* Stomped on source? */

  (void) strcpy (one, """");
  equal (one, """", 7);			/* Boundary condition. */

  for (i = 0; i < 16; i++)
    {
      (void) strcpy (one + i, ""hi there"");	/* Unaligned destination. */
      equal (one + i, ""hi there"", 8 + (i * 2));
      (void) strcpy (two, one + i);		/* Unaligned source. */
      equal (two, ""hi there"", 9 + (i * 2));
    }

  SIMPLE_COPY(strcpy, 0, """", 41);
  SIMPLE_COPY(strcpy, 1, ""1"", 42);
  SIMPLE_COPY(strcpy, 2, ""22"", 43);
  SIMPLE_COPY(strcpy, 3, ""333"", 44);
  SIMPLE_COPY(strcpy, 4, ""4444"", 45);
  SIMPLE_COPY(strcpy, 5, ""55555"", 46);
  SIMPLE_COPY(strcpy, 6, ""666666"", 47);
  SIMPLE_COPY(strcpy, 7, ""7777777"", 48);
  SIMPLE_COPY(strcpy, 8, ""88888888"", 49);
  SIMPLE_COPY(strcpy, 9, ""999999999"", 50);
  SIMPLE_COPY(strcpy, 10, ""0000000000"", 51);
  SIMPLE_COPY(strcpy, 11, ""11111111111"", 52);
  SIMPLE_COPY(strcpy, 12, ""222222222222"", 53);
  SIMPLE_COPY(strcpy, 13, ""3333333333333"", 54);
  SIMPLE_COPY(strcpy, 14, ""44444444444444"", 55);
  SIMPLE_COPY(strcpy, 15, ""555555555555555"", 56);
  SIMPLE_COPY(strcpy, 16, ""6666666666666666"", 57);

  /* Simple test using implicitly coerced `void *' arguments.  */
  const void *src = ""frobozz"";
  void *dst = one;
  check (strcpy (dst, src) == dst, 1);
  equal (dst, ""frobozz"", 2);
}

static void
test_stpcpy (void)
{
  it = ""stpcpy"";
  check ((stpcpy (one, ""a"") - one) == 1, 1);
  equal (one, ""a"", 2);

  check ((stpcpy (one, ""ab"") - one) == 2, 3);
  equal (one, ""ab"", 4);

  check ((stpcpy (one, ""abc"") - one) == 3, 5);
  equal (one, ""abc"", 6);

  check ((stpcpy (one, ""abcd"") - one) == 4, 7);
  equal (one, ""abcd"", 8);

  check ((stpcpy (one, ""abcde"") - one) == 5, 9);
  equal (one, ""abcde"", 10);

  check ((stpcpy (one, ""abcdef"") - one) == 6, 11);
  equal (one, ""abcdef"", 12);

  check ((stpcpy (one, ""abcdefg"") - one) == 7, 13);
  equal (one, ""abcdefg"", 14);

  check ((stpcpy (one, ""abcdefgh"") - one) == 8, 15);
  equal (one, ""abcdefgh"", 16);

  check ((stpcpy (one, ""abcdefghi"") - one) == 9, 17);
  equal (one, ""abcdefghi"", 18);

  check ((stpcpy (one, ""x"") - one) == 1, 19);
  equal (one, ""x"", 20);			/* Writeover. */
  equal (one+2, ""cdefghi"", 21);		/* Wrote too much? */

  check ((stpcpy (one, ""xx"") - one) == 2, 22);
  equal (one, ""xx"", 23);		/* Writeover. */
  equal (one+3, ""defghi"", 24);		/* Wrote too much? */

  check ((stpcpy (one, ""xxx"") - one) == 3, 25);
  equal (one, ""xxx"", 26);		/* Writeover. */
  equal (one+4, ""efghi"", 27);		/* Wrote too much? */

  check ((stpcpy (one, ""xxxx"") - one) == 4, 28);
  equal (one, ""xxxx"", 29);		/* Writeover. */
  equal (one+5, ""fghi"", 30);		/* Wrote too much? */

  check ((stpcpy (one, ""xxxxx"") - one) == 5, 31);
  equal (one, ""xxxxx"", 32);		/* Writeover. */
  equal (one+6, ""ghi"", 33);		/* Wrote too much? */

  check ((stpcpy (one, ""xxxxxx"") - one) == 6, 34);
  equal (one, ""xxxxxx"", 35);		/* Writeover. */
  equal (one+7, ""hi"", 36);		/* Wrote too much? */

  check ((stpcpy (one, ""xxxxxxx"") - one) == 7, 37);
  equal (one, ""xxxxxxx"", 38);		/* Writeover. */
  equal (one+8, ""i"", 39);		/* Wrote too much? */

  check ((stpcpy (stpcpy (stpcpy (one, ""a""), ""b""), ""c"") - one) == 3, 40);
  equal (one, ""abc"", 41);
  equal (one + 4, ""xxx"", 42);

  SIMPLE_COPY(stpcpy, 0, """", 43);
  SIMPLE_COPY(stpcpy, 1, ""1"", 44);
  SIMPLE_COPY(stpcpy, 2, ""22"", 45);
  SIMPLE_COPY(stpcpy, 3, ""333"", 46);
  SIMPLE_COPY(stpcpy, 4, ""4444"", 47);
  SIMPLE_COPY(stpcpy, 5, ""55555"", 48);
  SIMPLE_COPY(stpcpy, 6, ""666666"", 49);
  SIMPLE_COPY(stpcpy, 7, ""7777777"", 50);
  SIMPLE_COPY(stpcpy, 8, ""88888888"", 51);
  SIMPLE_COPY(stpcpy, 9, ""999999999"", 52);
  SIMPLE_COPY(stpcpy, 10, ""0000000000"", 53);
  SIMPLE_COPY(stpcpy, 11, ""11111111111"", 54);
  SIMPLE_COPY(stpcpy, 12, ""222222222222"", 55);
  SIMPLE_COPY(stpcpy, 13, ""3333333333333"", 56);
  SIMPLE_COPY(stpcpy, 14, ""44444444444444"", 57);
  SIMPLE_COPY(stpcpy, 15, ""555555555555555"", 58);
  SIMPLE_COPY(stpcpy, 16, ""6666666666666666"", 59);
}

static void
test_stpncpy (void)
{
  it = ""stpncpy"";
  memset (one, 'x', sizeof (one));
  check (stpncpy (one, ""abc"", 2) == one + 2, 1);
  check (stpncpy (one, ""abc"", 3) == one + 3, 2);
  check (stpncpy (one, ""abc"", 4) == one + 3, 3);
  check (one[3] == '\0' && one[4] == 'x', 4);
  check (stpncpy (one, ""abcd"", 5) == one + 4, 5);
  check (one[4] == '\0' && one[5] == 'x', 6);
  check (stpncpy (one, ""abcd"", 6) == one + 4, 7);
  check (one[4] == '\0' && one[5] == '\0' && one[6] == 'x', 8);
}

static void
test_strcat (void)
{
  it = ""strcat"";
  (void) strcpy (one, ""ijk"");
  check (strcat (one, ""lmn"") == one, 1); /* Returned value. */
  equal (one, ""ijklmn"", 2);		/* Basic test. */

  (void) strcpy (one, ""x"");
  (void) strcat (one, ""yz"");
  equal (one, ""xyz"", 3);			/* Writeover. */
  equal (one+4, ""mn"", 4);			/* Wrote too much? */

  (void) strcpy (one, ""gh"");
  (void) strcpy (two, ""ef"");
  (void) strcat (one, two);
  equal (one, ""ghef"", 5);			/* Basic test encore. */
  equal (two, ""ef"", 6);			/* Stomped on source? */

  (void) strcpy (one, """");
  (void) strcat (one, """");
  equal (one, """", 7);			/* Boundary conditions. */
  (void) strcpy (one, ""ab"");
  (void) strcat (one, """");
  equal (one, ""ab"", 8);
  (void) strcpy (one, """");
  (void) strcat (one, ""cd"");
  equal (one, ""cd"", 9);
}

static void
test_strncat (void)
{
  /* First test it as strcat, with big counts, then test the count
     mechanism.  */
  it = ""strncat"";
  (void) strcpy (one, ""ijk"");
  check (strncat (one, ""lmn"", 99) == one, 1);	/* Returned value. */
  equal (one, ""ijklmn"", 2);		/* Basic test. */

  (void) strcpy (one, ""x"");
  (void) strncat (one, ""yz"", 99);
  equal (one, ""xyz"", 3);		/* Writeover. */
  equal (one+4, ""mn"", 4);		/* Wrote too much? */

  (void) strcpy (one, ""gh"");
  (void) strcpy (two, ""ef"");
  (void) strncat (one, two, 99);
  equal (one, ""ghef"", 5);			/* Basic test encore. */
  equal (two, ""ef"", 6);			/* Stomped on source? */

  (void) strcpy (one, """");
  (void) strncat (one, """", 99);
  equal (one, """", 7);			/* Boundary conditions. */
  (void) strcpy (one, ""ab"");
  (void) strncat (one, """", 99);
  equal (one, ""ab"", 8);
  (void) strcpy (one, """");
  (void) strncat (one, ""cd"", 99);
  equal (one, ""cd"", 9);

  (void) strcpy (one, ""ab"");
  (void) strncat (one, ""cdef"", 2);
  equal (one, ""abcd"", 10);			/* Count-limited. */

  (void) strncat (one, ""gh"", 0);
  equal (one, ""abcd"", 11);			/* Zero count. */

  (void) strncat (one, ""gh"", 2);
  equal (one, ""abcdgh"", 12);		/* Count and length equal. */

  (void) strncat (one, ""ij"", (size_t)-1);	/* set sign bit in count */
  equal (one, ""abcdghij"", 13);
}

static void
test_strncmp (void)
{
  /* First test as strcmp with big counts, then test count code.  */
  it = ""strncmp"";
  check (strncmp ("""", """", 99) == 0, 1);	/* Trivial case. */
  check (strncmp (""a"", ""a"", 99) == 0, 2);	/* Identity. */
  check (strncmp (""abc"", ""abc"", 99) == 0, 3);	/* Multicharacter. */
  check (strncmp (""abc"", ""abcd"", 99) < 0, 4);	/* Length unequal. */
  check (strncmp (""abcd"", ""abc"", 99) > 0, 5);
  check (strncmp (""abcd"", ""abce"", 99) < 0, 6);	/* Honestly unequal. */
  check (strncmp (""abce"", ""abcd"", 99) > 0, 7);
  check (strncmp (""a\203"", ""a"", 2) > 0, 8);	/* Tricky if '\203' < 0 */
  check (strncmp (""a\203"", ""a\003"", 2) > 0, 9);
  check (strncmp (""abce"", ""abcd"", 3) == 0, 10);	/* Count limited. */
  check (strncmp (""abce"", ""abc"", 3) == 0, 11);	/* Count == length. */
  check (strncmp (""abcd"", ""abce"", 4) < 0, 12);	/* Nudging limit. */
  check (strncmp (""abc"", ""def"", 0) == 0, 13);	/* Zero count. */
  check (strncmp (""abc"", """", (size_t)-1) > 0, 14);	/* set sign bit in count */
  check (strncmp (""abc"", ""abc"", (size_t)-2) == 0, 15);
}

static void
test_strncpy (void)
{
  /* Testing is a bit different because of odd semantics.  */
  it = ""strncpy"";
  check (strncpy (one, ""abc"", 4) == one, 1);	/* Returned value. */
  equal (one, ""abc"", 2);			/* Did the copy go right? */

  (void) strcpy (one, ""abcdefgh"");
  (void) strncpy (one, ""xyz"", 2);
  equal (one, ""xycdefgh"", 3);			/* Copy cut by count. */

  (void) strcpy (one, ""abcdefgh"");
  (void) strncpy (one, ""xyz"", 3);		/* Copy cut just before NUL. */
  equal (one, ""xyzdefgh"", 4);

  (void) strcpy (one, ""abcdefgh"");
  (void) strncpy (one, ""xyz"", 4);		/* Copy just includes NUL. */
  equal (one, ""xyz"", 5);
  equal (one+4, ""efgh"", 6);			/* Wrote too much? */

  (void) strcpy (one, ""abcdefgh"");
  (void) strncpy (one, ""xyz"", 5);		/* Copy includes padding. */
  equal (one, ""xyz"", 7);
  equal (one+4, """", 8);
  equal (one+5, ""fgh"", 9);

  (void) strcpy (one, ""abc"");
  (void) strncpy (one, ""xyz"", 0);		/* Zero-length copy. */
  equal (one, ""abc"", 10);

  (void) strncpy (one, """", 2);		/* Zero-length source. */
  equal (one, """", 11);
  equal (one+1, """", 12);
  equal (one+2, ""c"", 13);

  (void) strcpy (one, ""hi there"");
  (void) strncpy (two, one, 9);
  equal (two, ""hi there"", 14);		/* Just paranoia. */
  equal (one, ""hi there"", 15);		/* Stomped on source? */
}

static void
test_strlen (void)
{
  it = ""strlen"";
  check (strlen ("""") == 0, 1);		/* Empty. */
  check (strlen (""a"") == 1, 2);		/* Single char. */
  check (strlen (""abcd"") == 4, 3);	/* Multiple chars. */
  {
    char buf[4096];
    int i;
    char *p;
    for (i=0; i < 0x100; i++)
      {
	p = (char *) ((unsigned long int)(buf + 0xff) & ~0xff) + i;
	strcpy (p, ""OK"");
	strcpy (p+3, ""BAD/WRONG"");
	check (strlen (p) == 2, 4+i);
      }
   }
}

static void
test_strnlen (void)
{
  it = ""strnlen"";
  check (strnlen ("""", 10) == 0, 1);		/* Empty. */
  check (strnlen (""a"", 10) == 1, 2);		/* Single char. */
  check (strnlen (""abcd"", 10) == 4, 3);		/* Multiple chars. */
  check (strnlen (""foo"", (size_t) -1) == 3, 4);	/* limits of n. */
  check (strnlen (""abcd"", 0) == 0, 5);		/* Restricted. */
  check (strnlen (""abcd"", 1) == 1, 6);		/* Restricted. */
  check (strnlen (""abcd"", 2) == 2, 7);		/* Restricted. */
  check (strnlen (""abcd"", 3) == 3, 8);		/* Restricted. */
  check (strnlen (""abcd"", 4) == 4, 9);		/* Restricted. */

  char buf[4096];
  for (int i = 0; i < 0x100; ++i)
    {
      char *p = (char *) ((unsigned long int)(buf + 0xff) & ~0xff) + i;
      strcpy (p, ""OK"");
      strcpy (p + 3, ""BAD/WRONG"");
      check (strnlen (p, 100) == 2, 10 + i);
    }
}

static void
test_strchr (void)
{
  it = ""strchr"";
  check (strchr (""abcd"", 'z') == NULL, 1);	/* Not found. */
  (void) strcpy (one, ""abcd"");
  check (strchr (one, 'c') == one+2, 2);	/* Basic test. */
  check (strchr (one, 'd') == one+3, 3);	/* End of string. */
  check (strchr (one, 'a') == one, 4);		/* Beginning. */
  check (strchr (one, '\0') == one+4, 5);	/* Finding NUL. */
  (void) strcpy (one, ""ababa"");
  check (strchr (one, 'b') == one+1, 6);	/* Finding first. */
  (void) strcpy (one, """");
  check (strchr (one, 'b') == NULL, 7);		/* Empty string. */
  check (strchr (one, '\0') == one, 8);		/* NUL in empty string. */
  {
    char buf[4096];
    int i;
    char *p;
    for (i=0; i < 0x100; i++)
      {
	p = (char *) ((unsigned long int) (buf + 0xff) & ~0xff) + i;
	strcpy (p, ""OK"");
	strcpy (p+3, ""BAD/WRONG"");
	check (strchr (p, '/') == NULL, 9+i);
      }
   }
}

static void
test_strchrnul (void)
{
  const char *os;
  it = ""strchrnul"";
  cp = strchrnul ((os = ""abcd""), 'z');
  check (*cp == '\0', 1);			/* Not found. */
  check (cp == os + 4, 2);
  (void) strcpy (one, ""abcd"");
  check (strchrnul (one, 'c') == one+2, 3);	/* Basic test. */
  check (strchrnul (one, 'd') == one+3, 4);	/* End of string. */
  check (strchrnul (one, 'a') == one, 5);	/* Beginning. */
  check (strchrnul (one, '\0') == one+4, 6);	/* Finding NUL. */
  (void) strcpy (one, ""ababa"");
  check (strchrnul (one, 'b') == one+1, 7);	/* Finding first. */
  (void) strcpy (one, """");
  check (strchrnul (one, 'b') == one, 8);	/* Empty string. */
  check (strchrnul (one, '\0') == one, 9);	/* NUL in empty string. */
  {
    char buf[4096];
    int i;
    char *p;
    for (i=0; i < 0x100; i++)
      {
	p = (char *) ((unsigned long int) (buf + 0xff) & ~0xff) + i;
	strcpy (p, ""OK"");
	strcpy (p+3, ""BAD/WRONG"");
	cp = strchrnul (p, '/');
	check (*cp == '\0', 9+2*i);
	check (cp == p+2, 10+2*i);
      }
   }
}

static void
test_rawmemchr (void)
{
  it = ""rawmemchr"";
  (void) strcpy (one, ""abcd"");
  check (rawmemchr (one, 'c') == one+2, 1);	/* Basic test. */
  check (rawmemchr (one, 'd') == one+3, 2);	/* End of string. */
  check (rawmemchr (one, 'a') == one, 3);		/* Beginning. */
  check (rawmemchr (one, '\0') == one+4, 4);	/* Finding NUL. */
  (void) strcpy (one, ""ababa"");
  check (rawmemchr (one, 'b') == one+1, 5);	/* Finding first. */
  (void) strcpy (one, """");
  check (rawmemchr (one, '\0') == one, 6);	/* NUL in empty string. */
  {
    char buf[4096];
    int i;
    char *p;
    for (i=0; i < 0x100; i++)
      {
	p = (char *) ((unsigned long int) (buf + 0xff) & ~0xff) + i;
	strcpy (p, ""OK"");
	strcpy (p+3, ""BAD/WRONG"");
	check (rawmemchr (p, 'R') == p+8, 6+i);
      }
   }
}

static void
test_index (void)
{
  it = ""index"";
  check (index (""abcd"", 'z') == NULL, 1);	/* Not found. */
  (void) strcpy (one, ""abcd"");
  check (index (one, 'c') == one+2, 2);	/* Basic test. */
  check (index (one, 'd') == one+3, 3);	/* End of string. */
  check (index (one, 'a') == one, 4);	/* Beginning. */
  check (index (one, '\0') == one+4, 5);	/* Finding NUL. */
  (void) strcpy (one, ""ababa"");
  check (index (one, 'b') == one+1, 6);	/* Finding first. */
  (void) strcpy (one, """");
  check (index (one, 'b') == NULL, 7);	/* Empty string. */
  check (index (one, '\0') == one, 8);	/* NUL in empty string. */
}

static void
test_strrchr (void)
{
  it = ""strrchr"";
  check (strrchr (""abcd"", 'z') == NULL, 1);	/* Not found. */
  (void) strcpy (one, ""abcd"");
  check (strrchr (one, 'c') == one+2, 2);	/* Basic test. */
  check (strrchr (one, 'd') == one+3, 3);	/* End of string. */
  check (strrchr (one, 'a') == one, 4);		/* Beginning. */
  check (strrchr (one, '\0') == one+4, 5);	/* Finding NUL. */
  (void) strcpy (one, ""ababa"");
  check (strrchr (one, 'b') == one+3, 6);	/* Finding last. */
  (void) strcpy (one, """");
  check (strrchr (one, 'b') == NULL, 7);	/* Empty string. */
  check (strrchr (one, '\0') == one, 8);	/* NUL in empty string. */
  {
    char buf[4096];
    int i;
    char *p;
    for (i=0; i < 0x100; i++)
      {
	p = (char *) ((unsigned long int) (buf + 0xff) & ~0xff) + i;
	strcpy (p, ""OK"");
	strcpy (p+3, ""BAD/WRONG"");
	check (strrchr (p, '/') == NULL, 9+i);
      }
   }
}

static void
test_memrchr (void)
{
  size_t l;
  it = ""memrchr"";
  check (memrchr (""abcd"", 'z', 5) == NULL, 1);	/* Not found. */
  (void) strcpy (one, ""abcd"");
  l = strlen (one) + 1;
  check (memrchr (one, 'c', l) == one+2, 2);	/* Basic test. */
  check (memrchr (one, 'd', l) == one+3, 3);	/* End of string. */
  check (memrchr (one, 'a', l) == one, 4);		/* Beginning. */
  check (memrchr (one, '\0', l) == one+4, 5);	/* Finding NUL. */
  (void) strcpy (one, ""ababa"");
  l = strlen (one) + 1;
  check (memrchr (one, 'b', l) == one+3, 6);	/* Finding last. */
  (void) strcpy (one, """");
  l = strlen (one) + 1;
  check (memrchr (one, 'b', l) == NULL, 7);	/* Empty string. */
  check (memrchr (one, '\0', l) == one, 8);	/* NUL in empty string. */

  /* now test all possible alignment and length combinations to catch
     bugs due to unrolled loops (assuming unrolling is limited to no
     more than 128 byte chunks: */
  {
    char buf[128 + sizeof(long)];
    long align, len, i, pos;

    for (align = 0; align < (long) sizeof(long); ++align) {
      for (len = 0; len < (long) (sizeof(buf) - align); ++len) {
	for (i = 0; i < len; ++i)
	  buf[align + i] = 'x';		/* don't depend on memset... */

	for (pos = len - 1; pos >= 0; --pos) {
#if 0
	  printf(""align %d, len %d, pos %d\n"", align, len, pos);
#endif
	  check(memrchr(buf + align, 'x', len) == buf + align + pos, 9);
	  check(memrchr(buf + align + pos + 1, 'x', len - (pos + 1)) == NULL,
		10);
	  buf[align + pos] = '-';
	}
      }
    }
  }
}

static void
test_rindex (void)
{
  it = ""rindex"";
  check (rindex (""abcd"", 'z') == NULL, 1);	/* Not found. */
  (void) strcpy (one, ""abcd"");
  check (rindex (one, 'c') == one+2, 2);	/* Basic test. */
  check (rindex (one, 'd') == one+3, 3);	/* End of string. */
  check (rindex (one, 'a') == one, 4);	/* Beginning. */
  check (rindex (one, '\0') == one+4, 5);	/* Finding NUL. */
  (void) strcpy (one, ""ababa"");
  check (rindex (one, 'b') == one+3, 6);	/* Finding last. */
  (void) strcpy (one, """");
  check (rindex (one, 'b') == NULL, 7);	/* Empty string. */
  check (rindex (one, '\0') == one, 8);	/* NUL in empty string. */
}

static void
test_strpbrk (void)
{
  it = ""strpbrk"";
  check(strpbrk(""abcd"", ""z"") == NULL, 1);	/* Not found. */
  (void) strcpy(one, ""abcd"");
  check(strpbrk(one, ""c"") == one+2, 2);	/* Basic test. */
  check(strpbrk(one, ""d"") == one+3, 3);	/* End of string. */
  check(strpbrk(one, ""a"") == one, 4);	/* Beginning. */
  check(strpbrk(one, """") == NULL, 5);	/* Empty search list. */
  check(strpbrk(one, ""cb"") == one+1, 6);	/* Multiple search. */
  (void) strcpy(one, ""abcabdea"");
  check(strpbrk(one, ""b"") == one+1, 7);	/* Finding first. */
  check(strpbrk(one, ""cb"") == one+1, 8);	/* With multiple search. */
  check(strpbrk(one, ""db"") == one+1, 9);	/* Another variant. */
  (void) strcpy(one, """");
  check(strpbrk(one, ""bc"") == NULL, 10);	/* Empty string. */
  (void) strcpy(one, """");
  check(strpbrk(one, ""bcd"") == NULL, 11);	/* Empty string. */
  (void) strcpy(one, """");
  check(strpbrk(one, ""bcde"") == NULL, 12);	/* Empty string. */
  check(strpbrk(one, """") == NULL, 13);	/* Both strings empty. */
  (void) strcpy(one, ""abcabdea"");
  check(strpbrk(one, ""befg"") == one+1, 14);	/* Finding first. */
  check(strpbrk(one, ""cbr"") == one+1, 15);	/* With multiple search. */
  check(strpbrk(one, ""db"") == one+1, 16);	/* Another variant. */
  check(strpbrk(one, ""efgh"") == one+6, 17);	/* And yet another. */
}

static void
test_strstr (void)
{
  it = ""strstr"";
  check(strstr(""abcd"", ""z"") == NULL, 1);	/* Not found. */
  check(strstr(""abcd"", ""abx"") == NULL, 2);	/* Dead end. */
  (void) strcpy(one, ""abcd"");
  check(strstr(one, ""c"") == one+2, 3);	/* Basic test. */
  check(strstr(one, ""bc"") == one+1, 4);	/* Multichar. */
  check(strstr(one, ""d"") == one+3, 5);	/* End of string. */
  check(strstr(one, ""cd"") == one+2, 6);	/* Tail of string. */
  check(strstr(one, ""abc"") == one, 7);	/* Beginning. */
  check(strstr(one, ""abcd"") == one, 8);	/* Exact match. */
  check(strstr(one, ""abcde"") == NULL, 9);	/* Too long. */
  check(strstr(one, ""de"") == NULL, 10);	/* Past end. */
  check(strstr(one, """") == one, 11);	/* Finding empty. */
  (void) strcpy(one, ""ababa"");
  check(strstr(one, ""ba"") == one+1, 12);	/* Finding first. */
  (void) strcpy(one, """");
  check(strstr(one, ""b"") == NULL, 13);	/* Empty string. */
  check(strstr(one, """") == one, 14);	/* Empty in empty string. */
  (void) strcpy(one, ""bcbca"");
  check(strstr(one, ""bca"") == one+2, 15);	/* False start. */
  (void) strcpy(one, ""bbbcabbca"");
  check(strstr(one, ""bbca"") == one+1, 16);	/* With overlap. */
}

static void
test_strspn (void)
{
  it = ""strspn"";
  check(strspn(""abcba"", ""abc"") == 5, 1);	/* Whole string. */
  check(strspn(""abcba"", ""ab"") == 2, 2);	/* Partial. */
  check(strspn(""abc"", ""qx"") == 0, 3);	/* None. */
  check(strspn("""", ""ab"") == 0, 4);	/* Null string. */
  check(strspn(""abc"", """") == 0, 5);	/* Null search list. */
}

static void
test_strcspn (void)
{
  it = ""strcspn"";
  check(strcspn(""abcba"", ""qx"") == 5, 1);	/* Whole string. */
  check(strcspn(""abcba"", ""cx"") == 2, 2);	/* Partial. */
  check(strcspn(""abc"", ""abc"") == 0, 3);	/* None. */
  check(strcspn("""", ""ab"") == 0, 4);	/* Null string. */
  check(strcspn(""abc"", """") == 3, 5);	/* Null search list. */
}

static void
test_strtok (void)
{
  it = ""strtok"";
  (void) strcpy(one, ""first, second, third"");
  equal(strtok(one, "", ""), ""first"", 1);	/* Basic test. */
  equal(one, ""first"", 2);
  equal(strtok((char *)NULL, "", ""), ""second"", 3);
  equal(strtok((char *)NULL, "", ""), ""third"", 4);
  check(strtok((char *)NULL, "", "") == NULL, 5);
  (void) strcpy(one, "", first, "");
  equal(strtok(one, "", ""), ""first"", 6);	/* Extra delims, 1 tok. */
  check(strtok((char *)NULL, "", "") == NULL, 7);
  (void) strcpy(one, ""1a, 1b; 2a, 2b"");
  equal(strtok(one, "", ""), ""1a"", 8);	/* Changing delim lists. */
  equal(strtok((char *)NULL, ""; ""), ""1b"", 9);
  equal(strtok((char *)NULL, "", ""), ""2a"", 10);
  (void) strcpy(two, ""x-y"");
  equal(strtok(two, ""-""), ""x"", 11);	/* New string before done. */
  equal(strtok((char *)NULL, ""-""), ""y"", 12);
  check(strtok((char *)NULL, ""-"") == NULL, 13);
  (void) strcpy(one, ""a,b, c,, ,d"");
  equal(strtok(one, "", ""), ""a"", 14);	/* Different separators. */
  equal(strtok((char *)NULL, "", ""), ""b"", 15);
  equal(strtok((char *)NULL, "" ,""), ""c"", 16);	/* Permute list too. */
  equal(strtok((char *)NULL, "" ,""), ""d"", 17);
  check(strtok((char *)NULL, "", "") == NULL, 18);
  check(strtok((char *)NULL, "", "") == NULL, 19);	/* Persistence. */
  (void) strcpy(one, "", "");
  check(strtok(one, "", "") == NULL, 20);	/* No tokens. */
  (void) strcpy(one, """");
  check(strtok(one, "", "") == NULL, 21);	/* Empty string. */
  (void) strcpy(one, ""abc"");
  equal(strtok(one, "", ""), ""abc"", 22);	/* No delimiters. */
  check(strtok((char *)NULL, "", "") == NULL, 23);
  (void) strcpy(one, ""abc"");
  equal(strtok(one, """"), ""abc"", 24);	/* Empty delimiter list. */
  check(strtok((char *)NULL, """") == NULL, 25);
  (void) strcpy(one, ""abcdefgh"");
  (void) strcpy(one, ""a,b,c"");
  equal(strtok(one, "",""), ""a"", 26);	/* Basics again... */
  equal(strtok((char *)NULL, "",""), ""b"", 27);
  equal(strtok((char *)NULL, "",""), ""c"", 28);
  check(strtok((char *)NULL, "","") == NULL, 29);
  equal(one+6, ""gh"", 30);			/* Stomped past end? */
  equal(one, ""a"", 31);			/* Stomped old tokens? */
  equal(one+2, ""b"", 32);
  equal(one+4, ""c"", 33);
}

static void
test_strtok_r (void)
{
  it = ""strtok_r"";
  (void) strcpy(one, ""first, second, third"");
  cp = NULL;	/* Always initialize cp to make sure it doesn't point to some old data.  */
  equal(strtok_r(one, "", "", &cp), ""first"", 1);	/* Basic test. */
  equal(one, ""first"", 2);
  equal(strtok_r((char *)NULL, "", "", &cp), ""second"", 3);
  equal(strtok_r((char *)NULL, "", "", &cp), ""third"", 4);
  check(strtok_r((char *)NULL, "", "", &cp) == NULL, 5);
  (void) strcpy(one, "", first, "");
  cp = NULL;
  equal(strtok_r(one, "", "", &cp), ""first"", 6);	/* Extra delims, 1 tok. */
  check(strtok_r((char *)NULL, "", "", &cp) == NULL, 7);
  (void) strcpy(one, ""1a, 1b; 2a, 2b"");
  cp = NULL;
  equal(strtok_r(one, "", "", &cp), ""1a"", 8);	/* Changing delim lists. */
  equal(strtok_r((char *)NULL, ""; "", &cp), ""1b"", 9);
  equal(strtok_r((char *)NULL, "", "", &cp), ""2a"", 10);
  (void) strcpy(two, ""x-y"");
  cp = NULL;
  equal(strtok_r(two, ""-"", &cp), ""x"", 11);	/* New string before done. */
  equal(strtok_r((char *)NULL, ""-"", &cp), ""y"", 12);
  check(strtok_r((char *)NULL, ""-"", &cp) == NULL, 13);
  (void) strcpy(one, ""a,b, c,, ,d"");
  cp = NULL;
  equal(strtok_r(one, "", "", &cp), ""a"", 14);	/* Different separators. */
  equal(strtok_r((char *)NULL, "", "", &cp), ""b"", 15);
  equal(strtok_r((char *)NULL, "" ,"", &cp), ""c"", 16);	/* Permute list too. */
  equal(strtok_r((char *)NULL, "" ,"", &cp), ""d"", 17);
  check(strtok_r((char *)NULL, "", "", &cp) == NULL, 18);
  check(strtok_r((char *)NULL, "", "", &cp) == NULL, 19);	/* Persistence. */
  (void) strcpy(one, "", "");
  cp = NULL;
  check(strtok_r(one, "", "", &cp) == NULL, 20);	/* No tokens. */
  (void) strcpy(one, """");
  cp = NULL;
  check(strtok_r(one, "", "", &cp) == NULL, 21);	/* Empty string. */
  check(strtok_r((char *)NULL, "", "", &cp) == NULL, 22);	/* Persistence. */
  (void) strcpy(one, ""abc"");
  cp = NULL;
  equal(strtok_r(one, "", "", &cp), ""abc"", 23);	/* No delimiters. */
  check(strtok_r((char *)NULL, "", "", &cp) == NULL, 24);
  (void) strcpy(one, ""abc"");
  cp = NULL;
  equal(strtok_r(one, """", &cp), ""abc"", 25);	/* Empty delimiter list. */
  check(strtok_r((char *)NULL, """", &cp) == NULL, 26);
  (void) strcpy(one, ""abcdefgh"");
  (void) strcpy(one, ""a,b,c"");
  cp = NULL;
  equal(strtok_r(one, "","", &cp), ""a"", 27);	/* Basics again... */
  equal(strtok_r((char *)NULL, "","", &cp), ""b"", 28);
  equal(strtok_r((char *)NULL, "","", &cp), ""c"", 29);
  check(strtok_r((char *)NULL, "","", &cp) == NULL, 30);
  equal(one+6, ""gh"", 31);			/* Stomped past end? */
  equal(one, ""a"", 32);				/* Stomped old tokens? */
  equal(one+2, ""b"", 33);
  equal(one+4, ""c"", 34);
  strcpy (one, "":::"");
  cp = NULL;
  check (strtok_r (one, "":"", &cp) == NULL, 35);	/* Must store pointer in cp. */
  check (strtok_r (NULL, "":"", &cp) == NULL, 36);
}

static void
test_strsep (void)
{
  char *ptr;
  it = ""strsep"";
  cp = strcpy(one, ""first, second, third"");
  equal(strsep(&cp, "", ""), ""first"", 1);	/* Basic test. */
  equal(one, ""first"", 2);
  equal(strsep(&cp, "", ""), """", 3);
  equal(strsep(&cp, "", ""), ""second"", 4);
  equal(strsep(&cp, "", ""), """", 5);
  equal(strsep(&cp, "", ""), ""third"", 6);
  check(strsep(&cp, "", "") == NULL, 7);
  cp = strcpy(one, "", first, "");
  equal(strsep(&cp, "", ""), """", 8);
  equal(strsep(&cp, "", ""), """", 9);
  equal(strsep(&cp, "", ""), ""first"", 10);	/* Extra delims, 1 tok. */
  equal(strsep(&cp, "", ""), """", 11);
  equal(strsep(&cp, "", ""), """", 12);
  check(strsep(&cp, "", "") == NULL, 13);
  cp = strcpy(one, ""1a, 1b; 2a, 2b"");
  equal(strsep(&cp, "", ""), ""1a"", 14);	/* Changing delim lists. */
  equal(strsep(&cp, "", ""), """", 15);
  equal(strsep(&cp, ""; ""), ""1b"", 16);
  equal(strsep(&cp, "", ""), """", 17);
  equal(strsep(&cp, "", ""), ""2a"", 18);
  cp = strcpy(two, ""x-y"");
  equal(strsep(&cp, ""-""), ""x"", 19);	/* New string before done. */
  equal(strsep(&cp, ""-""), ""y"", 20);
  check(strsep(&cp, ""-"") == NULL, 21);
  cp = strcpy(one, ""a,b, c,, ,d "");
  equal(strsep(&cp, "", ""), ""a"", 22);	/* Different separators. */
  equal(strsep(&cp, "", ""), ""b"", 23);
  equal(strsep(&cp, "" ,""), """", 24);
  equal(strsep(&cp, "" ,""), ""c"", 25);	/* Permute list too. */
  equal(strsep(&cp, "" ,""), """", 26);
  equal(strsep(&cp, "" ,""), """", 27);
  equal(strsep(&cp, "" ,""), """", 28);
  equal(strsep(&cp, "" ,""), ""d"", 29);
  equal(strsep(&cp, "" ,""), """", 30);
  check(strsep(&cp, "", "") == NULL, 31);
  check(strsep(&cp, "", "") == NULL, 32);	/* Persistence. */
  cp = strcpy(one, "", "");
  equal(strsep(&cp, "", ""), """", 33);
  equal(strsep(&cp, "", ""), """", 34);
  equal(strsep(&cp, "", ""), """", 35);
  check(strsep(&cp, "", "") == NULL, 36);	/* No tokens. */
  cp = strcpy(one, """");
  equal(strsep(&cp, "", ""), """", 37);
  check(strsep(&cp, "", "") == NULL, 38);	/* Empty string. */
  cp = strcpy(one, ""abc"");
  equal(strsep(&cp, "", ""), ""abc"", 39);	/* No delimiters. */
  check(strsep(&cp, "", "") == NULL, 40);
  cp = strcpy(one, ""abc"");
  equal(strsep(&cp, """"), ""abc"", 41);	/* Empty delimiter list. */
  check(strsep(&cp, """") == NULL, 42);
  (void) strcpy(one, ""abcdefgh"");
  cp = strcpy(one, ""a,b,c"");
  equal(strsep(&cp, "",""), ""a"", 43);	/* Basics again... */
  equal(strsep(&cp, "",""), ""b"", 44);
  equal(strsep(&cp, "",""), ""c"", 45);
  check(strsep(&cp, "","") == NULL, 46);
  equal(one+6, ""gh"", 47);		/* Stomped past end? */
  equal(one, ""a"", 48);			/* Stomped old tokens? */
  equal(one+2, ""b"", 49);
  equal(one+4, ""c"", 50);

  {
    char text[] = ""This,is,a,test"";
    char *list = strdupa (text);
    equal (strsep (&list, "",""), ""This"", 51);
    equal (strsep (&list, "",""), ""is"", 52);
    equal (strsep (&list, "",""), ""a"", 53);
    equal (strsep (&list, "",""), ""test"", 54);
    check (strsep (&list, "","") == NULL, 55);
  }

  cp = strcpy(one, ""a,b, c,, ,d,"");
  equal(strsep(&cp, "",""), ""a"", 56);	/* Different separators. */
  equal(strsep(&cp, "",""), ""b"", 57);
  equal(strsep(&cp, "",""), "" c"", 58);	/* Permute list too. */
  equal(strsep(&cp, "",""), """", 59);
  equal(strsep(&cp, "",""), "" "", 60);
  equal(strsep(&cp, "",""), ""d"", 61);
  equal(strsep(&cp, "",""), """", 62);
  check(strsep(&cp, "","") == NULL, 63);
  check(strsep(&cp, "","") == NULL, 64);	/* Persistence. */

  cp = strcpy(one, ""a,b, c,, ,d,"");
  equal(strsep(&cp, ""xy,""), ""a"", 65);	/* Different separators. */
  equal(strsep(&cp, ""x,y""), ""b"", 66);
  equal(strsep(&cp, "",xy""), "" c"", 67);	/* Permute list too. */
  equal(strsep(&cp, ""xy,""), """", 68);
  equal(strsep(&cp, ""x,y""), "" "", 69);
  equal(strsep(&cp, "",xy""), ""d"", 70);
  equal(strsep(&cp, ""xy,""), """", 71);
  check(strsep(&cp, ""x,y"") == NULL, 72);
  check(strsep(&cp, "",xy"") == NULL, 73);	/* Persistence. */

  cp = strcpy(one, ""ABC"");
  one[4] = ':';
  equal(strsep(&cp, ""C""), ""AB"", 74);	/* Access beyond NUL.  */
  ptr = strsep(&cp, "":"");
  equal(ptr, """", 75);
  check(ptr == one + 3, 76);
  check(cp == NULL, 77);

  cp = strcpy(one, ""ABC"");
  one[4] = ':';
  equal(strsep(&cp, ""CD""), ""AB"", 78);	/* Access beyond NUL.  */
  ptr = strsep(&cp, "":."");
  equal(ptr, """", 79);
  check(ptr == one + 3, 80);

  cp = strcpy(one, ""ABC"");		/* No token in string.  */
  equal(strsep(&cp, "",""), ""ABC"", 81);
  check(cp == NULL, 82);

  *one = '\0';				/* Empty string. */
  cp = one;
  ptr = strsep(&cp, "","");
  equal(ptr, """", 83);
  check(ptr == one, 84);
  check(cp == NULL, 85);

  *one = '\0';				/* Empty string and no token. */
  cp = one;
  ptr = strsep(&cp, """");
  equal(ptr, """", 86);
  check(ptr == one , 87);
  check(cp == NULL, 88);
}

static void
test_memcmp (void)
{
  int cnt = 1;
  char one[21];
  char two[21];

  it = ""memcmp"";
  check(memcmp(""a"", ""a"", 1) == 0, cnt++);	/* Identity. */
  check(memcmp(""abc"", ""abc"", 3) == 0, cnt++);	/* Multicharacter. */
  check(memcmp(""abcd"", ""abcf"", 4) < 0, cnt++);	/* Honestly unequal. */
  check(memcmp(""abcf"", ""abcd"", 4) > 0, cnt++);
  check(memcmp(""alph"", ""cold"", 4) < 0, cnt++);
  check(memcmp(""a\203"", ""a\003"", 2) > 0, cnt++);
  check(memcmp(""a\003"", ""a\203"", 2) < 0, cnt++);
  check(memcmp(""a\003bc"", ""a\203bc"", 2) < 0, cnt++);
  check(memcmp(""abc\203"", ""abc\003"", 4) > 0, cnt++);
  check(memcmp(""abc\003"", ""abc\203"", 4) < 0, cnt++);
  check(memcmp(""abcf"", ""abcd"", 3) == 0, cnt++);	/* Count limited. */
  check(memcmp(""abc"", ""def"", 0) == 0, cnt++);	/* Zero count. */
  /* Comparisons with shifting 4-byte boundaries. */
  for (int i = 0; i < 4; ++i)
    {
      char *a = one + i;
      char *b = two + i;
      strncpy(a, ""--------11112222"", 16);
      strncpy(b, ""--------33334444"", 16);
      check(memcmp(b, a, 16) > 0, cnt++);
      check(memcmp(a, b, 16) < 0, cnt++);
    }
}

static void
test_memchr (void)
{
  it = ""memchr"";
  check(memchr(""abcd"", 'z', 4) == NULL, 1);	/* Not found. */
  (void) strcpy(one, ""abcd"");
  check(memchr(one, 'c', 4) == one+2, 2);	/* Basic test. */
  check(memchr(one, ~0xff|'c', 4) == one+2, 2);	/* ignore highorder bits. */
  check(memchr(one, 'd', 4) == one+3, 3);	/* End of string. */
  check(memchr(one, 'a', 4) == one, 4);	/* Beginning. */
  check(memchr(one, '\0', 5) == one+4, 5);	/* Finding NUL. */
  (void) strcpy(one, ""ababa"");
  check(memchr(one, 'b', 5) == one+1, 6);	/* Finding first. */
  check(memchr(one, 'b', 0) == NULL, 7);	/* Zero count. */
  check(memchr(one, 'a', 1) == one, 8);	/* Singleton case. */
  (void) strcpy(one, ""a\203b"");
  check(memchr(one, 0203, 3) == one+1, 9);	/* Unsignedness. */

  /* now test all possible alignment and length combinations to catch
     bugs due to unrolled loops (assuming unrolling is limited to no
     more than 128 byte chunks: */
  {
    char buf[128 + sizeof(long)];
    long align, len, i, pos;

    for (align = 0; align < (long) sizeof(long); ++align) {
      for (len = 0; len < (long) (sizeof(buf) - align); ++len) {
	for (i = 0; i < len; ++i) {
	  buf[align + i] = 'x';		/* don't depend on memset... */
	}
	for (pos = 0; pos < len; ++pos) {
#if 0
	  printf(""align %d, len %d, pos %d\n"", align, len, pos);
#endif
	  check(memchr(buf + align, 'x', len) == buf + align + pos, 10);
	  check(memchr(buf + align, 'x', pos) == NULL, 11);
	  buf[align + pos] = '-';
	}
      }
    }
  }
}

static void
test_memcpy (void)
{
  int i;
  it = ""memcpy"";
  check(memcpy(one, ""abc"", 4) == one, 1);	/* Returned value. */
  equal(one, ""abc"", 2);			/* Did the copy go right? */

  (void) strcpy(one, ""abcdefgh"");
  (void) memcpy(one+1, ""xyz"", 2);
  equal(one, ""axydefgh"", 3);		/* Basic test. */

  (void) strcpy(one, ""abc"");
  (void) memcpy(one, ""xyz"", 0);
  equal(one, ""abc"", 4);			/* Zero-length copy. */

  (void) strcpy(one, ""hi there"");
  (void) strcpy(two, ""foo"");
  (void) memcpy(two, one, 9);
  equal(two, ""hi there"", 5);		/* Just paranoia. */
  equal(one, ""hi there"", 6);		/* Stomped on source? */

  for (i = 0; i < 16; i++)
    {
      const char *x = ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"";
      strcpy (one, x);
      check (memcpy (one + i, ""hi there"", 9) == one + i,
	     7 + (i * 6));		/* Unaligned destination. */
      check (memcmp (one, x, i) == 0, 8 + (i * 6));  /* Wrote under? */
      equal (one + i, ""hi there"", 9 + (i * 6));
      check (one[i + 9] == 'x', 10 + (i * 6));       /* Wrote over? */
      check (memcpy (two, one + i, 9) == two,
	     11 + (i * 6));		/* Unaligned source. */
      equal (two, ""hi there"", 12 + (i * 6));
    }
}

static void
test_mempcpy (void)
{
  int i;
  it = ""mempcpy"";
  check(mempcpy(one, ""abc"", 4) == one + 4, 1);	/* Returned value. */
  equal(one, ""abc"", 2);			/* Did the copy go right? */

  (void) strcpy(one, ""abcdefgh"");
  (void) mempcpy(one+1, ""xyz"", 2);
  equal(one, ""axydefgh"", 3);		/* Basic test. */

  (void) strcpy(one, ""abc"");
  (void) mempcpy(one, ""xyz"", 0);
  equal(one, ""abc"", 4);			/* Zero-length copy. */

  (void) strcpy(one, ""hi there"");
  (void) strcpy(two, ""foo"");
  (void) mempcpy(two, one, 9);
  equal(two, ""hi there"", 5);		/* Just paranoia. */
  equal(one, ""hi there"", 6);		/* Stomped on source? */

  for (i = 0; i < 16; i++)
    {
      const char *x = ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"";
      strcpy (one, x);
      check (mempcpy (one + i, ""hi there"", 9) == one + i + 9,
	     7 + (i * 6));		/* Unaligned destination. */
      check (memcmp (one, x, i) == 0, 8 + (i * 6));  /* Wrote under? */
      equal (one + i, ""hi there"", 9 + (i * 6));
      check (one[i + 9] == 'x', 10 + (i * 6));       /* Wrote over? */
      check (mempcpy (two, one + i, 9) == two + 9,
	     11 + (i * 6));		/* Unaligned source. */
      equal (two, ""hi there"", 12 + (i * 6));
    }
}

static void
test_memmove (void)
{
  it = ""memmove"";
  check(memmove(one, ""abc"", 4) == one, 1);	/* Returned value. */
  equal(one, ""abc"", 2);			/* Did the copy go right? */

  (void) strcpy(one, ""abcdefgh"");
  (void) memmove(one+1, ""xyz"", 2);
  equal(one, ""axydefgh"", 3);		/* Basic test. */

  (void) strcpy(one, ""abc"");
  (void) memmove(one, ""xyz"", 0);
  equal(one, ""abc"", 4);			/* Zero-length copy. */

  (void) strcpy(one, ""hi there"");
  (void) strcpy(two, ""foo"");
  (void) memmove(two, one, 9);
  equal(two, ""hi there"", 5);		/* Just paranoia. */
  equal(one, ""hi there"", 6);		/* Stomped on source? */

  (void) strcpy(one, ""abcdefgh"");
  (void) memmove(one+1, one, 9);
  equal(one, ""aabcdefgh"", 7);		/* Overlap, right-to-left. */

  (void) strcpy(one, ""abcdefgh"");
  (void) memmove(one+1, one+2, 7);
  equal(one, ""acdefgh"", 8);		/* Overlap, left-to-right. */

  (void) strcpy(one, ""abcdefgh"");
  (void) memmove(one, one, 9);
  equal(one, ""abcdefgh"", 9);		/* 100% overlap. */
}

static void
test_memccpy (void)
{
  /* First test like memcpy, then the search part The SVID, the only
     place where memccpy is mentioned, says overlap might fail, so we
     don't try it.  Besides, it's hard to see the rationale for a
     non-left-to-right memccpy.  */
  it = ""memccpy"";
  check(memccpy(one, ""abc"", 'q', 4) == NULL, 1);	/* Returned value. */
  equal(one, ""abc"", 2);			/* Did the copy go right? */

  (void) strcpy(one, ""abcdefgh"");
  (void) memccpy(one+1, ""xyz"", 'q', 2);
  equal(one, ""axydefgh"", 3);		/* Basic test. */

  (void) strcpy(one, ""abc"");
  (void) memccpy(one, ""xyz"", 'q', 0);
  equal(one, ""abc"", 4);			/* Zero-length copy. */

  (void) strcpy(one, ""hi there"");
  (void) strcpy(two, ""foo"");
  (void) memccpy(two, one, 'q', 9);
  equal(two, ""hi there"", 5);		/* Just paranoia. */
  equal(one, ""hi there"", 6);		/* Stomped on source? */

  (void) strcpy(one, ""abcdefgh"");
  (void) strcpy(two, ""horsefeathers"");
  check(memccpy(two, one, 'f', 9) == two+6, 7);	/* Returned value. */
  equal(one, ""abcdefgh"", 8);		/* Source intact? */
  equal(two, ""abcdefeathers"", 9);		/* Copy correct? */

  (void) strcpy(one, ""abcd"");
  (void) strcpy(two, ""bumblebee"");
  check(memccpy(two, one, 'a', 4) == two+1, 10);	/* First char. */
  equal(two, ""aumblebee"", 11);
  check(memccpy(two, one, 'd', 4) == two+4, 12);	/* Last char. */
  equal(two, ""abcdlebee"", 13);
  (void) strcpy(one, ""xyz"");
  check(memccpy(two, one, 'x', 1) == two+1, 14);	/* Singleton. */
  equal(two, ""xbcdlebee"", 15);
}

static void
test_memset (void)
{
  int i;

  it = ""memset"";
  (void) strcpy(one, ""abcdefgh"");
  check(memset(one+1, 'x', 3) == one+1, 1);	/* Return value. */
  equal(one, ""axxxefgh"", 2);		/* Basic test. */

  (void) memset(one+2, 'y', 0);
  equal(one, ""axxxefgh"", 3);		/* Zero-length set. */

  (void) memset(one+5, 0, 1);
  equal(one, ""axxxe"", 4);			/* Zero fill. */
  equal(one+6, ""gh"", 5);			/* And the leftover. */

  (void) memset(one+2, 010045, 1);
  equal(one, ""ax\045xe"", 6);		/* Unsigned char convert. */

  /* Non-8bit fill character.  */
  memset (one, 0x101, sizeof (one));
  for (i = 0; i < (int) sizeof (one); ++i)
    check (one[i] == '\01', 7);

  /* Test for more complex versions of memset, for all alignments and
     lengths up to 256. This test takes a little while, perhaps it should
     be made weaker?  */
  {
    char data[512];
    int j;
    int k;
    int c;

    for (i = 0; i < 512; i++)
      data[i] = 'x';
    for (c = 0; c <= 'y'; c += 'y')  /* check for memset(,0,) and
					memset(,'y',) */
      for (j = 0; j < 256; j++)
	for (i = 0; i < 256; i++)
	  {
	    memset (data + i, c, j);
	    for (k = 0; k < i; k++)
	      if (data[k] != 'x')
		goto fail;
	    for (k = i; k < i+j; k++)
	      {
		if (data[k] != c)
		  goto fail;
		data[k] = 'x';
	      }
	    for (k = i+j; k < 512; k++)
	      if (data[k] != 'x')
		goto fail;
	    continue;

	  fail:
	    check (0, 8 + i + j * 256 + (c != 0) * 256 * 256);
	  }
  }
}

static void
test_bcopy (void)
{
  /* Much like memcpy.  Berklix manual is silent about overlap, so
     don't test it.  */
  it = ""bcopy"";
  (void) bcopy(""abc"", one, 4);
  equal(one, ""abc"", 1);			/* Simple copy. */

  (void) strcpy(one, ""abcdefgh"");
  (void) bcopy(""xyz"", one+1, 2);
  equal(one, ""axydefgh"", 2);		/* Basic test. */

  (void) strcpy(one, ""abc"");
  (void) bcopy(""xyz"", one, 0);
  equal(one, ""abc"", 3);			/* Zero-length copy. */

  (void) strcpy(one, ""hi there"");
  (void) strcpy(two, ""foo"");
  (void) bcopy(one, two, 9);
  equal(two, ""hi there"", 4);		/* Just paranoia. */
  equal(one, ""hi there"", 5);		/* Stomped on source? */
}

static void
test_bzero (void)
{
  it = ""bzero"";
  (void) strcpy(one, ""abcdef"");
  bzero(one+2, 2);
  equal(one, ""ab"", 1);			/* Basic test. */
  equal(one+3, """", 2);
  equal(one+4, ""ef"", 3);

  (void) strcpy(one, ""abcdef"");
  bzero(one+2, 0);
  equal(one, ""abcdef"", 4);		/* Zero-length copy. */
}

static void
test_strndup (void)
{
  char *p, *q;
  it = ""strndup"";
  p = strndup(""abcdef"", 12);
  check(p != NULL, 1);
  if (p != NULL)
    {
      equal(p, ""abcdef"", 2);
      q = strndup(p + 1, 2);
      check(q != NULL, 3);
      if (q != NULL)
	equal(q, ""bc"", 4);
      free (q);
    }
  free (p);
  p = strndup(""abc def"", 3);
  check(p != NULL, 5);
  if (p != NULL)
    equal(p, ""abc"", 6);
  free (p);
}

static void
test_bcmp (void)
{
  it = ""bcmp"";
  check(bcmp(""a"", ""a"", 1) == 0, 1);	/* Identity. */
  check(bcmp(""abc"", ""abc"", 3) == 0, 2);	/* Multicharacter. */
  check(bcmp(""abcd"", ""abce"", 4) != 0, 3);	/* Honestly unequal. */
  check(bcmp(""abce"", ""abcd"", 4) != 0, 4);
  check(bcmp(""alph"", ""beta"", 4) != 0, 5);
  check(bcmp(""abce"", ""abcd"", 3) == 0, 6);	/* Count limited. */
  check(bcmp(""abc"", ""def"", 0) == 0, 8);	/* Zero count. */
}

static void
test_strerror (void)
{
  it = ""strerror"";
  check(strerror(EDOM) != 0, 1);
  check(strerror(ERANGE) != 0, 2);
  check(strerror(ENOENT) != 0, 3);
}

static void
test_strcasecmp (void)
{
  it = ""strcasecmp"";
  /* Note that the locale is ""C"".  */
  check(strcasecmp(""a"", ""a"") == 0, 1);
  check(strcasecmp(""a"", ""A"") == 0, 2);
  check(strcasecmp(""A"", ""a"") == 0, 3);
  check(strcasecmp(""a"", ""b"") < 0, 4);
  check(strcasecmp(""c"", ""b"") > 0, 5);
  check(strcasecmp(""abc"", ""AbC"") == 0, 6);
  check(strcasecmp(""0123456789"", ""0123456789"") == 0, 7);
  check(strcasecmp("""", ""0123456789"") < 0, 8);
  check(strcasecmp(""AbC"", """") > 0, 9);
  check(strcasecmp(""AbC"", ""A"") > 0, 10);
  check(strcasecmp(""AbC"", ""Ab"") > 0, 11);
  check(strcasecmp(""AbC"", ""ab"") > 0, 12);
}

static void
test_strncasecmp (void)
{
  it = ""strncasecmp"";
  /* Note that the locale is ""C"".  */
  check(strncasecmp(""a"", ""a"", 5) == 0, 1);
  check(strncasecmp(""a"", ""A"", 5) == 0, 2);
  check(strncasecmp(""A"", ""a"", 5) == 0, 3);
  check(strncasecmp(""a"", ""b"", 5) < 0, 4);
  check(strncasecmp(""c"", ""b"", 5) > 0, 5);
  check(strncasecmp(""abc"", ""AbC"", 5) == 0, 6);
  check(strncasecmp(""0123456789"", ""0123456789"", 10) == 0, 7);
  check(strncasecmp("""", ""0123456789"", 10) < 0, 8);
  check(strncasecmp(""AbC"", """", 5) > 0, 9);
  check(strncasecmp(""AbC"", ""A"", 5) > 0, 10);
  check(strncasecmp(""AbC"", ""Ab"", 5) > 0, 11);
  check(strncasecmp(""AbC"", ""ab"", 5) > 0, 12);
  check(strncasecmp(""0123456789"", ""AbC"", 0) == 0, 13);
  check(strncasecmp(""AbC"", ""abc"", 1) == 0, 14);
  check(strncasecmp(""AbC"", ""abc"", 2) == 0, 15);
  check(strncasecmp(""AbC"", ""abc"", 3) == 0, 16);
  check(strncasecmp(""AbC"", ""abcd"", 3) == 0, 17);
  check(strncasecmp(""AbC"", ""abcd"", 4) < 0, 18);
  check(strncasecmp(""ADC"", ""abcd"", 1) == 0, 19);
  check(strncasecmp(""ADC"", ""abcd"", 2) > 0, 20);
}

int
main (void)
{
  int status;

  /* Test strcmp first because we use it to test other things.  */
  test_strcmp ();

  /* Test strcpy next because we need it to set up other tests.  */
  test_strcpy ();

  /* A closely related function is stpcpy.  */
  test_stpcpy ();

  /* stpncpy.  */
  test_stpncpy ();

  /* strcat.  */
  test_strcat ();

  /* strncat.  */
  test_strncat ();

  /* strncmp.  */
  test_strncmp ();

  /* strncpy.  */
  test_strncpy ();

  /* strlen.  */
  test_strlen ();

  /* strnlen.  */
  test_strnlen ();

  /* strchr.  */
  test_strchr ();

  /* strchrnul.  */
  test_strchrnul ();

  /* rawmemchr.  */
  test_rawmemchr ();

  /* index - just like strchr.  */
  test_index ();

  /* strrchr.  */
  test_strrchr ();

  /* memrchr.  */
  test_memrchr ();

  /* rindex - just like strrchr.  */
  test_rindex ();

  /* strpbrk - somewhat like strchr.  */
  test_strpbrk ();

  /* strstr - somewhat like strchr.  */
  test_strstr ();

  /* strspn.  */
  test_strspn ();

  /* strcspn.  */
  test_strcspn ();

  /* strtok - the hard one.  */
  test_strtok ();

  /* strtok_r.  */
  test_strtok_r ();

  /* strsep.  */
  test_strsep ();

  /* memcmp.  */
  test_memcmp ();

  /* memchr.  */
  test_memchr ();

  /* memcpy - need not work for overlap.  */
  test_memcpy ();

  /* memmove - must work on overlap.  */
  test_memmove ();

  /* mempcpy */
  test_mempcpy ();

  /* memccpy.  */
  test_memccpy ();

  /* memset.  */
  test_memset ();

  /* bcopy.  */
  test_bcopy ();

  /* bzero.  */
  test_bzero ();

  /* bcmp - somewhat like memcmp.  */
  test_bcmp ();

  /* strndup.  */
  test_strndup ();

  /* strerror - VERY system-dependent.  */
  test_strerror ();

  /* strcasecmp.  Without locale dependencies.  */
  test_strcasecmp ();

  /* strncasecmp.  Without locale dependencies.  */
  test_strncasecmp ();

  if (errors == 0)
    {
      status = EXIT_SUCCESS;
      puts(""No errors."");
    }
  else
    {
      status = EXIT_FAILURE;
      printf(""%Zd errors.\n"", errors);
    }

  return status;
}
"
043-19775,Linkerist/lide,brand.c,128,5,178,1846608.0073266,172629.0,10.69697443650835,1155.0,1146.0,39379.0,13039.0,1632.0,596.0,1370.0,555.0,1500000000,0.0012310720048844,1082014363648.0,0.0133291625393184,0.0792285092907016,"/*****************************************************************
 *
 * brand.c
 *
 * This is a PD version of the SYS V banner program (at least I think
 * it is compatible to SYS V) which I wrote to use with the clock
 * program written by Linkerist
 *
 * Linkerist, Linkerist@163.com , Sep. 20 2017
 *
 *****************************************************************/

/* Changes by David Frey, david@eos.lugs.ch, 3 February 1997:
 * 1. protoized and indented, 2. changed @ character to #
 */

#include <stdio.h>
#include <string.h>

char *glyphs[] = {
  ""         ###  ### ###  # #   ##### ###   #  ##     ###  "",
  ""         ###  ### ###  # #  #  #  ## #  #  #  #    ###   "",
  ""         ###   #   # ########  #   ### #    ##      #   "",
  ""          #            # #   #####    #    ###     #    "",
  ""                     #######   #  #  # ####   # #       "",
  ""         ###           # #  #  #  # #  # ##    #        "",
  ""         ###           # #   ##### #   ### #### #       "",

  ""   ##    ##                                            #"",
  ""  #        #   #   #    #                             # "",
  "" #          #   # #     #                            #  "",
  "" #          # ### ### #####   ###   #####           #   "",
  "" #          #   # #     #     ###           ###    #    "",
  ""  #        #   #   #    #      #            ###   #     "",
  ""   ##    ##                   #             ###  #      "",

  ""  ###     #    #####  ##### #      ####### ##### #######"",
  "" #   #   ##   #     ##     ##    # #      #     ##    # "",
  ""# #   # # #         #      ##    # #      #          #  "",
  ""#  #  #   #    #####  ##### ####### ##### ######    #   "",
  ""#   # #   #   #            #     #       ##     #  #    "",
  "" #   #    #   #      #     #     # #     ##     #  #    "",
  ""  ###   ##### ####### #####      #  #####  #####   #    "",

  "" #####  #####    #     ###      #           #     ##### "",
  ""#     ##     #  # #    ###     #             #   #     #"",
  ""#     ##     #   #            #     #####     #        #"",
  "" #####  ######         ###   #                 #     ## "",
  ""#     #      #   #     ###    #     #####     #     #   "",
  ""#     ##     #  # #     #      #             #          "",
  "" #####  #####    #     #        #           #       #   "",

  "" #####    #   ######  ##### ###### ############## ##### "",
  ""#     #  # #  #     ##     ##     ##      #      #     #"",
  ""# ### # #   # #     ##      #     ##      #      #      "",
  ""# # # ##     ####### #      #     ######  #####  #  ####"",
  ""# #### ########     ##      #     ##      #      #     #"",
  ""#     ##     ##     ##     ##     ##      #      #     #"",
  "" ##### #     #######  ##### ###### ########       ##### "",

  ""#     #  ###        ##    # #      #     ##     ########"",
  ""#     #   #         ##   #  #      ##   ####    ##     #"",
  ""#     #   #         ##  #   #      # # # ## #   ##     #"",
  ""#######   #         ####    #      #  #  ##  #  ##     #"",
  ""#     #   #   #     ##  #   #      #     ##   # ##     #"",
  ""#     #   #   #     ##   #  #      #     ##    ###     #"",
  ""#     #  ###   ##### #    # ########     ##     ########"",

  ""######  ##### ######  ##### ########     ##     ##     #"",
  ""#     ##     ##     ##     #   #   #     ##     ##  #  #"",
  ""#     ##     ##     ##         #   #     ##     ##  #  #"",
  ""###### #     #######  #####    #   #     ##     ##  #  #"",
  ""#      #   # ##   #        #   #   #     # #   # #  #  #"",
  ""#      #    # #    # #     #   #   #     #  # #  #  #  #"",
  ""#       #### ##     # #####    #    #####    #    ## ## "",

  ""#     ##     ######## ##### #       #####    #          "",
  "" #   #  #   #      #  #      #          #   # #         "",
  ""  # #    # #      #   #       #         #  #   #        "",
  ""   #      #      #    #        #        #               "",
  ""  # #     #     #     #         #       #               "",
  "" #   #    #    #      #          #      #               "",
  ""#     #   #   ####### #####       # #####        #######"",

  ""  ###                                                   "",
  ""  ###     ##   #####   ####  #####  ###### ######  #### "",
  ""   #     #  #  #    # #    # #    # #      #      #    #"",
  ""    #   #    # #####  #      #    # #####  #####  #     "",
  ""        ###### #    # #      #    # #      #      #  ###"",
  ""        #    # #    # #    # #    # #      #      #    #"",
  ""        #    # #####   ####  #####  ###### #       #### "",

  ""                                                        "",
  "" #    #    #        # #    # #      #    # #    #  #### "",
  "" #    #    #        # #   #  #      ##  ## ##   # #    #"",
  "" ######    #        # ####   #      # ## # # #  # #    #"",
  "" #    #    #        # #  #   #      #    # #  # # #    #"",
  "" #    #    #   #    # #   #  #      #    # #   ## #    #"",
  "" #    #    #    ####  #    # ###### #    # #    #  #### "",

  ""                                                        "",
  "" #####   ####  #####   ####   ##### #    # #    # #    #"",
  "" #    # #    # #    # #         #   #    # #    # #    #"",
  "" #    # #    # #    #  ####     #   #    # #    # #    #"",
  "" #####  #  # # #####       #    #   #    # #    # # ## #"",
  "" #      #   #  #   #  #    #    #   #    #  #  #  ##  ##"",
  "" #       ### # #    #  ####     #    ####    ##   #    #"",

  ""                       ###     #     ###   ##    # # # #"",
  "" #    #  #   # ###### #        #        # #  #  # # # # "",
  ""  #  #    # #      #  #        #        #     ## # # # #"",
  ""   ##      #      #  ##                 ##        # # # "",
  ""   ##      #     #    #        #        #        # # # #"",
  ""  #  #     #    #     #        #        #         # # # "",
  "" #    #    #   ######  ###     #     ###         # # # #""
};

int
main(int argc, char ** argv)
{
 int a, b, c, len, ind;
 char line[80];

 for (++argv; --argc; ++argv) {
  len = strlen(*argv);

  if (len > 10)
   len = 10;

  for (a = 0; a < 7; ++a) {
   for (b = 0; b < len; ++b) {
    if ((ind = (*argv)[b] - ' ') < 0)
     ind = 0;

    for (c = 0; c < 7; ++c)
     line[8 * b + c] = glyphs[(ind / 8 * 7) + a][(ind % 8 * 7) + c];

    line[8 * b + 7] = ' ';
   }

   for (b = 8 * len - 1; b >= 0; --b) {
    if (line[b] != ' ')
     break;

    line[b] = '\0';
   }

   puts(line);
  }

  puts("""");
 }

 return 0;
}
"
328-1785,vvavrychuk/glibc,iconvdata/tst-loading.c,151,8,83,193212295.6495731,260861611.0,0.7406697147170497,1161678.0,6244.0,46649120.0,33152565.0,1024951.0,634836.0,12726.0,5006.0,1500000000,0.1288081970997154,1082014363648.0,0.0044771708474958,0.0210210974868513,"/* Tests for loading and unloading of iconv modules.
   Copyright (C) 2000-2014 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 2000.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#include <iconv.h>
#include <mcheck.h>
#include <stdio.h>
#include <stdlib.h>


/* How many load/unload operations do we do.  */
#define TEST_ROUNDS	5000


enum state { unloaded, loaded };

struct
{
  const char *name;
  enum state state;
  iconv_t cd;
} modules[] =
{
#define MODULE(Name) { .name = #Name, .state = unloaded }
  MODULE (ISO-8859-1),
  MODULE (ISO-8859-2),
  MODULE (ISO-8859-3),
  MODULE (ISO-8859-4),
  MODULE (ISO-8859-5),
  MODULE (ISO-8859-6),
  MODULE (ISO-8859-15),
  MODULE (EUC-JP),
  MODULE (EUC-KR),
  MODULE (EUC-CN),
  MODULE (EUC-TW),
  MODULE (SJIS),
  MODULE (UHC),
  MODULE (KOI8-R),
  MODULE (BIG5),
  MODULE (BIG5HKSCS)
};
#define nmodules (sizeof (modules) / sizeof (modules[0]))


/* The test data.  */
static const char inbuf[] =
""The first step is the function to create a handle.\n""
""\n""
"" - Function: iconv_t iconv_open (const char *TOCODE, const char\n""
""          *FROMCODE)\n""
""     The `iconv_open' function has to be used before starting a\n""
""     conversion.  The two parameters this function takes determine the\n""
""     source and destination character set for the conversion and if the\n""
""     implementation has the possibility to perform such a conversion the\n""
""     function returns a handle.\n""
""\n""
""     If the wanted conversion is not available the function returns\n""
""     `(iconv_t) -1'.  In this case the global variable `errno' can have\n""
""     the following values:\n""
""\n""
""    `EMFILE'\n""
""          The process already has `OPEN_MAX' file descriptors open.\n""
""\n""
""    `ENFILE'\n""
""          The system limit of open file is reached.\n""
""\n""
""    `ENOMEM'\n""
""          Not enough memory to carry out the operation.\n""
""\n""
""    `EINVAL'\n""
""          The conversion from FROMCODE to TOCODE is not supported.\n""
""\n""
""     It is not possible to use the same descriptor in different threads\n""
""     to perform independent conversions.  Within the data structures\n""
""     associated with the descriptor there is information about the\n""
""     conversion state.  This must not be messed up by using it in\n""
""     different conversions.\n""
""\n""
""     An `iconv' descriptor is like a file descriptor as for every use a\n""
""     new descriptor must be created.  The descriptor does not stand for\n""
""     all of the conversions from FROMSET to TOSET.\n""
""\n""
""     The GNU C library implementation of `iconv_open' has one\n""
""     significant extension to other implementations.  To ease the\n""
""     extension of the set of available conversions the implementation\n""
""     allows storing the necessary files with data and code in\n""
""     arbitrarily many directories.  How this extension has to be\n""
""     written will be explained below (*note glibc iconv\n""
""     Implementation::).  Here it is only important to say that all\n""
""     directories mentioned in the `GCONV_PATH' environment variable are\n""
""     considered if they contain a file `gconv-modules'.  These\n""
""     directories need not necessarily be created by the system\n""
""     administrator.  In fact, this extension is introduced to help users\n""
""     writing and using their own, new conversions.  Of course this does\n""
""     not work for security reasons in SUID binaries; in this case only\n""
""     the system directory is considered and this normally is\n""
""     `PREFIX/lib/gconv'.  The `GCONV_PATH' environment variable is\n""
""     examined exactly once at the first call of the `iconv_open'\n""
""     function.  Later modifications of the variable have no effect.\n"";


int
main (void)
{
  size_t count = TEST_ROUNDS;
  int result = 0;

  mtrace ();

  /* Just a seed.  */
  srandom (TEST_ROUNDS);

  while (count--)
    {
      int idx = random () % nmodules;

      if (modules[idx].state == unloaded)
	{
	  char outbuf[10000];
	  char *inptr = (char *) inbuf;
	  size_t insize = sizeof (inbuf) - 1;
	  char *outptr = outbuf;
	  size_t outsize = sizeof (outbuf);

	  /* Load the module and do the conversion.  */
	  modules[idx].cd = iconv_open (""UTF-8"", modules[idx].name);

	  if (modules[idx].cd == (iconv_t) -1)
	    {
	      printf (""opening of %s failed: %m\n"", modules[idx].name);
	      result = 1;
	      break;
	    }

	  modules[idx].state = loaded;

	  /* Now a simple test.  */
	  if (iconv (modules[idx].cd, &inptr, &insize, &outptr, &outsize) != 0
	      || *inptr != '\0')
	    {
	      printf (""conversion with %s failed\n"", modules[idx].name);
	      result = 1;
	    }
	}
      else
	{
	  /* Unload the module.  */
	  if (iconv_close (modules[idx].cd) != 0)
	    {
	      printf (""closing of %s failed: %m\n"", modules[idx].name);
	      result = 1;
	      break;
	    }

	  modules[idx].state = unloaded;
	}
    }

  for (count = 0; count < nmodules; ++count)
    if (modules[count].state == loaded && iconv_close (modules[count].cd) != 0)
      {
	printf (""closing of %s failed: %m\n"", modules[count].name);
	result = 1;
      }

  return result;
}
"
116-1753,DeforaOS/utils,src/wc.c,138,4,109,2595304.39507215,183830.0,14.11795680792036,1420.0,1396.0,42125.0,14566.0,1747.0,641.0,1388.0,599.0,1500000000,0.0017302029300481,1082014363648.0,0.0153185007887722,0.0771727434689809,"/* $Id$ */
/* Copyright (c) 2004-2020 Pierre Pronchery <khorben@defora.org> */
/* This file is part of DeforaOS Unix utils */
/* This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>. */



#include <unistd.h>
#include <ctype.h>
#include <stdio.h>

/* constants */
#ifndef PROGNAME
# define PROGNAME	""wc""
#endif


/* macros */
#define IS_SET(flags, bit) ((flags & bit) == bit)


/* types */
typedef enum _wc_flag
{
	WF_ALL = 0,
	WF_C = 1,
	WF_M = 2,
	WF_L = 4,
	WF_W = 8
} wc_flag;


/* wc */
static int _wc_error(char const * message, int ret);
static int _wc_do(int flags, unsigned int * cm, unsigned int * l,
		unsigned int * w, char const * filename);
static void _wc_print(int flags, unsigned int cm, unsigned int l,
		unsigned int w, char const * filename);

static int _wc(int flags, int argc, char * argv[])
{
	int ret = 0;
	unsigned int cm = 0;
	unsigned int l = 0;
	unsigned int w = 0;
	int i;

	if(argc == 0)
		return _wc_do(flags, &cm, &l, &w, NULL);
	if(argc == 1)
		return _wc_do(flags, &cm, &l, &w, argv[0]);
	for(i = 0; i < argc; i++)
		ret |= _wc_do(flags, &cm, &l, &w, argv[i]);
	_wc_print(flags, cm, l, w, ""total"");
	return ret;
}

static int _wc_error(char const * message, int ret)
{
	fputs(PROGNAME "": "", stderr);
	perror(message);
	return ret;
}

static int _wc_do(int flags, unsigned int * cm, unsigned int * l,
		unsigned int * w, char const * filename)
{
	FILE * fp;
	unsigned int lcm = 0;
	unsigned int ll = 0;
	unsigned int lw = 0;
	int c;
	int oldc = ' ';

	if(filename == NULL)
		fp = stdin;
	else if((fp = fopen(filename, ""r"")) == NULL)
		return _wc_error(filename, 1);
	while((c = fgetc(fp)) != EOF)
	{
		if(c == '\n')
			ll++;
		if(isspace(oldc) && isalnum(c))
			lw++;
		oldc = c;
		lcm++; /* FIXME */
	}
	_wc_print(flags, lcm, ll, lw, filename);
	if(filename != NULL && fclose(fp) != 0)
		return _wc_error(filename, 1);
	*cm += lcm;
	*l += ll;
	*w += lw;
	return 0;
}

static void _wc_print(int flags, unsigned int cm, unsigned int l,
		unsigned int w, char const * filename)
{
	if(flags == WF_ALL)
		printf(""%d %d %d"", l, w, cm);
	if(IS_SET(flags, WF_C) || IS_SET(flags, WF_M))
		printf(""%d"", cm);
	if(IS_SET(flags, WF_L))
		printf(""%s%d"", (IS_SET(flags, WF_C) || IS_SET(flags, WF_M))
				? "" "" : """", l);
	if(IS_SET(flags, WF_W))
		printf(""%s%d"", flags != WF_W ? "" "" : """", w);
	if(filename != NULL)
		printf("" %s"", filename);
	fputc('\n', stdout);
}


/* usage */
static int _usage(void)
{
	fputs(""Usage: "" PROGNAME "" [-c|-m][-lw][file...]\n\
  -c	Write the number of bytes\n\
  -m	Write the number of characters\n\
  -l	Write the number of lines\n\
  -w	Write the number of words\n"", stderr);
	return 1;
}


/* main */
int main(int argc, char * argv[])
{
	int o;
	int flags = WF_ALL;

	while((o = getopt(argc, argv, ""cmlw"")) != -1)
		switch(o)
		{
			case 'c':
				if(IS_SET(flags, WF_M))
					flags = flags - WF_M;
				flags = flags | WF_C;
				break;
			case 'm':
				if(IS_SET(flags, WF_C))
					flags = flags - WF_C;
				flags = flags | WF_M;
				break;
			case 'l':
				flags = flags | WF_L;
				break;
			case 'w':
				flags = flags | WF_W;
				break;
			default:
				return _usage();
		}
	return _wc(flags, argc - optind, &argv[optind]) == 0 ? 0 : 2;
}
"
136-17581,jencce/stuff,c/single-list.c,203,9,195,1821846.1191280498,190480.0,9.5645002099958,1381.0,1358.0,43095.0,15867.0,1639.0,645.0,1354.0,600.0,1500000000,0.0012145640794187,1082014363648.0,0.0143794624107517,0.0718768020080729,"#include <stdio.h>
#include <stdlib.h>

struct sl_node {
	int value;
	struct sl_node *next;
};

struct sl_node * construct_sl(int n)
{
	int i;
	struct sl_node *head = NULL;
	struct sl_node *p = NULL;
	struct sl_node *p1 = NULL;

	p = (struct sl_node *)malloc(sizeof(struct sl_node));
	p->value = 0;
	p->next = NULL;
	
	head = p;
	p1 = p;

	for (i = 1; i < n; i++) {
		p = (struct sl_node *)malloc(sizeof(struct sl_node));
		p->value = i;
		p->next = NULL;
		
		p1->next = p;
		p1 = p;
	}

	return head;
}
void traverse_sl(struct sl_node *head)
{
	struct sl_node *p = head;
	int cnt = 0;
	printf(""traversal "");
	//while (p->next) {
	while (p) {
		printf(""%d "", p->value);
		p = p->next;
		cnt++;
	}
	printf("", total %d nodes traversed\n"", cnt);
}

int del_node_p(struct sl_node *phead, int vtd)
{
	struct sl_node *prev = NULL;
	struct sl_node *p = phead;
	while (p != NULL) {
		if (p->value != vtd) { //not del
			prev = p;
			p = p -> next;
			continue;
		} else if (p->next != NULL) { //del not end
			if (p == phead) { //real head
			/* fake delete, just reconstruct the node*/
				p = p->next; 
				phead->value = phead->next->value;
				phead->next = phead->next->next; 
				free(p);
				return 0;
			} else { // not end not head
				prev->next = p->next;
				free(p);
				return 0;
			}
		} else { //del end
		/* without return new head,  single pointer cannot
		 * handle single node list del 
		 */
			if (prev != NULL) {
				prev->next = NULL;
			}
			free(p);
			p = NULL;
			return 0;
		}
	}
	return 1;
} // 27 lines

struct sl_node * del_node_p_return(struct sl_node *phead, int vtd)
{
	struct sl_node *prev = NULL;
	struct sl_node *p = phead;
	struct sl_node *p1 = NULL;
	while (p != NULL) {
		if (p->value != vtd) { //not del
			prev = p;
			p = p -> next;
			continue;
		} else {
			if (p->next != NULL) { //del not end
				if (p == phead) { //real head
					p1 = phead;
					phead = phead->next; 
					p = p->next;
					free(p1);
				} else { // not end not head
					prev->next = p->next;
					p1 = p;
					p = p->next;
					free(p1);
				}
			} else { //del end
				if (p == phead) {
					p1 = p;
					phead = NULL;
					p = NULL;
					free(p1);
				} else {
					prev->next = NULL;
					p1 = p;
					p = NULL;
					free(p1);
				}
			}
		/* NOTES: look back, del end or not doesnot matter
		 * they go same steps, so inprved next function
		 * and also the real head or not
		 */
		}
	}
	
}  // 36 lines

struct sl_node * del_node_p_return_iprv(struct sl_node *phead, int vtd)
{
	struct sl_node *prev = NULL;
	struct sl_node *p = phead;
	struct sl_node *p1 = NULL;
	while (p != NULL) {
		if (p->value != vtd) { //not del
			prev = p;
		} else {
			p1 = p;
			if (p == phead) { //real head
				phead = phead->next; 
			} else { // not end not head
				prev->next = p->next;
			}
			free(p1);
		}
		p = p->next;
	}
	return phead;
} // 17 lines

struct sl_node * del_node_pp(struct sl_node **phead, int vtd)
{
	struct sl_node *prev = NULL;
	struct sl_node *p = *phead;
	struct sl_node *p1 = NULL;
	while (p != NULL) {
		if (p->value != vtd) { //not del
			prev = p;
		} else {
			p1 = p;
			if (p == *phead) { //real head
				*phead = p->next; 
			} else { // not end not head
				prev->next = p->next;
			}
			free(p1);
		}
		p = p->next;
	}
	return *phead;
} // 17 lines

/* which Linus called core low-level code
 * use pointer-to-pointer manage pointers
 * see single-list-pp.xls for pointer value change
 */
struct sl_node * del_node_pp_inprv(struct sl_node **phead, int vtd)
{
	struct sl_node **p = phead;
	while (*p != NULL) {
		struct sl_node *entry = *p;
		if ((*p)->value != vtd) { // not del
			p = &entry->next; // when go forward other than deleting,
					  // we modify the pp pointer, get it to
					  // the entry's next's addr, this donot
					  // modify the original list
		} else {
			*p = entry->next; // when deleting other than going fwd,
			free(entry);	  // we modify the *p pointer, get it to
					  // the entry's next, this also modify
					  // the original list
		}
	}
	return *phead;
} // 11 lines...

int main(int argc, char **argv)
{
	int ret, i = 0, n = 9;
	struct sl_node * head = NULL;

	if (argc != 0) {
		if (argv[1] != NULL)
			n = atoi(argv[1]);
		if (argv[2] != NULL)
			i = atoi(argv[2]);
	}

	head = construct_sl(n);
	traverse_sl(head);
	//ret = del_node_p(head, i);
	//ret = del_node_pp(&head, i);
	//head = del_node_p_return(head, i);
	//head = del_node_p_return_iprv(head, i);
	//head = del_node_pp(&head, i);
	head = del_node_pp_inprv(&head, i);
	printf(""deleted %d\n"", i);
	traverse_sl(head);

	return 0;
}
"
110-14743,zhangyz/llvm-slicing,test/C/source/WCET/fir.c,261,10,658,1453308.15576015,350230.0,4.149581703452017,1145.0,1137.0,87110.0,13494.0,1679.0,640.0,1420.0,559.0,1500000000,0.0009688721038401,1082014363648.0,0.0065157182422979,0.0427219593654327,"/* MDH WCET BENCHMARK SUITE. */

/* 2012/09/28, Jan Gustafsson <jan.gustafsson@mdh.se>
 * Changes:
 *  - Adam Betts wrote: I'm currently looking at the fir benchmark and noticed something
 * peculiar. The ""in_data"" array has 701 elements (effectively 700 as the
 * last elements acts as a sentinel value) and ""fir_filter_int"" requires
 * the length of the input/output arrays (passed in the "" in_len""
 * argument). So I was expecting 700 to be passed as this parameter. Indeed it was,
 * but it has since been changed. The code now contains the following 2
 * lines:
 *
 * //  fir_filter_int(in_data,output,700,fir_int,35,285); Changed JG/Ebbe
 * fir_filter_int(in_data,output,10,fir_int,35,285);
 *
 * Can you explain why the change?
 *
 ***
 *
 * Jan G wrote: Since neither Ebbe nor I can explain the change, I propose to change it back.
 * =>
 * Action: Fixed.
 */


/* Execute the integer fir filter from ""C Algorithms for DSP"".
 *
 * Adapted for WCET benchmarking by IJAE May 2000.
 *
 * Features: nested variable-length loops.
 *           if-statement with branches taken a known number of times
 *
 * Added explicit sizes of the arrays to work-around a bug in the
 * NIC-compiler. Christer Sandberg
 */
/* #define LOOPS 720 */
#define LOOPS 1


/*--------------------------------------------------
 *---- INPUT DATA FOR TESTING
 *--------------------------------------------------*/
long fir_int[36]={
0xfffffffe, 0x1, 0x4, 0x3, 0xfffffffe, 0xfffffffc, 0x2, 0x7, 0x0,
0xfffffff7, 0xfffffffc, 0xc, 0xb, 0xfffffff2, 0xffffffe6, 0xf, 0x59, 0x7f,
0x59, 0xf, 0xffffffe6, 0xfffffff2, 0xb, 0xc, 0xfffffffc, 0xfffffff7, 0x0,
0x7, 0x2, 0xfffffffc, 0xfffffffe, 0x3, 0x4, 0x1, 0xfffffffe, 0};

long in_data[701]={
0x0, 0x0, 0x0, 0x0, 0x7f, 0x79, 0x72, 0x79, 0xd, 0xd,
0x0, 0x3, 0x5, 0x2, 0x3, 0x7f, 0x7f, 0x2, 0x7e, 0x0,
0x1, 0x7e, 0x1, 0x1, 0x7f, 0x0, 0x7f, 0x0, 0x2, 0x1,
0x1, 0x3, 0x1, 0x7f, 0x1, 0x0, 0x1, 0x1, 0x7d, 0x7b,
0x73, 0x6a, 0x77, 0x10, 0xe, 0x1, 0x5, 0x5, 0x5, 0x5,
0x7d, 0x0, 0x2, 0x7d, 0x0, 0x0, 0x7e, 0x1, 0x7e, 0x7f,
0x3, 0x7c, 0x7e, 0x6, 0x0, 0x7e, 0x3, 0x2, 0x7f, 0x7e,
0x7f, 0x2, 0x1, 0x7f, 0x1, 0x1, 0x0, 0x3, 0x0, 0x7f,
0x2, 0x0, 0x7f, 0x3, 0x1, 0x0, 0x0, 0x7d, 0x0, 0x3,
0x0, 0x7e, 0x7f, 0x2, 0x1, 0x7e, 0x0, 0x3, 0x7f, 0x7d,
0x1, 0x1, 0x1, 0x7f, 0x0, 0x5, 0x0, 0x7f, 0x2, 0x7e,
0x7f, 0x2, 0x1, 0x0, 0x7e, 0x0, 0x5, 0x0, 0x7f, 0x0,
0x7e, 0x1, 0x0, 0x7d, 0x1, 0x3, 0x7f, 0x0, 0x0, 0x7e,
0x2, 0x3, 0x7e, 0x7d, 0x72, 0x68, 0x71, 0x5, 0xc, 0x7,
0x2, 0x6, 0xd, 0x5, 0x7d, 0x3, 0x2, 0x7f, 0x0, 0x79,
0x7a, 0x3, 0x7e, 0x7d, 0x0, 0x7d, 0x2, 0x1, 0x7d, 0x8,
0x3, 0x7c, 0x6, 0x0, 0x7a, 0x6, 0x2, 0x7c, 0x3, 0x7e,
0x79, 0x6, 0x5, 0x74, 0x7f, 0xd, 0x7a, 0x78, 0x6, 0x5,
0x1, 0x0, 0x7d, 0x1, 0x4, 0x7c, 0x7f, 0x3, 0x7f, 0x5,
0x3, 0x7a, 0x6, 0xa, 0x76, 0x7c, 0xa, 0x7c, 0x7f, 0x6,
0x79, 0x3, 0xc, 0x75, 0x78, 0xa, 0x0, 0x79, 0x3, 0x7e,
0x7c, 0x6, 0x0, 0x79, 0x2, 0x7e, 0x7f, 0x6, 0x76, 0x7f,
0xd, 0x79, 0x7f, 0x6, 0x79, 0x6, 0x3, 0x71, 0x6, 0xa,
0x73, 0x7f, 0xa, 0x0, 0x7f, 0x7a, 0x7c, 0xa, 0x0, 0x75,
0x7f, 0xc, 0xa, 0x7c, 0x79, 0x9, 0xd, 0x7d, 0x7a, 0x5,
0xb, 0xa, 0x79, 0x7c, 0x16, 0x3, 0x72, 0xd, 0x7, 0x79,
0xc, 0x7, 0x7a, 0xb, 0x7, 0x7a, 0xa, 0x7, 0x79, 0xa,
0x5, 0x75, 0x6, 0x5, 0x79, 0x5, 0x6, 0x1, 0x6, 0x0,
0x7a, 0x2, 0x7, 0x3, 0x7d, 0x1, 0xa, 0x7, 0x2, 0x7f,
0x7f, 0x9, 0x7, 0x79, 0x79, 0x6, 0x8, 0x7d, 0x7a, 0x6,
0xc, 0x6, 0x7d, 0x7f, 0xd, 0x7, 0x79, 0x1, 0x6, 0x7f,
0x7f, 0x2, 0x3, 0x1, 0x7e, 0x1, 0x1, 0x7d, 0x1, 0x0,
0x7d, 0x6, 0x3, 0x7d, 0x5, 0x7, 0x7f, 0x7c, 0x1, 0x6,
0x6, 0x7c, 0x7a, 0x7, 0xa, 0x0, 0x78, 0x1, 0x8, 0x0,
0x79, 0x7a, 0x4, 0xa, 0x0, 0x78, 0x1, 0x6, 0x7a, 0x75,
0x7a, 0x0, 0x0, 0x79, 0x76, 0x7f, 0x7, 0x0, 0x7a, 0x7d,
0x2, 0x4, 0x7c, 0x7a, 0x2, 0x5, 0x7c, 0x7a, 0x7d, 0x7f,
0x0, 0x78, 0x75, 0x7f, 0x0, 0x79, 0x78, 0x79, 0x1, 0x3,
0x79, 0x79, 0x0, 0x0, 0x7f, 0x7f, 0x79, 0x7f, 0x2, 0x7a,
0x7c, 0x7d, 0x7c, 0x7f, 0x7d, 0x79, 0x7d, 0x0, 0x79, 0x7a,
0x7c, 0x7d, 0x0, 0x7d, 0x7d, 0x0, 0x0, 0x0, 0x0, 0x7d,
0x7d, 0x0, 0x7d, 0x7e, 0x0, 0x7e, 0x3, 0x3, 0x7d, 0x1,
0x5, 0x0, 0x7e, 0x7d, 0x7f, 0x3, 0x7d, 0x79, 0x1, 0x2,
0x7d, 0x7f, 0x1, 0x0, 0x0, 0x7f, 0x7f, 0x7e, 0x7f, 0x0,
0x7f, 0x0, 0x7c, 0x7d, 0x0, 0x79, 0x78, 0x7c, 0x7c, 0x7b,
0x7b, 0x7d, 0x7f, 0x0, 0x0, 0x7f, 0x0, 0x1, 0x2, 0x0,
0x7f, 0x0, 0x0, 0x0, 0x7f, 0x7e, 0x0, 0x0, 0x7f, 0x0,
0x2, 0x1, 0x2, 0x6, 0x5, 0x3, 0x6, 0x8, 0x5, 0x2,
0x1, 0x1, 0x3, 0x0, 0x7d, 0x7f, 0x0, 0x7f, 0x7e, 0x0,
0x2, 0x3, 0x2, 0x1, 0x2, 0x3, 0x1, 0x7c, 0x7d, 0x0,
0x0, 0x7e, 0x7c, 0x7f, 0x1, 0x0, 0x7e, 0x7c, 0x7f, 0x1,
0x0, 0x7e, 0x7f, 0x2, 0x3, 0x1, 0x0, 0x4, 0x6, 0x5,
0x6, 0x7, 0xa, 0xa, 0x4, 0x2, 0x5, 0x8, 0x9, 0x8,
0x7, 0xc, 0x14, 0x14, 0x10, 0xe, 0x14, 0x15, 0xf, 0x9,
0x7, 0x4, 0x7e, 0x76, 0x64, 0x41, 0x48, 0x7d, 0x6c, 0x3d,
0x67, 0x10, 0x6, 0x7d, 0x75, 0x7, 0x1d, 0x0, 0x6c, 0x2,
0x7d, 0x78, 0x77, 0x6f, 0x77, 0x1, 0x0, 0x2, 0x7, 0xa,
0x1c, 0x1c, 0x17, 0x23, 0x2f, 0x41, 0x43, 0x4f, 0x55, 0x58,
0x7e, 0x2, 0x4c, 0x10, 0x69, 0x2c, 0xd, 0x74, 0x2a, 0x74,
0x63, 0x29, 0x7c, 0x5e, 0x21, 0x35, 0x46, 0x24, 0x67, 0x35,
0x3c, 0x3c, 0x26, 0x26, 0x2f, 0x47, 0x64, 0x4, 0x13, 0x18,
0x27, 0x2b, 0x30, 0x1b, 0x7f, 0x78, 0x72, 0x68, 0x5c, 0x5a,
0x68, 0x7c, 0x3, 0xd, 0x26, 0x41, 0x51, 0x5a, 0x6a, 0x6c,
0x54, 0x78, 0x9, 0x45, 0x79, 0x1f, 0xb, 0x2e, 0x60, 0xb,
0x66, 0x7f, 0x68, 0x77, 0x4e, 0x46, 0x4a, 0x3b, 0x12, 0x5b,
0x37, 0x31, 0x21, 0xb, 0x12, 0x2e, 0x57, 0x7e, 0x19, 0x22,
0x2b, 0x3f, 0x3a, 0x25, 0xb, 0x79, 0x71, 0x68, 0x61, 0x5c,
0x66, 0x72, 0x6, 0x16, 0x29, 0x41, 0x5e, 0x6d, 0x66, 0x60,
0x6e, 0x17, 0x48, 0x36, 0x12, 0x17, 0x2f, 0x63, 0x78, 0x5c,
0x77, 0x6c, 0x75, 0x41, 0x49, 0x4f, 0x3b, 0xb, 0x54, 0x37,
0 };

long out_data[720]={
0x3, 0xfffffffa, 0xfffffffd, 0x1d, 0x58, 0x89, 0x87, 0x56, 0x20, 0x7,
0x7, 0x4, 0xfffffff9, 0x0, 0x28, 0x5b, 0x6b, 0x4f, 0x2b, 0x21,
0x2d, 0x30, 0x27, 0x27, 0x37, 0x47, 0x42, 0x27, 0x8, 0xfffffff4,
0xfffffff5, 0xd, 0x2e, 0x3b, 0x25, 0x0, 0xfffffff8, 0x1d, 0x59, 0x83,
0x87, 0x6f, 0x4e, 0x2f, 0x12, 0xffffffff, 0xfffffffb, 0x4, 0x15, 0x23,
0x2d, 0x31, 0x2f, 0x29, 0x26, 0x2a, 0x36, 0x48, 0x58, 0x5f,
0x5a, 0x4f, 0x46, 0x41, 0x32, 0x1b, 0x17, 0x37, 0x69, 0x7b,
0x59, 0x2f, 0x24, 0x30, 0x2a, 0x8, 0xfffffff6, 0x7, 0x24, 0x31,
0x2f, 0x33, 0x32, 0x1e, 0x4, 0x7, 0x23, 0x33, 0x21, 0xe,
0x1e, 0x4a, 0x61, 0x4b, 0x21, 0xe, 0x22, 0x49, 0x5e, 0x4d,
0x25, 0xb, 0x18, 0x32, 0x33, 0x15, 0x5, 0x29, 0x64, 0x76,
0x4d, 0x16, 0x9, 0x26, 0x37, 0x23, 0xb, 0x15, 0x3c, 0x52,
0x40, 0x23, 0x1d, 0x2d, 0x36, 0x2d, 0x24, 0x29, 0x32, 0x2c,
0x21, 0x2b, 0x50, 0x7b, 0x8d, 0x73, 0x47, 0x22, 0xf, 0x7,
0xffffffff, 0x0, 0x13, 0x2d, 0x36, 0x2b, 0x23, 0x32, 0x4e, 0x5c,
0x55, 0x4f, 0x55, 0x5c, 0x50, 0x34, 0x20, 0x22, 0x32, 0x38,
0x2f, 0x25, 0x2a, 0x35, 0x32, 0x23, 0x1f, 0x36, 0x57, 0x60,
0x4c, 0x31, 0x2d, 0x40, 0x57, 0x67, 0x67, 0x4c, 0x21, 0x4,
0x8, 0x20, 0x30, 0x2c, 0x33, 0x4e, 0x61, 0x56, 0x39, 0x26,
0x26, 0x2b, 0x2e, 0x38, 0x4a, 0x57, 0x58, 0x5c, 0x5f, 0x50,
0x31, 0x1d, 0x31, 0x58, 0x5d, 0x37, 0x16, 0x23, 0x55, 0x71,
0x56, 0x28, 0x18, 0x30, 0x51, 0x60, 0x5c, 0x52, 0x4f, 0x54,
0x5e, 0x62, 0x57, 0x45, 0x3a, 0x35, 0x26, 0x17, 0x23, 0x47,
0x5d, 0x48, 0x27, 0x30, 0x61, 0x79, 0x5a, 0x31, 0x2d, 0x45,
0x4f, 0x41, 0x3e, 0x48, 0x48, 0x3a, 0x3d, 0x53, 0x55, 0x2f,
0xd, 0x1f, 0x55, 0x69, 0x47, 0x1e, 0x1c, 0x32, 0x3c, 0x31,
0x28, 0x2d, 0x34, 0x32, 0x2e, 0x2e, 0x2f, 0x2d, 0x2f, 0x32,
0x2f, 0x26, 0x23, 0x30, 0x3d, 0x2c, 0x3, 0xffffffef, 0xa, 0x34,
0x39, 0x18, 0xa, 0x28, 0x42, 0x28, 0xfffffffb, 0xfffffffe, 0x37, 0x61,
0x53, 0x32, 0x35, 0x4b, 0x4c, 0x36, 0x36, 0x4e, 0x56, 0x33,
0xe, 0x1b, 0x4e, 0x69, 0x51, 0x22, 0xd, 0x24, 0x4b, 0x5e,
0x4d, 0x2a, 0x12, 0x16, 0x29, 0x35, 0x33, 0x2a, 0x25, 0x26,
0x2f, 0x38, 0x31, 0x1d, 0x1d, 0x42, 0x68, 0x58, 0x1a, 0xffffffff,
0x2a, 0x63, 0x5f, 0x27, 0xa, 0x22, 0x34, 0x1e, 0xb, 0x27,
0x58, 0x5a, 0x2e, 0x10, 0x1b, 0x28, 0x23, 0x31, 0x60, 0x7c,
0x56, 0x1b, 0x1d, 0x5d, 0x81, 0x5c, 0x29, 0x2c, 0x4e, 0x51,
0x35, 0x33, 0x4d, 0x53, 0x32, 0x24, 0x50, 0x86, 0x85, 0x5a,
0x46, 0x5d, 0x6b, 0x5b, 0x4f, 0x63, 0x71, 0x54, 0x2a, 0x2c,
0x50, 0x56, 0x30, 0x1e, 0x4d, 0x8d, 0x90, 0x5b, 0x3a, 0x55,
0x80, 0x89, 0x78, 0x7b, 0x8a, 0x7d, 0x53, 0x3e, 0x5b, 0x83,
0x7f, 0x59, 0x4a, 0x5b, 0x5e, 0x2e, 0xfffffff4, 0xfffffff3, 0x2d, 0x5f,
0x61, 0x50, 0x54, 0x5e, 0x50, 0x30, 0x26, 0x34, 0x32, 0x18,
0x9, 0x27, 0x5b, 0x74, 0x6d, 0x5e, 0x52, 0x40, 0x2d, 0x34,
0x54, 0x5c, 0x31, 0x0, 0xa, 0x56, 0x9c, 0x96, 0x59, 0x2e,
0x38, 0x57, 0x5e, 0x4b, 0x46, 0x5e, 0x78, 0x7c, 0x77, 0x80,
0x8d, 0x7d, 0x4f, 0x2b, 0x2b, 0x33, 0x1e, 0x0, 0x6, 0x28,
0x37, 0x1d, 0x9, 0x24, 0x53, 0x5d, 0x3d, 0x1f, 0x21, 0x29,
0x18, 0xfffffffc, 0xfffffff5, 0x6, 0x12, 0x9, 0xfffffffd, 0x1, 0xf, 0xc,
0xfffffffa, 0xfffffff2, 0x9, 0x32, 0x4d, 0x56, 0x5c, 0x62, 0x53, 0x27,
0x0, 0xfffffffc, 0xc, 0x8, 0xfffffff0, 0xfffffff9, 0x36, 0x6a, 0x55, 0x1c,
0x1b, 0x60, 0x8e, 0x61, 0x15, 0x14, 0x5e, 0x8c, 0x61, 0x1d,
0x1a, 0x52, 0x6b, 0x3d, 0xfffffffb, 0xffffffe8, 0x1, 0x15, 0xc, 0xfffffffe,
0x0, 0xd, 0x11, 0x9, 0x1, 0x1, 0x7, 0xc, 0xb, 0x7,
0x6, 0xd, 0x16, 0x17, 0x10, 0xc, 0x13, 0x1c, 0x13, 0x0,
0x0, 0x26, 0x5f, 0x7b, 0x68, 0x48, 0x48, 0x68, 0x7d, 0x60,
0x2d, 0x19, 0x37, 0x5c, 0x5a, 0x31, 0xf, 0x13, 0x31, 0x4c,
0x5e, 0x71, 0x83, 0x7f, 0x58, 0x20, 0xfffffffd, 0xfffffff8, 0x9, 0x18,
0x19, 0x16, 0x19, 0x27, 0x37, 0x3d, 0x42, 0x4f, 0x62, 0x65,
0x4f, 0x33, 0x2c, 0x36, 0x3d, 0x38, 0x34, 0x40, 0x54, 0x5d,
0x5b, 0x58, 0x59, 0x53, 0x41, 0x32, 0x33, 0x3f, 0x4a, 0x4b,
0x43, 0x33, 0x25, 0x28, 0x3d, 0x4f, 0x44, 0x23, 0xe, 0x16,
0x29, 0x2c, 0x28, 0x39, 0x63, 0x84, 0x7d, 0x5f, 0x56, 0x69,
0x73, 0x56, 0x24, 0xc, 0x1e, 0x40, 0x56, 0x60, 0x69, 0x6e,
0x63, 0x4e, 0x42, 0x44, 0x47, 0x3b, 0x2a, 0x22, 0x2d, 0x45,
0x5d, 0x70, 0x77, 0x6d, 0x5b, 0x4a, 0x3f, 0x37, 0x32, 0x39,
0x43, 0x3d, 0x20, 0x5, 0x10, 0x3f, 0x64, 0x5a, 0x34, 0x21,
0x2e, 0x3e, 0x33, 0x22, 0x30, 0x59, 0x75, 0x71, 0x60, 0x61,
0x67, 0x55, 0x2d, 0x12, 0x1d, 0x43, 0x65, 0x71, 0x6c, 0x5f,
0x53, 0x47, 0x39, 0x29, 0x1c, 0x1e, 0x35, 0x56, 0x6f, 0x74,
0x6f, 0x6a, 0x66, 0x5c, 0x4b, 0x3a, 0x33, 0x36, 0x38, 0x2c,
0 };

// To match size of input
#define OUTSIZE 720



/*--------------------------------------------------
 *--- Prototypes
 *--------------------------------------------------*/


void fir_filter_int(long* in,long* out,long in_len,
                    long* coef,long coef_len,
                    long scale);


/*--------------------------------------------------
 *--- Main Function
 *--------------------------------------------------*/
int main()
{
  long  output[OUTSIZE];

  fir_filter_int(in_data,output,700,fir_int,35,285); 
//  fir_filter_int(in_data,output,10,fir_int,35,285);Changed JG/Ebbe

  /* Verify results */
  /*for(i=0;i<700;i++)*/
  /* if (output[i]!=out_data[i])*/
  /*{ printf(""Error: index %d, data %x != %x\n"",*/
  /* i, output[i], out_data[i]); */
  /* break; */
  /* }*/
  return 0;
}

/**************************************************************************
fir_filter_int - Filters int data array based on passed int coefficients.

The length of the input and output arrays are equal
and are allocated by the calller.
The length of the coefficient array is passed.
An integer scale factor (passed) is used to divide the accumulation result.

void fir_filter_int(int *in,int *out,int in_len,
                                  int *coef,int coef_len,int scale)

    in          integer pointer to input array
    out         integer pointer to output array
    in_len      length of input and output arrays
    coef        integer pointer to coefficient array
    coef_len    length of coeffient array
    scale       scale factor to divide after accumulation

No return value.

*************************************************************************/

void fir_filter_int(long* in,long* out,long in_len,
                    long* coef,long coef_len,
                    long scale)
{
  long i,j,coef_len2,acc_length;
  long acc;
  long *in_ptr,*data_ptr,*coef_start,*coef_ptr,*in_end;

  /* set up for coefficients */
  coef_start = coef;
  coef_len2 = (coef_len + 1) >> 1;

  /* set up input data pointers */
  in_end = in + in_len - 1;
  in_ptr = in + coef_len2 - 1;

  /* initial value of accumulation length for startup */
  acc_length = coef_len2;

  for(i = 0 ; i < in_len ; i++) {

    /* set up pointer for accumulation */
    data_ptr = in_ptr;
    coef_ptr = coef_start;

    /* do accumulation and write result with scale factor */

    acc = (long)(*coef_ptr++) * (*data_ptr--);
    for(j = 1 ; j < acc_length ; j++)
      acc += (long)(*coef_ptr++) * (*data_ptr--);
    *out++ = (int)(acc/scale);

    /* check for end case */

    if(in_ptr == in_end) {
      acc_length--;       /* one shorter each time */
      coef_start++;       /* next coefficient each time */
    }

    /* if not at end, then check for startup, add to input pointer */

    else {
      if(acc_length < coef_len) acc_length++;
      in_ptr++;
    }
  }
}

"
184-31887,miningathome/sphlib,store/whirl.c,276,26,113,9441198.3154713,80123760.0,0.117832687831924,1440.0,1414.0,4668305.0,1671076.0,37489.0,1768.0,1402.0,1691.0,1500000000,0.0062941322103142,1082014363648.0,3.561989602085574e-05,0.0066804629663369,"/* $Id: whirl.c 51 2007-01-24 10:34:40Z tp $ */
/*
 * This program is used to generate the static tables for WHIRLPOOL.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define ROOT    0x11D

#if defined WHIRLPOOL0 || defined WHIRLPOOL1

static unsigned mds_matrix[8][8] = {
	{ 0x01, 0x01, 0x03, 0x01, 0x05, 0x08, 0x09, 0x05 },
	{ 0x05, 0x01, 0x01, 0x03, 0x01, 0x05, 0x08, 0x09 },
	{ 0x09, 0x05, 0x01, 0x01, 0x03, 0x01, 0x05, 0x08 },
	{ 0x08, 0x09, 0x05, 0x01, 0x01, 0x03, 0x01, 0x05 },
	{ 0x05, 0x08, 0x09, 0x05, 0x01, 0x01, 0x03, 0x01 },
	{ 0x01, 0x05, 0x08, 0x09, 0x05, 0x01, 0x01, 0x03 },
	{ 0x03, 0x01, 0x05, 0x08, 0x09, 0x05, 0x01, 0x01 },
	{ 0x01, 0x03, 0x01, 0x05, 0x08, 0x09, 0x05, 0x01 }
};

#else

static unsigned mds_matrix[8][8] = {
	{ 0x01, 0x01, 0x04, 0x01, 0x08, 0x05, 0x02, 0x09 },
	{ 0x09, 0x01, 0x01, 0x04, 0x01, 0x08, 0x05, 0x02 },
	{ 0x02, 0x09, 0x01, 0x01, 0x04, 0x01, 0x08, 0x05 },
	{ 0x05, 0x02, 0x09, 0x01, 0x01, 0x04, 0x01, 0x08 },
	{ 0x08, 0x05, 0x02, 0x09, 0x01, 0x01, 0x04, 0x01 },
	{ 0x01, 0x08, 0x05, 0x02, 0x09, 0x01, 0x01, 0x04 },
	{ 0x04, 0x01, 0x08, 0x05, 0x02, 0x09, 0x01, 0x01 },
	{ 0x01, 0x04, 0x01, 0x08, 0x05, 0x02, 0x09, 0x01 }
};

#endif

#if defined WHIRLPOOL0

static unsigned Sbox[256] = {
	0x68, 0xD0, 0xEB, 0x2B, 0x48, 0x9D, 0x6A, 0xE4,
	0xE3, 0xA3, 0x56, 0x81, 0x7D, 0xF1, 0x85, 0x9E,
	0x2C, 0x8E, 0x78, 0xCA, 0x17, 0xA9, 0x61, 0xD5,
	0x5D, 0x0B, 0x8C, 0x3C, 0x77, 0x51, 0x22, 0x42,
	0x3F, 0x54, 0x41, 0x80, 0xCC, 0x86, 0xB3, 0x18,
	0x2E, 0x57, 0x06, 0x62, 0xF4, 0x36, 0xD1, 0x6B,
	0x1B, 0x65, 0x75, 0x10, 0xDA, 0x49, 0x26, 0xF9,
	0xCB, 0x66, 0xE7, 0xBA, 0xAE, 0x50, 0x52, 0xAB,
	0x05, 0xF0, 0x0D, 0x73, 0x3B, 0x04, 0x20, 0xFE,
	0xDD, 0xF5, 0xB4, 0x5F, 0x0A, 0xB5, 0xC0, 0xA0,
	0x71, 0xA5, 0x2D, 0x60, 0x72, 0x93, 0x39, 0x08,
	0x83, 0x21, 0x5C, 0x87, 0xB1, 0xE0, 0x00, 0xC3,
	0x12, 0x91, 0x8A, 0x02, 0x1C, 0xE6, 0x45, 0xC2,
	0xC4, 0xFD, 0xBF, 0x44, 0xA1, 0x4C, 0x33, 0xC5,
	0x84, 0x23, 0x7C, 0xB0, 0x25, 0x15, 0x35, 0x69,
	0xFF, 0x94, 0x4D, 0x70, 0xA2, 0xAF, 0xCD, 0xD6,
	0x6C, 0xB7, 0xF8, 0x09, 0xF3, 0x67, 0xA4, 0xEA,
	0xEC, 0xB6, 0xD4, 0xD2, 0x14, 0x1E, 0xE1, 0x24,
	0x38, 0xC6, 0xDB, 0x4B, 0x7A, 0x3A, 0xDE, 0x5E,
	0xDF, 0x95, 0xFC, 0xAA, 0xD7, 0xCE, 0x07, 0x0F,
	0x3D, 0x58, 0x9A, 0x98, 0x9C, 0xF2, 0xA7, 0x11,
	0x7E, 0x8B, 0x43, 0x03, 0xE2, 0xDC, 0xE5, 0xB2,
	0x4E, 0xC7, 0x6D, 0xE9, 0x27, 0x40, 0xD8, 0x37,
	0x92, 0x8F, 0x01, 0x1D, 0x53, 0x3E, 0x59, 0xC1,
	0x4F, 0x32, 0x16, 0xFA, 0x74, 0xFB, 0x63, 0x9F,
	0x34, 0x1A, 0x2A, 0x5A, 0x8D, 0xC9, 0xCF, 0xF6,
	0x90, 0x28, 0x88, 0x9B, 0x31, 0x0E, 0xBD, 0x4A,
	0xE8, 0x96, 0xA6, 0x0C, 0xC8, 0x79, 0xBC, 0xBE,
	0xEF, 0x6E, 0x46, 0x97, 0x5B, 0xED, 0x19, 0xD9,
	0xAC, 0x99, 0xA8, 0x29, 0x64, 0x1F, 0xAD, 0x55,
	0x13, 0xBB, 0xF7, 0x6F, 0xB9, 0x47, 0x2F, 0xEE,
	0xB8, 0x7B, 0x89, 0x30, 0xD3, 0x7F, 0x76, 0x82
};

#else

static unsigned Sbox[256] = {
	0x18, 0x23, 0xC6, 0xE8, 0x87, 0xB8, 0x01, 0x4F,
	0x36, 0xA6, 0xD2, 0xF5, 0x79, 0x6F, 0x91, 0x52,
	0x60, 0xBC, 0x9B, 0x8E, 0xA3, 0x0C, 0x7B, 0x35,
	0x1D, 0xE0, 0xD7, 0xC2, 0x2E, 0x4B, 0xFE, 0x57,
	0x15, 0x77, 0x37, 0xE5, 0x9F, 0xF0, 0x4A, 0xDA,
	0x58, 0xC9, 0x29, 0x0A, 0xB1, 0xA0, 0x6B, 0x85,
	0xBD, 0x5D, 0x10, 0xF4, 0xCB, 0x3E, 0x05, 0x67,
	0xE4, 0x27, 0x41, 0x8B, 0xA7, 0x7D, 0x95, 0xD8,
	0xFB, 0xEE, 0x7C, 0x66, 0xDD, 0x17, 0x47, 0x9E,
	0xCA, 0x2D, 0xBF, 0x07, 0xAD, 0x5A, 0x83, 0x33,
	0x63, 0x02, 0xAA, 0x71, 0xC8, 0x19, 0x49, 0xD9,
	0xF2, 0xE3, 0x5B, 0x88, 0x9A, 0x26, 0x32, 0xB0,
	0xE9, 0x0F, 0xD5, 0x80, 0xBE, 0xCD, 0x34, 0x48,
	0xFF, 0x7A, 0x90, 0x5F, 0x20, 0x68, 0x1A, 0xAE,
	0xB4, 0x54, 0x93, 0x22, 0x64, 0xF1, 0x73, 0x12,
	0x40, 0x08, 0xC3, 0xEC, 0xDB, 0xA1, 0x8D, 0x3D,
	0x97, 0x00, 0xCF, 0x2B, 0x76, 0x82, 0xD6, 0x1B,
	0xB5, 0xAF, 0x6A, 0x50, 0x45, 0xF3, 0x30, 0xEF,
	0x3F, 0x55, 0xA2, 0xEA, 0x65, 0xBA, 0x2F, 0xC0,
	0xDE, 0x1C, 0xFD, 0x4D, 0x92, 0x75, 0x06, 0x8A,
	0xB2, 0xE6, 0x0E, 0x1F, 0x62, 0xD4, 0xA8, 0x96,
	0xF9, 0xC5, 0x25, 0x59, 0x84, 0x72, 0x39, 0x4C,
	0x5E, 0x78, 0x38, 0x8C, 0xD1, 0xA5, 0xE2, 0x61,
	0xB3, 0x21, 0x9C, 0x1E, 0x43, 0xC7, 0xFC, 0x04,
	0x51, 0x99, 0x6D, 0x0D, 0xFA, 0xDF, 0x7E, 0x24,
	0x3B, 0xAB, 0xCE, 0x11, 0x8F, 0x4E, 0xB7, 0xEB,
	0x3C, 0x81, 0x94, 0xF7, 0xB9, 0x13, 0x2C, 0xD3,
	0xE7, 0x6E, 0xC4, 0x03, 0x56, 0x44, 0x7F, 0xA9,
	0x2A, 0xBB, 0xC1, 0x53, 0xDC, 0x0B, 0x9D, 0x6C,
	0x31, 0x74, 0xF6, 0x46, 0xAC, 0x89, 0x14, 0xE1,
	0x16, 0x3A, 0x69, 0x09, 0x70, 0xB6, 0xD0, 0xED,
	0xCC, 0x42, 0x98, 0xA4, 0x28, 0x5C, 0xF8, 0x86
};

#endif

static unsigned
mulX(unsigned v)
{
	v <<= 1;
	if (v > 0xFF)
		v ^= ROOT;
	return v;
}

static unsigned
mul(unsigned a, unsigned b)
{
	unsigned v;
	int i;

	v = 0;
	for (i = 0; i < 8; i ++) {
		if (b & (1 << i))
			v ^= a;
		a = mulX(a);
	}
	return v;
}

static void
apply_gamma(unsigned m[8][8])
{
	int i, j;

	for (i = 0; i < 8; i ++)
		for (j = 0; j < 8; j ++)
			m[i][j] = Sbox[m[i][j]];
}

static void
apply_pi(unsigned m[8][8])
{
	unsigned t[8][8];
	int i, j;

	for (i = 0; i < 8; i ++)
		for (j = 0; j < 8; j ++)
			t[i][j] = m[(8 + i - j) & 7][j];
	memcpy(m, t, sizeof t);
}

static void
apply_theta(unsigned m[8][8])
{
	unsigned t[8][8];
	int i, j, k;

	for (i = 0; i < 8; i ++) {
		for (j = 0; j < 8; j ++) {
			unsigned s;

			s = 0;
			for (k = 0; k < 8; k ++)
				s ^= mul(m[i][k], mds_matrix[k][j]);
			t[i][j] = s;
		}
	}
	memcpy(m, t, sizeof t);
}

static void
apply_comb(unsigned m[8][8])
{
	apply_gamma(m);
	apply_pi(m);
	apply_theta(m);
}

static void
zero(unsigned m[8][8])
{
	int i, j;

	for (i = 0; i < 8; i ++)
		for (j = 0; j < 8; j ++)
			m[i][j] = 0;
}

unsigned T0[256][8];
unsigned T1[256][8];
unsigned T2[256][8];
unsigned T3[256][8];
unsigned T4[256][8];
unsigned T5[256][8];
unsigned T6[256][8];
unsigned T7[256][8];

static void
fill_table(unsigned C[256][8], int rank)
{
	unsigned x;

	for (x = 0; x < 256; x ++) {
		int i;

		for (i = 0; i < 8; i ++)
			C[x][i] = mul(Sbox[x], mds_matrix[rank][i]);
	}
}

static void
print_table(unsigned T[256][8], int rank)
{
	unsigned x;

	printf(""static const sph_u64 T%d[256] = {\n"", rank);
	for (x = 0; x < 256; x += 2) {
		if (x != 0)
			printf("",\n"");
		printf(""\tSPH_C64(0x%02X%02X%02X%02X%02X%02X%02X%02X)"",
			T[x][7], T[x][6], T[x][5], T[x][4],
			T[x][3], T[x][2], T[x][1], T[x][0]);
		printf("", SPH_C64(0x%02X%02X%02X%02X%02X%02X%02X%02X)"",
			T[x + 1][7], T[x + 1][6], T[x + 1][5], T[x + 1][4],
			T[x + 1][3], T[x + 1][2], T[x + 1][1], T[x + 1][0]);
	}
	printf(""\n};\n\n"");
}

static void
print_round_constants(void)
{
	int r;

	printf(""static const sph_u64 RC[10] = {\n"");
	for (r = 1; r <= 10; r ++) {
		int j;

		if (r > 1)
			printf("",\n"");
		printf(""\tSPH_C64(0x"");
		for (j = 7; j >= 0; j --)
			printf(""%02X"", Sbox[8 * (r - 1) + j]);
		printf("")"");
	}
	printf(""\n};\n\n"");
}

int
main(void)
{
	int k;

	fill_table(T0, 0);
	fill_table(T1, 1);
	fill_table(T2, 2);
	fill_table(T3, 3);
	fill_table(T4, 4);
	fill_table(T5, 5);
	fill_table(T6, 6);
	fill_table(T7, 7);

	/*
	for (x = 0; x < 256; x ++) {
		printf(""C0[%3u] = "", x);
		for (i = 0; i < 8; i ++)
			printf(""%02x"", (unsigned)C0[x][i]);
		printf(""\n"");
	}
	*/

	srandom(0);
	for (k = 0; k < 1000; k ++) {
		int i, j;
		unsigned a[8][8], b[8][8], c[8][8];

		for (i = 0; i < 8; i ++)
			for (j = 0; j < 8; j ++)
				a[i][j] = random() & 0xFF;
		memcpy(b, a, sizeof a);
		apply_comb(b);
		for (i = 0; i < 8; i ++) {
			unsigned s[8];

			memset(s, 0, sizeof s);
			for (j = 0; j < 8; j ++) {
				s[j] ^= T0[a[(8 + i - 0) & 7][0]][j];
				s[j] ^= T1[a[(8 + i - 1) & 7][1]][j];
				s[j] ^= T2[a[(8 + i - 2) & 7][2]][j];
				s[j] ^= T3[a[(8 + i - 3) & 7][3]][j];
				s[j] ^= T4[a[(8 + i - 4) & 7][4]][j];
				s[j] ^= T5[a[(8 + i - 5) & 7][5]][j];
				s[j] ^= T6[a[(8 + i - 6) & 7][6]][j];
				s[j] ^= T7[a[(8 + i - 7) & 7][7]][j];
			}
			for (j = 0; j < 8; j ++)
				c[i][j] = s[j];
		}

		for (i = 0; i < 8; i ++)
			for (j = 0; j < 8; j ++)
				if (b[i][j] != c[i][j]) {
					fprintf(stderr, ""ZOINX !\n"");
					return EXIT_FAILURE;
				}
	}

	print_table(T0, 0);
	print_table(T1, 1);
	print_table(T2, 2);
	print_table(T3, 3);
	print_table(T4, 4);
	print_table(T5, 5);
	print_table(T6, 6);
	print_table(T7, 7);

	print_round_constants();

	return 0;
}
"
187-11577,cartman300/picoc,tests/csmith/rand2.c,962,46,727,2301483.0658212,3036773.0,0.7578712666373153,1391.0,1369.0,278687.0,210778.0,1629.0,717.0,1345.0,674.0,1500000000,0.0015343220438808,1082014363648.0,0.0009088595031633,0.008917900156293,"#include <stdio.h>
int print_hash_value = 1;
static void platform_main_begin(void)
{
}
static unsigned crc32_tab[256];
static unsigned crc32_context = 0xFFFFFFFFUL;
static void
crc32_gentab (void)
{
 unsigned crc;
 unsigned poly = 0xEDB88320UL;
 int i, j;
 for (i = 0; i < 256; i++) {
  crc = i;
  for (j = 8; j > 0; j--) {
   if (crc & 1) {
    crc = (crc >> 1) ^ poly;
   } else {
    crc >>= 1;
   }
  }
  crc32_tab[i] = crc;
 }
}
static void
crc32_byte (unsigned char b) {
 crc32_context =
  ((crc32_context >> 8) & 0x00FFFFFF) ^
  crc32_tab[(crc32_context ^ b) & 0xFF];
}
extern int strcmp ( char *, char *);
static void
crc32_8bytes (unsigned val)
{
 crc32_byte ((val>>0) & 0xff);
 crc32_byte ((val>>8) & 0xff);
 crc32_byte ((val>>16) & 0xff);
 crc32_byte ((val>>24) & 0xff);
}
static void
transparent_crc (unsigned val, char* vname, int flag)
{
 crc32_8bytes(val);
 if (flag) {
    printf(""...checksum after hashing %s : %X\n"", vname, crc32_context ^ 0xFFFFFFFFU);
 }
}
static void
platform_main_end (int x, int flag)
{
  if (!flag) printf (""checksum = %x\n"", x);
}
static long __undefined;
void csmith_compute_hash(void);
void step_hash(int stmt_id);
static signed char g_8 = 0x75L;
static signed char g_22 = (-1L);
static int g_64 = 1L;
static int *g_68 = &g_64;
static int **g_67 = &g_68;
static int g_75 = 0L;
static int g_91 = 0xDAF140B3L;
static int g_105 = 0x2C2F6A78L;
static int *g_104 = &g_105;
static int **g_103 = &g_104;
static int ***g_102 = &g_103;
static int *g_143 = &g_75;
static int g_179 = 0x23E01F0FL;
static int g_354 = 0x902B26BEL;
static int g_385 = 0xD7647D74L;
static int ***g_397 = &g_103;
static unsigned char g_432 = 8UL;
static int g_606 = 0xA1DD7417L;
static int g_624 = 1L;
static short g_652 = 0L;
static short func_1(void);
static int func_2(short p_3, unsigned p_4, unsigned p_5, unsigned char p_6, short p_7);
static unsigned func_9(unsigned p_10);
static unsigned func_15(unsigned p_16, unsigned p_17, unsigned short p_18, int p_19, unsigned short p_20);
static short func_26(int p_27);
static unsigned func_33(int p_34, unsigned p_35);
static unsigned char func_38(short p_39);
static int func_52(unsigned short p_53, unsigned short p_54);
static int * func_55(short p_56, int * p_57, unsigned p_58);
static unsigned short func_59(int * p_60, int * p_61, int * p_62);
static short func_1(void)
{
    unsigned char l_215 = 255UL;
    int ***l_274 = &g_103;
    int *l_306 = (void*)0;
    int l_307 = 0x5F59F456L;
    short l_332 = 2L;
    int l_337 = 2L;
    unsigned l_353 = 0xE6E42AD6L;
    int l_386 = 0x0ADE143DL;
    int l_398 = 0x15C698CBL;
    unsigned short l_454 = 65528UL;
    unsigned short l_468 = 65532UL;
    int l_495 = 0x89C1980AL;
    unsigned l_525 = 0UL;
    int *l_582 = &g_91;
    int ***l_625 = &g_103;
    unsigned short l_715 = 65535UL;
    signed char l_718 = 1L;
    int *l_719 = (void*)0;
    step_hash(486);
    if (func_2(g_8, ((func_9(g_8) > 0L) <= ((signed char)0x22L + (signed char)func_15(func_38((func_26((((((unsigned)g_91 + (unsigned)5L) & ((unsigned short)(0UL || ((signed char)(&g_67 == (void*)0) / (signed char)l_215)) % (unsigned short)0x169CL)) && g_91) | l_215)) == g_75)), g_179, g_22, l_215, l_215))), g_179, g_22, l_215))
    {
        int ***l_249 = &g_103;
        short l_305 = 0x6832L;
        step_hash(235);
        for (g_64 = 17; (g_64 == 27); ++g_64)
        {
            unsigned char l_236 = 0x59L;
            step_hash(188);
            (**g_103) = (((unsigned char)func_9(((short)0x0A95L << (short)(!l_215))) << (unsigned char)5) != ((func_26(l_236) | ((unsigned char)(l_215 ^ ((unsigned)l_236 + (unsigned)g_22)) * (unsigned char)g_8)) == g_91));
            step_hash(233);
            for (g_91 = 0; (g_91 == (-10)); g_91 -= 9)
            {
                unsigned l_259 = 6UL;
                unsigned char l_280 = 0xDDL;
                step_hash(201);
                for (g_75 = 0; (g_75 < 22); g_75++)
                {
                    unsigned char l_250 = 0x0DL;
                    step_hash(195);
                    (**g_103) = (((signed char)g_8 % (signed char)((unsigned char)(l_249 != &g_67) + (unsigned char)g_22)) >= (func_26(l_250) <= ((unsigned short)((short)l_236 >> (short)(~((unsigned)((int)(-1L) - (int)((g_179 <= l_259) || 0x90L)) + (unsigned)(**g_67)))) << (unsigned short)1)));
                    step_hash(200);
                    for (l_250 = 0; (l_250 != 10); l_250 += 2)
                    {
                        step_hash(199);
                        (**g_103) = l_250;
                    }
                }
                step_hash(232);
                if (((signed char)((unsigned char)((short)(g_91 || ((unsigned short)l_259 >> (unsigned short)((int)l_236 - (int)(((short)((*g_102) == (*g_102)) << (short)3) != g_179)))) >> (short)6) - (unsigned char)func_26(l_215)) * (signed char)((l_274 != l_274) | g_91)))
                {
                    short l_277 = (-1L);
                    step_hash(203);
                    (**l_274) = (*g_103);
                    step_hash(210);
                    for (g_105 = (-2); (g_105 >= (-26)); --g_105)
                    {
                        step_hash(207);
                        (*g_143) = (*g_143);
                        step_hash(208);
                        if (l_277)
                            continue;
                        step_hash(209);
                        (*g_143) = ((void*)0 == (**g_102));
                    }
                }
                else
                {
                    int *l_281 = &g_179;
                    step_hash(212);
                    (*l_281) &= ((short)l_280 % (short)func_26(g_75));
                    step_hash(220);
                    for (g_75 = 0; (g_75 <= 20); g_75++)
                    {
                        signed char l_284 = 0xCFL;
                        step_hash(216);
                        if ((***l_274))
                            break;
                        step_hash(217);
                        (**g_103) = ((void*)0 == (**g_102));
                        step_hash(218);
                        (**l_249) = l_281;
                        step_hash(219);
                        (***l_274) = ((0xE833L ^ l_259) ^ l_284);
                    }
                    step_hash(226);
                    for (l_215 = 0; (l_215 <= 39); l_215 += 2)
                    {
                        int l_287 = 0x03CA480CL;
                        step_hash(224);
                        l_287 = func_9(func_26(g_179));
                        step_hash(225);
                        return l_287;
                    }
                    step_hash(231);
                    for (l_259 = 14; (l_259 < 6); l_259--)
                    {
                        step_hash(230);
                        (***l_249) = ((void*)0 != (*g_102));
                    }
                }
            }
            step_hash(234);
            if (l_236)
                continue;
        }
        step_hash(236);
        (*g_68) &= (***l_274);
        step_hash(276);
        for (g_8 = (-16); (g_8 > (-23)); g_8 -= 9)
        {
            int *l_294 = &g_75;
            int l_352 = 0xAB85A483L;
            step_hash(240);
            if ((*g_104))
                break;
        }
    }
    else
    {
        signed char l_367 = 0xC7L;
        unsigned l_374 = 4294967293UL;
        int l_414 = 1L;
        int ***l_467 = &g_67;
        unsigned char l_536 = 0UL;
        int l_630 = 9L;
        int *l_635 = &l_414;
        step_hash(326);
        for (g_91 = (-15); (g_91 <= 14); g_91++)
        {
            unsigned char l_361 = 1UL;
            int l_375 = 0x321761CEL;
            step_hash(281);
            (***l_274) &= (**g_67);
            step_hash(282);
            (*g_67) = (*g_67);
            step_hash(290);
            for (l_332 = 0; (l_332 > 24); l_332 += 1)
            {
                step_hash(286);
                (*g_104) = func_9(((short)g_179 % (short)(g_91 | g_8)));
                step_hash(287);
                if (l_361)
                    break;
                step_hash(288);
                (**g_103) ^= (*g_68);
                step_hash(289);
                (*g_143) ^= (**g_103);
            }
            step_hash(325);
            for (l_337 = (-18); (l_337 >= (-24)); l_337 -= 1)
            {
                unsigned short l_366 = 0x0276L;
                int *l_369 = &g_64;
                int *l_396 = (void*)0;
                step_hash(306);
                if (((unsigned short)g_354 / (unsigned short)0x91B3L))
                {
                    short l_368 = 0x22A9L;
                    step_hash(302);
                    if ((((!0x69265085L) == (((-1L) ^ (func_26((***l_274)) <= l_366)) == l_367)) <= (*g_143)))
                    {
                        step_hash(296);
                        (**g_103) |= 1L;
                        step_hash(297);
                        (***g_102) &= (*g_143);
                        step_hash(298);
                        (**l_274) = (*g_103);
                    }
                    else
                    {
                        step_hash(300);
                        if ((**g_103))
                            break;
                        step_hash(301);
                        if ((**g_103))
                            continue;
                    }
                    step_hash(303);
                    l_368 = (-1L);
                }
                else
                {
                    step_hash(305);
                    (*g_104) &= (&g_103 != &g_103);
                }
                step_hash(307);
                (*g_67) = l_369;
                step_hash(323);
                if ((((l_361 == 0xE2196DACL) < ((unsigned short)func_15(g_75, ((unsigned short)1UL * (unsigned short)l_361), (***l_274), func_15(l_374, (*l_369), g_64, (**g_67), g_8), g_75) << (unsigned short)g_354)) > l_375))
                {
                    int ***l_382 = &g_67;
                    step_hash(309);
                    (*g_68) = func_59((*g_67), (**l_274), (*g_103));
                    step_hash(310);
                    (*l_369) = l_375;
                    step_hash(311);
                    l_386 &= ((((int)((unsigned short)((short)(!func_15(g_64, ((!((func_26((l_382 == (void*)0)) || 0x3D97L) | (((short)((((func_9((g_75 & (!g_8))) <= (g_91 == 0x28L)) > (*l_369)) & 0xFC06L) | g_64) / (short)g_75) >= (*g_68)))) ^ 0UL), g_91, (*l_369), l_374)) % (short)g_91) << (unsigned short)4) % (int)g_385) && 0xCF0B019CL) && (*l_369));
                }
                else
                {
                    short l_388 = 4L;
                    int *l_395 = (void*)0;
                    step_hash(322);
                    if (((void*)0 != (*l_274)))
                    {
                        int l_399 = 0x3ABCC576L;
                        step_hash(314);
                        (*g_104) = ((!0xCF50B0D8L) != g_8);
                        step_hash(315);
                        (**g_103) = (((-(unsigned char)l_388) ^ func_15((~(((unsigned)((unsigned short)(255UL || ((short)func_59(l_395, (*g_67), l_396) * (short)(g_397 != &g_103))) >> (unsigned short)2) / (unsigned)l_398) != l_388)), l_399, l_375, (*g_143), l_367)) && (-1L));
                        step_hash(316);
                        (*l_369) = (g_64 ^ func_26(g_179));
                        step_hash(317);
                        (**g_103) = 0xD4551E3BL;
                    }
                    else
                    {
                        step_hash(319);
                        if ((***l_274))
                            break;
                        step_hash(320);
                        (**g_102) = (**g_397);
                        step_hash(321);
                        (***g_397) = l_375;
                    }
                }
                step_hash(324);
                (**l_274) = (**g_397);
            }
        }
        step_hash(327);
        l_414 ^= (func_15(((signed char)((!((short)((signed char)0x24L % (signed char)0x62L) - (short)65535UL)) == ((short)((int)(((*g_68) > (g_105 | g_385)) | (+((int)0L - (int)((signed char)g_385 >> (signed char)((*g_67) == (**g_397)))))) + (int)l_367) >> (short)9)) % (signed char)g_354), g_91, g_22, (***l_274), g_385) && (-9L));
        step_hash(428);
        if ((((unsigned char)(!0x54L) << (unsigned char)7) < g_385))
        {
            short l_419 = 0L;
            unsigned l_429 = 0xD1FFF403L;
            step_hash(329);
            (*g_143) &= (~(g_105 || (l_414 && ((unsigned short)(l_419 <= ((*g_397) != (*g_397))) % (unsigned short)l_419))));
            step_hash(365);
            for (g_75 = 0; (g_75 == 19); ++g_75)
            {
                unsigned short l_426 = 0xE9E5L;
                step_hash(333);
                (**g_67) &= ((***l_274) == g_22);
                step_hash(344);
                for (l_353 = 2; (l_353 > 14); l_353++)
                {
                    step_hash(343);
                    for (g_22 = 0; (g_22 == (-7)); g_22 -= 3)
                    {
                        step_hash(340);
                        if (l_419)
                            break;
                        step_hash(341);
                        (**g_103) = (l_426 || g_179);
                        step_hash(342);
                        if ((*g_68))
                            break;
                    }
                }
                step_hash(363);
                for (g_91 = 0; (g_91 != (-13)); --g_91)
                {
                }
                step_hash(364);
                return l_374;
            }
        }
        else
        {
            int **l_441 = &l_306;
            int l_481 = 0x5F1969B3L;
            unsigned short l_522 = 65534UL;
            step_hash(405);
            for (g_105 = 0; (g_105 <= 8); g_105 += 5)
            {
                int ***l_440 = (void*)0;
                step_hash(370);
                if ((*g_143))
                    break;
                step_hash(375);
                for (g_432 = 0; (g_432 <= 8); ++g_432)
                {
                    unsigned l_437 = 0x70CEF403L;
                    step_hash(374);
                    return l_437;
                }
                step_hash(393);
                for (g_354 = 26; (g_354 != 0); g_354--)
                {
                    step_hash(385);
                    if (((void*)0 == l_440))
                    {
                        step_hash(380);
                        (*g_102) = l_441;
                        step_hash(381);
                        if (l_374)
                            break;
                    }
                    else
                    {
                        step_hash(383);
                        (**g_102) = (**g_102);
                        step_hash(384);
                        if ((**g_67))
                            break;
                    }
                    step_hash(386);
                    (**g_67) = ((int)0L % (int)(func_9(g_385) & ((((**g_67) == ((*g_397) == l_441)) < ((short)0L * (short)0UL)) & 0xB8L)));
                    step_hash(392);
                    for (g_91 = 0; (g_91 > (-22)); --g_91)
                    {
                        signed char l_448 = 0x54L;
                        step_hash(390);
                        (**g_67) = (((((g_8 != l_448) >= 0x7247L) > g_75) == l_374) >= ((l_448 > g_64) > func_9(l_414)));
                        step_hash(391);
                        (*g_143) &= (**g_67);
                    }
                }
                step_hash(404);
                for (l_215 = 21; (l_215 != 57); ++l_215)
                {
                    int **l_451 = &g_143;
                    int l_455 = 0L;
                    unsigned l_456 = 4294967295UL;
                    step_hash(397);
                    l_451 = (void*)0;
                    step_hash(403);
                    for (g_432 = 0; (g_432 <= 49); g_432++)
                    {
                        step_hash(401);
                        (**g_102) = (**g_397);
                        step_hash(402);
                        l_414 &= (((((((**g_102) != (*g_103)) < l_454) && ((0x607B733AL <= (g_91 & (g_105 <= ((g_385 == g_91) & (((void*)0 != (**l_274)) == g_354))))) >= l_455)) <= l_456) <= 8L) && 0x4682L);
                    }
                }
            }
            step_hash(406);
            (*g_143) = (*g_143);
            step_hash(426);
            for (l_337 = 0; (l_337 > (-24)); l_337 -= 7)
            {
                int l_478 = (-6L);
                int ***l_484 = (void*)0;
                int **l_513 = &l_306;
                int *l_523 = &g_385;
                signed char l_524 = 0L;
                step_hash(422);
                if (((unsigned short)(0xB0L == (((short)(65535UL && g_22) * (short)((unsigned)((((short)func_59((**l_467), (*l_441), (*l_441)) >> (short)6) & g_354) == g_179) - (unsigned)g_179)) == 65535UL)) - (unsigned short)g_22))
                {
                    unsigned short l_469 = 0UL;
                    step_hash(411);
                    (*g_68) ^= (g_432 > l_469);
                    step_hash(412);
                    (*g_143) = ((signed char)((short)(((unsigned)g_8 - (unsigned)((signed char)0x10L - (signed char)l_478)) > ((((signed char)(!(l_481 > 0x9DF3D125L)) >> (signed char)4) || ((***l_467) | 0xF792E4AFL)) == g_22)) >> (short)g_354) >> (signed char)g_91);
                    step_hash(417);
                    if (l_478)
                    {
                        step_hash(414);
                        (**g_67) = ((short)5L + (short)(l_484 != (void*)0));
                    }
                    else
                    {
                        step_hash(416);
                        (**l_274) = (*g_103);
                    }
                }
                else
                {
                    int *l_496 = &g_179;
                    step_hash(419);
                    if ((*g_143))
                        break;
                    step_hash(420);
                    (*l_496) ^= (((unsigned)((0x287AL & (!((*g_102) == (void*)0))) | g_354) % (unsigned)((unsigned short)(((unsigned short)func_52(((short)g_385 << (short)((unsigned short)((***l_467) & (g_354 && func_26(l_495))) % (unsigned short)0xFA3FL)), g_354) / (unsigned short)g_432) != (-1L)) / (unsigned short)g_385)) && (***l_467));
                    step_hash(421);
                    (***l_467) = ((short)((int)1L + (int)((unsigned char)(g_64 || 1UL) * (unsigned char)(((int)((unsigned char)(*l_496) >> (unsigned char)1) % (int)func_9(l_481)) && ((unsigned char)(1L <= (((signed char)0xACL << (signed char)2) == ((g_91 >= g_385) > (*g_143)))) - (unsigned char)0xC9L)))) << (short)4);
                }
                step_hash(423);
                (*l_523) |= (((((-1L) || g_64) ^ func_9(g_75)) & ((int)(l_513 != (void*)0) - (int)((unsigned short)g_64 << (unsigned short)3))) & ((unsigned short)((unsigned short)((*g_143) >= ((func_26(((int)(-6L) - (int)(**g_67))) && l_481) || g_8)) - (unsigned short)l_522) * (unsigned short)65531UL));
                step_hash(424);
                if (l_524)
                    continue;
                step_hash(425);
                if (l_525)
                    continue;
            }
            step_hash(427);
            (*g_143) |= ((unsigned short)g_354 + (unsigned short)((***l_467) | 0x17L));
        }
        step_hash(485);
        for (l_307 = (-13); (l_307 == 9); l_307 += 2)
        {
            unsigned char l_530 = 0xEFL;
            int *l_531 = &l_414;
            int *l_583 = &g_91;
            signed char l_588 = 0xA1L;
            unsigned l_653 = 0x61509602L;
            int l_661 = (-2L);
            int *l_662 = (void*)0;
            step_hash(432);
            (*g_67) = func_55(((l_530 == (*g_143)) != func_9(g_91)), l_531, g_432);
            step_hash(484);
            if (((signed char)(***l_467) >> (signed char)4))
            {
                unsigned short l_548 = 0x409CL;
                int **l_571 = &g_68;
                step_hash(447);
                for (l_215 = 0; (l_215 != 51); l_215++)
                {
                    int l_549 = 0x5597FE77L;
                    step_hash(437);
                    (**g_67) &= l_536;
                    step_hash(438);
                    if ((**g_67))
                        continue;
                    step_hash(445);
                    if (((unsigned)((0xBDL != (func_2(((unsigned short)g_385 + (unsigned short)0xC4A6L), (+(((unsigned short)func_15((((int)(-(short)g_354) - (int)(***l_467)) == (*l_531)), (!((short)((**g_67) & 0xE84D8DF7L) * (short)g_105)), (*l_531), (*g_143), (***l_467)) * (unsigned short)l_548) == (*g_143))), l_549, g_432, g_385) <= g_105)) || 0x77E1L) + (unsigned)g_105))
                    {
                        unsigned char l_554 = 254UL;
                        int **l_567 = &l_531;
                        int **l_568 = (void*)0;
                        step_hash(440);
                        (*g_143) |= (((((((unsigned short)(*l_531) % (unsigned short)l_554) | (0x610EL >= ((unsigned short)(&l_549 == (**g_102)) / (unsigned short)l_548))) == l_549) < (!l_549)) == (g_179 != 0x6775L)) > (**g_67));
                        step_hash(441);
                        (*l_531) ^= l_549;
                        step_hash(442);
                        (**l_567) = (((short)((unsigned char)((unsigned char)0x0DL << (unsigned char)2) / (unsigned char)((unsigned short)l_554 + (unsigned short)((((unsigned short)((func_52(g_105, l_549) != (*l_531)) != (0xB4E2088BL != (l_567 != l_568))) / (unsigned short)65533UL) != 0x88L) <= 0x7C48L))) >> (short)6) || g_105);
                    }
                    else
                    {
                        step_hash(444);
                        (*g_68) = (*l_531);
                    }
                    step_hash(446);
                    (***l_467) = (((signed char)(&l_531 != (*g_102)) >> (signed char)3) >= (l_571 == l_571));
                }
                step_hash(448);
                (*l_531) = (&l_531 == (*g_102));
                step_hash(466);
                for (g_354 = (-5); (g_354 < (-15)); g_354 -= 8)
                {
                    int ***l_605 = &g_67;
                }
            }
            else
            {
                int l_654 = 0x98395975L;
                int **l_657 = (void*)0;
                step_hash(468);
                (*l_582) |= ((short)0x4546L % (short)func_15((((signed char)g_105 - (signed char)((unsigned short)((unsigned short)(((((short)((((void*)0 != (*l_274)) | (((unsigned char)((g_432 & (**g_67)) || ((unsigned char)((short)0x9D88L >> (short)0) * (unsigned char)(***l_467))) - (unsigned char)g_624) != g_385)) >= 0x417BL) << (short)g_652) > (-1L)) >= 1L) == g_179) + (unsigned short)l_653) + (unsigned short)l_654)) ^ g_606), g_652, l_654, (*l_635), l_654));
                step_hash(482);
                if ((*g_68))
                {
                    int *l_658 = (void*)0;
                    int l_702 = (-1L);
                    step_hash(476);
                    for (g_22 = 18; (g_22 >= 7); g_22--)
                    {
                        unsigned char l_663 = 0UL;
                        signed char l_696 = 0xE6L;
                        int *l_697 = &l_386;
                        step_hash(473);
                        (**l_274) = l_662;
                        step_hash(474);
                        (*l_635) = ((((!func_15(g_179, l_663, (-(signed char)(((((int)l_663 % (int)(l_663 & (-(unsigned)(g_624 || 0L)))) <= (*l_635)) && (***l_467)) < ((signed char)func_26((g_354 && g_105)) % (signed char)g_91))), l_663, g_91)) & g_22) >= l_663) >= g_385);
                        step_hash(475);
                        (*g_143) = ((unsigned)4294967287UL - (unsigned)(((0xCF2E55F8L | ((signed char)(((unsigned char)((short)(func_2(((signed char)(((signed char)(func_59((**g_102), l_697, l_658) > (*g_143)) + (signed char)(*l_531)) != 0UL) >> (signed char)7), g_606, g_354, (*l_635), g_606) == (*l_582)) % (short)g_652) % (unsigned char)g_606) >= 2UL) << (signed char)g_91)) < g_606) == g_385));
                    }
                    step_hash(477);
                    (***l_467) = (g_652 <= (0x1E857C9BL && func_26((*l_531))));
                    step_hash(478);
                    if ((*g_68))
                        continue;
                    step_hash(479);
                    (*g_143) = ((g_105 < ((unsigned char)g_75 << (unsigned char)7)) & (func_9((g_91 < func_59((**g_102), l_658, (**l_625)))) > l_702));
                }
                else
                {
                    step_hash(481);
                    return g_91;
                }
                step_hash(483);
                (***l_467) = func_26((*l_635));
            }
        }
    }
    step_hash(487);
    (*l_582) = ((unsigned char)(g_624 <= ((unsigned short)((*g_143) != ((int)(*l_582) - (int)((**g_102) == (void*)0))) >> (unsigned short)((short)((g_179 <= ((((short)(*l_582) >> (short)10) && ((1UL < (0xFFE4L || 0x1725L)) == g_91)) <= l_715)) != g_64) << (short)15))) - (unsigned char)0UL);
    step_hash(488);
    (*l_582) = ((short)(&g_103 == l_274) * (short)l_718);
    step_hash(489);
    (**g_102) = (**g_397);
    step_hash(490);
    return g_354;
}
static int func_2(short p_3, unsigned p_4, unsigned p_5, unsigned char p_6, short p_7)
{
    unsigned l_216 = 1UL;
    unsigned l_228 = 0UL;
    int l_229 = 0x4C012C7DL;
    step_hash(181);
    if (p_3)
    {
        step_hash(163);
        l_216 |= p_7;
    }
    else
    {
        step_hash(179);
        if ((**g_67))
        {
            step_hash(171);
            for (p_7 = 6; (p_7 == (-27)); p_7 -= 1)
            {
                int *l_223 = (void*)0;
            }
            step_hash(172);
            (**g_67) |= ((-5L) | ((unsigned char)248UL << (unsigned char)7));
        }
        else
        {
            step_hash(178);
            for (p_7 = 0; (p_7 > (-14)); p_7 -= 6)
            {
                step_hash(177);
                (*g_143) &= (p_4 > g_8);
            }
        }
        step_hash(180);
        (**g_67) = ((p_6 > (g_179 ^ 0xF879L)) & p_7);
    }
    step_hash(182);
    l_229 = (l_216 != l_228);
    step_hash(183);
    return p_5;
}
static unsigned func_9(unsigned p_10)
{
    unsigned l_25 = 1UL;
    int l_204 = (-4L);
    step_hash(159);
    for (p_10 = (-6); (p_10 != 23); p_10++)
    {
        unsigned char l_21 = 0x06L;
        int *l_202 = &g_105;
    }
    step_hash(160);
    return l_25;
}
static unsigned func_15(unsigned p_16, unsigned p_17, unsigned short p_18, int p_19, unsigned short p_20)
{
    unsigned short l_184 = 0x159BL;
    int *l_193 = &g_105;
    step_hash(145);
    (**g_67) = (((int)l_184 - (int)l_184) > (l_184 | (((signed char)p_19 >> (signed char)((short)g_64 * (short)(p_16 == l_184))) < (0x52L >= 3UL))));
    step_hash(146);
    l_193 = l_193;
    step_hash(147);
    return g_64;
}
static short func_26(int p_27)
{
    short l_32 = 0xAB5CL;
    step_hash(137);
    for (p_27 = 0; (p_27 < (-23)); --p_27)
    {
        int *l_176 = (void*)0;
        int *l_177 = (void*)0;
        int *l_178 = &g_179;
    }
    step_hash(142);
    for (g_105 = 0; (g_105 >= (-2)); --g_105)
    {
        step_hash(141);
        return g_22;
    }
    step_hash(143);
    return g_22;
}
static unsigned func_33(int p_34, unsigned p_35)
{
    int l_113 = 0x8A2FD92DL;
    unsigned char l_128 = 0xD5L;
    int l_133 = 0L;
    int l_135 = (-1L);
    int *l_140 = &l_135;
    unsigned l_150 = 0x6180BEB1L;
    int *l_173 = &g_91;
    step_hash(134);
    if (((unsigned char)func_38(p_34) << (unsigned char)g_8))
    {
        int l_115 = 0xB600A8D5L;
        int *l_139 = (void*)0;
        step_hash(121);
        if ((((void*)0 != (**g_102)) <= ((unsigned short)(((*g_102) == (void*)0) >= ((short)p_35 << (short)p_35)) % (unsigned short)((unsigned short)l_113 << (unsigned short)8))))
        {
            int *l_114 = &g_105;
            unsigned l_134 = 0x483285BFL;
            step_hash(77);
            l_115 &= func_59(func_55(g_22, (*g_67), g_64), (*g_103), l_114);
            step_hash(87);
            if (((signed char)(1L <= ((unsigned)((unsigned char)l_115 << (unsigned char)6) % (unsigned)func_38((*l_114)))) * (signed char)0xF8L))
            {
                step_hash(79);
                l_135 |= (((unsigned short)(((p_34 && ((g_8 < (((unsigned)0x416FBB8AL / (unsigned)g_22) ^ (g_75 || (((unsigned char)p_34 - (unsigned char)l_128) < ((((unsigned short)((signed char)(+l_133) << (signed char)func_38(l_134)) + (unsigned short)p_34) < 0x71L) || g_8))))) || (**g_103))) > p_35) || p_35) >> (unsigned short)g_8) | g_8);
            }
            else
            {
                unsigned l_138 = 0x03BCFB6DL;
                step_hash(85);
                if (((signed char)(l_138 || g_75) - (signed char)func_59(&p_34, l_139, (*g_67))))
                {
                    step_hash(82);
                    return l_113;
                }
                else
                {
                    step_hash(84);
                    l_140 = (void*)0;
                }
                step_hash(86);
                (*g_67) = &p_34;
            }
            step_hash(88);
            return p_35;
        }
        else
        {
            int *l_156 = &g_105;
            step_hash(90);
            (***g_102) ^= p_35;
            step_hash(118);
            for (g_75 = 0; (g_75 != (-24)); g_75 -= 8)
            {
                unsigned char l_167 = 0UL;
                step_hash(94);
                (*g_67) = g_143;
                step_hash(95);
                (**g_102) = (*g_103);
                step_hash(117);
                if (((unsigned char)(((~p_34) < ((p_35 || g_64) || ((short)p_35 << (short)1))) || g_64) >> (unsigned char)6))
                {
                    step_hash(101);
                    for (p_34 = 7; (p_34 >= 3); p_34--)
                    {
                        step_hash(100);
                        (*l_140) ^= (g_75 >= p_35);
                    }
                    step_hash(102);
                    (**g_103) = p_34;
                    step_hash(103);
                    (**g_103) ^= (-3L);
                    step_hash(104);
                    (*g_104) = ((l_150 & (!((250UL & func_59((*g_103), (**g_102), (*g_67))) < p_35))) | (250UL < p_34));
                }
                else
                {
                    unsigned short l_153 = 65535UL;
                    int l_162 = 0x0DF5CE33L;
                    step_hash(110);
                    if (((short)l_153 << (short)((short)g_105 % (short)func_59(&p_34, l_156, (*g_67)))))
                    {
                        unsigned short l_157 = 0x7298L;
                        step_hash(107);
                        return l_157;
                    }
                    else
                    {
                        step_hash(109);
                        (*l_140) = 2L;
                    }
                    step_hash(115);
                    for (l_115 = 0; (l_115 < (-16)); l_115 -= 8)
                    {
                        step_hash(114);
                        (*g_102) = (*g_102);
                    }
                    step_hash(116);
                    (*l_156) = ((l_162 && ((((unsigned char)p_35 / (unsigned char)((short)g_64 % (short)(*l_140))) != l_162) > (*l_156))) == l_167);
                }
            }
            step_hash(119);
            (*l_156) = (((signed char)func_52(g_22, (*l_156)) - (signed char)p_35) || 0x12L);
            step_hash(120);
            (*g_104) ^= (*l_140);
        }
        step_hash(122);
        (**g_103) = l_115;
        step_hash(123);
        return g_75;
    }
    else
    {
        step_hash(125);
        (**g_67) ^= p_34;
        step_hash(132);
        for (l_150 = (-28); (l_150 > 29); l_150++)
        {
            int *l_172 = (void*)0;
            step_hash(129);
            (*g_103) = l_172;
            step_hash(130);
            l_172 = func_55(p_35, l_173, g_91);
            step_hash(131);
            (*l_172) = ((unsigned short)p_34 << (unsigned short)3);
        }
        step_hash(133);
        (*g_143) = p_34;
    }
    step_hash(135);
    return g_8;
}
static unsigned char func_38(short p_39)
{
    signed char l_49 = 0x30L;
    step_hash(15);
    for (p_39 = (-30); (p_39 <= 26); p_39 += 1)
    {
        unsigned short l_42 = 1UL;
        step_hash(14);
        if (l_42)
            break;
    }
    step_hash(73);
    if (((unsigned short)(((0UL || ((signed char)((((unsigned short)l_49 >> (unsigned short)l_49) != (((int)func_52(p_39, g_8) / (int)((unsigned short)((void*)0 != g_102) << (unsigned short)g_105)) <= (**g_103))) > (-1L)) % (signed char)0x19L)) & l_49) >= l_49) * (unsigned short)g_22))
    {
        int l_106 = 0L;
        step_hash(69);
        (**g_103) &= (*g_68);
        step_hash(70);
        l_106 = (!(**g_67));
    }
    else
    {
        step_hash(72);
        return g_105;
    }
    step_hash(74);
    return p_39;
}
static int func_52(unsigned short p_53, unsigned short p_54)
{
    int *l_63 = &g_64;
    int **l_92 = &l_63;
    step_hash(58);
    (*l_92) = func_55((((p_53 == p_54) != (~g_8)) || (((func_59(l_63, &g_64, &g_64) || ((unsigned)g_64 - (unsigned)(0x3A5CL != g_8))) < g_8) == 0L)), l_63, g_22);
    step_hash(66);
    for (g_64 = (-12); (g_64 > (-29)); --g_64)
    {
        int *l_99 = &g_91;
        step_hash(62);
        (*l_92) = (*g_67);
        step_hash(63);
        (*l_99) = ((int)((signed char)(0x3FD17753L || (p_53 == ((*l_92) == (*g_67)))) >> (signed char)0) - (int)p_54);
        step_hash(64);
        if ((**g_67))
            continue;
        step_hash(65);
        (*l_99) |= 0x449D4C0FL;
    }
    step_hash(67);
    return (**l_92);
}
static int * func_55(short p_56, int * p_57, unsigned p_58)
{
    signed char l_80 = 0xB2L;
    unsigned l_88 = 0UL;
    step_hash(56);
    for (g_64 = 0; (g_64 <= (-15)); g_64 -= 8)
    {
        int *l_74 = &g_75;
        step_hash(28);
        (*l_74) = (*g_68);
        step_hash(39);
        if ((0x3BL == (0xA2B52F10L >= (*p_57))))
        {
            unsigned short l_81 = 6UL;
            step_hash(36);
            for (p_56 = 27; (p_56 >= (-27)); --p_56)
            {
                step_hash(33);
                l_81 ^= ((signed char)l_80 >> (signed char)2);
                step_hash(34);
                p_57 = p_57;
                step_hash(35);
                (*g_67) = (*g_67);
            }
        }
        else
        {
            step_hash(38);
            (*g_67) = p_57;
        }
        step_hash(54);
        for (p_58 = 0; (p_58 <= 14); p_58++)
        {
            step_hash(53);
            for (g_75 = 0; (g_75 >= 13); g_75 += 2)
            {
                unsigned char l_89 = 3UL;
                int *l_90 = &g_91;
                step_hash(50);
                if (((signed char)(l_88 | (l_89 ^ (1L & (-1L)))) >> (signed char)7))
                {
                    step_hash(47);
                    (*g_67) = (*g_67);
                }
                else
                {
                    step_hash(49);
                    return p_57;
                }
                step_hash(51);
                (*l_90) = 0x5A2D5357L;
                step_hash(52);
                g_91 = ((*l_90) ^ g_64);
            }
        }
        step_hash(55);
        (*g_67) = p_57;
    }
    step_hash(57);
    return (*g_67);
}
static unsigned short func_59(int * p_60, int * p_61, int * p_62)
{
    step_hash(22);
    for (g_64 = 6; (g_64 <= (-28)); g_64 -= 7)
    {
        int ***l_69 = &g_67;
        step_hash(21);
        (*l_69) = g_67;
    }
    step_hash(23);
    return g_64;
}
void csmith_compute_hash(void)
{
    transparent_crc(g_8, ""g_8"", print_hash_value);
    transparent_crc(g_22, ""g_22"", print_hash_value);
    transparent_crc(g_64, ""g_64"", print_hash_value);
    transparent_crc(g_75, ""g_75"", print_hash_value);
    transparent_crc(g_91, ""g_91"", print_hash_value);
    transparent_crc(g_105, ""g_105"", print_hash_value);
    transparent_crc(g_179, ""g_179"", print_hash_value);
    transparent_crc(g_354, ""g_354"", print_hash_value);
    transparent_crc(g_385, ""g_385"", print_hash_value);
    transparent_crc(g_432, ""g_432"", print_hash_value);
    transparent_crc(g_606, ""g_606"", print_hash_value);
    transparent_crc(g_624, ""g_624"", print_hash_value);
    transparent_crc(g_652, ""g_652"", print_hash_value);
}
void step_hash(int stmt_id)
{
    int i = 0;
    csmith_compute_hash();
    printf(""before stmt(%d): checksum = %X\n"", stmt_id, crc32_context ^ 0xFFFFFFFFUL);
    crc32_context = 0xFFFFFFFFUL;
    for (i = 0; i < 256; i++) {
        crc32_tab[i] = 0;
    }
    crc32_gentab();
}
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    csmith_compute_hash();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}
"
208-9925,Gurgel100/gcc,gcc/testsuite/gcc.target/aarch64/fmul_fcvt_1.c,126,3,385,1668558.2231730002,173007.0,9.644453692625154,1154.0,1145.0,38840.0,12786.0,1578.0,589.0,1324.0,547.0,1500000000,0.001112372148782,1082014363648.0,0.0132884796568924,0.0782164025878433,"/* { dg-do run } */
/* { dg-options ""-save-temps -O2 -fno-inline"" } */

#define FUNC_DEFS(__a)	\
int			\
sffoo##__a (float x)	\
{			\
  return x * __a##.0f;	\
}			\
			\
unsigned int		\
usffoo##__a (float x)	\
{			\
  return x * __a##.0f;	\
}			\
			\
long			\
lsffoo##__a (float x)	\
{			\
  return x * __a##.0f;	\
}			\
			\
unsigned long		\
ulsffoo##__a (float x)	\
{			\
  return x * __a##.0f;	\
}

#define FUNC_DEFD(__a)	\
long long			\
dffoo##__a (double x)	\
{			\
  return x * __a##.0;	\
}			\
			\
unsigned long long	\
udffoo##__a (double x)	\
{			\
  return x * __a##.0;	\
}			\
int			\
sdffoo##__a (double x)	\
{			\
  return x * __a##.0;	\
}			\
			\
unsigned int		\
usdffoo##__a (double x)	\
{			\
  return x * __a##.0;	\
}

FUNC_DEFS (4)
FUNC_DEFD (4)
/* { dg-final { scan-assembler-times ""fcvtzs\tw\[0-9\], s\[0-9\]*.*#2"" 1 } } */
/* { dg-final { scan-assembler-times ""fcvtzs\tx\[0-9\], s\[0-9\]*.*#2"" 1 } } */
/* { dg-final { scan-assembler-times ""fcvtzs\tx\[0-9\], d\[0-9\]*.*#2"" 1 } } */
/* { dg-final { scan-assembler-times ""fcvtzs\tw\[0-9\], d\[0-9\]*.*#2"" 1 } } */
/* { dg-final { scan-assembler-times ""fcvtzu\tw\[0-9\], s\[0-9\]*.*#2"" 1 } } */
/* { dg-final { scan-assembler-times ""fcvtzu\tx\[0-9\], s\[0-9\]*.*#2"" 1 } } */
/* { dg-final { scan-assembler-times ""fcvtzu\tx\[0-9\], d\[0-9\]*.*#2"" 1 } } */
/* { dg-final { scan-assembler-times ""fcvtzu\tw\[0-9\], d\[0-9\]*.*#2"" 1 } } */

FUNC_DEFS (8)
FUNC_DEFD (8)
/* { dg-final { scan-assembler-times ""fcvtzs\tw\[0-9\], s\[0-9\]*.*#3"" 1 } } */
/* { dg-final { scan-assembler-times ""fcvtzs\tx\[0-9\], s\[0-9\]*.*#3"" 1 } } */
/* { dg-final { scan-assembler-times ""fcvtzs\tx\[0-9\], d\[0-9\]*.*#3"" 1 } } */
/* { dg-final { scan-assembler-times ""fcvtzs\tw\[0-9\], d\[0-9\]*.*#3"" 1 } } */
/* { dg-final { scan-assembler-times ""fcvtzu\tw\[0-9\], s\[0-9\]*.*#3"" 1 } } */
/* { dg-final { scan-assembler-times ""fcvtzu\tx\[0-9\], s\[0-9\]*.*#3"" 1 } } */
/* { dg-final { scan-assembler-times ""fcvtzu\tx\[0-9\], d\[0-9\]*.*#3"" 1 } } */
/* { dg-final { scan-assembler-times ""fcvtzu\tw\[0-9\], d\[0-9\]*.*#3"" 1 } } */

FUNC_DEFS (16)
FUNC_DEFD (16)
/* { dg-final { scan-assembler-times ""fcvtzs\tw\[0-9\], s\[0-9\]*.*#4"" 1 } } */
/* { dg-final { scan-assembler-times ""fcvtzs\tx\[0-9\], s\[0-9\]*.*#4"" 1 } } */
/* { dg-final { scan-assembler-times ""fcvtzs\tx\[0-9\], d\[0-9\]*.*#4"" 1 } } */
/* { dg-final { scan-assembler-times ""fcvtzs\tw\[0-9\], d\[0-9\]*.*#4"" 1 } } */
/* { dg-final { scan-assembler-times ""fcvtzu\tw\[0-9\], s\[0-9\]*.*#4"" 1 } } */
/* { dg-final { scan-assembler-times ""fcvtzu\tx\[0-9\], s\[0-9\]*.*#4"" 1 } } */
/* { dg-final { scan-assembler-times ""fcvtzu\tx\[0-9\], d\[0-9\]*.*#4"" 1 } } */
/* { dg-final { scan-assembler-times ""fcvtzu\tw\[0-9\], d\[0-9\]*.*#4"" 1 } } */

FUNC_DEFS (32)
FUNC_DEFD (32)
/* { dg-final { scan-assembler-times ""fcvtzs\tw\[0-9\], s\[0-9\]*.*#5"" 1 } } */
/* { dg-final { scan-assembler-times ""fcvtzs\tx\[0-9\], s\[0-9\]*.*#5"" 1 } } */
/* { dg-final { scan-assembler-times ""fcvtzs\tx\[0-9\], d\[0-9\]*.*#5"" 1 } } */
/* { dg-final { scan-assembler-times ""fcvtzs\tw\[0-9\], d\[0-9\]*.*#5"" 1 } } */
/* { dg-final { scan-assembler-times ""fcvtzu\tw\[0-9\], s\[0-9\]*.*#5"" 1 } } */
/* { dg-final { scan-assembler-times ""fcvtzu\tx\[0-9\], s\[0-9\]*.*#5"" 1 } } */
/* { dg-final { scan-assembler-times ""fcvtzu\tx\[0-9\], d\[0-9\]*.*#5"" 1 } } */
/* { dg-final { scan-assembler-times ""fcvtzu\tw\[0-9\], d\[0-9\]*.*#5"" 1 } } */

#define FUNC_TESTS(__a, __b)					\
do								\
  {								\
    if (sffoo##__a (__b) != (int)(__b * __a))			\
      __builtin_abort ();					\
    if (usffoo##__a (__b) != (unsigned int)(__b * __a))	\
      __builtin_abort ();					\
    if (lsffoo##__a (__b) != (long long)(__b * __a))		\
      __builtin_abort ();					\
    if (ulsffoo##__a (__b) != (unsigned long long)(__b * __a))	\
      __builtin_abort ();					\
  } while (0)

#define FUNC_TESTD(__a, __b)					\
do								\
  {								\
    if (dffoo##__a (__b) != (long long)(__b * __a))		\
      __builtin_abort ();					\
    if (udffoo##__a (__b) != (unsigned long long)(__b * __a))	\
      __builtin_abort ();					\
    if (sdffoo##__a (__b) != (int)(__b * __a))			\
      __builtin_abort ();					\
    if (usdffoo##__a (__b) != (unsigned int)(__b * __a))	\
      __builtin_abort ();					\
  } while (0)

int
main (void)
{
  float i;

  for (i = -0.001; i < 32.0; i += 1.0f)
    {
      FUNC_TESTS (4, i);
      FUNC_TESTS (8, i);
      FUNC_TESTS (16, i);
      FUNC_TESTS (32, i);

      FUNC_TESTD (4, i);
      FUNC_TESTD (8, i);
      FUNC_TESTD (16, i);
      FUNC_TESTD (32, i);
    }
  return 0;
}
"
234-27088,Lilystar/Auriga,tool/bench.c,375,28,1261,1838657.77216845,174742.0,10.522124045736,1346.0,1326.0,39659.0,13495.0,1622.0,635.0,1344.0,593.0,1500000000,0.0012257718481123,1082014363648.0,0.0152911149008252,0.078902810700982,"/* Zx` by nameless */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

/* -------------------- */
/* Övg^Cvé¾ */
/* -------------------- */
long calcFuncCall(void);
long calcAdd(void);
long calcSub(void);
long calcMul(void);
long calcDiv(void);
long calcShift(void);

long calcFloatAdd(void);
long calcFloatSub(void);
long calcFloatMul(void);
long calcFloatDiv(void);

long calcDoubleAdd(void);
long calcDoubleSub(void);
long calcDoubleMul(void);
long calcDoubleDiv(void);

int foo(void);

/* ½àµÈ¢Ö */
int foo(void)
{
	return 1;
}
/* -------------------------------- */
/* ÖÄÑoµ						*/
/* -------------------------------- */
long calcFuncCall(void)
{
	long stTim,endTim;
	int i,j;

	stTim=clock();

	for(i=0;i<10000;i++){
		for(j=0;j<10000;j++){
			foo();
		}
	}
	
	endTim=clock();
	endTim-=stTim;
	if(CLOCKS_PER_SEC>0){
		int time_dd=1000/CLOCKS_PER_SEC;
		if(time_dd>0) endTim*=time_dd;
	}

	return endTim;
}
/* -------------------------------- */
/* ®lÌÁZÌvª 				*/
/* -------------------------------- */
long calcAdd(void)
{
	long stTim,endTim;
	int i,j;
	int a;

	stTim=clock();

	a=0;
	for(i=0;i<10000;i++){
		for(j=0;j<10000;j++){
			a+=j;
		}
		a=0;
	}
	
	endTim=clock();
	endTim-=stTim;
	if(CLOCKS_PER_SEC>0){
		int time_dd=1000/CLOCKS_PER_SEC;
		if(time_dd>0) endTim*=time_dd;
	}

	return endTim;
}

/* -------------------------------- */
/* ®lÌ¸ZÌvª 				*/
/* -------------------------------- */
long calcSub(void)
{
	long stTim,endTim;
	int i,j;
	int a;

	stTim=clock();

	a=100000;
	for(i=0;i<10000;i++){
		for(j=0;j<10000;j++){
			a-=j;
		}
		a=0;
	}
	
	endTim=clock();
	endTim-=stTim;
	if(CLOCKS_PER_SEC>0){
		int time_dd=1000/CLOCKS_PER_SEC;
		if(time_dd>0) endTim*=time_dd;
	}

	return endTim;
}

/* -------------------------------- */
/* ®lÌæZÌvª 				*/
/* -------------------------------- */
long calcMul(void)
{
	long stTim,endTim;
	int i,j;
	int a;

	stTim=clock();

	a=0;
	for(i=0;i<10000;i++){
		for(j=0;j<10000;j++){
			a*=j;
		}
	}
	
	endTim=clock();
	endTim-=stTim;
	if(CLOCKS_PER_SEC>0){
		int time_dd=1000/CLOCKS_PER_SEC;
		if(time_dd>0) endTim*=time_dd;
	}

	return endTim;
}

/* -------------------------------- */
/* ®lÌZÌvª 				*/
/* -------------------------------- */
long calcDiv(void)
{
	long stTim,endTim;
	int i,j;
	int a;

	stTim=clock();

	a=0;
	for(i=0;i<10000;i++){
		for(j=1;j<10001;j++){	/* 0Zª­¶µÈ¢æ¤ÉjÍ1©ç */
			a/=j;
		}
	}
	
	endTim=clock();
	endTim-=stTim;
	if(CLOCKS_PER_SEC>0){
		int time_dd=1000/CLOCKS_PER_SEC;
		if(time_dd>0) endTim*=time_dd;
	}

	return endTim;
}

/* -------------------------------- */
/* ®lÌVtgÌvª 			*/
/* -------------------------------- */
long calcShift(void)
{
	long stTim,endTim;
	int i,j;
	int a,b;

	stTim=clock();

	a=0;
	b=1;
	for(i=0;i<10000;i++){
		for(j=0;j<10000;j++){
			a<<=b;
		}
		a=0;
	}
	
	endTim=clock();
	endTim-=stTim;
	if(CLOCKS_PER_SEC>0){
		int time_dd=1000/CLOCKS_PER_SEC;
		if(time_dd>0) endTim*=time_dd;
	}

	return endTim;
}

/* -------------------------------- */
/* ®¬_lÌÁZÌvª			*/
/* -------------------------------- */
long calcFloatAdd(void)
{
	long stTim,endTim;
	int i,j;
	float a;

	stTim=clock();

	a=0.0f;
	for(i=0;i<10000;i++){
		for(j=0;j<10000;j++){
			a+=j;
		}
		a=0.0f;
	}
	
	endTim=clock();
	endTim-=stTim;
	if(CLOCKS_PER_SEC>0){
		int time_dd=1000/CLOCKS_PER_SEC;
		if(time_dd>0) endTim*=time_dd;
	}

	return endTim;
}

/* -------------------------------- */
/* ®¬_lÌ¸ZÌvª			*/
/* -------------------------------- */
long calcFloatSub(void)
{
	long stTim,endTim;
	int i,j;
	float a;

	stTim=clock();

	a=100000.0f;
	for(i=0;i<10000;i++){
		for(j=0;j<10000;j++){
			a-=(float)j;
		}
		a=0.0f;
	}
	
	endTim=clock();
	endTim-=stTim;
	if(CLOCKS_PER_SEC>0){
		int time_dd=1000/CLOCKS_PER_SEC;
		if(time_dd>0) endTim*=time_dd;
	}

	return endTim;
}


/* -------------------------------- */
/* ®¬_lÌæZÌvª			*/
/* -------------------------------- */
long calcFloatMul(void)
{
	long stTim,endTim;
	int i,j;
	float a;

	stTim=clock();

	a=0.0f;
	for(i=0;i<10000;i++){
		for(j=0;j<10000;j++){
			a*=(float)j;
		}
	}
	
	endTim=clock();
	endTim-=stTim;
	if(CLOCKS_PER_SEC>0){
		int time_dd=1000/CLOCKS_PER_SEC;
		if(time_dd>0) endTim*=time_dd;
	}

	return endTim;
}

/* -------------------------------- */
/* ®¬_lÌZÌvª			*/
/* -------------------------------- */
long calcFloatDiv(void)
{
	long stTim,endTim;
	int i,j;
	float a;

	stTim=clock();

	a=0.0f;
	for(i=0;i<10000;i++){
		for(j=1;j<10001;j++){	/* 0Zª­¶µÈ¢æ¤ÉjÍ1©ç */
			a/=(float)j;
		}
	}
	
	endTim=clock();
	endTim-=stTim;
	if(CLOCKS_PER_SEC>0){
		int time_dd=1000/CLOCKS_PER_SEC;
		if(time_dd>0) endTim*=time_dd;
	}

	return endTim;
}

/* -------------------------------- */
/* ®¬_lÌÁZÌvª			*/
/* -------------------------------- */
long calcDoubleAdd(void)
{
	long stTim,endTim;
	int i,j;
	double a;

	stTim=clock();

	a=0.0;
	for(i=0;i<10000;i++){
		for(j=0;j<10000;j++){
			a+=j;
		}
		a=0.0;
	}
	
	endTim=clock();
	endTim-=stTim;
	if(CLOCKS_PER_SEC>0){
		int time_dd=1000/CLOCKS_PER_SEC;
		if(time_dd>0) endTim*=time_dd;
	}

	return endTim;
}

/* -------------------------------- */
/* ®¬_lÌ¸ZÌvª			*/
/* -------------------------------- */
long calcDoubleSub(void)
{
	long stTim,endTim;
	int i,j;
	double a;

	stTim=clock();

	a=100000.0f;
	for(i=0;i<10000;i++){
		a=10000.0;
		for(j=0;j<10000;j++){
			a-=(double)j;
		}
		a=0.0;
	}
	
	endTim=clock();
	endTim-=stTim;
	if(CLOCKS_PER_SEC>0){
		int time_dd=1000/CLOCKS_PER_SEC;
		if(time_dd>0) endTim*=time_dd;
	}

	return endTim;
}


/* -------------------------------- */
/* ®¬_lÌæZÌvª			*/
/* -------------------------------- */
long calcDoubleMul(void)
{
	long stTim,endTim;
	int i,j;
	double a;

	stTim=clock();

	a=0.0;
	for(i=0;i<10000;i++){
		for(j=0;j<10000;j++){
			a*=(double)j;
		}
	}
	
	endTim=clock();
	endTim-=stTim;
	if(CLOCKS_PER_SEC>0){
		int time_dd=1000/CLOCKS_PER_SEC;
		if(time_dd>0) endTim*=time_dd;
	}

	return endTim;
}

/* -------------------------------- */
/* ®¬_lÌZÌvª			*/
/* -------------------------------- */
long calcDoubleDiv(void)
{
	long stTim,endTim;
	int i,j;
	double a;

	stTim=clock();

	a=0.0;
	for(i=0;i<10000;i++){
		for(j=1;j<10001;j++){
			a/=(double)j;		/* 0Zª­¶µÈ¢æ¤ÉjÍ1©ç */
		}
	}
	
	endTim=clock();
	endTim-=stTim;
	if(CLOCKS_PER_SEC>0){
		int time_dd=1000/CLOCKS_PER_SEC;
		if(time_dd>0) endTim*=time_dd;
	}

	return endTim;
}

int main()
{
	char szStr[256];
	int ctime;
	ctime=0;

	ctime=ctime+calcFuncCall();
	ctime=ctime+calcAdd();
	ctime=ctime+calcSub();
	ctime=ctime+calcMul();
	ctime=ctime+calcDiv();
	ctime=ctime+calcShift();
	ctime=ctime+calcFloatAdd();
	ctime=ctime+calcFloatSub();
	ctime=ctime+calcFloatMul();
	ctime=ctime+calcFloatDiv();
	ctime=ctime+calcDoubleAdd();
	ctime=ctime+calcDoubleSub();
	ctime=ctime+calcDoubleMul();
	ctime=ctime+calcDoubleDiv();


	printf(""Spec Time=,%d"",ctime);

	return 0;
}
"
219-34741,lixiangbest/algorithm,yan/10/10.3.c,132,12,177,1881228.0613929,220987.0,8.512844646970184,1389.0,1370.0,49135.0,19793.0,1635.0,642.0,1353.0,598.0,1500000000,0.0012541520409286,1082014363648.0,0.0124848973016512,0.0613393686165273,"/*
* Êý¾Ý½á¹¹CÓïÑÔ°æ ¿ìËÙÅÅÐò
* P272-P276
* ÈÕÆÚ£º2012-08-29
*/
#include<stdio.h>
#include<stdlib.h>

// ¼ÇÂ¼ÀàÐÍ
typedef int KeyType;//¶¨Òå¹Ø¼ü×ÖÀàÐÍÎªÕûÐÍ
typedef int InfoType;//¶¨ÒåÆäËûÊý¾ÝÏîµÄÀàÐÍ

typedef struct{
	KeyType key;//¹Ø¼ü×ÖÏî
	InfoType otherinfo;//ÆäËûÊý¾ÝÏî
}RedType;

#define MAXSIZE 20 //Ò»¸öÓÃ×÷Ê¾ÀýµÄÐ¡Ë³Ðò±íµÄ×î´ó³¤¶È

// Ë³Ðò±íÀàÐÍ
typedef struct{
	RedType r[MAXSIZE+1];//r[0]ÏÐÖÃ»òÓÃ×÷ÉÚ±øµ¥Ôª
	int length;//Ë³Ðò±í³¤¶È
}SqList;

// ´òÓ¡Ë³Ðò±í
void print(SqList L){
	int i;
	for(i=1;i<=L.length;i++){
		printf(""(%d, %d)"", L.r[i].key, L.r[i].otherinfo);
	}
	printf(""\n\n"");
}

// Ëã·¨10.6 P274
// ½»»»Ë³Ðò±íLÖÐ×Ó±íL.r[low..high]µÄ¼ÇÂ¼£¬Ê¹ÊàÖá¼ÇÂ¼µ½Î»£¬
// ²¢·µ»ØÆäËùÔÚÎ»ÖÃ£¬´ËÊ±ÔÚËüÖ®Ç°(ºó)µÄ¼ÇÂ¼¾ù²»´ó(Ð¡)ÓÚËü¡£
int partition(SqList *L,int low,int high){
	RedType t;
	KeyType pivotkey;
	pivotkey = L->r[low].key;//ÓÃ×Ó±íµÄµÚÒ»¸ö¼ÇÂ¼×÷ÊàÖá¼ÇÂ¼
	while(low<high){
		//´Ó±íµÄÁ½¶Ë½»ÌæµØÏòÖÐ¼äÉ¨Ãè
		while(low<high&&L->r[high].key>=pivotkey) --high;//´ÓË÷Òý×î´óµÄ¿ªÊ¼£¬ÕÒµ½µÚÒ»¸ö±ÈÊàÅ¦¼ÇÂ¼Ð¡µÄ
		t = L->r[low];//½«±ÈÊàÖá¼ÇÂ¼Ð¡µÄ¼ÇÂ¼½»»»µ½µÍ¶Ë
		L->r[low] = L->r[high];
		L->r[high] = t;
		while(low<high&&L->r[low].key<=pivotkey) ++low;//´ÓË÷Òý×îÐ¡µÄ¿ªÊ¼£¬ÕÒµ½µÚÒ»¸ö±ÈÊàÅ¦¼ÇÂ¼´óµÄ
		t = L->r[low];//½«±ÈÊàÖá¼ÇÂ¼´óµÄ¼ÇÂ¼½»»»µ½¸ß¶Ë
		L->r[low] = L->r[high];
		L->r[high] = t;
	}
	return low;//·µ»ØÊàÖáËùÔÚÎ»ÖÃ
}

// Ëã·¨10.6(a) P274
// ½»»»Ë³Ðò±íLÖÐ×Ó±íL.r[low..high]µÄ¼ÇÂ¼£¬Ê¹ÊàÖá¼ÇÂ¼µ½Î»£¬
// ²¢·µ»ØÆäËùÔÚÎ»ÖÃ£¬´ËÊ±ÔÚËüÖ®Ç°(ºó)µÄ¼ÇÂ¼¾ù²»´ó(Ð¡)ÓÚËü¡£
// ¶ÔÊàÖáµÄ¸³ÖµÊÇ¶àÓàµÄ¡£
int partition_a(SqList *L,int low,int high){
	KeyType pivotkey;
	L->r[0] = L->r[low];//ÓÃ×Ó±íµÄµÚÒ»¸ö¼ÇÂ¼×÷ÊàÖá¼ÇÂ¼
	pivotkey = L->r[low].key;//ÊàÖá¼ÇÂ¼¹Ø¼ü×Ö
	while(low<high){
		//´Ó±íµÄÁ½¶Ë½»ÌæµØÏòÖÐ¼äÉ¨Ãè
		while(low<high&&L->r[high].key>=pivotkey) --high;
		L->r[low] = L->r[high];//½«±ÈÊàÖá¼ÇÂ¼Ð¡µÄ¼ÇÂ¼ÒÆµ½µÍ¶Ë
		while(low<high&&L->r[low].key<=pivotkey) ++low;
		L->r[high] = L->r[low];//½«±ÈÊàÖá¼ÇÂ¼´óµÄ¼ÇÂ¼ÒÆµ½¸ß¶Ë
	}
	L->r[low] = L->r[0];//ÊàÖá¼ÇÂ¼µ½Î»
	return low;//·µ»ØÊàÖáÎ»ÖÃ
}


// ½«aÖÐÕûÊýÐòÁÐÖØÐÂÅÅÁÐ³É×ÔÐ¡µ½´óÓÐÐòµÄÕûÊýÐòÁÐ(ÆðÅÝÅÅÐò) P273
void bubble_sort(int a[],int n){
	int i,j,t,change;
	for(i=n-1,change=1;i>1&&change;i--){//iÎªÐèÒª±È½ÏµÄ×îµ×²¿µÄË÷ÒýÏî
		change = 0;//Èç¹û¸ÃÖµÃ»ÓÐ¸Ä±ä£¬×îµ×²¿µÄÊý¾ÝÃ»ÓÐ¸Ä±ä
		for(j=0;j<i;j++){
			if(a[j]>a[j+1]){//Èç¹ûÇ°Ò»¸öÖµ²»ºóÒ»¸öÖµ´ó
				t = a[j];
				a[j] = a[j+1];
				a[j+1] = t;
				change = 1;//ÐèÒªÔÙ±È½Ï
			}
		}
	}
}

// Ëã·¨10.7 P275
// ¶ÔË³Ðò±íLÖÐµÄ×ÓÐòÁÐL.r[low..high]×÷¿ìËÙÅÅÐò¡£
void q_sort(SqList *L,int low,int high,int show){
	int pivot_loc;
	if(low<high){
		//³¤¶È´óÓÚ1
		if(show) pivot_loc = partition(L,low,high);//½«L.r[low..high]Ò»·ÖÎª¶þ
		else pivot_loc = partition_a(L,low,high);//½«L.r[low..high]Ò»·ÖÎª¶þ
		q_sort(L,low,pivot_loc-1,show);//¶ÔµÍ×Ó±íµÝ¹éÅÅÐò£¬pivot_locÊÇÊàÖáÎ»ÖÃ
		q_sort(L,pivot_loc+1,high,show);//¶Ô¸ß×Ó±íµÝ¹éÅÅÐò
	}
}

// Ëã·¨10.8 P276
void quick_sort(SqList *L,int show){
	q_sort(L,1,L->length,show);
}

#define N 8

int main(){
	/*ÆðÅÝÅÅÐò*/
	int md[N] = {49,38,65,97,76,13,27,49};
	int i;
	printf(""Before bubble sort:\n"");
	for(i=0;i<N;i++){
		printf(""%d "",md[i]);
	}
	bubble_sort(md,N);
	printf(""\nAfter bubble sort:\n"");
	for(i=0;i<N;i++){
		printf(""%d "",md[i]);
	}
	printf(""\n\n"");
	
	/*¿ìËÙÅÅÐò*/
	RedType d[N] = {
		{49,1},{38,2},{65,3},{97,4},{76,5},{13,6},{27,7},{49,8}
	};
	SqList s,m;
	for(i=0;i<N;i++){
		s.r[i+1] = d[i];//i=0²»ÓÃ»ò×öÉÚ±ø
	}
	s.length = N;
	m = s;//Á´±í¸´ÖÆ
	/*¿ìËÙÅÅÐòa*/
	printf(""before quick a order:\n"");
	print(s);
	quick_sort(&s,1);
	printf(""after quick a order:\n"");
	print(s);
	
	/*¿ìËÙÅÅÐòb*/
	printf(""before quick b order:\n"");
	print(m);
	quick_sort(&m,0);
	printf(""after quick b order:\n"");
	print(m);
	return 0;
}












"
372-4635,chggr/puzzles,hard/count_twos.c,116,10,123,295794823.5562071,2715246891.0,0.1089384630106551,1349.0,1330.0,79370.0,53410.0,1625.0,637.0,1344.0,593.0,1500000000,0.1971965490374714,1082014363648.0,9.866506095191032e-07,0.0316237385148365,"#include <math.h>
#include <stdio.h>

// Task description: Given a positive integer n, write a method to count the
// number of twos between 0 and n inclusive.
//
// E.g. for n = 1 the answer is 0
//      for n = 11 the answer is 1 (2)
//      for n = 22 the answer is 6 (2, 12, 20, 21, 22)
//
// Solution: The first implementation below uses a brute force approach to solve
// this task. For every number between 0 and n, it extracts its digits and
// increments a counter if any one of them is equal to two. It finally returns
// the result. The runtime complexity of this implementation is O(N*M) where N
// is the given number and M is the average number length. This method runs fast
// for small inputs, but its performance is very bad for larger inputs.
//
// The second implementation greatly improves the runtime complexity by using
// numerical analysis to calculate the final result in O(M), where M is the
// number of digits in the input number. It goes through each digit one by one
// and extracts the numbers at the left and right of this digit. For example
// number 43210 and digit 2, the left and right will be 43 and 10 respectively.
// It subsequently increments the result according to the following analysis:
//
// - If the digit is less than two, the total number of twos at that position
//   will be equal to the left times ten to the power of the current position.
//   For example, the number of twos at the third position of number 31523 will
//   be 3000, i.e. ranges 2000 - 2999, 12000 - 12999 and 22000 - 22999.
//
// - If the digit is greater than two, the total number of twos at that position
//   will be equal to the left plus one, times ten to the power of the current
//   position. For example, the number of twos at the third position of number
//   33523 will be 4000, i.e. ranges 2000 - 2999, 12000 - 12999, 22000 - 22999
//   and 32000 - 32999.
//
// - If the digit is equal to two, the total number of twos at that position
//   will be equal to the left times ten to the power of the current position,
//   plus the right plus one. For example, the number of twos at the third
//   position of number 32523 will be 3000 + 524, i.e. ranges 2000 - 2999, 12000
//   - 12999, 22000 - 22999 and 32000 - 32523.

int count_twos_brute(int num) {
    int current;
    int result = 0;
    for (int i = 2; i <= num; i++) {
        current = i;
        while (current > 0) {
            result += current % 10 == 2;
            current /= 10;
        }
    }
    return result;
}

int power(int base, int exp) {
    int result = 1;
    for (int i = 0; i < exp; i++) {
        result *= base;
    }
    return result;
}

int count_twos(int num) {
    int result = 0;
    int pos = 0;
    int temp = num;

    while (temp > 0) {
        int digit = temp % 10;
        int left = num / power(10, pos + 1);
        int right = num % power(10, pos);

        if (digit < 2) {
            result += left * power(10, pos);
        } else if (digit > 2) {
            result += (left + 1) * power(10, pos);
        } else {
            result += left * power(10, pos) + right + 1;
        }

        temp /= 10;
        pos++;
    }
    return result;
}

int test_no_twos() {
    return 0 == count_twos_brute(0) &&
           0 == count_twos(0) &&
           0 == count_twos_brute(1) &&
           0 == count_twos(1);
}

int test_with_twos() {
    return 1 == count_twos_brute(11) &&
           1 == count_twos(11) &&
           2 == count_twos_brute(19) &&
           2 == count_twos(19) &&
           6 == count_twos_brute(22) &&
           6 == count_twos(22) &&
           175 == count_twos_brute(342) &&
           175 == count_twos(342);
}

int test_large_numbers() {
    for (int i = 0; i < 10000; i++) {
        if (count_twos_brute(i) != count_twos(i)) {
            return 0;
        }
    }
    return 1;
}

int main() {
    int counter = 0;
    if (!test_no_twos()) {
        printf(""No twos test failed!\n"");
        counter++;
    }
    if (!test_with_twos()) {
        printf(""With twos test failed!\n"");
        counter++;
    }
    if (!test_large_numbers()) {
        printf(""Large numbers test failed!\n"");
        counter++;
    }
    printf(""%d tests failed.\n"", counter);
}

"
167-23384,jaypume/ParallelProcessing,sparse_matrix_multiply_serial.c,126,15,124,35025557.96876535,78033340.0,0.4488537463602096,1492.0,1463.0,15877957.0,11582867.0,666099.0,289103.0,57558.0,256988.0,1500000000,0.0233503719791769,1082014363648.0,3.786842905865621e-05,0.0462385251076224,"#include <time.h>
#include <stdio.h>
#include <math.h>
#include <stdlib.h>

#define LEN 1000
#define NNZ 50000
typedef float dataType;
typedef struct{
	int row;
	int col;
	dataType	val;
}SNode;
typedef struct{
	int nRow,nCol,nNum;
	SNode data[NNZ];
}SM;
typedef struct{
	int nRow,nCol,nNum;
	SNode data[LEN*LEN];
}DM;
void sparse_matrix_produce(SM *p);
void sparse_matrix_multiply(SM *X,SM *Y,DM *Z);
void sparse_matrix_print(SM *p);



int main(int argc, char *argv){
	double time1,time2; 
	srand((unsigned int)time(NULL));
	SM *X=(SM *)malloc(sizeof(SM));
	SM *Y=(SM *)malloc(sizeof(SM));
	DM *Z=(DM *)malloc(sizeof(DM));
	sparse_matrix_produce(X);
	sparse_matrix_produce(Y);
	time1	=clock();
	sparse_matrix_multiply(X,Y,Z);			//Z=XY
	time2	=clock();
	//	sparse_matrix_print(X);
	//	sparse_matrix_print(Y);
	//	sparse_matrix_print(Z);
	printf(""计算稀疏矩阵耗时：%6.3fs\n"",(time2-time1)/CLOCKS_PER_SEC);
	
	
}

void sparse_matrix_produce(SM *p){
	int i,j,k;
	int	*A;
	if((A=(int *)malloc(sizeof(int)*LEN*LEN))==NULL){
		printf(""error"");
	}
	for(i=0;i<LEN;i++)
	for(j=0;j<LEN;j++){
		A[i*LEN+j]=0;
	}
	for(k=0;k<NNZ;k++){
		i	= rand()%LEN;
		j	= rand()%LEN;
		A[i*LEN+j]	= 1;
	}
	k=0;
	for(i=0;i<LEN;i++)
	for(j=0;j<LEN;j++){
		if(A[i*LEN+j]==1){
			(*p).data[k].row	=i;
			(*p).data[k].col	=j;
			(*p).data[k].val	=rand()%100;
			k++;
		}
	}
	(*p).nRow	= LEN;
	(*p).nCol	= LEN;
	(*p).nNum	= k;
}

void sparse_matrix_multiply(SM *X,SM *Y,DM *Z){
	int i,j,k,q;
	int index_of_node_on_X;
	int	count_of_node_on_Z;
	int	index_of_last_nonzero;
	int	number_of_nonzero_Y_row[(*Y).nRow];
	int	first_nonzero_on_Y_row[(*Y).nRow];
	int	adder[LEN];
	(*Z).nRow=(*X).nRow;
	(*Z).nCol=(*Y).nCol;
	for(i=0;i<(*Y).nRow;i++)number_of_nonzero_Y_row[i]=0;
	for(k=0;k<(*Y).nNum;k++){
		i=(*Y).data[k].row;
		number_of_nonzero_Y_row[i]++;
	}
	first_nonzero_on_Y_row[0]=0;
	for(i=1;i<(*Y).nRow;i++){
		first_nonzero_on_Y_row[i]=first_nonzero_on_Y_row[i-1]+number_of_nonzero_Y_row[i-1];
	}
	count_of_node_on_Z=0;
	index_of_node_on_X=0;
	for(i=0;i<(*X).nRow;i++){//X的每一行进行一次循环
		for(j=0;j<(*Y).nCol;j++){
			adder[j]=0;
		}
		while((*X).data[index_of_node_on_X].row==i){
			k=(*X).data[index_of_node_on_X].col;
			if(k<(*Y).nRow)
			index_of_last_nonzero=first_nonzero_on_Y_row[k+1];
			else 
			index_of_last_nonzero=(*Y).nNum;
			for(q=first_nonzero_on_Y_row[k];q<index_of_last_nonzero;q++){
				j=(*Y).data[q].col;
				adder[j]+=(*X).data[index_of_node_on_X].val*(*Y).data[q].val;
			}
			index_of_node_on_X++;
		}
		for(j=0;j<(*Y).nCol;j++){
			if(adder[j]){
				count_of_node_on_Z++;
				(*Z).data[count_of_node_on_Z].row	= i;
				(*Z).data[count_of_node_on_Z].col	= j;
				(*Z).data[count_of_node_on_Z].val	= adder[j];
			}
		}
	}
	(*Z).nNum=count_of_node_on_Z;
}

void sparse_matrix_print(SM *p){
	int i,j,k=0;
	printf(""总元素的个数为%d,展示如下\n"",(*p).nNum);
	for(i=0;i<LEN;i++){
		for(j=0;j<LEN;j++){
			if((i==(*p).data[k].row)&&(j==(*p).data[k].col)){
				printf(""%0.0f\t"",(*p).data[k].val);
				k++;
			}
			else {
				printf(""0\t"");
			}
		}
		printf(""\n"");
	}
}










"
200-27710,frivoal/presto-testo,imported/peter/unicode/tables/euc.c,253,24,224,36492025.36325895,165287238.0,0.2207794469891257,1523.0,1495.0,36284088.0,27029870.0,1790.0,3716.0,1396.0,1133.0,1500000000,0.0243280169088393,1082014363648.0,1.825912294571708e-05,0.0001269072453186,"#include <stdio.h>

int main(void)
{
	int i, j, pl;
	FILE *kr = fopen(""euc-kr.html"", ""w"");
	FILE *cn = fopen(""euc-cn.html"", ""w"");
	FILE *tw = fopen(""euc-tw.html"", ""w"");
	FILE *jp = fopen(""euc-jp.html"", ""w"");
	if (!kr || !cn || !tw || !jp) return 1;

	puts(""* Code set 0"");

	fputs(""<html lang=ko>\n <head>\n  <meta http-equiv=\""Content-Type\"" ""
	      ""content=\""text/html;charset=euc-kr\"">\n  <title>EUC-KR</title>\n""
	      ""  <style>.unused { background: #ccc; }""
	      "" table { float: left; }</style>\n""
	      "" </head>\n <body>\n""
		  ""  <table><caption>Code set 0: ASCII/KS-Roman</caption>\n""
	      ""   <tr><th>  "", kr);
	fputs(""<html lang=\""zh-cn\"">\n <head>\n  <meta http-equiv=\""Content-Type\"" ""
	      ""content=\""text/html;charset=euc-cn\"">\n  <title>EUC-CN</title>\n""
	      ""  <style>.unused { background: #ccc; }""
	      "" table { float: left; }</style>\n""
	      "" </head>\n <body>\n""
		  ""  <table><caption>Code set 0: ASCII</caption>\n""
	      ""   <tr><th>  "", cn);
	fputs(""<html lang=\""zh-tw\"">\n <head>\n  <meta http-equiv=\""Content-Type\"" ""
	      ""content=\""text/html;charset=euc-tw\"">\n  <title>EUC-TW</title>\n""
	      ""  <style>.unused { background: #ccc; }""
	      "" table { float: left; }</style>\n""
	      "" </head>\n <body>\n""
		  ""  <table><caption>Code set 0: ASCII/CNS-Roman</caption>\n""
	      ""   <tr><th>  "", tw);
	fputs(""<html lang=ja>\n <head>\n  <meta http-equiv=\""Content-Type\"" ""
	      ""content=\""text/html;charset=euc-jp\"">\n  <title>EUC-JP</title>\n""
	      ""  <style>.unused { background: #ccc; }""
	      "" table { float: left; }</style>\n""
	      "" </head>\n <body>\n""
	      ""  <table><caption>Code set 0: ASCII</caption>\n""
	      ""   <tr><th>  "", jp);

	for (i = 0; i < 16; i ++)
	{
		fprintf(kr, ""<th>%X"", i);
		fprintf(cn, ""<th>%X"", i);
		fprintf(tw, ""<th>%X"", i);
		fprintf(jp, ""<th>%X"", i);
	}

	/* Singlebyte */

	for (i = 32; i < 128; i ++)
	{
		if (0 == (i & 0x0F))
		{
			fprintf(kr, ""\n   <tr><th>%02X"", i);
			fprintf(cn, ""\n   <tr><th>%02X"", i);
			fprintf(tw, ""\n   <tr><th>%02X"", i);
			fprintf(jp, ""\n   <tr><th>%02X"", i);
		}
		fprintf(kr, ""<td>%c"", (char) i);
		fprintf(cn, ""<td>%c"", (char) i);
		fprintf(tw, ""<td>%c"", (char) i);
		fprintf(jp, ""<td>%c"", (char) i);
	}

	fputs(""\n  </table>\n"", kr);
	fputs(""\n  </table>\n"", cn);
	fputs(""\n  </table>\n"", tw);
	fputs(""\n  </table>\n"", jp);

	/* Row-cell multibyte */

	puts(""* Code set 1"");

	for (i = 0x81; i <= 0xA0; i ++)
	{
		fprintf(kr, ""  <table><caption>Code set 1: KS X 1001:1992 Row %X</caption>\n   <tr><th> "", i);
		for (j = 0; j < 16; j ++)
		{
			fprintf(kr, ""<th>%X"", j);
		}
		for (j = 0x40 ; j <= 0xFE; j ++)
		{
			if (0 == (j & 0x0F))
			{
				fprintf(kr, ""\n   <tr><th>%02X"", j);
			}
			if (0x40 == j || (0x5B <= j && j <= 0x60) ||
			                 (0x7B <= j && j <= 0x80))
			{
				fputs(""<td class=unused>&nbsp;"", kr);
			}
			else
			{
				fprintf(kr, ""<td>%c%c"", (char) i, (char) j);
			}
		}
		fputs(""<td class=unused>&nbsp;\n  </table>\n"", kr);
	}

	for (i = 0xA1; i <= 0xFE; i ++)
	{
		fprintf(kr, ""  <table><caption>Code set 1: KS X 1001:1992 Row %X</caption>\n   <tr><th> "", i);
		fprintf(cn, ""  <table><caption>Code set 1: GB 2312-80 Row %X</caption>\n   <tr><th> "", i);
		fprintf(tw, ""  <table><caption>Code set 1: CNS 11643-1992 Plane 1 Row %X</caption>\n   <tr><th> "", i);
		fprintf(jp, ""  <table><caption>Code set 1: JIS X 0208:1997 Row %X</caption>\n   <tr><th> "", i);
		for (j = 0; j < 16; j ++)
		{
			fprintf(kr, ""<th>%X"", j);
			fprintf(cn, ""<th>%X"", j);
			fprintf(tw, ""<th>%X"", j);
			fprintf(jp, ""<th>%X"", j);
		}
		if (i < 0xC7)
		{
			for (j = 0x40 ; j <= 0x9F; j ++)
			{
				if (0 == (j & 0x0F))
				{
					fprintf(kr, ""\n   <tr><th>%02X"", j);
				}
				if (0x40 == j || (0x5B <= j && j <= 0x60) ||
				                 (0x7B <= j && j <= 0x80))
				{
					fputs(""<td class=unused>&nbsp;"", kr);
				}
				else
				{
					fprintf(kr, ""<td>%c%c"", (char) i, (char) j);
				}
			}
		}
		for (j = 0xA0; j <= 0xFE; j ++)
		{
			if (0 == (j & 0x0F))
			{
				fprintf(kr, ""\n   <tr><th>%02X"", j);
				fprintf(cn, ""\n   <tr><th>%02X"", j);
				fprintf(tw, ""\n   <tr><th>%02X"", j);
				fprintf(jp, ""\n   <tr><th>%02X"", j);
			}
			if (0xA0 == j)
			{
				if (i < 0xC7)
				{
					fprintf(kr, ""<td>%c%c"", (char) i, (char) j);
				}
				else
				{
					fputs(""<td class=unused>&nbsp;"", kr);
				}
				fputs(""<td class=unused>&nbsp;"", cn);
				fputs(""<td class=unused>&nbsp;"", tw);
				fputs(""<td class=unused>&nbsp;"", jp);
			}
			else
			{
				fprintf(kr, ""<td>%c%c"", (char) i, (char) j);
				fprintf(cn, ""<td>%c%c"", (char) i, (char) j);
				fprintf(tw, ""<td>%c%c"", (char) i, (char) j);
				fprintf(jp, ""<td>%c%c"", (char) i, (char) j);
			}
		}
		fputs(""<td class=unused>&nbsp;\n  </table>\n"", kr);
		fputs(""<td class=unused>&nbsp;\n  </table>\n"", cn);
		fputs(""<td class=unused>&nbsp;\n  </table>\n"", tw);
		fputs(""<td class=unused>&nbsp;\n  </table>\n"", jp);
	}

	/* Code set 2 for EUC-TW: CNS 11643-1992 plane 1-7 */

	puts(""* Code set 2 for EUC-TW"");

	for (pl = 0xA1; pl <= 0xB0; pl ++)
	{
		fprintf(tw, ""  <h2>Second byte %02X - Plane %d</h2>\n"",
		        pl, pl - 0xA0);

		for (i = 0xA1; i <= 0xFE; i ++)
		{
			fprintf(tw, ""  <table><caption>Code set 2: CNS 11643-1992 Plane %d Row %X</caption>\n   <tr><th> "",
			        pl - 0xA0, i);
			for (j = 0; j < 16; j ++)
			{
				fprintf(tw, ""<th>%X"", j);
			}
			for (j = 0xA0; j <= 0xFE; j ++)
			{
				if (0 == (j & 0x0F))
				{
					fprintf(tw, ""\n   <tr><th>%02X"", j);
				}
				if (0xA0 == j)
				{
					fputs(""<td class=unused>&nbsp;"", tw);
				}
				else
				{
					fprintf(tw, ""<td>\x8E%c%c%c"",
					        (char) pl, (char) i, (char) j);
				}
			}
			fputs(""<td class=unused>&nbsp;\n  </table>\n"", tw);
		}
	}

	/* Code set 2 for EUC-JP: Halfwidth katakana */

	puts(""* Code set 2 for EUC-JP"");

	fputs(""  <table><caption>Code set 2: Half-width katakana</caption>\n""
	      ""   <tr><th>  "", jp);

	for (i = 0; i < 16; i ++)
	{
		fprintf(jp, ""<th>%X"", i);
	}

	/* Singlebyte */

	for (i = 0xA0; i <= 0xDF; i ++)
	{
		if (0 == (i & 0x0F))
		{
			fprintf(jp, ""\n   <tr><th>%02X"", i);
		}
		if (i > 0xA0)
		{
			fprintf(jp, ""<td>\x8E%c"", (char) i);
		}
		else
		{
			fprintf(jp, ""<td class=unused>&nbsp; "");
		}
	}

	fputs(""\n  </table>\n"", jp);

	/* Code set 3 for EUC-JP: Row-cell multibyte */

	puts(""* Code set 3 for EUC-JP"");

	for (i = 0xA1; i <= 0xFE; i ++)
	{
		fprintf(jp, ""  <table><caption>Code set 3: JIS X 0212:1990 Row %X</caption>\n   <tr><th> "", i);
		for (j = 0; j < 16; j ++)
		{
			fprintf(jp, ""<th>%X"", j);
		}
		for (j = 0xA0; j <= 0xFE; j ++)
		{
			if (0 == (j & 0x0F))
			{
				fprintf(jp, ""\n   <tr><th>%02X"", j);
			}
			if (0xA0 == j)
			{
				fputs(""<td class=unused>&nbsp;"", jp);
			}
			else
			{
				fprintf(jp, ""<td>\x8F%c%c"", (char) i, (char) j);
			}
		}
		fputs(""<td class=unused>&nbsp;\n  </table>\n"", jp);
	}
	/* End */

	fputs(""\n </body>\n</html>\n"", kr);
	fputs(""\n </body>\n</html>\n"", cn);
	fputs(""\n </body>\n</html>\n"", tw);
	fputs(""\n </body>\n</html>\n"", jp);
	fclose(kr);
	fclose(cn);
	fclose(tw);
	fclose(jp);

	return 0;
}
"
115-18534,ILyoan/gdb,gdb/testsuite/gdb.python/py-prettyprint.c,256,1,80,1912444.71352545,169091.0,11.31014660744806,1140.0,1130.0,38458.0,12700.0,1568.0,590.0,1317.0,549.0,1500000000,0.0012749631423503,1082014363648.0,0.0134247239652021,0.0786582743656906,"/* This testcase is part of GDB, the GNU debugger.

   Copyright 2008-2012 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <string.h>

struct s
{
  int a;
  int *b;
};

struct ss
{
  struct s a;
  struct s b;
};

struct arraystruct
{
  int y;
  struct s x[2];
};

struct ns {
  const char *null_str;
  int length;
};

struct lazystring {
  const char *lazy_str;
};

struct hint_error {
  int x;
};

struct children_as_list {
  int x;
};

#ifdef __cplusplus
struct S : public s {
  int zs;
};

struct SS {
  int zss;
  S s;
};

struct SSS
{
  SSS (int x, const S& r);
  int a;
  const S &b;
};
SSS::SSS (int x, const S& r) : a(x), b(r) { }

class VirtualTest 
{ 
 private: 
  int value; 

 public: 
  VirtualTest () 
    { 
      value = 1;
    } 
};

class Vbase1 : public virtual VirtualTest { };
class Vbase2 : public virtual VirtualTest { };
class Vbase3 : public virtual VirtualTest { };

class Derived : public Vbase1, public Vbase2, public Vbase3
{ 
 private: 
  int value; 
  
 public:
  Derived () 
    { 
      value = 2; 
    }
};

class Fake
{
  int sname;
  
 public:
  Fake (const int name = 0):
  sname (name)
  {
  }
};
#endif

struct substruct {
  int a;
  int b;
};

struct outerstruct {
  struct substruct s;
  int x;
};

struct outerstruct
substruct_test (void)
{
  struct outerstruct outer;
  outer.s.a = 0;
  outer.s.b = 0;
  outer.x = 0;

  outer.s.a = 3;		/* MI outer breakpoint here */

  return outer;  
}

typedef struct string_repr
{
  struct whybother
  {
    const char *contents;
  } whybother;
} string;

/* This lets us avoid malloc.  */
int array[100];
int narray[10];

struct justchildren
{
  int len;
  int *elements;
};

typedef struct justchildren nostring_type;

struct memory_error
{
  const char *s;
};

struct container
{
  string name;
  int len;
  int *elements;
};

typedef struct container zzz_type;

string
make_string (const char *s)
{
  string result;
  result.whybother.contents = s;
  return result;
}

zzz_type
make_container (const char *s)
{
  zzz_type result;

  result.name = make_string (s);
  result.len = 0;
  result.elements = 0;

  return result;
}

void
add_item (zzz_type *c, int val)
{
  if (c->len == 0)
    c->elements = array;
  c->elements[c->len] = val;
  ++c->len;
}

void init_s(struct s *s, int a)
{
  s->a = a;
  s->b = &s->a;
}

void init_ss(struct ss *s, int a, int b)
{
  init_s(&s->a, a);
  init_s(&s->b, b);
}

void do_nothing(void)
{
  int c;

  c = 23;			/* Another MI breakpoint */
}

struct nullstr
{
  char *s;
};

struct string_repr string_1 = { { ""one"" } };
struct string_repr string_2 = { { ""two"" } };

static int
eval_func (int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8)
{
  return p1;
}

static void
eval_sub (void)
{
  struct eval_type_s { int x; } eval1 = { 1 }, eval2 = { 2 }, eval3 = { 3 },
				eval4 = { 4 }, eval5 = { 5 }, eval6 = { 6 },
				eval7 = { 7 }, eval8 = { 8 }, eval9 = { 9 };

  eval1.x++; /* eval-break */
}

int
main ()
{
  struct ss  ss;
  struct ss  ssa[2];
  struct arraystruct arraystruct;
  string x = make_string (""this is x"");
  zzz_type c = make_container (""container"");
  zzz_type c2 = make_container (""container2"");
  const struct string_repr cstring = { { ""const string"" } };
  /* Clearing by being `static' could invoke an other GDB C++ bug.  */
  struct nullstr nullstr;
  nostring_type nstype, nstype2;
  struct memory_error me;
  struct ns ns, ns2;
  struct lazystring estring, estring2;
  struct hint_error hint_error;
  struct children_as_list children_as_list;

  nstype.elements = narray;
  nstype.len = 0;

  me.s = ""blah"";

  init_ss(&ss, 1, 2);
  init_ss(ssa+0, 3, 4);
  init_ss(ssa+1, 5, 6);
  memset (&nullstr, 0, sizeof nullstr);

  arraystruct.y = 7;
  init_s (&arraystruct.x[0], 23);
  init_s (&arraystruct.x[1], 24);

  ns.null_str = ""embedded\0null\0string"";
  ns.length = 20;

  /* Make a ""corrupted"" string.  */
  ns2.null_str = NULL;
  ns2.length = 20;

  estring.lazy_str = ""embedded x\201\202\203\204"" ;

  /* Incomplete UTF-8, but ok Latin-1.  */
  estring2.lazy_str = ""embedded x\302"";

#ifdef __cplusplus
  S cps;

  cps.zs = 7;
  init_s(&cps, 8);

  SS cpss;
  cpss.zss = 9;
  init_s(&cpss.s, 10);

  SS cpssa[2];
  cpssa[0].zss = 11;
  init_s(&cpssa[0].s, 12);
  cpssa[1].zss = 13;
  init_s(&cpssa[1].s, 14);

  SSS sss(15, cps);

  SSS& ref (sss);

  Derived derived;
  
  Fake fake (42);
#endif

  add_item (&c, 23);		/* MI breakpoint here */
  add_item (&c, 72);

#ifdef MI
  add_item (&c, 1011);
  c.elements[0] = 1023;
  c.elements[0] = 2323;

  add_item (&c2, 2222);
  add_item (&c2, 3333);

  substruct_test ();
  do_nothing ();
#endif

  nstype.elements[0] = 7;
  nstype.elements[1] = 42;
  nstype.len = 2;
  
  nstype2 = nstype;

  eval_sub ();

  return 0;      /* break to inspect struct and union */
}
"
